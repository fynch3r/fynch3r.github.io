<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-pace-theme-flash.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<!--

  <script src="//code.tidio.co/oixl41gwhy8tvqy6jte9uvglyrqcjrvc.js" async></script>

-->

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fynch3r.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>
  <meta name="description" content="序言 醉里挑灯看剑，梦回吹角连营。  整理Javassist相关知识 。">
<meta property="og:type" content="article">
<meta property="og:title" content="Javassist学习笔记">
<meta property="og:url" content="https://fynch3r.github.io/Javassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="fynch3r的小窝">
<meta property="og:description" content="序言 醉里挑灯看剑，梦回吹角连营。  整理Javassist相关知识 。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fynch3r.github.io/images/Javassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210217231334157.png">
<meta property="article:published_time" content="2021-02-16T11:13:46.000Z">
<meta property="article:modified_time" content="2021-11-09T02:54:58.481Z">
<meta property="article:author" content="fynch3r">
<meta property="article:tag" content="Javassist">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fynch3r.github.io/images/Javassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210217231334157.png">

<link rel="canonical" href="https://fynch3r.github.io/Javassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>Javassist学习笔记 | fynch3r的小窝</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="fynch3r的小窝" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
<a href="https://github.com/0range228" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#FFA500; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">fynch3r的小窝</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Trust the process.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">32</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">14</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">56</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fynch3r.github.io/Javassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yfy.png">
      <meta itemprop="name" content="fynch3r">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fynch3r的小窝">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Javassist学习笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-16 19:13:46" itemprop="dateCreated datePublished" datetime="2021-02-16T19:13:46+08:00">2021-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-09 10:54:58" itemprop="dateModified" datetime="2021-11-09T10:54:58+08:00">2021-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span id="/Javassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="Javassist学习笔记" title="热度">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">热度：</span>
              <span class="leancloud-visitors-count"></span>
              <span>°C</span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/Javassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Javassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>37k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:01</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>醉里挑灯看剑，梦回吹角连营。</p>
</blockquote>
<p>整理Javassist相关知识 。  </p>
<a id="more"></a>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>比ASM更适合<strong>人类</strong>操纵字节码，使用API可以实现例如生成类、修改类的操作。</p>
<p>允许Java程序可以在运行时定义一个新的Class、在JVM加载时修改.class文件。</p>
<p>提供了2各层次的API：源码级别、字节码级别。</p>
<p>如果用户使用了源码级别的API，就可以在不了解Java字节码规范的情况下编辑class文件。整个API是基于Java语言词汇设计的。你甚至可以以源码文本形式指定插入字节码，javassist编译它是非常快的。</p>
<p>另一方面。字节码层次的API允许用户像其它编辑器一样直接编辑class文件。</p>
<p><a href="http://www.javassist.org/html/index.html" target="_blank" rel="noopener">API文档</a></p>
<h2 id="读写字节码"><a href="#读写字节码" class="headerlink" title="读写字节码"></a>读写字节码</h2><p>Javassist是一个处理字节码的类库。Java字节码存储在一个叫做*.class的二进制文件中。每个class文件包含一个Java类或者接口。</p>
<p><code>javassist.CtClass</code> 代表一个class文件的抽象类表示形式。一个<code>CtClass</code>(compile-time class编译时的类)是一个处理class文件的句柄，以下是一个简单的程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(<span class="string">"test.Rectangle"</span>);</span><br><span class="line">cc.setSuperclass(pool.get(<span class="string">"test.Point"</span>));</span><br><span class="line">cc.writeFile();</span><br></pre></td></tr></table></figure>

<p>这段程序首先包含一个<code>ClassPool</code>对象，通过Javassist控制字节码的修改。</p>
<p><code>ClassPool</code>对象是代表class文件的<code>CtClass</code>对象的容器。它根据构造一个<code>CtClass</code>对象的需求读取一个class文件，并记录被构建好的对象以供将来进行访问。 为了修改一个类的定义，用户必须首先从<code>ClassPool</code>对象的<code>.get(className)</code>方法获取一个<code>CtClass</code>引用。 </p>
<p>在上述示例中，<code>CtClass</code>对象cc表示<code>ClassPool</code>中的类<code>test.Rectangle</code>，并且将其分配给变量<code>cc</code>。 <code>ClassPool</code>对象由静态方法<code>getDefault</code>方法查找默认的系统检索path返回。格式为“包名.类名”。</p>
<p>从实现上来看，<code>ClassPool</code>是一个<code>CtClass</code>的哈希表，使用class name作为key。</p>
<p><code>ClassPool.get()</code>方法通过检索这个哈希表找到一个<code>CtClass</code>对象关联指定的key。</p>
<p>如果<code>CtClass</code>对象没有找到，<code>get()</code>方法会读取class文件去构造一个<code>CtClass</code>对象，记录在哈希表中然后作为<code>get()</code>的返回值返回。</p>
<p>从<code>ClassPool</code>中获取到的<code>CtClass</code>对象是可以被修改的。在上述示例中，它被修改了 <code>test.Rectangle</code>的父类变更为<code>test.Point</code>,这个修改将会在最后<code>CtClass.writeFile()</code>方法调用后反映在class文件中。</p>
<p>javassist提供了写到类文件的方法：</p>
<p><code>writeFile()</code> 方法将<code>CtClass</code>对象转换到class文件并且将其写入本地磁盘。Javassist也提供了一个方法用于直接获取修改后的字节码：<code>toBytecode()</code>:</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte[] </span><span class="keyword">b </span>= cc.toBytecode()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>也可以像这样直接加载<code>CtClass</code>:</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Class clazz</span> = cc.toClass();</span><br></pre></td></tr></table></figure>

<p><code>toClass</code> 请求当前线程的上下文类加载器去加载class文件，返回一个<code>java.lang.Class</code>对象。</p>
<p>例子：</p>
<h3 id="定义一个新类"><a href="#定义一个新类" class="headerlink" title="定义一个新类"></a>定义一个新类</h3><p>重新定义一个新的类，<code>ClassPool.makeClass</code>方法将会被调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个新的类</span></span><br><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.makeClass(<span class="string">"com.sec.Point"</span>);</span><br><span class="line">System.out.println(cc.toClass()); <span class="comment">// 输出class com.sec.Point</span></span><br></pre></td></tr></table></figure>

<p>这个程序定义了一个<code>Point</code>类，未包含任何成员，成员方法可以通过使用<code>CtClass</code>的<code>addMethod()</code>方法传入一个<code>CtMethod</code>的factory方法创建的对象作为参数来追加。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个新的类</span></span><br><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.makeClass(<span class="string">"hello.make.Point"</span>);</span><br><span class="line"><span class="comment">//System.out.println(cc2.toClass().getMethods().length); // 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 追加方法</span></span><br><span class="line">cc.addMethod(CtMethod.make(<span class="string">"public void sayHello()&#123;\n"</span> +</span><br><span class="line">        <span class="string">"        System.out.println(\"Hello!\");\n"</span> +</span><br><span class="line">        <span class="string">"    &#125;"</span>,cc));</span><br><span class="line">System.out.println(cc.toClass().getMethods().length);  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p><code>makeClass()</code>方法不能创建一个新的接口，需要使用<code>makeInterface()</code>方法才可以创建一个新的接口。 接口中的成员方法可以通过<code>CtMethod</code>的<code>abstractMethod</code>方法创建。   </p>
<p>以上这个例子会报错：<code>com.sec.Point class is frozen</code></p>
<h3 id="Frozen冻结类"><a href="#Frozen冻结类" class="headerlink" title="Frozen冻结类"></a>Frozen冻结类</h3><blockquote>
<p> <strong>冻结类的含义</strong></p>
<p>如果一个<code>CtClass</code>对象通过<code>writeFile()</code>、<code>toBytecode</code>、<code>toClass()</code>方法被转换到class文件中，Javassist则会冻结这个<code>CtClass</code>对象。再对这个<code>CtClass</code>对象进行操作则是不允许的，当开发者尝试去修改一个已经被JVM加载过的class文件的时候会发出警告，因为JVM不允许重复加载一个class。 </p>
</blockquote>
<p>一个冻结的<code>CtClass</code>可以通过其<code>defrost()</code>方法解冻，解冻后可以允许对这个CtClass修改： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被冻结了，不能再修改(Exception in thread "main" java.lang.RuntimeException: com.sec.Point class is frozen)</span></span><br><span class="line"><span class="comment">// 解冻后可以修改</span></span><br><span class="line">cc.toBytecode(); or cc.toClass();<span class="comment">// 被冻结</span></span><br><span class="line">cc.defrost();<span class="comment">// 解冻</span></span><br><span class="line"><span class="comment">//以上两部顺序不能反，都是先解冻再修改。</span></span><br><span class="line">System.out.println(cc.getFields().length);</span><br><span class="line">cc.addField(CtField.make(<span class="string">"private String name;"</span>, cc));<span class="comment">// 解冻后允许修改</span></span><br><span class="line">cc.writeFile();</span><br><span class="line">System.out.println(cc.getFields().length);</span><br></pre></td></tr></table></figure>



<h3 id="修剪类-prune"><a href="#修剪类-prune" class="headerlink" title="修剪类 prune"></a>修剪类 prune</h3><p>如果ClassPool.doPruning被设置为true，那么当Javassist冻结一个CtClass对象时，Javassist就会对该对象中包含的数据结构进行修剪。为了减少内存消耗，修剪会丢弃该对象中不必要的属性（attribute_info结构）。例如，Code_attribute结构（方法体）会被丢弃。因此，当一个CtClass对象被修剪后，除了方法名、签名和注释外，无法访问方法的字节码。修剪后的CtClass对象不能再被解冻。ClassPool.doPruning 的默认值是 false。</p>
<p>要禁止修剪一个特定的CtClass，必须事先对该对象调用stopPruning(true)。</p>
<p>在调试时，你可能想暂时停止修剪和冻结，并将修改后的类文件写入磁盘驱动器。debugWriteFile()是一个方便的方法。它停止修剪，写入一个类文件，将其解冻，并再次开启修剪（如果最初是开启的）。</p>
<h3 id="类搜索路径"><a href="#类搜索路径" class="headerlink" title="类搜索路径"></a>类搜索路径</h3><p>默认的<code>ClassPool.getDefault()</code>检索路径和JVM底层路径一致（classpath）。<strong><em>如果一个程序运行在一个web应用程序比如JBoss、Tomcat中，<code>ClassPool</code>对象则可能搜索不到用户的类</em></strong>，因为这样的Web应用服务器使用多个类加载器以及系统类加载器。==在这种情况下，一个额外的classpath必须注册到<code>ClassPool</code>中==。假设pool引用了一个ClassPool对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加class查找路径search path</span></span><br><span class="line">pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(<span class="keyword">this</span>.getClass()));</span><br></pre></td></tr></table></figure>

<p>这个语句注册了用于加载这个对象类的类路径。你可以使用任何Class对象作为参数来代替this.getClass()。<code>Class</code>对象已经被注册上了的表现就是它所在的class path被加载了。</p>
<p>你也可以注册一个目录的名称作为一个class查找路径。例如，以下代码添加了<code>/usr/local/javalib</code>到class查找路径中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加文件目录作为class查找路径</span></span><br><span class="line">pool.insertClassPath(<span class="string">"/usr/local/javalib"</span>);</span><br></pre></td></tr></table></figure>

<p>还可以添加URL作为class查找路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加URL作为class查找路径，第三个参数必须/开头、第四个参数必须.结尾</span></span><br><span class="line"><span class="comment">// 添加 "http://www.javassist.org:80/java/"</span></span><br><span class="line">ClassPath cp = <span class="keyword">new</span> URLClassPath(<span class="string">"www.javassist.org"</span>, <span class="number">80</span>, <span class="string">"/java/"</span>, <span class="string">"org.javassist."</span>);</span><br><span class="line">pool.insertClassPath(cp);</span><br></pre></td></tr></table></figure>

<p>上面操作添加了<code>http://www.javassist.org:80/java/</code>到class查找路径中。这个URL仅仅用来查找<code>org.javassist.</code>包的类。</p>
<p>例如：加载一个<code>org.javassist.test.Main</code>类，它的class文件是： <code>http://www.javassist.org:80/java/org/javassist/test/Main.class</code> </p>
<p>此外，你还可以直接给一个byte数组去构建一个<code>CtClass</code>对象，可以使用<code>ByteArrayClassPath</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// byte数组形式class path</span></span><br><span class="line">ClassPool pool2 = ClassPool.getDefault();</span><br><span class="line"><span class="keyword">byte</span>[] arr = <span class="string">"org.byron4j"</span>.getBytes();</span><br><span class="line">String name = <span class="string">"org.byron4j.Hello"</span>;</span><br><span class="line">pool2.insertClassPath(<span class="keyword">new</span> ByteArrayClassPath(name, arr));</span><br><span class="line">CtClass ctClass = pool2.get(name);</span><br></pre></td></tr></table></figure>

<p><code>CtClass</code>对象ctClass表示字节数组b指定的class文件定义的类实例。<code>ClassPool</code>从给定的<code>ByteArrayClassPath</code>读取一个class文件。</p>
<p>如果调用get()并且给get()的类名等于name指定的类名，则ClassPool从给定的ByteArrayClassPath中读取类文件。</p>
<p>如果你不确定类的完全限定名，你可以使用<code>ClassPool</code>的<code>makeClass</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// makeClass</span></span><br><span class="line">ClassPool pool3 = ClassPool.getDefault();</span><br><span class="line">InputStream ins = <span class="keyword">new</span> FileInputStream(<span class="string">"/usr/local/javalib"</span>);</span><br><span class="line">CtClass ctClass1 = pool3.makeClass(ins);</span><br></pre></td></tr></table></figure>

<p>这里，makeClass() 返回从给定的输入流构建的 CtClass 对象。</p>
<p>你可以使用makeClass()将类文件急切地送入ClassPool对象。如果搜索路径包含一个大的jar文件，这可以提高性能。由于ClassPool对象按需读取类文件，它可能会重复搜索整个jar文件中的每一个类文件，makeClass()可以用来优化这种搜索。makeClass()构造的CtClass会被保存在ClassPool对象中，并且永远不会再读取类文件。</p>
<p>用户可以扩展class查找路径。可以定义一个实现<code>ClassPath</code>接口的新类，并将该类的一个实例交给ClassPool中的insertClassPath()。这种方式可以允许将非标准资源包含到class查找路径中。</p>
<h2 id="ClassPool"><a href="#ClassPool" class="headerlink" title="ClassPool"></a>ClassPool</h2><p>一个ClassPool对象是CtClass对象的容器。一旦一个CtClass对象被创建，它将永远记录在ClassPool中。这是因为编译器在以后编译引用该CtClass所代表的类的源代码时，可能需要访问该CtClass对象。</p>
<p>例如，假设一个新的方法getter()被添加到代表Point类的CtClass对象中。之后，程序试图编译包括Point中对getter()的方法调用的源代码，并将编译后的代码作为方法的主体，将其添加到另一个类Line中。如果丢失了代表Point的CtClass对象，编译器就无法编译对getter()的方法调用。请注意，原来的类定义并不包括getter()。因此，为了正确地编译这样的方法调用，ClassPool必须在程序执行的所有时间都包含CtClass的所有实例。</p>
<h3 id="避免内存不足"><a href="#避免内存不足" class="headerlink" title="避免内存不足"></a>避免内存不足</h3><p>如果CtClass对象的数量变得大得惊人，ClassPool的这种规范可能会造成巨大的内存消耗（这种情况很少发生，因为Javassist试图通过各种方式减少内存消耗：冻结calss等方式）。为了避免这个问题，你可以明确地从ClassPool中删除一个不必要的CtClass对象。如果你在一个CtClass对象上调用detach()，那么这个CtClass对象就会从ClassPool中删除。例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassPool classPool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = classPool.get(<span class="string">"org.byron4j.cookbook.javaagent.Javassist2ClassPool"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用该方法后，会将CtClass对象从ClassPool中移除</span></span><br><span class="line">cc.writeFile();</span><br><span class="line">cc.detach();</span><br></pre></td></tr></table></figure>

<p>在detach()被调用后，你不能调用该CtClass对象上的任何方法。但是，你可以在ClassPool上调用get()来制作一个新的代表同一个类的CtClass实例。如果你调用get()，ClassPool会再次读取一个类文件，并新创建一个CtClass对象，这个对象由get()返回。</p>
<p>另一个想法是偶尔用新的ClassPool替换一个ClassPool，并丢弃旧的ClassPool。如果一个旧的ClassPool被垃圾回收，那么该ClassPool中包含的CtClass对象也会被垃圾回收。要创建一个新的ClassPool实例，请执行以下代码片段:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPool cp = <span class="keyword">new</span> ClassPool(<span class="keyword">true</span>)<span class="comment">//简单粗暴</span></span><br><span class="line"><span class="comment">// if needed, append an extra search path by appendClassPath()</span></span><br></pre></td></tr></table></figure>

<p>这将创建一个ClassPool对象，它的行为就像ClassPool.getDefault()返回的默认ClassPool一样，getDefault()只是一个方便的方法。</p>
<p>注意，new ClassPool(true)是一个方便的构造函数，它可以构造一个ClassPool对象，并将系统搜索路径附加到它上面。调用该构造函数相当于下面的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPool cp = <span class="keyword">new</span> ClassPool();</span><br><span class="line">cp.appendSystemPath();  <span class="comment">// or append another path by appendClassPath()</span></span><br></pre></td></tr></table></figure>



<h3 id="级联ClassPool"><a href="#级联ClassPool" class="headerlink" title="级联ClassPool"></a>级联ClassPool</h3><p>如果程序运行在Web应用服务器上，是需要创建ClassPool的多个实例；应该为每个类加载器（容器）创建一个ClassPool的实例。==程序应该通过不调用getDefault()而调用ClassPool的构造函数来创建ClassPool对象==。</p>
<p>多个ClassPool对象可以像java.lang.ClassLoader一样级联。比如说 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 级联ClassPool</span></span><br><span class="line">ClassPool parent = ClassPool.getDefault();</span><br><span class="line">ClassPool child = <span class="keyword">new</span> ClassPool(parent);</span><br><span class="line">child.insertClassPath(<span class="string">"./classes"</span>);</span><br></pre></td></tr></table></figure>

<p>如果调用了child.get()，子ClassPool首先委托给父ClassPool。如果父ClassPool未能找到一个类文件，那么子ClassPool会尝试在./classes目录下找到一个类文件。</p>
<p>如果child.childFirstLookup为true，则子ClassPool在委托给父ClassPool之前，会尝试查找类文件。例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child classpool在委托之前加载类文件</span></span><br><span class="line">ClassPool parent2 = ClassPool.getDefault();</span><br><span class="line">ClassPool child2 = <span class="keyword">new</span> ClassPool(parent2);</span><br><span class="line">child2.appendSystemPath();         <span class="comment">// 和默认同样的class查找路径</span></span><br><span class="line">child2.childFirstLookup = <span class="keyword">true</span>;    <span class="comment">// 改变child的行为</span></span><br></pre></td></tr></table></figure>



<h3 id="改变类名来定义新类"><a href="#改变类名来定义新类" class="headerlink" title="改变类名来定义新类"></a>改变类名来定义新类</h3><p>一个新的class可以被定义为一个已存在的类的副本。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool3 = ClassPool.getDefault();</span><br><span class="line">CtClass cc3 = pool3.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">cc3.setName(<span class="string">"Pair"</span>);</span><br></pre></td></tr></table></figure>

<p>这个程序首先包含类Point的CtClass对象，然后调用<code>setName()</code>方法为CtClass对象设置新的名称。</p>
<p>在这个调用之后，该CtClass对象所代表的类定义中所有出现的类名都由Point改为Pair。类定义的其他部分不会改变。</p>
<p>注意，CtClass中的setName()会改变ClassPool对象中的一条记录。从实现的角度来看，ClassPool对象是一个CtClass对象的哈希表，setName()改变了哈希表中与CtClass对象相关联的key。该键由原来的类名改为新的类名。</p>
<p>因此，如果以后再次调用ClassPool对象的get(“Point”)，那么它再也不会返回变量cc3所指的CtClass对象。ClassPool对象又读取了一个类文件Point.class，它为类Point构造了一个新的CtClass对象。这是因为与名称Point相关联的CtClass对象已经不存在了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">CtClass cc1 = pool.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">cc.setName(<span class="string">"Pair"</span>);</span><br><span class="line">CtClass cc2 = pool.get(<span class="string">"Pair"</span>);</span><br><span class="line">CtClass cc3 = pool.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">System.out.println(cc == cc2);  <span class="comment">// true;</span></span><br><span class="line">System.out.println(cc3 == cc2); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure>

<p>cc1和cc2指的是和cc一样的CtClass实例，而cc3没有。请注意，在执行cc.setName(“Pair”)后，cc和cc1引用的CtClass对象代表Pair类，所以cc2是去寻找Pair类而cc3还是去寻找Point类。</p>
<p><code>ClassPool</code> 对象用于维护类和CtClass的一对一映射关系。javassist不允许两个不一样的CtClass表示同一个class，除非是两个独立的ClassPool创建的。</p>
<p>为了创建一个默认ClassPool实例(Clas.getDefault()返回的)的一个副本，可以使用以下代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassPool cp = <span class="keyword">new</span> ClassPool(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>这样一来，你拥有了两个ClassPool对象，可以从每一个ClassPool提供不同的CtClass对象表示同一个类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool10 = ClassPool.getDefault();</span><br><span class="line">CtClass ctClass10 = pool10.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">ClassPool pool20 = <span class="keyword">new</span> ClassPool(<span class="keyword">true</span>);</span><br><span class="line">CtClass ctClass20 = pool20.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">System.out.println(pool10 == pool20);   <span class="comment">// false 不同的ClassPool中表示同一个类的CtClass对象</span></span><br></pre></td></tr></table></figure>



<h3 id="通过重命名一个冻结的CtClass来创建一个新的CtClass对象"><a href="#通过重命名一个冻结的CtClass来创建一个新的CtClass对象" class="headerlink" title="通过重命名一个冻结的CtClass来创建一个新的CtClass对象"></a>通过重命名一个冻结的CtClass来创建一个新的CtClass对象</h3><p>一旦一个CtClass对象已经被writeFile()或者toBytecode()方法转到class文件，Javassist拒绝进一步修改该CtClass对象。因此，如果代表Point类的CtClass对象冻结后不能通过setName()修改它的名称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">cc.writeFile();<span class="comment">// 被冻结</span></span><br><span class="line">cc.setName(<span class="string">"Pair"</span>);<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>为了打破这个约束，可以使用ClassPool的<code>getAndRename()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool30 = ClassPool.getDefault();</span><br><span class="line">CtClass ctClass30 = pool30.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">ctClass30.writeFile();<span class="comment">// 被冻结</span></span><br><span class="line"><span class="comment">//ctClass30.setName("Pair");// 冻结后不能使用--错误</span></span><br><span class="line">pool30.getAndRename(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>, <span class="string">"Pair"</span>);</span><br></pre></td></tr></table></figure>

<p>这是因为，如果调用getAndRename()，ClassPool首先读取Point.class来创建一个新的代表Point类的CtClass对象。然而，它在将该CtClass对象记录在哈希表中之前，会将该CtClass对象从Point重命名为Pair。因此，getAndRename()可以在调用代表Point类的CtClass对象的writeFile()或toBytecode()之后执行。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CtClass <span class="title">getAndRename</span><span class="params">(String orgName, String newName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取一个新的CtClass对象</span></span><br><span class="line">    CtClass clazz = get0(orgName, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotFoundException(orgName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz <span class="keyword">instanceof</span> CtClassType)</span><br><span class="line">        ((CtClassType)clazz).setClassPool(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新的名称</span></span><br><span class="line">    clazz.setName(newName);         <span class="comment">// indirectly calls</span></span><br><span class="line">                                    <span class="comment">// classNameChanged() in this class</span></span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ClassLoader-类加载"><a href="#ClassLoader-类加载" class="headerlink" title="ClassLoader 类加载"></a>ClassLoader 类加载</h2><p>如果事先知道必须修改什么类，那么修改类的最简单方法如下。</p>
<ol>
<li>通过调用ClassPool.get()获得一个CtClass对象。</li>
<li>修改它</li>
<li>在该CtClass对象上调用writeFile()或toBytecode()来获取修改后的类文件。</li>
</ol>
<p>如果一个类是否被修改是在加载时确定的，用户必须使Javassist与一个类加载器协作。Javassist可以与类加载器配合使用，这样就可以在加载时修改字节码。Javassist的用户可以定义自己版本的类加载器，但也可以使用Javassist提供的类加载器。</p>
<h3 id="CtClass的toClass-方法"><a href="#CtClass的toClass-方法" class="headerlink" title="CtClass的toClass()方法"></a>CtClass的toClass()方法</h3><p>CtClass提供了一个方便的方法toClass()，它请求当前线程的上下文类加载器加载CtClass对象所代表的类。要调用这个方法，调用者必须有相应的权限，否则，可能会抛出一个SecurityException。</p>
<p>下面的程序显示了如何使用toClass()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPool cp = ClassPool.getDefault();</span><br><span class="line">        CtClass cc = cp.get(<span class="string">"Hello"</span>);</span><br><span class="line">        CtMethod m = cc.getDeclaredMethod(<span class="string">"say"</span>);</span><br><span class="line">        m.insertBefore(<span class="string">"&#123; System.out.println(\"Hello.say():\"); &#125;"</span>);</span><br><span class="line">        Class c = cc.toClass();</span><br><span class="line">        Hello h = (Hello)c.newInstance();</span><br><span class="line">        h.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Test.main()在Hello的say()的方法体中插入了对println()的调用。然后构造一个修改后的Hello类的实例，并在该实例上调用say()。</p>
<p>注意，==上面的程序取决于在调用toClass()之前，Hello类从未被加载==。如果不是这样，JVM就会在toClass()请求加载修改后的Hello类之前加载原来的Hello类。因此，加载修改后的Hello类会失败（会抛出LinkageError）。例如，如果Test中的main()是这样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Hello orig = <span class="keyword">new</span> Hello();</span><br><span class="line">    ClassPool cp = ClassPool.getDefault();</span><br><span class="line">    CtClass cc = cp.get(<span class="string">"Hello"</span>);</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么原来的Hello类在main的第一行就被加载了，而调用toClass()会抛出一个异常，因为==类加载器不能同时加载两个不同版本的Hello类==。</p>
<p><strong><em>如果程序运行在web容器中例如JBoss、Tomcat中，</em></strong> 上下文的类加载器使用<code>toClass()</code>方法可能并不适当。在这种情况下，你可能会看到一个不期望的异常<code>ClassCastException</code>。为了避免这种情况，你==必须明白清楚地给定一个适当的类加载器给<code>toClass</code>方法==。例如，如果<code>bean</code>是你的会话的bean对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CtClass cc = ...</span><br><span class="line">Class c = cc.toClass(bean.getClass().getClassLoader());</span><br></pre></td></tr></table></figure>

<p>提供toClass()是为了方便。如果你需要更复杂的功能，你应该编写自己的类加载器。</p>
<h3 id="Java中的类加载"><a href="#Java中的类加载" class="headerlink" title="Java中的类加载"></a>Java中的类加载</h3><p>在Java中，多个类加载器可以共存，每个类加载器创建自己的命名空间。不同的类加载器可以加载具有相同类名的不同class文件，加载的两个类视为不同的类，这一个特性保证我们可以在一个JVM中运行多个应用程序即使这些程序包含相同类名的不同类实例。</p>
<p><strong>注意:</strong></p>
<p>==JVM不允许动态的重新加载一个类。一旦某个类加载器加载了某个类后，它就不能在运行时再重新加载一个新版本的类了。==</p>
<p>因此，你==不能在JVM加载类后，再去变更类的定义。==</p>
<p>但是，JPDA（Java平台调试架构）提供了有限的类重加载能力。</p>
<p>如果相同的class文件被不同的类加载器加载了，==JVM会使用相同的名称和定义创建两个不同的类==，这两个类会被看做是不同的。既然这两个类是不同的，所以一个类的实例就不能分配给另一个类类型的变量了。两个类之间的转码操作失败，并抛出一个ClassCastException。</p>
<p>例如，下面的代码片段就会抛出一个ClassCastException异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyClassLoader myLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">Class clazz = myLoader.loadClass(<span class="string">"Box"</span>);</span><br><span class="line">Object obj = clazz.newInstance();</span><br><span class="line">Box b = (Box)obj;<span class="comment">// this always throws ClassCastException.</span></span><br></pre></td></tr></table></figure>

<p>Box类是由两个类加载器加载的。假设一个类加载器CL加载一个包括这个代码片段的类。由于这个代码片段引用了MyClassLoader、Class、Object和Box，CL也会加载这些类（除非它委托给另一个类加载器）。因此，变量b的类型就是CL加载的Box类。另一方面，myLoader也加载Box类。对象obj是myLoader加载的Box类的一个实例。因此，最后一条语句总是抛出一个ClassCastException，因为obj的类与作为变量b类型的Box类的不同版本。</p>
<p><strong>多个类加载器形成一个树结构</strong>:</p>
<p>每个类加载器（引导加载器BootstrapClassLoader除外）都有一个父的类加载器（通常是加载了该子类加载器的类）。类加载请求可以沿着这个类加载器层级委托，一个类可能会被不是你请求的类加载器去加载。因此，被请求去加载一个类C的类加载器和实际加载这个类C的加载器可能不是同一个类加载器。以示区别，我们将前面的加载器称为<strong><em>C的启动器</em></strong>，后面的称为<strong><em>C的真实加载器</em></strong>。</p>
<p>此外，如果请求加载类C的类加载器CL（C的发起者）委托给父类加载器PL，之后，类加载器CL则再也不会被请求去加载类C定义中引用的任何类。CL不是类C的引用的类的启动器，相反，PL成为了类C的引用的类的启动器，并且PL将会被请求去加载它们。<strong>类C的定义所引用的类是由C的真正的加载器加载</strong>。</p>
<p>再看一个有些细微差异的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;    <span class="comment">// 被PL加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;      <span class="comment">// 引导器是CL，但是真实加载器是PL</span></span><br><span class="line">    <span class="keyword">private</span> Point upperLeft, size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBaseX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> upperLeft.x; &#125;</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;    <span class="comment">// 被CL加载</span></span><br><span class="line">    <span class="keyword">private</span> Box box;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBaseX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> box.getBaseX(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设一个类<code>Window</code>被一个类加载器CL加载了，则它的引导器和真实加载器都是CL。因为Window的定义引用了Box，所以JVM会请求CL加载Box。这里，假设CL将这个任务委托给父类加载器PL。加载Box的发起者是CL，但真正的加载器是PL。在这种情况下，Point的发起者不是CL，而是PL，因为它与Box的真正加载器相同。因此，CL永远不会被请求加载Point。</p>
<p>接下来，让我们考虑一个稍加修改的例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;      <span class="comment">// 引导器是CL，但是真实加载器是PL</span></span><br><span class="line">    <span class="keyword">private</span> Point upperLeft, size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;    <span class="comment">// 被CL加载</span></span><br><span class="line">    <span class="keyword">private</span> Box box;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">widthIs</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        Point p = box.getSize();</span><br><span class="line">        <span class="keyword">return</span> w == p.getX();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在<code>Window</code>类的定义也引用了<code>Point</code>类，在这个案例中，CL在被请求加载<code>Point</code>时也将委托给PL。<strong><em>你必须避免存在两个不同的类加载器重复加载同一个类</em></strong>，二者中的其中一个必须委托给另外一个。 如果在<code>Point</code>加载的时候，CL没有委托给PL，<code>widthIs()</code>将会抛出一个<code>ClassCastException</code>。因为<code>Box</code>的真实加载器是PL，<code>Box</code>中引用的类<code>Point</code>类也会被PL加载。因此，<code>getSize()</code>方法返回值是PL加载的<code>Point</code>的一个实例，然而<code>getSize()</code>方法中的变量是CL加载的<code>Point</code>类型，JVM将它们视作不同的类型，所以会抛出类型不匹配的异常。</p>
<p>这种行为有些不方便但却是必要的,如果<code>Point p = box.getSize();</code>不会抛出异常，则<code>Window</code>的程序员就打破了<code>Point</code>类的封装性。例如，在PL加载的Point中，字段x是私有的。但是，如果CL用下面的定义加载Point(public代替private)，Window类则可以直接访问x的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x, y;    <span class="comment">// not private</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用javassist-Loader"><a href="#使用javassist-Loader" class="headerlink" title="使用javassist.Loader"></a>使用javassist.Loader</h3><p>Javassist提供了一个类加载器<code>javassist.Loader</code>，这个类加载器使用<code>javassist.ClassPool</code>对象读取class文件。</p>
<p>例如，<code>javassist.Loader</code>可用于使用javassist修改的指定的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line"><span class="comment">// 使用ClassPool创建Loader</span></span><br><span class="line">Loader cl = <span class="keyword">new</span> Loader(pool);</span><br><span class="line"></span><br><span class="line">CtClass ct = pool.get(<span class="string">"org.byron4j.cookbook.javaagent.Rectangle"</span>);</span><br><span class="line">ct.setSuperclass(pool.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>));</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; c = cl.loadClass(<span class="string">"org.byron4j.cookbook.javaagent.Rectangle"</span>);</span><br><span class="line">Object o = c.newInstance();</span><br></pre></td></tr></table></figure>

<p>这个程序修改了类Rectangle类，将其父类设置为Point类，然后程序加载了修改后的Rectangle类，并且创建了一个实例。</p>
<p><strong>如果用户想在加载一个类的时候按需修改它，则用户可以添加一个<code>javassist.Loader</code>的事件监听器。当这个类加载器加载一个类的时候就会通知添加好的事件监听器。</strong> 事件监听器必须实现以下两个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Translator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(ClassPool pool)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoad</span><span class="params">(ClassPool pool, String classname)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>当javassist.Loader中的addTranslator()将这个事件监听器添加到javassist.Loader对象中时，start()方法被调用。</li>
<li>方法onLoad()在javassist.Loader加载一个类之前被调用。onLoad()可以修改加载类的定义。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Loader的观察者</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Translator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当对象附加到加载器对象时，加载器将调用该对象进行初始化。此方法可用于获取(用于缓存)一些将在Translator的onLoad()中访问的CtClass对象。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> pool</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NotFoundException</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> CannotCompileException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(ClassPool pool)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> NotFoundException, CannotCompileException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当Loader加载一个类时，就会通知调用该方法。Loader会在onLoad()方法返回后调用</span></span><br><span class="line"><span class="comment">    *     pool.get(classname).toBytecode()</span></span><br><span class="line"><span class="comment">    * 方法去读取class文件，classname可能是尚未创建的类的名称。</span></span><br><span class="line"><span class="comment">    * 如果这样的话，&lt;code&gt;onLoad()&lt;/code&gt;方法必须创建那个class，以便Loader可以在&lt;code&gt;onLoad()&lt;/code&gt;方法返回后读取它。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> pool</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> classname</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NotFoundException</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> CannotCompileException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoad</span><span class="params">(ClassPool pool, String classname)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> NotFoundException, CannotCompileException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>javassist.Loader</code>对象的<code>addTranslator()</code>方法添加事件监听器的时候，<code>start()</code>方法就会被调用。 <code>onLoad()</code>方法会在<code>javassist.Loader</code>加载一个类之前被调用。</p>
<p> 以下是这两种情况的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加事件监听器的时候，就会调用监听器的start方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTranslator</span><span class="params">(ClassPool cp, Translator t)</span> <span class="keyword">throws</span> NotFoundException, CannotCompileException </span>&#123;</span><br><span class="line">    source = cp;</span><br><span class="line">    translator = t;</span><br><span class="line">    t.start(cp);<span class="comment">//&lt;---</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存在监听器，则在Loader的findClass方法中，先执行监听器的onLoad()方法，再通过.get(name).toBytecode()加载类</span></span><br><span class="line"><span class="keyword">if</span> (source != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (translator != <span class="keyword">null</span>)</span><br><span class="line">        translator.onLoad(source, name);<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        classfile = source.get(name).toBytecode();<span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>所以，<code>translator.onLoad</code>的方法中可以修改加载的类的定义。</strong></p>
<p>例如，下面的事件监听器在加载之前将所有的类改为公共类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTranslator</span> <span class="keyword">implements</span> <span class="title">Translator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(ClassPool pool)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NotFoundException, CannotCompileException </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoad</span><span class="params">(ClassPool pool, String classname)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NotFoundException, CannotCompileException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CtClass cc = pool.get(classname);</span><br><span class="line">        cc.setModifiers(Modifier.PUBLIC);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，onLoad()不必调用toBytecode()或writeFile()，因为javassist.Loader调用这些方法来获取类文件。</p>
<p>要运行一个带有MyTranslator对象的应用程序类MyApp，需要写一个主类，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"com.sec.Point#main invoked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">     Translator t = <span class="keyword">new</span> MyTranslator();</span><br><span class="line">     ClassPool pool = ClassPool.getDefault();</span><br><span class="line">     Loader cl = <span class="keyword">new</span> Loader();</span><br><span class="line">     cl.addTranslator(pool, t);</span><br><span class="line">     <span class="comment">// cl.run方法会运行指定MyApp的main方法</span></span><br><span class="line">     cl.run(<span class="string">"com.sec.Point"</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">% java Main2 arg1 arg2</span><br></pre></td></tr></table></figure>



<p>注意：应用的类像Point是不能访问加载器的类如MyTranslator、ClassPool的，因为它们是被不同的加载器加载的。应用的类是由javassist.Loader加载，而其他的是由默认的JVM类加载器加载的。</p>
<p><code>javassist.Loader</code>加载类的顺序和<code>java.lang.ClassLoader</code>不同。 <code>ClassLoader</code>首先将加载操作委托给父加载器，如果父加载器找不到它们才由自身尝试加载类。 反过来说，<code>javassist.Loader</code>在委托给父加载器之前尝试加载类。只有在以下情况才去委托父加载器：</p>
<ul>
<li>类不是由<code>ClassPool.get()</code>找到的</li>
<li>类使用了<code>delegateLoadingOf()</code>去指定由父加载器加载。</li>
</ul>
<p>这个搜索顺序允许Javassist加载修改过的类。然而，如果加载失败的话就会委托给父加载器去加载。一旦一个类由其父加载器加载了，这个类引用的其它类也会由其父加载器加载，则这些类就不会被当前类加载器修改了。 回想一下，类C中所有引用的类都是由类C的真实加载器负责加载的。<strong><em>如果你的程序不能加载一个修改过的类，</em></strong>你应该确保所有使用该类的类都已经被<code>javassist.Loader</code>加载了。</p>
<h3 id="编写一个类加载器"><a href="#编写一个类加载器" class="headerlink" title="编写一个类加载器"></a>编写一个类加载器</h3><p>一个使用Javassist的简单类加载器如下，继承ClassLoader。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClassPool pool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SampleLoader</span><span class="params">()</span> <span class="keyword">throws</span> NotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pool = ClassPool.getDefault();</span><br><span class="line">        <span class="keyword">this</span>.pool.insertClassPath(<span class="string">"./target/classes"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        CtClass cc;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            cc = pool.get(name);</span><br><span class="line">            <span class="comment">//TODO</span></span><br><span class="line">            <span class="keyword">byte</span>[] bb = cc.toBytecode();</span><br><span class="line">            <span class="keyword">return</span> defineClass(name,bb,<span class="number">0</span>,bb.length);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SampleLoader sl = <span class="keyword">new</span> SampleLoader();</span><br><span class="line">        Class&lt;?&gt; cl = sl.loadClass(<span class="string">"com.sec.Point"</span>);</span><br><span class="line">        cl.getDeclaredMethod("main",new Class[]&#123;String[].class&#125;).invoke(null,new Object[]&#123;args&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设Point是一个应用程序，为了执行这个程序，首先指定<code>./target/classes</code>为class文件目录。构造器中<code>insertClassPath()</code>方法指定了目录名称<code>./target/classes</code>，你可以使用不同的目录名称来代替你想要加载的类路径地址。 执行该程序，类加载器会加载Point类(Point.class文件)并且调用其main方法。</p>
<p>这是使用javassist最简单的示例。然而，如果你想编写一个更加复杂的类加载器，你需要了解更多的java类加载的机制。例如，上面的程序将Point类在命名空间与SampleLoader命名空间分开了，因为这两个是由不同的类加载器加载的。因此，Point类不能直接访问SampleLoader类。</p>
<h3 id="修改一个系统类"><a href="#修改一个系统类" class="headerlink" title="修改一个系统类"></a>修改一个系统类</h3><p>java.lang.String等系统类不能被系统类加载器以外的类加载器加载。因此，上图所示的SampleLoader或javassist.Loader不能在加载时修改系统类。</p>
<p>如果你的应用想那样去做的话（修改系统类），必须<strong><em>静态地</em></strong>修改系统类。</p>
<p>例如，添加一个新的属性字段给<code>java.lang.String</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加字段给系统类：java.lang.String</span></span><br><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass ctClass = pool.get(<span class="string">"java.lang.String"</span>);</span><br><span class="line"><span class="comment">// 创建字段</span></span><br><span class="line">CtField cf = <span class="keyword">new</span> CtField(CtClass.intType, <span class="string">"hiddenValue"</span>, ctClass);</span><br><span class="line">cf.setModifiers(Modifier.PUBLIC);</span><br><span class="line"><span class="comment">//添加字段</span></span><br><span class="line">ctClass.addField(cf);</span><br><span class="line">ctClass.writeFile(<span class="string">"."</span>);</span><br></pre></td></tr></table></figure>

<p>这个程序产生一个文件”./java/lang/String.class”。</p>
<p><code>% java -Xbootclasspath/p:. MyApp arg1 arg2...</code></p>
<h3 id="在运行时重新加载一个类"><a href="#在运行时重新加载一个类" class="headerlink" title="在运行时重新加载一个类"></a>在运行时重新加载一个类</h3><p><strong><em>如果启动JVM时启动了JPDA</em></strong>，则一个类可以重加载。在JVM加载一个类后，旧的版本的类的定义可以卸载，新的版本可以重新加载。 换言之，类的定义可以在运行时动态修改。然而，一个新的类的定义必须与旧的类定义在某种程度上兼容。 <strong><em>JVM不允许两个版本之间更改模式。</em></strong> 它们拥有相同的方法、成员变量。</p>
<p>Javassist提供了一个方便的类，用于在运行时重载一个类。更多信息，请参见 javassist.tools.HotSwapper 的 API 文档。</p>
<h2 id="自省-amp-定制化"><a href="#自省-amp-定制化" class="headerlink" title="自省 &amp; 定制化"></a>自省 &amp; 定制化</h2><p><code>CtClass</code>提供了自省的一些方法。Javassist的内省功能和Java反射API的内省功能兼容。 <code>CtClass</code>提供了<code>getName()</code>、<code>getSuperclass()</code>、<code>getMethods()</code>等等方法。<code>CtClass</code>也提供了修改类定义的方法，允许添加一个新的成员变量、构造器、方法，也可以检测方法体。 方法由<code>CtMethod</code>对象表示。<code>CtMethod</code>提供了修改方法定义的几个方法。注意：如果一个方法继承了某个类，则CtMethod表示为是在父类中声明的方法。一个<code>CtMethod</code>对象对应一个方法声明。</p>
<p>例如，如果类Point声明了一个方法move()，而Point类的的一个子类ColorPoint没有覆盖move()方法，这两个move()方法即Point中声名的和ColorPoint中继承的都由相同的CtMethod对象表示。如果修改这个CtMethod对象标表示的方法的定义，则修改会表现到这两个方法上。如果你仅仅想修改ColorPoint中的该方法，你首先必须给ColorPoint添加一个表示move()方法的CtMethod的副本，可以通过<code>CtNewMethod.copy()</code>方法获得。</p>
<p>Javassist不允许移除一个方法或者成员变量，但是允许变更方法名。所以如果一个方法不再需要了，应该重命名并且修改为私有的：调用CtMethod中的<code>setName()</code>和<code>setModifiers()</code>方法。 </p>
<p>Javassist不允许在一个已存在的方法中添加额外的参数，为了处理这样的变更，接受额外参数或者其他参数的新方法应该添加在同一个类中。例如，如果你想在一个方法中添加一个额外的参数： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> newX, <span class="keyword">int</span> newY)</span> </span>&#123; x = newX; y = newY; &#125;</span><br></pre></td></tr></table></figure>

<p>改成:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> newX, <span class="keyword">int</span> newY, <span class="keyword">int</span> newZ)</span> </span>&#123;    </span><br><span class="line">  <span class="comment">// do what you want with newZ.    </span></span><br><span class="line">  move(newX, newY); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Javassist 也提供了更低层次的API可以直接编辑原生class文件。例如,CtClass的<code>getClassFile()</code>返回一个<code>ClassFile</code>对象表示一个原生class文件。 CtMethod中的<code>getMethodInfo()</code>方法返回一个<code>MethodInfo</code>对象表示在class文件中的一个<code>method_info</code>结构。 低层次的API使用了来自JVM规范的词汇。用户必须了解class文件和字节码。更多的细节，可以参考<a href="http://www.javassist.org/tutorial/tutorial3.html#intro" target="_blank" rel="noopener">javassist.bytecode包</a>。</p>
<p>如果需要被修改的类包含以下以<code>$</code>开头的特殊标识符，则在运行时需要<code>javassist.runtime</code>包来支持。</p>
<h3 id="在方法体的前部、后部插入代码"><a href="#在方法体的前部、后部插入代码" class="headerlink" title="在方法体的前部、后部插入代码"></a>在方法体的前部、后部插入代码</h3><p><code>CtMethod</code>和<code>CtConstructor</code>提供了<code>insertBefore()</code>,<code>insertAfter()</code>和<code>addCatch()</code>方法。他们都是在已存在的方法体中插入代码段，用户可以使用Java中的<strong>源代码文本方式编写代码段</strong>。<strong>Javassist包含一个简单的Java编译器用于处理源文本，接收Java中的源文本并编译成字节码到方法体中。</strong></p>
<p>插入代码段在指定行也是可以的（如果行号表在class文件中的话），<code>CtMethod</code>和<code>CtConstructor</code>的<code>insertAt()</code>方法在源class文件中获取源文本和行号，它将编译源文本并且在指定行插入编译过的代码。 </p>
<p>语句和代码块可以指的是字段和方法。特殊变量<code>$0，$1，$2，</code>…来访问方法参数。虽然允许在块中声明一个新的局部变量，但不允许访问方法中声明的局部变量。然而，<code>insertAt()</code>允许语句和代码块访问局部变量，如果这些变量在指定的行号处可用，并且目标方法是用-g选项编译的。</p>
<p>传递给方法<code>insertBefore()</code>、<code>insertAfter()</code>、<code>addCatch()</code>和<code>insertAt()</code>的String对象是由Javassist中包含的编译器编译的。由于编译器支持语言扩展，所以几个以$开头的标识符具有特殊的意义。</p>
<p><img src="../images/Javassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210217231334157.png" alt="image-20210217231334157"></p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>$0</code>, <code>$1</code>, <code>$2</code>, …</td>
<td><code>this</code> and 方法的参数</td>
</tr>
<tr>
<td><code>$args</code></td>
<td>方法参数数组.它的类型为 <code>Object[]</code></td>
</tr>
<tr>
<td><code>$$</code></td>
<td>所有实参。例如, <code>m($$)</code> 等价于 <code>m($1,$2,</code>…<code>)</code></td>
</tr>
<tr>
<td><code>$cflow(</code>…<code>)</code></td>
<td><code>cflow</code> 变量</td>
</tr>
<tr>
<td><code>$r</code></td>
<td>返回结果的类型，用于强制类型转换</td>
</tr>
<tr>
<td><code>$w</code></td>
<td>包装器类型，用于强制类型转换</td>
</tr>
<tr>
<td><code>$_</code></td>
<td>返回值</td>
</tr>
<tr>
<td><code>$sig</code></td>
<td>类型为 java.lang.Class 的参数类型数组</td>
</tr>
<tr>
<td><code>$type</code></td>
<td>一个 java.lang.Class 对象，表示返回值类型</td>
</tr>
<tr>
<td><code>$class</code></td>
<td>一个 java.lang.Class 对象，表示当前正在修改的类</td>
</tr>
</tbody></table>
<h4 id="0-1-2"><a href="#0-1-2" class="headerlink" title="$0,$1,$2"></a><code>$0,$1,$2</code></h4><p>传递给目标方法的参数可以用<code>$1</code>，<code>$2</code>，…代替原来的参数名进行访问。1元代表第一个参数，2元代表第二个参数，以此类推。这些变量的类型与参数类型相同。<code>$0</code>相当于<code>this</code>。如果方法是静态的，则<code>$0</code>不可用。</p>
<p>这些变量的用法如下。假设一个类Point:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123; x += dx; y += dy; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要在调用move()方法时打印dx和dy的值，请执行这个程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault(); </span><br><span class="line">CtClass cc = pool.get(<span class="string">"Point"</span>); </span><br><span class="line">CtMethod m = cc.getDeclaredMethod(<span class="string">"move"</span>); </span><br><span class="line">m.insertBefore(<span class="string">"&#123; System.out.println($1); System.out.println($2); &#125;"</span>); </span><br><span class="line">cc.writeFile();</span><br></pre></td></tr></table></figure>

<p>修改后的Point类的定义是这样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">        &#123; </span><br><span class="line">          System.out.println(dx); </span><br><span class="line">          System.out.println(dy); </span><br><span class="line">        &#125;</span><br><span class="line">        x += dx; y += dy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>$1</code>和<code>$2</code>分别由dx和dy代替。</p>
<p><code>$1</code>, <code>$2</code>, <code>$3</code> …是可以更新的。如果变量值更改了，那么参数的值也会更新。</p>
<h4 id="args"><a href="#args" class="headerlink" title="$args"></a><code>$args</code></h4><p>变量<code>$args</code>表示<strong>装载所有参数的参数数组</strong>。该变量的类型是一个Object类的数组。如果一个参数类型是一个基本类型，比如int，那么参数值就会被转换为一个包装对象，比如java.lang.Integer来存储在<code>$args</code>中。因此，<code>$args[0]</code>相当于<code>$1</code>，除非第一个参数的类型是一个基本类型。请注意，<code>$args[0]</code>并不等同于​<code>$0</code>，<code>$0</code>代表了<code>this</code>。</p>
<p>如果一个Object数组被分配给$args，那么该数组的每个元素都被分配给每个参数。如果一个参数类型是基本类型，那么对应元素的类型必须是封装类型。在将值分配给参数之前，会将其从封装类型转换为基本类型。</p>
<h4 id><a href="#" class="headerlink" title="$$"></a><code>$$</code></h4><p>变量 $$ 是所有参数列表的缩写，用逗号分隔。 例如，如果方法 move() 的有 3 个参数，则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">move($$) == move($<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>)</span><br><span class="line">exMove($$, context) == exMove($<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>, context)</span><br></pre></td></tr></table></figure>

<p>如果move()不接受任何参数，那么move($$)相当于move()。</p>
<p>请注意，$$使方法调用的通用符号与参数数量相关。它通常与后面的$proceed一起使用。</p>
<h4 id="cflow"><a href="#cflow" class="headerlink" title="$cflow"></a><code>$cflow</code></h4><p>$cflow的意思是 “控制流”。这个只读变量返回特定方法的递归调用深度。</p>
<p>假设下面所示的方法由CtMethod对象cm表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n * fact(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要使用<code>$cflow</code>，首先声明<code>$cflow</code>用于监控对方法fact()的调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CtMethod cm = ...;</span><br><span class="line">cm.useCflow(<span class="string">"fact"</span>);</span><br></pre></td></tr></table></figure>

<p>useCflow()的参数是声明的$cflow变量的标识符。任何有效的Java名称都可以作为标识符。由于标识符也可以包含<code>.</code>，例如，<code>my.Test.fact</code>就是一个有效的标识符。</p>
<p>那么，<code>$cflow(fact)</code>表示cm指定的方法的递归调用的深度。当方法第一次被调用时，$cflow(fact)的值是0，而当方法内部被递归调用时，它的值是1。例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cm.insertBefore(<span class="string">"if ($cflow(fact) == 0)"</span></span><br><span class="line">              + <span class="string">"    System.out.println(\"fact \" + $1);"</span>);</span><br></pre></td></tr></table></figure>

<p>翻译方法fact()，以便它显示参数。因为检查了 $cflow(fact) 的值，所以如果在 fact() 中递归调用，则方法 fact() 不会显示参数。</p>
<p><code>$cflow</code>的值是当前线程当前最上面的栈帧下与指定方法cm相关联的栈帧数。在与指定方法cm不同的方法中也可以访问$cflow。</p>
<h4 id="r"><a href="#r" class="headerlink" title="$r"></a><code>$r</code></h4><p>$r 表示方法的结果类型（返回类型）。它用在 cast 表达式中作 cast 转换类型。 下面是一个典型的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object result = ... ;</span><br><span class="line">$_ = ($r)result;</span><br></pre></td></tr></table></figure>

<p>如果结果类型是一个基元类型，那么<code>($r)</code>遵循特殊的语义。首先，如果抛出表达式的操作数类型是基本类型，<code>($r)</code>就会作为一个普通的抛出操作数对结果类型进行操作。</p>
<p>另一方面，如果操作数类型是封装类型，<code>($r)</code>就会从封装类型转换到结果类型。例如，如果结果类型是int，那么<code>($r)</code>从java.lang.Integer转换为int。</p>
<p>如果结果类型是void，那么<code>($r)</code>不转换类型，它什么也不做。然而，如果操作数是对void方法的调用，那么($r)的结果是null。例如，如果结果类型是void，而foo()是一个void方法，则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$_ = ($r)foo();</span><br></pre></td></tr></table></figure>





<h4 id="w"><a href="#w" class="headerlink" title="$w"></a><code>$w</code></h4><p><code>$w</code>代表一个封装类型。它必须在一个cast表达式中作为cast转换类型使用。($w)从一个基本类型转换到相应的封装类型。下面的代码是一个例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i = ($w)<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>选择的封装类型取决于 ($w) 后面的表达式类型。如果表达式的类型是double，那么包装器类型就是java.lang.Double.。</p>
<p>如果<code>($w)</code>后面的表达式类型不是基本类型，那么($w)什么都不做。</p>
<h4 id="-1"><a href="#-1" class="headerlink" title="$_"></a><code>$_</code></h4><p>CtMethod和CtConstructor中的<code>insertAfter()</code>将编译后的代码插入到方法的最后。在给<code>insertAfter()</code>的语句中，不仅有上面所示的变量如<code>$0,$1</code>，还可以有<code>$_</code>。</p>
<p>变量<code>$_</code>表示方法的结果值。该变量的类型就是该方法的结果类型（返回类型）。如果结果类型是void，那么<code>$_</code>的类型是Object，<code>$_</code>的值是null。</p>
<p>虽然由insertAfter()插入的编译代码是在控件从方法中正常返回之前执行的，但它也可以在方法抛出异常时执行。<strong>为了在发生异常时执行它，<code>insertAfter()</code>的第二个参数asFinally必须为true。</strong></p>
<p>如果抛出异常，由<code>insertAfter()</code>插入的编译代码将作为最后子句执行。在编译后的代码中，<code>$_</code>的值为0或空。在编译代码执行终止后，原来抛出的异常会重新抛给调用者。注意，<code>$_</code>的值永远不会被抛给调用者，而是被丢弃。</p>
<h4 id="sig"><a href="#sig" class="headerlink" title="$sig"></a><code>$sig</code></h4><p>$sig的值是一个由java.lang.Class对象组成的数组，这些对象<strong>按照声明顺序表示形参类型</strong>。</p>
<h4 id="type"><a href="#type" class="headerlink" title="$type"></a><code>$type</code></h4><p>$type的值是一个java.lang.Class对象，代表结果值的类型。如果这是一个构造函数，那么这个变量是指Void.class。</p>
<h4 id="class"><a href="#class" class="headerlink" title="$class"></a><code>$class</code></h4><p><code>$class</code> 的值是一个 java.lang.Class 对象，代表声明编辑的方法所在的类。这代表了<code>$0</code>的类型。</p>
<h4 id="addCatch"><a href="#addCatch" class="headerlink" title="addCatch"></a><code>addCatch</code></h4><p><code>addCatch()</code>插入方法体抛出异常时执行的代码，控制权会返回给调用者。 在插入的源代码中，异常用 $e 表示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CtMethod m = ...;</span><br><span class="line">CtClass etype = ClassPool.getDefault().get(<span class="string">"java.io.IOException"</span>);</span><br><span class="line">m.addCatch(<span class="string">"&#123; System.out.println($e); throw $e; &#125;"</span>, etype);</span><br></pre></td></tr></table></figure>

<p>转换成对应的 java 代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// the original method body</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，插入的代码片段必须以 throw 或 return 语句结束。</p>
<h3 id="修改方法体"><a href="#修改方法体" class="headerlink" title="修改方法体"></a>修改方法体</h3><p>CtMethod 和 CtConstructor 提供 setBody() 来替换整个方法体。<strong>它将新的源代码编译成 Java  字节码，并用它替换原方法体。</strong> 如果给定的源文本为 null，则替换后的方法体仅包含return语句，除非结果类型为 void，否则返回零或空值。</p>
<p>在传递给 setBody() 的源代码中，以 $ 开头的标识符具有特殊含义：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>$0</code>, <code>$1</code>, <code>$2</code>, …</td>
<td><code>this</code> and 方法的参数</td>
</tr>
<tr>
<td><code>$args</code></td>
<td>方法参数数组.它的类型为 <code>Object[]</code></td>
</tr>
<tr>
<td><code>$$</code></td>
<td>所有实参。例如, <code>m($$)</code> 等价于 <code>m($1,$2,</code>…<code>)</code></td>
</tr>
<tr>
<td><code>$cflow(</code>…<code>)</code></td>
<td><code>cflow</code> 变量</td>
</tr>
<tr>
<td><code>$r</code></td>
<td>返回结果的类型，用于强制类型转换</td>
</tr>
<tr>
<td><code>$w</code></td>
<td>包装器类型，用于强制类型转换</td>
</tr>
<tr>
<td><code>$sig</code></td>
<td>类型为 java.lang.Class 的参数类型数组</td>
</tr>
<tr>
<td><code>$type</code></td>
<td>一个 java.lang.Class 对象，表示返回值类型</td>
</tr>
<tr>
<td><code>$class</code></td>
<td>一个 java.lang.Class 对象，表示当前正在修改的类</td>
</tr>
</tbody></table>
<p><code>$_</code>不可用。</p>
<h3 id="替换表达式"><a href="#替换表达式" class="headerlink" title="替换表达式"></a>替换表达式</h3><p>Javassist 只允许修改方法体中包含的表达式。</p>
<p>javassist.expr.ExprEditor 是一个用于替换方法体中的表达式的类。用户可以定义 ExprEditor 的子类来指定修改表达式的方式。</p>
<p>要运行 ExprEditor 对象，用户必须在 CtMethod 或 CtClass 中调用 instrument()。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CtMethod cm = ... ;</span><br><span class="line">cm.instrument(</span><br><span class="line">    <span class="keyword">new</span> ExprEditor() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">edit</span><span class="params">(MethodCall m)</span> <span class="keyword">throws</span> CannotCompileException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (m.getClassName().equals(<span class="string">"Point"</span>)</span><br><span class="line">                          &amp;&amp; m.getMethodName().equals(<span class="string">"move"</span>))</span><br><span class="line">                m.replace(<span class="string">"&#123; $1 = 0; $_ = $proceed($$); &#125;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码，搜索由 cm 表示的方法体，并用使用下面的代码替换 Point 中的 move()调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; $<span class="number">1</span> = <span class="number">0</span>; $_ = $proceed($$); &#125;</span><br></pre></td></tr></table></figure>

<p>因此 move() 的第一个参数总是0。注意，替换的代码不是一个表达式，而是一个语句或块。 它不能是或包含 try-catch 语句。</p>
<p><strong>方法 instrument()搜索一个方法体。</strong>如果它找到了一个表达式，如方法调用、字段访问和对象创建，那么它就在<strong>给定的ExprEditor对象上调用edit()</strong>。<strong>edit()的参数是一个代表找到的表达式的对象</strong>。edit()方法可以通过该对象检查和替换该表达式。</p>
<p><strong>在edit()的参数上调用replace()，可以将给定的语句或块替换为表达式</strong>。如果给定的块是空块，也就是说，<strong>如果执行了replace(“{}”)，那么表达式就会从方法体中删除</strong>。如果你想在表达式之前/之后插入一条语句（或一个代码块），应该向 replace()传递一个类似下面的代码块，无论表达式是方法调用、字段访问、对象创建，还是其他：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; *before-statements;*  </span><br><span class="line">$_ = $proceed($$);  </span><br><span class="line">*after-statements;* &#125;</span><br></pre></td></tr></table></figure>

<p>当是write access写访问：</p>
<p><code>$_ = $proceed();</code></p>
<p>当是read access读访问：</p>
<p><code>$proceed($$);</code></p>
<h4 id="javassist-expr-MethodCall"><a href="#javassist-expr-MethodCall" class="headerlink" title="javassist.expr.MethodCall"></a>javassist.expr.MethodCall</h4><p>一个MethodCall对象代表一个方法调用。MethodCall中的方法replace()为方法调用替换了一条语句或一个代码块。它接收代表被替换的语句或代码块的源文本，其中以$开头的标识符具有特殊意义，就像传递给insertBefore()的源文本一样。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>$0</code></td>
<td>方法调用的目标对象。它不等于 this，它代表了调用者。 如果方法是静态的，则 $0 为 null</td>
</tr>
<tr>
<td><code>$1</code>, <code>$2</code> ..</td>
<td>方法的参数</td>
</tr>
<tr>
<td><code>$_</code></td>
<td>方法调用的结果</td>
</tr>
<tr>
<td><code>$r</code></td>
<td>返回结果的类型，用于强制类型转换</td>
</tr>
<tr>
<td><code>$class</code></td>
<td>一个 java.lang.Class 对象，表示当前正在修改的类</td>
</tr>
<tr>
<td><code>$sig</code></td>
<td>类型为 java.lang.Class 的参数类型数组</td>
</tr>
<tr>
<td><code>$type</code></td>
<td>一个 java.lang.Class 对象，表示返回值类型</td>
</tr>
<tr>
<td><code>$class</code></td>
<td>一个 java.lang.Class 对象，表示当前正在修改的类</td>
</tr>
<tr>
<td><code>$proceed</code></td>
<td>调用表达式中方法的名称</td>
</tr>
</tbody></table>
<p>这里的方法调用意味着由 MethodCall 对象表示的方法。</p>
<p>其他标识符如 <code>$w</code>，<code>$args</code> 和 <code>$$</code> 也可用。</p>
<p>除非方法调用的返回类型为 void，否则返回值必须在源代码中赋给 <code>$_</code> ，<code>$_</code>的类型是表达式的结果类型。如果结果类型为 void，那么 <code>$_</code> 的值将被忽略。</p>
<p>$proceed 不是字符串值，而是特殊的语法。 它后面必须跟一个由括号括起来的参数列表。</p>
<h4 id="javassist-expr-ConstructorCall"><a href="#javassist-expr-ConstructorCall" class="headerlink" title="javassist.expr.ConstructorCall"></a>javassist.expr.ConstructorCall</h4><p>ConstructorCall 表示构造函数调用，例如包含在构造函数中的 this() 和 super()。<strong>ConstructorCall 中的方法 replace() 可以使用语句或代码块来代替构造函数。</strong>它接收表示替换语句或块的源代码。和 insertBefore() 方法一样，<strong>传递给 replace 的源代码中，</strong>以 $ 开头的标识符具有特殊的含义。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>$0</code></td>
<td>构造调用的目标对象。它等于 this</td>
</tr>
<tr>
<td><code>$1</code>, <code>$2</code>, …</td>
<td>构造函数的参数</td>
</tr>
<tr>
<td><code>$class</code></td>
<td>一个 java.lang.Class 对象，表示当前正在修改的类</td>
</tr>
<tr>
<td><code>$sig</code></td>
<td>类型为 java.lang.Class 的参数类型数组</td>
</tr>
<tr>
<td><code>$proceed</code></td>
<td>调用表达式中构造函数的名称</td>
</tr>
</tbody></table>
<p>其他标识符如 <code>$w</code>，<code>$args</code> 和 <code>$$</code> 也可用。</p>
<p>由于任何构造函数必须调用超类的构造函数或同一类的另一个构造函数，所以替换语句必须包含构造函数调用，通常是对 $proceed() 的调用。</p>
<p>$proceed 不是字符串值，而是特殊的语法。 它后面必须跟一个由括号括起来的参数列表。</p>
<h4 id="javassist-expr-FieldAccess"><a href="#javassist-expr-FieldAccess" class="headerlink" title="javassist.expr.FieldAccess"></a>javassist.expr.FieldAccess</h4><p>FieldAccess 对象表示字段访问。 如果找到对应的字段访问操作，ExprEditor 中的 edit() 方法将接收到一个 FieldAccess 对象。FieldAccess 中的 replace() 方法接收替源代码来替换字段访问。</p>
<h4 id="javassist-expr-NewExpr"><a href="#javassist-expr-NewExpr" class="headerlink" title="javassist.expr.NewExpr"></a>javassist.expr.NewExpr</h4><p>NewExpr 表示使用 new 运算符（不包括数组创建）创建对象的表达式。 如果发现创建对象的操作，NewEditor 中的 edit() 方法将接收到一个 NewExpr 对象。NewExpr 中的 replace() 方法接收替源代码来替换字段访问。</p>
<h4 id="javassist-expr-NewArray"><a href="#javassist-expr-NewArray" class="headerlink" title="javassist.expr.NewArray"></a>javassist.expr.NewArray</h4><p>NewArray 表示使用 new 运算符创建数组。如果发现数组创建的操作，ExprEditor 中的 edit() 方法一个 NewArray 对象。NewArray 中的 replace() 方法可以使用源代码来替换数组创建操作。</p>
<h4 id="javassist-expr-Instanceof"><a href="#javassist-expr-Instanceof" class="headerlink" title="javassist.expr.Instanceof"></a>javassist.expr.Instanceof</h4><p>一个 InstanceOf 对象表示一个 instanceof 表达式。 如果找到 instanceof 表达式，则ExprEditor 中的 edit() 方法接收此对象。Instanceof 中的 replace() 方法可以使用源代码来替换 instanceof 表达式。</p>
<h4 id="javassist-expr-Cast"><a href="#javassist-expr-Cast" class="headerlink" title="javassist.expr.Cast"></a>javassist.expr.Cast</h4><p>Cast 表示 cast 表达式。如果找到 cast 表达式，ExprEditor 中的 edit() 方法会接收到一个 Cast 对象。 Cast 的 replace() 方法可以接收源代码来替换替换 cast 表达式。</p>
<h4 id="javassist-expr-Handler"><a href="#javassist-expr-Handler" class="headerlink" title="javassist.expr.Handler"></a>javassist.expr.Handler</h4><p>Handler 对象表示 try-catch 语句的 catch 子句。 如果找到 catch，ExprEditor 中的 edit() 方法会接收此对象。 Handler 中的 insertBefore() 方法会将收到的源代码插入到 catch 子句的开头。</p>
<h3 id="添加新方法和字段"><a href="#添加新方法和字段" class="headerlink" title="添加新方法和字段"></a>添加新方法和字段</h3><h4 id="添加新方法"><a href="#添加新方法" class="headerlink" title="添加新方法"></a>添加新方法</h4><p>Javassist 可以创建新的方法和构造函数。CtNewMethod 和 CtNewConstructor 提供了几个工厂方法来创建 CtMethod 或 CtConstructor 对象。make() 方法可以通过源代码来CtMethod 或 CtConstructor 对象。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CtClass point = ClassPool.getDefault().get(<span class="string">"Point"</span>);</span><br><span class="line">CtMethod m = CtNewMethod.make(<span class="string">"public int xmove(int dx) &#123; x += dx; &#125;"</span>,point);</span><br><span class="line">point.addMethod(m);</span><br></pre></td></tr></table></figure>

<p>上面的代码向类 Point 添加了一个公共方法 xmove()。在这个例子中，x 是类 Point 的一个int 字段。</p>
<p>传递给 make() 和 setBody() 的源文本可以包括以<code>$</code>开头的标识符（除了<code>$_</code>）。 如果目标对象和目标方法名也被传递给 make() 方法，源文本中也可以包括 <code>$proceed</code>。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CtClass point = ClassPool.getDefault().get(<span class="string">"Point"</span>);</span><br><span class="line">CtMethod m = CtNewMethod.make(<span class="string">"public int ymove(int dy) &#123; $proceed(0, dy); &#125;"</span>,</span><br><span class="line">                 point, <span class="string">"this"</span>, <span class="string">"move"</span>);</span><br><span class="line">point.addMethod(m);</span><br></pre></td></tr></table></figure>

<p>这个程序创建一个 ymove() 方法，定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ymove</span><span class="params">(<span class="keyword">int</span> dy)</span> </span>&#123; <span class="keyword">this</span>.move(<span class="number">0</span>, dy); &#125;</span><br></pre></td></tr></table></figure>

<p>注意，$proceed 已经被替换为 this.move。</p>
<p>Javassist 还提供了另一种添加新方法的方式。 你可以先创建一个抽象方法，然后给它一个方法体：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CtClass cc = ... ;</span><br><span class="line">CtMethod m = <span class="keyword">new</span> CtMethod(CtClass.intType, <span class="string">"move"</span>,<span class="keyword">new</span> CtClass[] &#123; CtClass.intType &#125;, cc);</span><br><span class="line">cc.addMethod(m);</span><br><span class="line">m.setBody(<span class="string">"&#123; x += $1; &#125;"</span>);</span><br><span class="line">cc.setModifiers(cc.getModifiers() &amp; ~Modifier.ABSTRACT);</span><br></pre></td></tr></table></figure>

<p>因为 Javassist 在类中添加了的方法是抽象的，所以在调用 setBody() 之后，必须将类显式地改回非抽象类（拥有方法体）。</p>
<h4 id="相互递归的方法"><a href="#相互递归的方法" class="headerlink" title="相互递归的方法"></a>相互递归的方法</h4><p>如果一个方法调用了另一个没有被添加到类中的方法，Javassist就不能编译该方法。</p>
<p>(<strong>但是Javassist 可以编译一个以递归方式调用自己的方法。</strong>)</p>
<p>要将相互递归的方法添加到一个类中，你需要一个如下所示的技巧。假设你想把方法m()和n()添加到一个由cc表示的类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CtClass cc = ... ;</span><br><span class="line">CtMethod m = CtNewMethod.make(<span class="string">"public abstract int m(int i);"</span>, cc);</span><br><span class="line">CtMethod n = CtNewMethod.make(<span class="string">"public abstract int n(int i);"</span>, cc);</span><br><span class="line">cc.addMethod(m);</span><br><span class="line">cc.addMethod(n);</span><br><span class="line">m.setBody(<span class="string">"&#123; return ($1 &lt;= 0) ? 1 : (n($1 - 1) * $1); &#125;"</span>);</span><br><span class="line">n.setBody(<span class="string">"&#123; return m($1); &#125;"</span>);</span><br><span class="line">cc.setModifiers(cc.getModifiers() &amp; ~Modifier.ABSTRACT);</span><br></pre></td></tr></table></figure>

<p>你必须先创建两个抽象方法，并将它们添加到类中。然后设置它们的方法体，即使方法体包括互相递归的调用。 最后，必须将类更改为非抽象类。</p>
<h4 id="添加一个字段"><a href="#添加一个字段" class="headerlink" title="添加一个字段"></a>添加一个字段</h4><p>Javassist 还允许用户创建一个新字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CtClass point = ClassPool.getDefault().get(<span class="string">"Point"</span>);</span><br><span class="line">CtField f = <span class="keyword">new</span> CtField(CtClass.intType, <span class="string">"z"</span>, point);<span class="comment">//int z;</span></span><br><span class="line">point.addField(f);</span><br></pre></td></tr></table></figure>

<p>该程序向类 Point 添加一个名为 z 的字段。 <code>int z;</code><br>如果必须指定添加字段的初始值，那么上面的程序必须修改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CtClass point = ClassPool.getDefault().get(<span class="string">"Point"</span>);</span><br><span class="line">CtField f = <span class="keyword">new</span> CtField(CtClass.intType, <span class="string">"z"</span>, point);</span><br><span class="line">point.addField(f, <span class="string">"0"</span>);  <span class="comment">// initial value is 0</span></span><br></pre></td></tr></table></figure>

<p><strong>总结：先声明再初始化。</strong></p>
<p>现在，方法 addField() 接收两个参数，第二个参数表示计算初始值的表达式。<strong>这个表达式可以是任意 Java 表达式，只要其结果与字段的类型匹配。 请注意，表达式不以分号结尾。</strong></p>
<p>此外，上述代码可以重写为更简单代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CtClass point = ClassPool.getDefault().<span class="keyword">get</span>(<span class="string">"Point"</span>);</span><br><span class="line">CtField f = CtField.make(<span class="string">"public int z = 0;"</span>, point);</span><br><span class="line">point.addField(f);</span><br></pre></td></tr></table></figure>



<h4 id="删除成员"><a href="#删除成员" class="headerlink" title="删除成员"></a>删除成员</h4><p>要删除字段或方法，请在 CtClass 的 removeField() 或 removeMethod() 方法。 一个CtConstructor 可以通过 CtClass 的 removeConstructor() 删除。</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>CtClass，CtMethod，CtField 和 CtConstructor 提供 getAnnotations() 方法，用于读取注解。 它返回一个注解类型的对象。</p>
<p>例如，假设有以下注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Author &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">year</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是使用注解的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Author</span>(name=<span class="string">"Chiba"</span>, year=<span class="number">2005</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，可以使用 getAnnotations() 获取注解的值。 它返回一个包含注解类型对象的数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CtClass cc = ClassPool.getDefault().get(<span class="string">"Point"</span>);</span><br><span class="line">Object[] all = cc.getAnnotations();</span><br><span class="line">Author a = (Author)all[<span class="number">0</span>];</span><br><span class="line">String name = a.name();</span><br><span class="line"><span class="keyword">int</span> year = a.year();</span><br><span class="line">System.out.println(<span class="string">"name: "</span> + name + <span class="string">", year: "</span> + year);</span><br></pre></td></tr></table></figure>

<p>这段代码输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name: Chiba, year: <span class="number">2005</span></span><br></pre></td></tr></table></figure>

<p>由于 Point 的注解只有 @Author，所以数组的长度是 1，all[0] 是一个 Author 对象。 注解成员值可以通过调用Author对象的 name() 和 year() 来获取。</p>
<p>要使用 getAnnotations()，注释类型（如 Author）必须包含在当前类路径中。它们也必须也可以从 ClassPool 对象访问。如果未找到注释类型的类文件，Javassist 将无法获取该注释类型的成员的默认值。</p>
<h3 id="运行时支持类"><a href="#运行时支持类" class="headerlink" title="运行时支持类"></a>运行时支持类</h3><p>在大多数情况下，使用 Javassist 修改类不需要运行 Javassist。 但是，Javassist 编译器生成的某些字节码需要运行时支持类，这些类位于 javassist.runtime 包中（有关详细信息，请阅读该包的API文档）。请注意，<strong>javassist.runtime 是修改的类时唯一可能需要使用的包</strong>。 修改类的运行时不会再使用其他的 Javassist 类。</p>
<h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p>源代码中的所有类名都必须是完整的（必须包含包名，java.lang 除外）。例如，Javassist 编译器可以解析 Object 以及 java.lang.Object。</p>
<p><strong>要告诉编译器在解析类名时搜索其他包，请在 ClassPool中 调用 importPackage()</strong>。 例如，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">pool.importPackage(<span class="string">"java.awt"</span>);</span><br><span class="line">CtClass cc = pool.makeClass(<span class="string">"Test"</span>);</span><br><span class="line">CtField f = CtField.make(<span class="string">"public Point p;"</span>, cc);<span class="comment">//识别为java.awt.Point</span></span><br><span class="line">cc.addField(f);</span><br></pre></td></tr></table></figure>

<p>第二行导入了 java.awt 包。 因此，第三行不会抛出异常。 <strong>编译器可以将 Point 识别为java.awt.Point</strong>。</p>
<p> <strong>importPackage() 不会影响 ClassPool 中的 get() 方法</strong>。只有编译器才考虑导入包。 get() 的参数必须是完整类名。</p>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>在目前实现中，Javassist 中包含的 Java 编译器有一些限制：</p>
<ul>
<li><p>J2SE 5.0 引入的新语法（包括枚举和泛型）不受支持。注释由 Javassist 的低级 API 支持。 参见 javassist.bytecode.annotation 包（以及 CtClass 和 CtBehavior 中的 getAnnotations()）。对泛型只提供部分支持。更多信息，请参阅<a href="http://www.javassist.org/tutorial/tutorial3.html#generics" target="_blank" rel="noopener">后面</a>的部分；</p>
</li>
<li><p>初始化数组时，只有一维数组可以用大括号加逗号分隔元素的形式初始化，多维数组还不支持；</p>
</li>
<li><p>编译器不能编译包含内部类和匿名类的源代码。 但是，Javassist 可以读取和修改内部/匿名类的类文件；</p>
</li>
<li><p>不支持带标记的 continue 和 break 语句；</p>
</li>
<li><p>编译器没有正确实现 Java 方法调度算法。编译器可能会混淆在类中定义的重载方法（方法名称相同，查参数列表不同）。例如：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(A a)</span> </span>&#123; .. &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(B b)</span> </span>&#123; .. &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果编译的表达式是 <code>x.foo(new C())</code>，其中 <code>x</code> 是 <code>X</code> 的实例，编译器将产生对 <code>foo(A)</code> 的调用，尽管编译器可以正确地编译 <code>foo((B) new C())</code> 。</p>
<p><strong>建议使用 # 作为类名和静态方法或字段名之间的分隔符</strong>。 例如，在常规 Java 中：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">javassist</span><span class="selector-class">.CtClass</span><span class="selector-class">.intType</span><span class="selector-class">.getName</span>()</span><br></pre></td></tr></table></figure>

<p>在 javassist.CtClass 中的静态字段 intType 指示的对象上调用一个方法 getName()。 在Javassist 中，用户也可以写上面的表达式，但是建议写成这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javassist.CtClass#intType.getName()</span><br></pre></td></tr></table></figure>

<p>可以使编译器可以快速解析表达式。</p>
<h2 id="字节码级API"><a href="#字节码级API" class="headerlink" title="字节码级API"></a>字节码级API</h2><p>Javassist 还提供了用于直接编辑类文件的低级级 API。 使用此 API之前，你需要详细了解Java 字节码和类文件格式，因为它允许你对类文件进行任意修改。</p>
<p>如果你只想生成一个简单的类文件，使用<code>javassist.bytecode.ClassFileWriter</code>就足够了。 它比<code>javassist.bytecode.ClassFile</code>更快而且更小。</p>
<h3 id="获取ClassFile对象"><a href="#获取ClassFile对象" class="headerlink" title="获取ClassFile对象"></a>获取ClassFile对象</h3><p>javassist.bytecode.ClassFile 对象表示类文件。要获得这个对象，<strong>应该调用 CtClass 中的 <code>getClassFile()</code> 方法</strong>。你<strong>也可以直接从类文件构造 javassist.bytecode.ClassFile 对象</strong>。 例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BufferedInputStream fin</span><br><span class="line">    = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"Point.class"</span>));</span><br><span class="line">ClassFile cf = <span class="keyword">new</span> ClassFile(<span class="keyword">new</span> DataInputStream(fin));</span><br></pre></td></tr></table></figure>

<p>这代码段从 Point.class 创建一个 ClassFile 对象。</p>
<p>ClassFile 对象可以写回类文件。</p>
<p>ClassFile 的 write() 将类文件的内容写入给定的 DataOutputStream。</p>
<p>也可以从头开始创建一个类文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassFile cf = <span class="keyword">new</span> ClassFile(<span class="keyword">false</span>, <span class="string">"test.Foo"</span>, <span class="keyword">null</span>);</span><br><span class="line">cf.setInterfaces(<span class="keyword">new</span> String[] &#123; <span class="string">"java.lang.Cloneable"</span> &#125;);  </span><br><span class="line">FieldInfo f = <span class="keyword">new</span> FieldInfo(cf.getConstPool(), <span class="string">"width"</span>, <span class="string">"I"</span>); f.setAccessFlags(AccessFlag.PUBLIC); </span><br><span class="line">cf.addField(f); </span><br><span class="line">cf.write(<span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"Foo.class"</span>)));</span><br></pre></td></tr></table></figure>

<p>这段代码生成了一个类文件Foo.class，实现结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> width; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="添加和删除成员"><a href="#添加和删除成员" class="headerlink" title="添加和删除成员"></a>添加和删除成员</h3><p><strong>ClassFile 提供了 addField()，addMethod() 和 addAttribute()</strong>，来向类添加字段、方法和类文件属性。</p>
<p>注意，FieldInfo，MethodInfo 和 AttributeInfo 对象包含了一个指向 ConstPool（常量池表）对象的链接。 ConstPool 对象必须是 ClassFile 对象和添加到该 ClassFile 对象的 FieldInfo（或MethodInfo 等）对象的共同对象。 换句话说，一个FieldInfo（或MethodInfo等）对象不能在不同的ClassFile 对象之间共享。</p>
<p>要从 ClassFile 对象中删除字段或方法，必须首先获取包含该类的所有字段的 java.util.List 对象。 getFields() 和 getMethods() 会返回这些列表。可以通过调用List对象的 remove() 来删除字段或方法。可以以类似的方式删除属性。在 FieldInfo 或 MethodInfo 中调用 getAttributes() 以获取属性列表，并从列表中删除一个属性。</p>
<h3 id="遍历方法体"><a href="#遍历方法体" class="headerlink" title="遍历方法体"></a>遍历方法体</h3><p>使用 CodeIterator 可以检查方法体中的每个字节码指令，要获得 CodeIterator 对象，参考以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassFile cf = ... ; </span><br><span class="line">MethodInfo minfo = cf.getMethod(<span class="string">"move"</span>);    <span class="comment">// we assume move is not overloaded. </span></span><br><span class="line">CodeAttribute ca = minfo.getCodeAttribute(); </span><br><span class="line">CodeIterator i = ca.iterator();</span><br></pre></td></tr></table></figure>

<p>CodeIterator 对象允许你逐个访问每个字节码指令。下面展示了一部分 CodeIterator 中声明的方法：</p>
<ul>
<li><code>void begin()</code> 移动到第一条指令</li>
<li><code>void move(int index)</code> 移动到指定位置的指令</li>
<li><code>boolean hasNext()</code> 是否有下一条指令</li>
<li><code>int next()</code> 返回下一条指令的索引。注意，它<strong>不返回下一条指令的操作码</strong>。</li>
<li><code>int byteAt（int index）</code> 返回索引处的无符号8位整数。</li>
<li><code>int u16bitAt（int index）</code> 返回索引处的无符号16位整数。</li>
<li><code>int write（byte [] code，int index）</code> 在索引处写入字节数组。</li>
<li><code>void insert（int index，byte [] code）</code> 在索引处插入字节数组。自动调整分支偏移量。</li>
</ul>
<p>以下代码段打印了方法体中所有的指令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CodeIterator ci = ... ;</span><br><span class="line"><span class="keyword">while</span> (ci.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = ci.next();</span><br><span class="line">    <span class="keyword">int</span> op = ci.byteAt(index);</span><br><span class="line">    System.out.println(Mnemonic.OPCODE[op]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="生成字节码序列"><a href="#生成字节码序列" class="headerlink" title="生成字节码序列"></a>生成字节码序列</h3><p><code>Bytecode</code> 对象表示字节码指令序列。它是一个可扩展，可增长的字节码数组。<br>以下是示例代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConstPool cp = ...;    <span class="comment">// constant pool table</span></span><br><span class="line">Bytecode b = <span class="keyword">new</span> Bytecode(cp, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">b.addIconst(<span class="number">3</span>);</span><br><span class="line">b.addReturn(CtClass.intType);</span><br><span class="line">CodeAttribute ca = b.toCodeAttribute();</span><br></pre></td></tr></table></figure>

<p>这段代码产生以下序列的代码属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iconst_3</span><br><span class="line">ireturn</span><br></pre></td></tr></table></figure>

<p>还可以通过调用 Bytecode 中的 get() 方法来获取包含此序列的字节数组。获得的数组可以插入另一个代码属性中。</p>
<p>Bytecode 提供了许多方法来添加特定的指令，例如使用 addOpcode() 添加一个 8 位操作码，使用 addIndex() 用于添加一个索引。每个操作码的值定义在 Opcode 接口中。</p>
<p>addOpcode() 和添加特定指令的方法，会自动维持最大堆栈深度，除非控制流没有分支。最大堆栈深度这个值可以通过调用 Bytecode 的 getMaxStack() 方法来获得。它也反映在从 Bytecode对象构造的 CodeAttribute 对象上。要重新计算方法体的最大堆栈深度，可以调用 CodeAttribute 的 computeMaxStack() 方法。</p>
<p>可以使用Bytecode来构造一个方法。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ClassFile cf = ...</span><br><span class="line">Bytecode code = <span class="keyword">new</span> Bytecode(cf.getConstPool());</span><br><span class="line">code.addAload(<span class="number">0</span>);</span><br><span class="line">code.addInvokespecial(<span class="string">"java/lang/Object"</span>, MethodInfo.nameInit, <span class="string">"()V"</span>);</span><br><span class="line">code.addReturn(<span class="keyword">null</span>);</span><br><span class="line">code.setMaxLocals(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">MethodInfo minfo = <span class="keyword">new</span> MethodInfo(cf.getConstPool(), MethodInfo.nameInit, <span class="string">"()V"</span>);</span><br><span class="line">minfo.setCodeAttribute(code.toCodeAttribute());</span><br><span class="line">cf.addMethod(minfo);</span><br></pre></td></tr></table></figure>

<p>这段代码制作了默认的构造函数，并将其添加到cf指定的类中，Bytecode对象首先被转换为CodeAttribute对象，然后添加到minfo指定的方法中。最后将该方法添加到类文件cf中。</p>
<h3 id="注解-元标签"><a href="#注解-元标签" class="headerlink" title="注解 元标签"></a>注解 元标签</h3><p>注释作为运行时不可见（或可见）的注记属性，存储在类文件中。</p>
<p>调用 getAttribute（AnnotationsAttribute.invisibleTag）方法，可以从 ClassFile，MethodInfo 或 FieldInfo 中获取注记属性。</p>
<p>更多信息，请参阅 <code>javassist.bytecode.AnnotationsAttribute</code> 和<code>javassist.bytecode.annotation</code> 包的 javadoc 手册。</p>
<p>Javassist还允许你通过更高级别的API访问注解。如果你想通过CtClass访问注解，在CtClass或CtBehavior中调用getAnnotations()。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>Javassist 的低级别 API 完全支持 Java 5 引入的泛型。但是，高级别的API（如CtClass）不直接支持泛型。</p>
<p>Java的泛型是通过擦除技术实现的。在编译之后，所有的类型参数都会被丢掉。例如，假设你的源代码声明了一个参数化类型Vector <String>。</String></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;String&gt; v = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">  :</span><br><span class="line">String s = v.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>编译后的字节码等价于以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line">  :</span><br><span class="line">String s = (String)v.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>所以当你写字节码变换器时，你可以直接放弃所有类型参数。</p>
<p>由于<strong>Javassist中嵌入的编译器不支持泛型</strong>，所以如果源代码是由Javassist编译的，例如通过CtMethod.make()，<strong>必须在调用者处插入一个显式类型转换</strong>。如果源代码是由普通的Java编译器（如javac）编译的，则无需进行类型转换。</p>
<p>例如，如果你有一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  T value;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Wrapper</span><span class="params">(T t)</span> </span>&#123; value = t; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并想添加一个接口 Getter<T> 到类 Wrapper<T>：</T></T></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Getter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么你真正要添加的接口其实是Getter（将类型参数<T>丢掉），最后你添加到 Wrapper 类的方法是这样的：</T></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br></pre></td></tr></table></figure>

<p>注意，不需要类型参数。 由于 get 返回一个 Object，如果源代码是由 Javassist 编译的，那么在调用方需要进行显式类型转换。 例如，如果类型参数 T 是 String，则必须插入（String），如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wrapper w = ...</span><br><span class="line">String s = (String)w.get();</span><br></pre></td></tr></table></figure>

<p>如果你需要在运行时通过反射使类型参数可以访问，你必须在类文件中添加通用签名。更多的细节，请参见CtClass中setGenericSignature方法的API文档（javadoc）。</p>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>目前，Javassist 不直接支持可变参数。 因此，要使用 varargs 创建方法，必须<strong>显式设置方法修饰符</strong>。假设要定义下面这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">int</span>... args)</span> </span>&#123; <span class="keyword">return</span> args.length; &#125;</span><br></pre></td></tr></table></figure>

<p>使用 Javassist 应该是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CtClass cc = <span class="comment">/* target class */</span>;</span><br><span class="line">CtMethod m = CtMethod.make(<span class="string">"public int length(int[] args) &#123; return args.length; &#125;"</span>, cc);</span><br><span class="line">m.setModifiers(m.getModifiers() | Modifier.VARARGS);</span><br><span class="line">cc.addMethod(m);</span><br></pre></td></tr></table></figure>

<p>参数类型<code>int ...</code>被更改为<code>int []</code>，<code>Modifier.VARARGS</code>被添加到方法修饰符中。</p>
<p>要在由 Javassist 的编译器编译的源代码中调用此方法，需要这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>而不是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Javassist/" rel="tag"><i class="fa fa-tag"></i>Javassist</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Java-Agent%E8%A7%A3%E8%AF%BB/" rel="prev" title="Java Agent解读">
      <i class="fa fa-chevron-left"></i> Java Agent解读
    </a></div>
      <div class="post-nav-item">
    <a href="/Git%E7%AC%94%E8%AE%B0/" rel="next" title="Git笔记">
      Git笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>
      <!--
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="https://link.hhtjim.com/163/26348068.mp3"></iframe>
      -->
      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#序言"><span class="nav-number">1.</span> <span class="nav-text">序言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#背景"><span class="nav-number">1.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读写字节码"><span class="nav-number">1.2.</span> <span class="nav-text">读写字节码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义一个新类"><span class="nav-number">1.2.1.</span> <span class="nav-text">定义一个新类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Frozen冻结类"><span class="nav-number">1.2.2.</span> <span class="nav-text">Frozen冻结类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修剪类-prune"><span class="nav-number">1.2.3.</span> <span class="nav-text">修剪类 prune</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类搜索路径"><span class="nav-number">1.2.4.</span> <span class="nav-text">类搜索路径</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ClassPool"><span class="nav-number">1.3.</span> <span class="nav-text">ClassPool</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#避免内存不足"><span class="nav-number">1.3.1.</span> <span class="nav-text">避免内存不足</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#级联ClassPool"><span class="nav-number">1.3.2.</span> <span class="nav-text">级联ClassPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#改变类名来定义新类"><span class="nav-number">1.3.3.</span> <span class="nav-text">改变类名来定义新类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过重命名一个冻结的CtClass来创建一个新的CtClass对象"><span class="nav-number">1.3.4.</span> <span class="nav-text">通过重命名一个冻结的CtClass来创建一个新的CtClass对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ClassLoader-类加载"><span class="nav-number">1.4.</span> <span class="nav-text">ClassLoader 类加载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CtClass的toClass-方法"><span class="nav-number">1.4.1.</span> <span class="nav-text">CtClass的toClass()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java中的类加载"><span class="nav-number">1.4.2.</span> <span class="nav-text">Java中的类加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用javassist-Loader"><span class="nav-number">1.4.3.</span> <span class="nav-text">使用javassist.Loader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编写一个类加载器"><span class="nav-number">1.4.4.</span> <span class="nav-text">编写一个类加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修改一个系统类"><span class="nav-number">1.4.5.</span> <span class="nav-text">修改一个系统类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在运行时重新加载一个类"><span class="nav-number">1.4.6.</span> <span class="nav-text">在运行时重新加载一个类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自省-amp-定制化"><span class="nav-number">1.5.</span> <span class="nav-text">自省 &amp; 定制化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在方法体的前部、后部插入代码"><span class="nav-number">1.5.1.</span> <span class="nav-text">在方法体的前部、后部插入代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#0-1-2"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">$0,$1,$2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#args"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">$args</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">$$</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cflow"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">$cflow</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#r"><span class="nav-number">1.5.1.5.</span> <span class="nav-text">$r</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#w"><span class="nav-number">1.5.1.6.</span> <span class="nav-text">$w</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#-1"><span class="nav-number">1.5.1.7.</span> <span class="nav-text">$_</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sig"><span class="nav-number">1.5.1.8.</span> <span class="nav-text">$sig</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#type"><span class="nav-number">1.5.1.9.</span> <span class="nav-text">$type</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#class"><span class="nav-number">1.5.1.10.</span> <span class="nav-text">$class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#addCatch"><span class="nav-number">1.5.1.11.</span> <span class="nav-text">addCatch</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修改方法体"><span class="nav-number">1.5.2.</span> <span class="nav-text">修改方法体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#替换表达式"><span class="nav-number">1.5.3.</span> <span class="nav-text">替换表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#javassist-expr-MethodCall"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">javassist.expr.MethodCall</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#javassist-expr-ConstructorCall"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">javassist.expr.ConstructorCall</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#javassist-expr-FieldAccess"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">javassist.expr.FieldAccess</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#javassist-expr-NewExpr"><span class="nav-number">1.5.3.4.</span> <span class="nav-text">javassist.expr.NewExpr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#javassist-expr-NewArray"><span class="nav-number">1.5.3.5.</span> <span class="nav-text">javassist.expr.NewArray</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#javassist-expr-Instanceof"><span class="nav-number">1.5.3.6.</span> <span class="nav-text">javassist.expr.Instanceof</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#javassist-expr-Cast"><span class="nav-number">1.5.3.7.</span> <span class="nav-text">javassist.expr.Cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#javassist-expr-Handler"><span class="nav-number">1.5.3.8.</span> <span class="nav-text">javassist.expr.Handler</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#添加新方法和字段"><span class="nav-number">1.5.4.</span> <span class="nav-text">添加新方法和字段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#添加新方法"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">添加新方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相互递归的方法"><span class="nav-number">1.5.4.2.</span> <span class="nav-text">相互递归的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#添加一个字段"><span class="nav-number">1.5.4.3.</span> <span class="nav-text">添加一个字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除成员"><span class="nav-number">1.5.4.4.</span> <span class="nav-text">删除成员</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注解"><span class="nav-number">1.5.5.</span> <span class="nav-text">注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时支持类"><span class="nav-number">1.5.6.</span> <span class="nav-text">运行时支持类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#导入包"><span class="nav-number">1.5.7.</span> <span class="nav-text">导入包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#限制"><span class="nav-number">1.5.8.</span> <span class="nav-text">限制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字节码级API"><span class="nav-number">1.6.</span> <span class="nav-text">字节码级API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#获取ClassFile对象"><span class="nav-number">1.6.1.</span> <span class="nav-text">获取ClassFile对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#添加和删除成员"><span class="nav-number">1.6.2.</span> <span class="nav-text">添加和删除成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#遍历方法体"><span class="nav-number">1.6.3.</span> <span class="nav-text">遍历方法体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成字节码序列"><span class="nav-number">1.6.4.</span> <span class="nav-text">生成字节码序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注解-元标签"><span class="nav-number">1.6.5.</span> <span class="nav-text">注解 元标签</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型"><span class="nav-number">1.7.</span> <span class="nav-text">泛型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可变参数"><span class="nav-number">1.8.</span> <span class="nav-text">可变参数</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fynch3r"
      src="/images/yfy.png">
  <p class="site-author-name" itemprop="name">fynch3r</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fynch3r" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fynch3r" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.0kami.cn/" title="https:&#x2F;&#x2F;blog.0kami.cn&#x2F;" rel="noopener" target="_blank">wh1t3p1g</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://zebork.org/" title="https:&#x2F;&#x2F;zebork.org" rel="noopener" target="_blank">Zebork</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://su18.org/" title="https:&#x2F;&#x2F;su18.org" rel="noopener" target="_blank">su18</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/tr1ple/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;tr1ple&#x2F;" rel="noopener" target="_blank">tr1ple</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://4ra1n.love/" title="https:&#x2F;&#x2F;4ra1n.love&#x2F;" rel="noopener" target="_blank">4ra1n</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.cnpanda.net/" title="http:&#x2F;&#x2F;www.cnpanda.net&#x2F;" rel="noopener" target="_blank">panda</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://m0d9.me/" title="http:&#x2F;&#x2F;m0d9.me&#x2F;" rel="noopener" target="_blank">yangbh</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://anemone.top/" title="http:&#x2F;&#x2F;anemone.top" rel="noopener" target="_blank">Anemone95</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.kingkk.com/" title="https:&#x2F;&#x2F;www.kingkk.com&#x2F;" rel="noopener" target="_blank">kingkk</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.yuque.com/ni4n/blogs" title="https:&#x2F;&#x2F;www.yuque.com&#x2F;ni4n&#x2F;blogs" rel="noopener" target="_blank">Ni4n</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://summersec.github.io/" title="https:&#x2F;&#x2F;summersec.github.io" rel="noopener" target="_blank">SummerSec</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.zhihu.com/people/chenwengang" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;chenwengang" rel="noopener" target="_blank">ApsarasX</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>




      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        


<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="true"></i>
  </span>
   Powered By - 
  <span class="author" itemprop="copyrightHolder">fynch3r</span>

  <!--
    <span class="post-meta-divider"> | </span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">822k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">22:50</span>
  -->

</div>

        






  <script>
  function leancloudSelector(url) {
    url = encodeURI(url);
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.getAttribute('id'));
      var title = visitors.dataset.flagTitle;

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.getAttribute('id'));
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (let item of results) {
            let { url, time } = item;
            leancloudSelector(url).innerText = time;
          }
          for (let url of entries) {
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=Xm92yiHJb6lBpsP02sgh3uGo-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : 'Xm92yiHJb6lBpsP02sgh3uGo-gzGzoHsz',
            'X-LC-Key'    : 'l8KvoMr1i8urA7X7BzPMtQC7',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Xm92yiHJb6lBpsP02sgh3uGo-gzGzoHsz',
      appKey     : 'l8KvoMr1i8urA7X7BzPMtQC7',
      placeholder: "Say Something~",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


<!--

  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unjkp.com/valine/dist/Valine.min.js"></script>  
  <script src="/js/Valine.min.js"></script> 

   
  
  <script src="/js/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(function (item) {
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'Xm92yiHJb6lBpsP02sgh3uGo-gzGzoHsz',
        appKey: 'l8KvoMr1i8urA7X7BzPMtQC7',
        placeholder: 'Say Something~',
        avatar:'mm',
        guest_info:['nick'] ,  //评论者只需要提供评论的昵称即可
        pageSize:'10' || 10,
    });
  
    var infoEle = document.querySelector('#comments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0){
      infoEle.childNodes.forEach(function(item) {
        item.parentNode.removeChild(item);
      });
    }
  </script>

-->

</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/click_love.js"></script>