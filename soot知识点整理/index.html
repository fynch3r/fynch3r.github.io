<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-pace-theme-flash.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<!--

  <script src="//code.tidio.co/oixl41gwhy8tvqy6jte9uvglyrqcjrvc.js" async></script>

-->

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"0range228.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>
  <meta name="description" content="序言 江山留胜迹，我辈复登临。  兜兜转转好几圈，发现还是用soot的人多。借此机会，再跟一遍tutorials，写点我自己的理解。 同步项目：MySootScript">
<meta property="og:type" content="article">
<meta property="og:title" content="Soot知识点整理">
<meta property="og:url" content="https://0range228.github.io/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="0range的小窝">
<meta property="og:description" content="序言 江山留胜迹，我辈复登临。  兜兜转转好几圈，发现还是用soot的人多。借此机会，再跟一遍tutorials，写点我自己的理解。 同步项目：MySootScript">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210324104136273.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325093439720.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210324104437621.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210619180333086.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210619182313742.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210619194142262.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325104642746.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325213104028.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210429202819731.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210323212112768.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210618145538494.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210618151630333.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210618152726361.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210621161925815.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210618195553353.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325112408646.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325112426889.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325144633222.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325142641719.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325142908378.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210328172341115.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210328220439227.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325165632527.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325200427960.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504174235403.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504175256326.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504175753420.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504165107321.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325101740004.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504163639221.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504164347627.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504164650563.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504164817152.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504164833065.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504165304260.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325111055645.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325143900136.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325110830807.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210702193719630.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504165925735.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325152047653.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210326153604047.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210326153831632.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210430161058053.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210430161544317.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210329152634399.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210329152706388.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210327155003872.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210329152722190.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210329153258001.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210329153345586.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210430181603345.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210430201447240.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210430202734875.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210501161528622.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210501162907634.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210501163108300.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210501170326266.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210501172943670.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504160140618.png">
<meta property="og:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504161739103.png">
<meta property="article:published_time" content="2020-07-18T11:14:40.000Z">
<meta property="article:modified_time" content="2021-10-17T03:03:40.963Z">
<meta property="article:author" content="0range">
<meta property="article:tag" content="Soot">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://0range228.github.io/images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210324104136273.png">

<link rel="canonical" href="https://0range228.github.io/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>Soot知识点整理 | 0range的小窝</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="0range的小窝" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
<a href="https://github.com/0range228" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#FFA500; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">0range的小窝</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Trust the process.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">31</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">55</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://0range228.github.io/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yfy.png">
      <meta itemprop="name" content="0range">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0range的小窝">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Soot知识点整理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-18 19:14:40" itemprop="dateCreated datePublished" datetime="2020-07-18T19:14:40+08:00">2020-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-17 11:03:40" itemprop="dateModified" datetime="2021-10-17T11:03:40+08:00">2021-10-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span id="/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" class="post-meta-item leancloud_visitors" data-flag-title="Soot知识点整理" title="热度">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">热度：</span>
              <span class="leancloud-visitors-count"></span>
              <span>°C</span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>31k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>51 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>江山留胜迹，我辈复登临。</p>
</blockquote>
<p>兜兜转转好几圈，发现还是用soot的人多。借此机会，再跟一遍<a href="https://github.com/soot-oss/soot/wiki/Tutorials" target="_blank" rel="noopener">tutorials</a>，写点我自己的理解。</p>
<p>同步项目：<a href="https://github.com/0range228/MySootScript" target="_blank" rel="noopener">MySootScript </a> </p>
<a id="more"></a>

<h1 id="SSA"><a href="#SSA" class="headerlink" title="SSA"></a>SSA</h1><p><strong>SSA</strong> 是static single assignment 的缩写，也就是<strong>静态</strong>单赋值形式。 顾名思义，就是每个变量只赋值一次。</p>
<h1 id="soot配置选项"><a href="#soot配置选项" class="headerlink" title="soot配置选项"></a>soot配置选项</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Options.v().set_output_format(Options.output_format_jimple);<span class="comment">//输出的形式</span></span><br><span class="line">Options.v().set_output_dir(<span class="string">"sootOutput"</span>);<span class="comment">//输出目录</span></span><br><span class="line">Options.v().set_whole_program(<span class="keyword">true</span>);<span class="comment">//全程序分析</span></span><br><span class="line">Options.v().set_verbose(<span class="keyword">true</span>);<span class="comment">//显示详细信息</span></span><br><span class="line">PackManager.v().writeOutput(); <span class="comment">//关键：启动输出。（不运行此语句不会进行输出）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Options.v().set_no_bodies_for_excluded(<span class="keyword">true</span>);<span class="comment">//不加载被排除的类 /callgraph边会减少很多</span></span><br><span class="line">Options.v().set_allow_phantom_refs(<span class="keyword">true</span>);<span class="comment">//找不到对应的源代码就被称作是虚类（phantom class） 允许虚类存在 不报错</span></span><br><span class="line">Options.v().set_process_dir(Collections.singletonList(apkPath));<span class="comment">//处理所有在dir中发现的类</span></span><br><span class="line">Options.v().setPhaseOption(“cg.spark”, “on”);<span class="comment">//开启SPARK分析CallGraph</span></span><br></pre></td></tr></table></figure>











<h1 id="soot的基本数据结构"><a href="#soot的基本数据结构" class="headerlink" title="soot的基本数据结构"></a>soot的基本数据结构</h1><p>soot有一个很复杂的层次结构，比如Scene，SootClass，SootClass，SootMethod，Body，Local，Trap，Unit；</p>
<p>Scene：</p>
<p>表示整个分析所发生的环境。</p>
<p>通过Scene可以设置提供给soot分析的所有的应用类、包含main方法的类和有关过程间分析的访问信息。</p>
<p>SootClass：</p>
<p>表示装入到soot中或者由soot创建的单个类。</p>
<p>在Scene中的各个类都是由SootClass类的实例表示的。</p>
<p>一个SootClass包含一个Java类所有相关的信息，例如这个类的类名、修饰符、父类、SootField、SootMethod链等。</p>
<p>SootField：</p>
<p>表示类的属性，也可以叫做域。</p>
<p>SootMethod：</p>
<p>表示一个类中的单个方法。</p>
<p>Body：</p>
<p>Body接口用来表示方法的实现。</p>
<p>在soot中，一个Body隶属于一个SootMethod，即soot用一个Body为一个方法存储代码。</p>
<p>分析应用可以使用Body访问各种信息，如一组声明的局部变量、方法体内语句、以及方法体内处理的异常。</p>
<p>Chain：</p>
<p>链。</p>
<p>每个Body里面有三个主链，分别是Units链、Locals链、Traps链。</p>
<p>Units：方法体内的语句。</p>
<p>Locals：方法内的局部变量。</p>
<p>Traps：方法内的异常处理。</p>
<p>四种Body：</p>
<p>BafBody、JimpleBody、ShimpleBody、GrimpBody，分别对应四种不同的中间表示法。</p>
<p>JimpleBody用得最多。</p>
<p>4种IR</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210324104136273.png" alt="image-20210324104136273"></p>
<h1 id="主流IR-Jimple"><a href="#主流IR-Jimple" class="headerlink" title="主流IR Jimple"></a>主流IR Jimple</h1><ol>
<li><p>基于栈</p>
<p>java语言的字节码表示本来就是栈的，而象Dalvik 是基于寄存器的，在这点上Jimple基于栈</p>
</li>
<li><p>有类型</p>
<p>每一个参数都定义了Type，并且类型精度没有丢失，比如int $i0</p>
</li>
<li><p>基于三地址分析</p>
<p>三地址解析中会出现很多的中间变量</p>
<p>三地址同时会拆解一些高级特性，被分解成多个单位，包含一些低级操作，支持低端指令一般而言，三地址代码将包含大部分低级操作，即目标机所支持的指令。</p>
</li>
</ol>
<p>此图<a href="https://blog.csdn.net/raintungli/article/details/101445822?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161663537516780271563057%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=161663537516780271563057&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v1~rank_blog_v1-3-101445822.pc_v1_rank_blog_v1&utm_term=soot" target="_blank" rel="noopener">参考</a></p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325093439720.png" alt="image-20210325093439720"></p>
<p>在body中有Units，Values，Traps，接下来细说。</p>
<p>Unit语句在Jimple中就是Stmt。</p>
<p>例如赋值语句：</p>
<p>AssignStmt：x=y+z</p>
<p>##Jimple Stmt类型</p>
<p>核心语句：NopStmt，IdentityStmt，AssignStmt</p>
<p>负责过程内控制流</p>
<p>IfStmt , GotoStmt , SwitchStmt</p>
<p>负责过程间的控制流：</p>
<p>InvokeStmt ,ReturnStmt,ReturnVoidStmt., ThrowStmt</p>
<p>监控语句：MonitorStmt</p>
<p>赋值语句：DefinitionStmt</p>
<p>其它类型：NopStmt, BreakponitStmt</p>
<p>已经不使用的语句RetStmt</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210324104437621.png" alt="image-20210324104437621"></p>
<p>Soot为中间代码的翻译建立了一系列的基础设施。</p>
<p><code>AbstractStmtSwitch</code></p>
<p><code>soot.jimple.AbstractJimpleValueSwitch</code></p>
<p>等等还有很多switch，他们都是针对不同的语句进行了很多情况的分析。</p>
<h2 id="Value-amp-Box"><a href="#Value-amp-Box" class="headerlink" title="Value&amp;Box"></a>Value&amp;Box</h2><p>Value：</p>
<ul>
<li>Local</li>
<li>Constant</li>
<li>Ref</li>
<li>Expr</li>
</ul>
<p>这里简单讲一下Expr接口，他又有一系列的实现，例如NewExpr和AddExpr，在下一节会详细介绍。</p>
<p>一般来说，一个Expr可以对若干个Value进行一些操作并且返回另一个Value；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = y + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>上面这是AssignStmt，他的leftOp是x，rightOp是一个AddExpr（y+2）</p>
<p>AddExpr又包含了值y和2作为操作数，前者是一个局部变量，而后者是一个常量。</p>
<p>在Jimple中，我们强制要求所有的Value<strong>最多包含一个表达式</strong>。</p>
<p>下面写一些常用的：</p>
<h3 id="Local"><a href="#Local" class="headerlink" title="Local"></a>Local</h3><p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210619180333086.png" alt="image-20210619180333086"></p>
<p><strong>JimpleLocal</strong> local变量</p>
<p><strong>TemporaryRegisterLocal</strong> $开头的临时变量</p>
<h3 id="Constant"><a href="#Constant" class="headerlink" title="Constant"></a>Constant</h3><p>各种常量</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210619182313742.png" alt="image-20210619182313742"></p>
<p>可以说是很完备了</p>
<p>最常用了也就是<strong>StringConstant</strong>和<strong>NumericConstant</strong>了。</p>
<h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><p>引用 相当于指针。RefTypes是以类名为参数。</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210619194142262.png" alt="image-20210619194142262"></p>
<p><strong>ConcreteRef</strong></p>
<ul>
<li>ArrayRef 指向数组</li>
<li>FieldRef 指向field<ul>
<li>StaticFieldRef 静态field的引用</li>
<li>InstanceFieldRef 指向的field是一个对象实例</li>
</ul>
</li>
</ul>
<p><strong>IdentityRef</strong></p>
<ul>
<li><strong>CaughtExcrptionRef</strong> 指向捕获到的异常的引用</li>
<li><strong>ParameterRef</strong> 函数参数的引用</li>
<li><strong>ThisRef</strong> this的引用</li>
</ul>
<h3 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box</h3><p>Box是指针！！！！！提供了对Soot对象的间接访问。<strong>一个Box提供了一个间接访问soot (Unit,Value)的入口</strong>，类似于Java的一个引用，当Unit包含另一个Unit的时候，需要通过Box来访问，Soot 里提供了两种类型的Box, 一个是ValueBox一个是UnitBox。</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325104642746.png" alt="image-20210325104642746"></p>
<p>上图可以看出来：</p>
<ul>
<li><strong>一个Unit有多个UnitBox，但是每个UnitBox只能指向一个Unit</strong>。GotoStmt 需要知道目标的Unit是什么，所以一个Unit会包含其它的UnitBox，通过 UnitBox获取下一个Unit。</li>
<li><strong>一个Value可以对应多个ValueBox，但是一个ValueBox只能对应一个Value</strong>，对于一个Unit，可以得到很多个ValueBox，包含着这条语句内部的所用到和所定义的语句。</li>
</ul>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325213104028.png" alt="image-20210325213104028"></p>
<p>两种Box：</p>
<ul>
<li>ValueBox，指向Values<ul>
<li>对于一条Unit来说，他的ValueBox存储的是在这条语句内部所<strong>用到</strong>的和<strong>所定义</strong>的语句。</li>
</ul>
</li>
<li>UnitBox，指向Units <ul>
<li>以goto语句为例，UnitBox其实存的就是goto所指的下一跳节点。</li>
<li>switch语句，则会包含很多boxes</li>
</ul>
</li>
</ul>
<p>i1=0 等于是一个Stmt,  i1是一个Valuebox，里面包含这i0这个local 的value。</p>
<p>多说几句：</p>
<p>DefBox是什么？</p>
<p>List defBoxes = ut.getDefBoxes();</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210429202819731.png" alt="image-20210429202819731"></p>
<p>举例常量叠加：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a  = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c = a + b;</span><br><span class="line"><span class="keyword">return</span> c;</span><br></pre></td></tr></table></figure>

<p>由于a,b的值都是常量，需要叠加一下，当然这部分soot内部已经实现了：</p>
<p>对于<code>int c = a + b</code>来说，这句话是一个赋值语句，也就是<code>AssignStmt</code>，在这个赋值语句中，左边是Local，右边是AddExpr，他们都是Value类型。</p>
<p>下面算法的逻辑：</p>
<ol>
<li>对于这个AssignStmt来说，需要首先获取他的Boxes，这些Boxes里面包含了Value的指针。</li>
<li>遍历Boxes，cast为ValueBox，然后获取他的Value，如果是AddExpr的话，那就是我们想优化的。</li>
<li>对于AddExpr来说，获取他的左值和右值，也就是两个value。</li>
<li>如果都是常量IntConstant的话，那么就把他们的value加在一起。</li>
<li>重新给AssignStmt的box赋值，让他指向sum和的常量。</li>
</ol>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210323212112768.png" alt="image-20210323212112768"></p>
<p>对于Unit语句类型来说，必须包含的方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List <span class="title">getUseBoxes</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List <span class="title">getDefBoxes</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List <span class="title">getUseAndDefBoxes</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>这些方法会返回在这条Unit语句内部Use的，Define的，或者两者都看。会以List of ValueBox的形式返回。</p>
<p>对于getUseBoxes()方法，将返回所有使用的值；当然包括各种Expr表达式及其组成部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List <span class="title">getUnitBoxes</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>上面这个方法会返回一个List （UnitBox），包含所有被这个Unit所指向的其他Unit。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List <span class="title">getBoxesPointingToThis</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>上面这个方法会返回一个List（UnitBox），包含那些指向这个Unit的Unit语句。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">fallsThrough</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">branches</span><span class="params">()</span></span>; <span class="comment">//如：IfStmt、GotoStmt</span></span><br></pre></td></tr></table></figure>

<p>处理在某条语句之后的执行流有关。</p>
<p>第一个方法：如果执行可以顺利流到紧挨着的下一条语句，就会返回True；</p>
<p>第二个方法：如果执行可以继续流下去，但是并不会流到紧挨着的下一条语句，返回True。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">redirectJumpsToThisTo</span><span class="params">(Unit newLocation)</span></span>;</span><br></pre></td></tr></table></figure>

<p>上面这个方法会用<code>getBoxesPointingToThis</code>方法去改变所有曾经指向这个Unit的跳转，让他们都指向这个新的<code>newLocation</code>。</p>
<p>总结：</p>
<p>我们能够确定<strong>跳转到这个Unit的其他Unit</strong>（调用getBoxesPointingToThis()），也可以找到<strong>跳到的其他Unit</strong>（调用getUnitBoxes()）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ValueBox&gt; <span class="title">getUseBoxes</span><span class="params">()</span></span>;<span class="comment">//返回Unit中使用的Value的引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ValueBox&gt; <span class="title">getDefBoxes</span><span class="params">()</span></span>;<span class="comment">//返回Unit中定义的Value的引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ValueBox&gt; <span class="title">getUseAndDefBox</span><span class="params">()</span></span>;<span class="comment">//返回Unit中定义并使用的Value的引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List <span class="title">geUnitBoxes</span><span class="params">()</span></span>;<span class="comment">//获得被这个unit跳转到的UnitxBox的List</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List <span class="title">getBoxesPointingTothis</span><span class="params">()</span></span>;<span class="comment">//获得该unit作为跳转对象时，所有跳转本身的UnitBox</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">fallsThrough</span><span class="params">()</span></span>;<span class="comment">//如果接下来执行后面挨着的unit，则为true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">branches</span><span class="params">()</span></span>;<span class="comment">//如果执行时会跳转到其他别的unit，则返回true。如：IfStmt、GotoStmt</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rediectJumpsToThisTo</span><span class="params">(Unit newLocation)</span></span>;<span class="comment">//该方法把跳转到该unit重定向到newLocation</span></span><br></pre></td></tr></table></figure>



<h2 id="Stmt和Expr的区别"><a href="#Stmt和Expr的区别" class="headerlink" title="Stmt和Expr的区别"></a>Stmt和Expr的区别</h2><p>Stmt的基本实现都在<code>soot.jimple.internal</code>中，我们把目光聚集到Jimple这种IR。关系图如下：</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210618145538494.png" alt="image-20210618145538494"></p>
<p>正如上图所示，<code>soot.jimple</code>包里面，<code>internal</code>包内部存放的是实现了<code>Stmt</code>的抽象类，没有在<code>internal</code>包内存放的是继承了<code>Stmt</code>接口的其余接口。</p>
<h3 id="AbstractStmt"><a href="#AbstractStmt" class="headerlink" title="AbstractStmt"></a>AbstractStmt</h3><p>在<code>internal</code>包内，最先实现<code>Stmt</code>接口的是<code>AbstractStmt</code>接口：</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210618151630333.png" alt="image-20210618151630333"></p>
<p>读到这里，我相信你应该有点感觉了，soot架构里面的抽象类应该都有对应的实现。</p>
<p>这也就是为什么，剩下的三个抽象类肯定还有具体的实现。</p>
<h4 id="AbstractDefinitionStmt"><a href="#AbstractDefinitionStmt" class="headerlink" title="AbstractDefinitionStmt"></a>AbstractDefinitionStmt</h4><p>表示一个赋值语句</p>
<p>我们先看AbstractDefinitionStmt抽象类的实现  </p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210618152726361.png" alt="image-20210618152726361"></p>
<p><strong>JAssignStmt</strong></p>
<p>一个正常的复制语句</p>
<p>比如说可以给一个堆栈变量<code>$stack5</code>赋值 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$stack5 = newarray (java.lang.Object)[<span class="number">0</span>]</span><br><span class="line">$stack4 = <span class="keyword">new</span> pta.ptademo.A;</span><br></pre></td></tr></table></figure>

<p>$变量其实就是模拟了JVM中局部变量表里面的堆栈变量，本质上也是一种Local</p>
<p><strong>JIdentityStmt</strong></p>
<p>通常指的是对变量赋值，这个变量既可以是显示的也可以是隐式的</p>
<p>函数传参，程序会帮你把从参数传入的变量，赋值给一个临时变量，给函数内部调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r1 := <span class="meta">@parameter</span>0: java.lang.String</span><br></pre></td></tr></table></figure>

<p>this变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r0 := <span class="meta">@this</span>: com.spring.Controller</span><br></pre></td></tr></table></figure>



<p><strong>两者区别！！！</strong></p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210621161925815.png" alt="image-20210621161925815"></p>
<p>可以理解为：</p>
<p>一个IdentityStmt将特殊值，如参数、this或被捕获的异常，分配给一个Local。</p>
<p>所有 “正常 “的赋值，例如从一个Local到另一个Local，或者从一个Constant到一个Local，都是用AssignStmt表示的。</p>
<blockquote>
<p>不同的IdentityStmts的共同点是它们分配的值都是 “神奇地从天而降”。在方法入口处，这些是参数和 “this”，而在异常处理程序中，这些是抛出的异常。换句话说，在处理程序开始的地方，在方法的主体里有一个带有异常引用的IdentityStmt是完全可以的，也是人们所期待的。Soot的唯一假设是，如果一个语句是Trap的目标，即处理程序的开始，那么该处理程序中的第一个语句应该是一个带有适当异常引用的IdentityStmt。</p>
</blockquote>
<h4 id="AbstractSwitchStmt"><a href="#AbstractSwitchStmt" class="headerlink" title="AbstractSwitchStmt"></a>AbstractSwitchStmt</h4><p>switch语句主要由于JVM对于不同的Switch语句，会生成不同的操作指令，从而也就有了两种Switch语句</p>
<p><strong>JLookupSwitchStmt</strong> lookup类型的switch</p>
<p><strong>JTableSwitchStmt</strong> table类型的switch</p>
<h4 id="AbstractOpStmt"><a href="#AbstractOpStmt" class="headerlink" title="AbstractOpStmt"></a>AbstractOpStmt</h4><p>四个实现类</p>
<table>
<thead>
<tr>
<th>类</th>
<th>表示</th>
</tr>
</thead>
<tbody><tr>
<td><strong>JEnterMonitorStmt</strong></td>
<td>线程进入</td>
</tr>
<tr>
<td><strong>JExitMonitorStmt</strong></td>
<td>线程退出</td>
</tr>
<tr>
<td><strong>JReturnStmt</strong></td>
<td>return语句</td>
</tr>
<tr>
<td><strong>JThrowStmt</strong></td>
<td>throw语句</td>
</tr>
</tbody></table>
<h3 id="其他Stmt-直接写上"><a href="#其他Stmt-直接写上" class="headerlink" title="其他Stmt 直接写上"></a>其他Stmt 直接写上</h3><table>
<thead>
<tr>
<th>Stmt</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>JInvokeStmt</strong></td>
<td>调用方法的语句</td>
</tr>
<tr>
<td><strong>JBreakpointStmt</strong></td>
<td>break语句</td>
</tr>
<tr>
<td><strong>JGotoStmt</strong></td>
<td>go to语句</td>
</tr>
<tr>
<td><strong>JIfStmt</strong></td>
<td>if 语句</td>
</tr>
<tr>
<td><strong>JNopStmt</strong></td>
<td>nop跳转</td>
</tr>
<tr>
<td><strong>JRetStmt</strong></td>
<td>jsr 基本不用了</td>
</tr>
<tr>
<td><strong>JReturnStmt</strong></td>
<td>return语句</td>
</tr>
<tr>
<td><strong>JReturnVoidStmt</strong></td>
<td>return void 语句</td>
</tr>
</tbody></table>
<h3 id="AbstractInvokeExpr"><a href="#AbstractInvokeExpr" class="headerlink" title="AbstractInvokeExpr"></a>AbstractInvokeExpr</h3><p>表示调用的表达式</p>
<p>之前也提到过，invoke一共有五种：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>soot</th>
<th>具体用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong>invokestatic</strong></td>
<td><strong>JStaticInvokeExpr</strong></td>
<td>调用static静态方法</td>
</tr>
<tr>
<td><strong>invokevirtual</strong></td>
<td><strong>JVirtualInvokeExpr</strong></td>
<td>调用虚方法、final方法</td>
</tr>
<tr>
<td><strong>invokeinterface</strong></td>
<td><strong>JInterfaceInvokeExpr</strong></td>
<td>调用接口方法，在运行时搜索实现了这个方法的对象，进行合适的调用</td>
</tr>
<tr>
<td><strong>invokespecial</strong></td>
<td><strong>JSpecialInvokeExpr</strong></td>
<td>调用实例方法，init构造方法、private、父类方法</td>
</tr>
<tr>
<td><strong>invokedynamic</strong></td>
<td><strong>JDynamicInvokeExpr</strong></td>
<td>动态解析出需要调用的方法，然后执行 invoke  lambda</td>
</tr>
</tbody></table>
<p>这五种被soot指派了两个抽象类来实现：</p>
<p>调用方法 静态static + 动态dynamic</p>
<ul>
<li><p><strong>JStaticInvokeExpr</strong></p>
</li>
<li><p><strong>JDynamicInvokeExpr</strong></p>
</li>
</ul>
<h3 id="AbstractInstanceInvokeExpr"><a href="#AbstractInstanceInvokeExpr" class="headerlink" title="AbstractInstanceInvokeExpr"></a>AbstractInstanceInvokeExpr</h3><p>调用一个变量调用自身的方法</p>
<ul>
<li><strong>JVirtualInvokeExpr</strong></li>
<li><strong>JInterfaceInvokeExpr</strong></li>
<li><strong>JSpecialInvokeExpr</strong></li>
</ul>
<p>这部分soot还有一种划分方式，</p>
<p>InvokeExpr</p>
<ul>
<li><p>InstanceInvokeExpr</p>
<ul>
<li>JVirtualInvokeExpr</li>
<li>JInterfaceInvokeExpr</li>
<li>JSpecialInvokeExpr</li>
</ul>
</li>
<li><p>StaticInvokeExpr</p>
<ul>
<li>JStaticInvokeExpr</li>
</ul>
</li>
<li><p>DynamicInvokeExpr</p>
<ul>
<li>JDynamicInvokeExpr</li>
</ul>
</li>
</ul>
<h3 id="AbstractBinopExpr"><a href="#AbstractBinopExpr" class="headerlink" title="AbstractBinopExpr"></a>AbstractBinopExpr</h3><p>一堆数学操作，加减乘除、逻辑与或非、比较、位运算</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210618195553353.png" alt="image-20210618195553353"></p>
<h4 id="其他Expr-直接写上"><a href="#其他Expr-直接写上" class="headerlink" title="其他Expr 直接写上"></a>其他Expr 直接写上</h4><table>
<thead>
<tr>
<th>Expr</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>JCastExpr</strong></td>
<td>cast 强制类型转换</td>
</tr>
<tr>
<td><strong>JInstanceOfExpr</strong></td>
<td>instanceof</td>
</tr>
<tr>
<td><strong>JNewMultiArrayExpr</strong></td>
<td>多维数组</td>
</tr>
<tr>
<td><strong>JNewExpr</strong></td>
<td>new</td>
</tr>
<tr>
<td><strong>JNewArrayExpr</strong></td>
<td>创建new array</td>
</tr>
<tr>
<td><strong>JLengthExpr</strong></td>
<td>数组长度</td>
</tr>
<tr>
<td><strong>JNegExpr</strong></td>
<td>否定一个int变量</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="处理阶段Pack-Transformer"><a href="#处理阶段Pack-Transformer" class="headerlink" title="处理阶段Pack/Transformer"></a>处理阶段Pack/Transformer</h1><p><strong>程序内分析</strong>：</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325112408646.png" alt="image-20210325112408646"></p>
<p>上面这张图是<strong>程序内分析</strong>大致框架图，入口点是Jimple，用户可以在转化阶段加入一些分析相关的信息。这个可以在<strong>jtp（Jimple Transformation pack）</strong>阶段来实现。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PackManager.v().getPack(<span class="string">"jtp"</span>).add(<span class="keyword">new</span> Transform(<span class="string">"jtp.myTransform"</span>, <span class="keyword">new</span> BodyTransformer()&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">internalTransform</span><span class="params">(Body b, String phaseName,</span></span></span><br><span class="line"><span class="function"><span class="params">			Map options)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			...</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码就是在jtp pack中插入小步骤myTransform，但soot的执行流执行完自定义的myTransform后，将继续沿着执行流执行，自定义的小步骤就像soot的一个插件，并不影响其他的执行流顺序。</p>
<p><strong>程序间分析</strong>：</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325112426889.png" alt="image-20210325112426889"></p>
<p>第二张图是程序间程序分析</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PackManager.v().getPack(<span class="string">"wjtp"</span>).add(</span><br><span class="line">	<span class="keyword">new</span> Transform(<span class="string">"wjtp.myTransform"</span>, <span class="keyword">new</span> SceneTransformer() &#123;				</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">internalTransform</span><span class="params">(String arg0,</span></span></span><br><span class="line"><span class="function"><span class="params">		Map&lt;String, String&gt; arg1)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">						</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">					</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>上述代码就是在wjtp pack中插入一个小步骤myTransform。 但soot的执行流执行完自定义的myTransform后，将继续沿着执行流执行，自定义的小步骤就像soot的一个插件，并不影响其他的执行流顺序。</p>
<p>这里总结一下各个阶段的命名规则：</p>
<p>第一个字母表示中间代码种类：</p>
<ul>
<li>j=Jimple</li>
<li>s=Shimple</li>
<li>b=Baf</li>
<li>g=Grimp</li>
</ul>
<p>第二个字母表示该阶段做的事情：</p>
<ul>
<li>b=body 方法体创建阶段</li>
<li>t=transform 用户自定的创建阶段</li>
<li>o=optimizations 优化阶段</li>
<li>a=annotion 属性生成阶段</li>
</ul>
<p>最后的P：</p>
<ul>
<li>p=pack 处理阶段</li>
</ul>
<img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325144633222.png" alt="image-20210325144633222" style="zoom:50%;">



<h2 id="核心阶段与小阶段"><a href="#核心阶段与小阶段" class="headerlink" title="核心阶段与小阶段"></a>核心阶段与小阶段</h2><p>在Soot的核心阶段分为PP-&gt;CG-&gt;TP-&gt;OP-&gt;AP，Soot支持多IR分析，但在核心过程中只支持Jimple, Shimple, 在Pack中可以插入自定义的Transform，这样就可以在每一个分析阶段加入自己的分析步骤，从而实现自定义分析的能力。</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325142641719.png" alt="image-20210325142641719"></p>
<p>但是一开始jb都是必须要做的，生成jimplebody，下图中，jb阶段就是核心阶段，下面罗列的就是小阶段：</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325142908378.png" alt="image-20210325142908378"></p>
<p>具体每个小阶段是干嘛的，可以看<a href="https://soot-build.cs.uni-paderborn.de/public/origin/develop/soot/soot-develop/options/soot_options.htm" target="_blank" rel="noopener">这里</a></p>
<p>PP</p>
<p>Pre-processing Pack 是第一个分析的Pack,该Pack允许你自定义一些自己的transform在构建call graph之前。</p>
<p>CG</p>
<p>CG Call Graph，调用图，调用图是静态层序分析的关键，方法调用图包含着整个函数调用的关系图。</p>
<h2 id="body-packs"><a href="#body-packs" class="headerlink" title="body packs"></a>body packs</h2><p>Body Packs 基于Body 的Packs分析，对不同的IR有不同的Packs。</p>
<p>和前面的核心Packs不同的是，这里只是基于Body进行分析，每个Packs依然可以自己定义Transform，区别是使用不同的Transformer，在Body packs里使用的是BodyTransformer。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">internalTransform</span><span class="params">(Body b, String phaseName, Map&lt;String, String&gt; options)</span></span>;</span><br></pre></td></tr></table></figure>

<p>internalTransform里面包含了Body 对象</p>
<p>与核心的Pack分析不同的是，当分析到Body的Packs的时候，Soot会启动多线程进行Pack的分析。</p>
<p>在Soot里，每个阶段都又对应的pack来完成。</p>
<p>Pack其实具体来说就是一组变换器(Transformer)，每个变换器对应着相应的子阶段。</p>
<p>当Pack被调用时，它按照执行顺序执行每一个Tranformer。</p>
<p>提供拓展机制的是那些允许用户自定义变换的Pack：</p>
<ol>
<li>jtp：Jimple-transformation-pack</li>
<li>stp：Shimple-transformation-pack</li>
</ol>
<p>在不改变Soot自身的情况下，用户往往可以自定义满足需求的类（变换器），然后将其注入到这些pack中，之后调用soot.Main()，使其进入到Soot的正常流程调度中。</p>
<h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h2><p>Transformer是Soot的变换器，允许用户自定义。</p>
<p>Soot变换器通常是继承两种：</p>
<ol>
<li>BodyTransformer：针对单个方法体，过程内，进行变换；</li>
<li>SceneTransformer：针对整个应用，过程间，进行变换。</li>
</ol>
<p>这两种方法下，变换器类都必须重构internalTransform方法，在这个方法里对被分析的代码执行某种变换。</p>
<p>你的transformer也可以分开写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">PackManager.v().getPack(<span class="string">"jtp"</span>).add(<span class="keyword">new</span> Transform(<span class="string">"jtp.myAnalysis"</span>, <span class="keyword">new</span> MyAnalysis()));</span><br><span class="line">PackManager.v().runPacks();</span><br><span class="line">System.out.println(Scene.v().getCallGraph().size());</span><br><span class="line">PackManager.v().writeOutput();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//MyAnalysis.java文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnalysis</span> <span class="keyword">extends</span> <span class="title">BodyTransformer</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">internalTransform</span><span class="params">(<span class="keyword">final</span> Body body,String phase, @SuppressWarnings(<span class="string">"rawtypes"</span>)</span>Map options)</span>&#123;      </span><br><span class="line">      <span class="keyword">for</span> (SootClass c:Scene.v().getApplicationClasses()) &#123;</span><br><span class="line">          System.out.println(<span class="string">"[sootClass]"</span>+c);</span><br><span class="line">        <span class="keyword">for</span>(SootMethod m:c.getMethods())</span><br><span class="line">        &#123;</span><br><span class="line">              System.out.println(<span class="string">"[sootMethod]"</span>+m);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(m.isConcrete())</span><br><span class="line">            &#123;</span><br><span class="line">                Body b=m.retrieveActiveBody();</span><br><span class="line">                  System.out.println(<span class="string">"[body]"</span>+b);</span><br><span class="line"></span><br><span class="line">                Iterator&lt;Unit&gt; i=b.getUnits().snapshotIterator();</span><br><span class="line">                <span class="keyword">while</span>(i.hasNext())</span><br><span class="line">                &#123;</span><br><span class="line">                    Unit u=i.next();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="控制流图-CFG"><a href="#控制流图-CFG" class="headerlink" title="控制流图 CFG"></a>控制流图 CFG</h1><p>soot有两种类型的控制流图(两个抽象类，均实现DirectedGraph接口)：</p>
<ul>
<li>UnitGraph</li>
<li>BlockGraph</li>
</ul>
<p>区别：</p>
<p>UnitGraph是语句图，结点是Units。</p>
<p>BlockGraph是基本控制流图，结点由基本块BasicBlocks组成。</p>
<p>共同点：</p>
<p>首先这两种类型图的表示是相通的。</p>
<p>该接口中的API们，可以获取到：</p>
<ul>
<li>图的入口节点和出口节点；</li>
<li>一个给定节点的前驱结点和后继结点；</li>
<li>一个以某种未明确规定的顺序和节点数在图中进行迭代的迭代器。</li>
<li>图的大小规模（节点数）</li>
</ul>
<img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210328172341115.png" alt="image-20210328172341115" style="zoom:60%;">



<p>在这些基础上就可以开发对任意DirectedGraph有向图进行处理的方法。</p>
<p>实际上，UnitGraph和BlockGraph都是抽象类，Soot自己也实现很多实例化的子类。</p>
<p>例如CompleteUnitGraph、BriefUnitGraph、CompleteBlockGraph、BriefBlockGraph等。</p>
<p>具体在soot.toolkits.graph有实现说明。</p>
<p>继承实现关系</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210328220439227.png" alt="image-20210328220439227"></p>
<h2 id="语句图UnitGraph"><a href="#语句图UnitGraph" class="headerlink" title="语句图UnitGraph"></a>语句图UnitGraph</h2><p>巧妙之处：数据的关系与数据的内容进行了分离。</p>
<p>UnitGraph只是将Unit中的关系进行了保存，并不会改动Unit，Body的内容。</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325165632527.png" alt="image-20210325165632527"></p>
<p>soot中UnitGraph是一个抽象程度较高的语句图。</p>
<p>重点说一下UnitGraph：</p>
<p>UnitGraph的优点是简化了控制流图，<strong>没有了基本块的概念</strong>。</p>
<p>使用它可以简化传统的固定点数据流分析的实现。(fixed point data flow analysis)</p>
<p>但是缺点是由于没有了基本块，那么也就增加了分析时间的开销。</p>
<h3 id="UnitGraph的四个子类"><a href="#UnitGraph的四个子类" class="headerlink" title="UnitGraph的四个子类"></a>UnitGraph的四个子类</h3><p>继承UnitGraph的有4种：</p>
<ul>
<li>BriefUnitGraph 【用得最多】</li>
<li>EnhancedUnitGraph</li>
<li>ExceptionalUnitGraph</li>
<li>TrapUnitGraph</li>
</ul>
<p>API：</p>
<img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325200427960.png" alt="image-20210325200427960" style="zoom:80%;">



<p>BriefUnitGraph：</p>
<p>【正常，异常分离】BriefUnitGraph将正常的流程，与异常的处理流程进行了分离。（不相交，在最后才进行汇聚）；不包含针对exception的边</p>
<p>ExceptionalUnitGraph：</p>
<p>【融合】将正常流程与异常流程进行了融合，而不再是分离的。包含exception的边</p>
<ul>
<li>包含从throw到catch的边，soot里面叫Trap</li>
<li>它还会计算语句中隐含的异常抛出</li>
<li>会有一条边从抛出异常那条语句的前驱节点指向异常处理的第一条语句Unit</li>
<li>如果包含异常的语句包含一些副作用，那么有副作用的边也会被添加到图里面</li>
</ul>
<p>TrapUnitGraph：</p>
<p>【相对于ExceptionalUnitGraph】一些很普通的语句也会跳转到异常流程中。（比如nop,goto[?=nop]）—-&gt;<strong>认为try 中包含的所有的语句都有可能触发异常</strong>。</p>
<ul>
<li>边是从trap语句连接到trap handler，例如try块</li>
<li>对于那些隐藏异常抛出的语句，这类图在他们的前驱节点并不会抛出一条边到handler</li>
<li>但是在那些隐藏异常抛出的语句本身会抛出一条语句指向handler</li>
</ul>
<p>通过以下代码对给定的函数创建CFG：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnitGraph g = <span class="keyword">new</span> ExceptionalUnitGraph(body);</span><br></pre></td></tr></table></figure>



<h1 id="Host-amp-Tag"><a href="#Host-amp-Tag" class="headerlink" title="Host &amp; Tag"></a>Host &amp; Tag</h1><p> soot层次如下图：</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504174235403.png" alt="image-20210504174235403"></p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504175256326.png" alt="image-20210504175256326"></p>
<p>Tag的接口由Host负责。</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504175753420.png" alt="image-20210504175753420"></p>
<p>Call Graph &amp; Point-to</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504165107321.png" alt="image-20210504165107321"></p>
<h2 id="CG-amp-CFG-amp-ICFG"><a href="#CG-amp-CFG-amp-ICFG" class="headerlink" title="CG &amp; CFG &amp; ICFG"></a>CG &amp; CFG &amp; ICFG</h2><p>CallGraph &amp; Control Flow Graph &amp; Interprocedural Control-Flow Graph</p>
<p>CG代表的是整个程序中方法之间调用关系的图，<strong>图中节点是函数，边代表的是调用关系</strong>。</p>
<p>CFG代表的是一个方法内程序执行流的图，<strong>图中节点是语句组成的基本块，边代表执行流</strong>。</p>
<p>CFG上条件语句节点的后缀会有多个，表示其后可能执行的不同branches。</p>
<p>ICFG就是CG+CFG，可以看作是CG和CFG信息的叠加。ICFG可以看做是给所有方法的CFG加上这些方法之间互相调用的边（CG）所形成的图。调用边（call edge）从调用语句（call site）连到被调方法（callee）的入口。与CG不同的是，ICFG除了调用边，还包含相应的返回边（return edge），从callee的出口连到call site之后执行的下一个语句。</p>
<h2 id="CG-Call-Graph"><a href="#CG-Call-Graph" class="headerlink" title="CG Call Graph"></a>CG Call Graph</h2><p>调用图，调用图是静态分析的关键，方法调用图包含着整个函数调用的关系图。</p>
<p>edge：</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325101740004.png" alt="image-20210325101740004"></p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504163639221.png" alt="image-20210504163639221"></p>
<h4 id="Querying-Call-Graph"><a href="#Querying-Call-Graph" class="headerlink" title="Querying Call Graph"></a>Querying Call Graph</h4><p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504164347627.png" alt="image-20210504164347627"></p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504164650563.png" alt="image-20210504164650563"></p>
<h4 id="Reachable-Methods"><a href="#Reachable-Methods" class="headerlink" title="Reachable Methods"></a>Reachable Methods</h4><p>记录从entry method开始可以到达的方法们</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504164817152.png" alt="image-20210504164817152"></p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504164833065.png" alt="image-20210504164833065"></p>
<h4 id="Transitive-Targets"><a href="#Transitive-Targets" class="headerlink" title="Transitive Targets"></a>Transitive Targets</h4><p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504165304260.png" alt="image-20210504165304260"></p>
<p>CallGraph结构：</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325111055645.png" alt="image-20210325111055645"></p>
<p>Call Graph对象里包含了所有的Edges的集合，同时也包含了了几个关键Map</p>
<ol>
<li>src Map</li>
<li>target Map</li>
<li>unit Map</li>
</ol>
<p>这些Map的Key是SootMethod，Unit而Value是Edge，为了更快的找到SootMethod或者Unit对应的Edge。</p>
<p>CallGraph构建</p>
<p>Call Graph是方法的调用图，要画出方法的调用图是需要起始点的，也就是我们常说的EntryPoint。</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325143900136.png" alt="image-20210325143900136"></p>
<p>在全程序分析的模式下，当一个调用图构建时，我们可以用<code>Scene</code>类里面的<code>getCallGraph</code>方法。</p>
<p>包含3个处理的办法，</p>
<p>CHA     SPARK      Paddle,</p>
<p>其中<strong>默认生成call graph使用的是CHA</strong>，CHA生成速度快，但是是最不准确的。</p>
<p>CHA是最简单的分析方式，它是默认程序中所有的路径都是连通的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CHATransformer.v().transform();</span><br><span class="line">SootClass a = Scene.v().getClass(<span class="string">"testers.A"</span>);</span><br><span class="line"></span><br><span class="line">SootMethod src = Scene.v().getMainClass().getMethodByName(<span class="string">"doStuff"</span>);</span><br><span class="line">CallGraph cg = Scene.v().getCallGraph();</span><br></pre></td></tr></table></figure>

<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325110830807.png" alt="image-20210325110830807"></p>
<p>这里前提是必须开启全局模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Options.v().set_whole_program(<span class="keyword">true</span>);</span><br><span class="line">PackManager.v().runPacks();</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Options.v().setPhaseOption(<span class="string">"cg.spark"</span>, <span class="string">"on"</span>);<span class="comment">//SPARK生成的call graph更准确</span></span><br><span class="line">Scene.v().loadNecessaryClasses();<span class="comment">//加载相关的类</span></span><br><span class="line"><span class="comment">//设置call graph的入口点</span></span><br><span class="line">SootMethod entryPoint = app.getEntryPointCreator().createDummyMain();</span><br><span class="line">Options.v().set_main_class(entryPoint.getSignature());</span><br><span class="line">Scene.v().setEntryPoints(Collections.singletonList(entryPoint));</span><br><span class="line">System.out.println(entryPoint.getActiveBody());</span><br><span class="line"><span class="comment">//就绪后开始运行</span></span><br><span class="line">PackManager.v().runPacks();</span><br><span class="line"><span class="comment">//获得运行之后的结果。（call graph相关的信息）</span></span><br><span class="line">System.out.println(Scene.v().getCallGraph().size());</span><br></pre></td></tr></table></figure>

<p>这里分析一个简单的程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallGraph</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        doStuff();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doStuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> D().foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>soot code：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String className = <span class="string">"demo.CallGraph"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String methodName = <span class="string">"doStuff"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String sourceDirectory = System.getProperty(<span class="string">"user.dir"</span>)+ File.separator + <span class="string">"target"</span> + File.separator + <span class="string">"classes"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setupSoot</span><span class="params">()</span></span>&#123;</span><br><span class="line">        G.reset();</span><br><span class="line">        Options.v().set_prepend_classpath(<span class="keyword">true</span>);</span><br><span class="line">        Options.v().set_allow_phantom_refs(<span class="keyword">true</span>);</span><br><span class="line">        Options.v().set_soot_classpath(sourceDirectory);</span><br><span class="line">        Options.v().set_output_format(Options.output_format_jimple);</span><br><span class="line">        Options.v().set_process_dir(Collections.singletonList(sourceDirectory));</span><br><span class="line">        Options.v().set_whole_program(<span class="keyword">true</span>);</span><br><span class="line">        Scene.v().loadNecessaryClasses();</span><br><span class="line">        PackManager.v().runPacks();</span><br><span class="line">        SootClass sootClass = Scene.v().loadClassAndSupport(className);</span><br><span class="line">        sootClass.setApplicationClass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        setupSoot();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        SootClass sc = Scene.v().forceResolve(className, SootClass.BODIES);也可以</span></span><br><span class="line">        SootClass sc = Scene.v().getSootClass(className);</span><br><span class="line">        SootMethod srcMethod = sc.getMethodByName(methodName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置入口点</span></span><br><span class="line">        List&lt;SootMethod&gt; entrypoint = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        entrypoint.add(srcMethod);</span><br><span class="line">        Scene.v().setEntryPoints(entrypoint);</span><br><span class="line"></span><br><span class="line">        PackManager.v().getPack(<span class="string">"wjtp"</span>).add(<span class="keyword">new</span> Transform(<span class="string">"wjtp.myTransform"</span>, <span class="keyword">new</span> SceneTransformer() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">internalTransform</span><span class="params">(String s, Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">                CHATransformer.v().transform();</span><br><span class="line">                SootClass sc = Scene.v().forceResolve(className, SootClass.BODIES);</span><br><span class="line">                SootMethod srcMethod = sc.getMethodByName(methodName);</span><br><span class="line">                CallGraph cg = Scene.v().getCallGraph();</span><br><span class="line">                Iterator&lt;MethodOrMethodContext&gt; targets = <span class="keyword">new</span> Targets(cg.edgesOutOf(srcMethod));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(targets.hasNext())&#123;</span><br><span class="line">                    SootMethod tgt = (SootMethod) targets.next();</span><br><span class="line">                    System.out.println(srcMethod+<span class="string">" may call "</span>+tgt);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        PackManager.v().runPacks();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看doStuff能调用哪个方法，CHA结果：</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210702193719630.png" alt="image-20210702193719630"></p>
<p><strong>发现并不是绝对的准确的结果</strong></p>
<p>备注：</p>
<p>PackMananger是负责进行阶段处理的，它控制着各种执行的运行，<strong>不启动则不会运行相应的阶段</strong>。</p>
<h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><p><a href="https://blog.csdn.net/raintungli/article/details/102635324" target="_blank" rel="noopener">Spark</a>分析</p>
<p><a href="https://blog.csdn.net/TheSnowBoy_2/article/details/53414419?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161665612916780261990999%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=161665612916780261990999&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~times_rank-12-53414419.pc_v2_rank_blog_default&utm_term=soot" target="_blank" rel="noopener">参考</a></p>
<p>Spark针对的是对于Java的指向分析，支持 基于集合的分析，以及 基于等值的分析。</p>
<p>但是，<strong>Spark提供的是基于上下文不敏感的子集的点对点分析</strong>。</p>
<p>指向分析（points-to）只是SPARK分析的一部分，一系列不同层次，不同方面的分析，可以通过配置options来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashMap opt = <span class="keyword">new</span> HashMap();</span><br><span class="line">opt.put(<span class="string">"verbose"</span>,<span class="string">"true"</span>);</span><br><span class="line">opt.put(<span class="string">"propagator"</span>,<span class="string">"worklist"</span>);</span><br><span class="line">opt.put(<span class="string">"simple-edges-bidirectional"</span>,<span class="string">"false"</span>);</span><br><span class="line">opt.put(<span class="string">"on-fly-cg"</span>,<span class="string">"true"</span>);</span><br><span class="line">opt.put(<span class="string">"set-impl"</span>,<span class="string">"double"</span>);</span><br><span class="line">opt.put(<span class="string">"double-set-old"</span>,<span class="string">"hybrid"</span>);</span><br><span class="line">opt.put(<span class="string">"double-set-new"</span>,<span class="string">"hybrid"</span>);</span><br><span class="line">SparkTransformer.v().transform(<span class="string">""</span>,opt);</span><br></pre></td></tr></table></figure>

<p>解读：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">verbose</span>. (设定SPARK在分析过程中，打印多种信息【提示信息】)</span><br><span class="line">- propagator SPARK. (包含两个传播算法，原生迭代算法，基于worklist的算法)</span><br><span class="line">- simple-edges-bidirectional. (如果设置为真，则所有的边都为双向的)</span><br><span class="line">- <span class="keyword">on</span>-fly-cg.（通过设置此选项，进行更加精确的points-<span class="keyword">to</span>分析，得到精确的<span class="keyword">call</span> graph）</span><br><span class="line">- <span class="keyword">set</span>-impl. (描述points-<span class="keyword">to</span>集合的实现。可能的值为hash,<span class="type">bit</span>,hybrid,<span class="keyword">array</span>,<span class="type">double</span>)</span><br><span class="line">- <span class="type">double</span>-<span class="keyword">set</span>-<span class="built_in">old</span>以及<span class="type">double</span>-<span class="keyword">set</span>-<span class="built_in">new</span>.</span><br></pre></td></tr></table></figure>

<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504165925735.png" alt="image-20210504165925735"></p>
<p>SPARK运行结果：</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325152047653.png" alt="image-20210325152047653"></p>
<p>解读：</p>
<p>左边列的数字表明，变量初始化的点。（比如：[4,8] Container intersect? false，中的数字表示在第4行初始化的变量，以及在第8行初始化的变量 ） </p>
<p>右边列表示，两个变量的指向的集合中交集是否为空。不空为true,空为false。</p>
<p>【结果分析】可以看出，c1自己与自己是有交集的。c1与c2是没有交集的。（c1, c3也是如此）</p>
<h2 id="Point-to"><a href="#Point-to" class="headerlink" title="Point-to"></a>Point-to</h2><p>interface</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">reachingObjects(Local) 返回指向某个Local变量的指针集合PointsToSet</span><br><span class="line">x = y</span><br><span class="line"></span><br><span class="line">reachingObjects(SootField)  返回指向某个静态属性的指针集合PointsToSet</span><br><span class="line">x = C.f</span><br><span class="line"> </span><br><span class="line">reachingObjects(Local,SootField) 返回指向某个实例对象的field指针集合PointsToSet</span><br><span class="line">x = y.f</span><br><span class="line">  </span><br><span class="line">possibleTypes() 返回某个对象的所有可能类型</span><br><span class="line">returns a set of the possible types of the objects in the points-to set</span><br><span class="line"></span><br><span class="line">hasNonEmptyIntersection(PointsToSet) 判断两个指针集合是否重叠（重叠当然就是alias别名关系）</span><br></pre></td></tr></table></figure>

<h4 id="例子a"><a href="#例子a" class="headerlink" title="例子a"></a>例子a</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">o.m()</span><br><span class="line">如果想知道上面调用中，o对象的所有类型</span><br><span class="line">Local o;</span><br><span class="line">PointsToAnalysis pa = Scene.v().getPointsToAnalysis();</span><br><span class="line">PointsToSet ptset = pa.reachingObjects( o );</span><br><span class="line">java.util.Set types = ptset.possibleTypes()</span><br></pre></td></tr></table></figure>

<h4 id="例子b"><a href="#例子b" class="headerlink" title="例子b"></a>例子b</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x.f = <span class="number">5</span>;</span><br><span class="line">y.f = <span class="number">6</span>;</span><br><span class="line">z = x.f;</span><br><span class="line">如果想判断x,y是否是别名关系</span><br><span class="line"></span><br><span class="line">Local x, y;</span><br><span class="line">PointsToAnalysis pa = Scene.v().getPointsToAnalysis();</span><br><span class="line">PointsToSet xset = pa.reachingObjects( x );</span><br><span class="line">PointsToSet yset = pa.reachingObjects( y );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(xset.hasNonEmptyIntersection(yset))</span><br><span class="line"><span class="comment">// they’re possibly aliased</span></span><br></pre></td></tr></table></figure>



<h1 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h1><p>在soot里面分为过程内数据流分析和过程间数据流分析。</p>
<p>程序可以看成是状态（数据）和状态之间的转移（控制）两部分，因为状态转移的条件都被忽略了，核心分析的部分是状态数据在转移过程中的变化，所以叫做数据流分析。</p>
<p>首先，总体来说：</p>
<ol>
<li>每个语句相当于一个小的加工厂，加工厂加工需要一定的原料（输入 in）,并且会产生一定的效果（输出 out）。</li>
<li><strong>out = in - kll +gen</strong>这个公式反映了数据流分析的本质，这让数据在语句中真正流动起来（在数据流分析中）。</li>
<li>kill和gen是主要依赖于语句本身的。比如说，a = 100这个语句的作用是将a中之前的值抹去（<strong>kill</strong>）,同时放入 100的值（<strong>gen</strong>）。</li>
<li>out反映的是语句处理之后造成的<strong>后果</strong>。</li>
</ol>
<h2 id="近似分析"><a href="#近似分析" class="headerlink" title="近似分析"></a>近似分析</h2><p>对于IfStmt来说，会出现branch分叉，那么对于汇聚点来说，就会存在Locals的不确定态。</p>
<h3 id="近似的两种级别"><a href="#近似的两种级别" class="headerlink" title="近似的两种级别"></a>近似的两种级别</h3><ul>
<li><p>must</p>
<p>取交集，分析的结果一定<strong>被包含</strong>于正确答案之内。</p>
</li>
<li><p>may</p>
<p>取并集，分析的结果<strong>包含</strong>正确的答案。</p>
</li>
</ul>
<img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210326153604047.png" alt="image-20210326153604047" style="zoom:80%;">

<p>举例：</p>
<img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210326153831632.png" alt="image-20210326153831632" style="zoom:80%;">

<p>may：-2 &lt; a &lt; 5</p>
<p>must: 0  &lt; a  &lt; 2</p>
<h2 id="敏感性"><a href="#敏感性" class="headerlink" title="敏感性"></a>敏感性</h2><p>程序分析的精度通常是和敏感性相关的。主要介绍下面几种敏感性：</p>
<ul>
<li>上下文敏感性  context-sensitivity</li>
<li>路径敏感性      path-sensitivity</li>
<li>流敏感性          flow-sensitivity</li>
</ul>
<p>谭添老师<a href="https://www.zhihu.com/question/35167483" target="_blank" rel="noopener">总结</a>得很好:</p>
<blockquote>
<p>通常所说的xxx-sensitive是指静态分析中用于降低误报（false positive）的技术，最常提的xxx正是所说的path, context以及flow。要具体解释这几个概念，首先我们来看看静态分析怎么产生false positive误报，然后我们再来看看如何用这几个技术（或者说概念）消除相应的false positive。</p>
<p>我们做静态分析时，无论是分析源代码还是目标代码，我们分析的对象（方法、语句、变量）都只有一份：同一个方法我们只会写一个方法体（方法体里的语句也就只有一份），同一个变量我们只会声明一次。然而动态运行程序的时候：</p>
<p>一个方法可能会被调用N次，每次调用的<strong>上下文</strong>可以不一样，不同上下文中这个方法里变量的值会不同；</p>
<p>一个方法里，一个变量在不同<strong>位置</strong>的值也会不一样。例如一个变量v，在方法执行到第1行和第10行的值会不同；</p>
<p>一个方法里同一个位置的变量的值在程序执行不同<strong>路径</strong>时也不一样。例如方法foo第10行要用变量v，第10行之前有一个if-else分支会修改v的值，那么程序途径true branch和false branch到达foo第10行时，v的值又不同。</p>
<p>按照我的理解，xxx-sensitive就是在静态分析时，按照xxx给程序里的对象（模拟动态运行）创建“分身”（或者说按照xxx区分分析对象）：按照<strong>上下文</strong>区分叫做context-sensitive；按照<strong>位置</strong>区分叫做flow-sensitive；按照<strong>路径</strong>区分叫做path-sensitive。区分之后再分析可以减少false positive。但是静态不可能完全模拟动态的所有情况，因为一旦有递归和循环，理论上你写下的方法和变量就能产生无穷无尽的“分身”。所以静态分析只能或多或少地通过xxx-sensitive技术减少false positive，而不可能消除。</p>
</blockquote>
<p>按照定义：path-sensitive最准，flow-次之，context-最差</p>
<h3 id="按照上下文区分：context-sentitive"><a href="#按照上下文区分：context-sentitive" class="headerlink" title="按照上下文区分：context-sentitive"></a>按照上下文区分：context-sentitive</h3><p>在提到context-sensitive 时一般context专指function call context，<strong>方法调用上下文</strong>。</p>
<p>只关心function之间的数据传递（参数、返回值、side-effect）而忽略了同一函数在不同call side下不同的context，即忽略了call stack。将call site和return当作goto，并添加一些赋值语句。</p>
<h3 id="按照位置区分：flow-sentitive"><a href="#按照位置区分：flow-sentitive" class="headerlink" title="按照位置区分：flow-sentitive"></a>按照位置区分：flow-sentitive</h3><p>和前两个相比，flow-sensitive 的概念有些混乱。</p>
<p>flow-sensitive要关注statements之间的先后顺序。</p>
<p>flow-insensitive是把statements当作一个集合来看的，各个statement之间没有顺序，所以control flow statement（if、while一类的）可以直接删除；</p>
<p>从SSA的角度来看，path-insensitive是在处理Phi node的时候丢弃分支的信息，只把各个分支来的所有值给merge。path-sensitive是要保留分支信息。</p>
<h3 id="按照路径区分：path-sentitive"><a href="#按照路径区分：path-sentitive" class="headerlink" title="按照路径区分：path-sentitive"></a>按照路径区分：path-sentitive</h3><p>path-sensitive其实就是flow-sensitive的一个特例，可以看作是特例或者说携带更高精度的信息的做法。</p>
<p>if、while静态分析时不知道动态的执行路线（path），所以一般会把它们不同的分支的数据流集merge起来。<strong>而path-sensitive则针对不同的路径的数据集不会merge，而是分别进行分析</strong>。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码的结尾x 的分析结果是<code>如果a &gt; 0 则为1，a &lt;= 0 则为2</code>。</p>
<p>这样分析的精度就高了很多，但是付出的代价是顺着control flow，path 的『分情况讨论』数量随指数增长。当然也有一些优化策略可以在某些情况下降低这个复杂度（比如property simulation）。</p>
<h2 id="soot实现数据流分析"><a href="#soot实现数据流分析" class="headerlink" title="soot实现数据流分析"></a>soot实现数据流分析</h2><p><strong>过程内数据流分析</strong></p>
<p>在sootwiki有说到：</p>
<blockquote>
<p>过程内数据分析是在以UnitGraph为主的cfg上操作的。</p>
<p>UnitGraph包含语句作为节点，如果控制可以从源节点代表的语句流向目标节点代表的语句，那么两个节点之间就有一条边。</p>
<p>数据流分析将两个元素与UnitGraph中的每个节点联系起来，通常是两个集合：一个inset和一个outset。这些集合首先初始化，然后沿着语句节点在UnitGraph中传播，直到达到一个固定点fixed-point。</p>
<p>最后，你要做的就是在每个语句前后检查inset与outset。通过分析的设计，你的集合特征应该准确地告诉你所需要的信息。</p>
</blockquote>
<h3 id="四步走"><a href="#四步走" class="headerlink" title="四步走"></a>四步走</h3><p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210430161058053.png" alt="image-20210430161058053"></p>
<ol>
<li>前向or后向？是否考虑分支情况？</li>
<li>问题域？那种语句会影响？</li>
<li>如何为每一种IR形式的语句写transfer function？</li>
<li>如何说明开始情况下的近似值？</li>
</ol>
<h3 id="义务，必须要做的事情，关键方法"><a href="#义务，必须要做的事情，关键方法" class="headerlink" title="义务，必须要做的事情，关键方法"></a>义务，必须要做的事情，关键方法</h3><p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210430161544317.png" alt="image-20210430161544317"></p>
<p><strong>实现你的分析框架，一定要做的事情</strong>：</p>
<ol>
<li>必须继承FlowAnalysis抽象类</li>
<li>实现抽象方法 ： merge() and copy()</li>
<li>实现数据流分析函数 ：flowThrough()</li>
<li>实现初始化函数：newInitialFlow() and entryInitialFlow()</li>
<li>框架的构造函数内必须调用 doAnalysis()</li>
</ol>
<p><strong>这里面doAnalysis() ，其实soot已经实现了在CFG上运用worklist算法进行程序内数据流分析。</strong></p>
<p><strong>三种数据流分析</strong></p>
<p>ForwardFlowAnalysis：以UnitGraph的<strong>entry statement</strong>作为开始并开始传播；</p>
<p>BackwardsFlowAnalysis：以UnitGraph的<strong>exit node(s)</strong>作为分析并且向后开始传播（当然可以将UnitGraph转换产生inverseGraph，然后再使用ForwardFlowAnalysis进行分析）；</p>
<p>ForwardBranchedFlowAnalysis：本质上也是Forward分析，但是它允许你在不同分支处传递不同的flow sets。例如：如果传播到如if(p!=null)语句处，当“p is not null”时，传播进入“then”分支，当“p is null”时传播进入“else”分支（Forward、backward分析都在分支处会将分析结果merge合并掉）。</p>
<img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210329152634399.png" alt="image-20210329152634399" style="zoom:67%;">

<img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210329152706388.png" alt="image-20210329152706388" style="zoom:67%;">

<p>在soot中，FlowAnalysis是一个抽象类。</p>
<h3 id="ForwardFlowAnalysis"><a href="#ForwardFlowAnalysis" class="headerlink" title="ForwardFlowAnalysis"></a>ForwardFlowAnalysis</h3><p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210327155003872.png" alt="image-20210327155003872"></p>
<p>ForwardFlowAnalysis是抽象类，继承关系如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbstractFlowAnalysis&lt;N,A&gt; -&gt; FlowAnalysis&lt;N,A&gt; -&gt; ForwardFlowAnalysis&lt;N,A&gt;</span><br></pre></td></tr></table></figure>

<p>ForwardFlowAnalysis有两个参数：</p>
<ul>
<li><p>N：节点种类。通常是Unit。</p>
</li>
<li><p>A：Abstraction Type 抽象类型。人们通常会用Set和Map来表示，但是，<strong>Soot要求抽象类型必须正确实现equals()和hashCode()方法，这样Soot才能确定何时到达一个固定点</strong>。</p>
</li>
</ul>
<h3 id="关键方法举例"><a href="#关键方法举例" class="headerlink" title="关键方法举例"></a>关键方法举例</h3><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210329152722190.png" alt="image-20210329152722190" style="zoom:67%;">

<p><strong>构造函数</strong></p>
<p>必须实现一个携带<code>DirectedGraph</code>作为参数的构造函数，并且将该参数传递给super constructor。然后，在构造函数结束时调用doAnalysis()，doAnalysis()将真正执行数据流分析。而在调用super constructor和doAnalysis之间，可以自定义数据分析结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyAnalysis</span><span class="params">(DirectedGraph graph)</span> </span>&#123; <span class="comment">//构造函数</span></span><br><span class="line">  </span><br><span class="line">	<span class="keyword">super</span>(graph);<span class="comment">//传递给父类</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	emptySet = <span class="keyword">new</span> ArraySparseSet();<span class="comment">//自定义分析</span></span><br><span class="line">  </span><br><span class="line">	doAnalysis();<span class="comment">//执行fixed-point</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数据流集合的初始化问题</strong></p>
<p>newInitialFlow &amp; entryInitialFlow</p>
<p>newInitialFlow()方法返回一个抽象类型A的对象，这个对象被赋值给每个语句的in-set和out-set集合，除过UnitGraph的第一个句子的in-set集合（如果你实现的是backwards分析，则是除去exit statement语句）。第一个句子的in-set集合由entryInitialFlow()初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">newInitialFlow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="keyword">return</span> emptySet.emptySet();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">entryInitialFlow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="keyword">return</span> emptySet.emptySet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>流集合操作</strong></p>
<p>集合复制 copy() </p>
<p><code>copy()</code>方法接收两个A类型的参数，分别是source和target，该方法其实就是把source复制到target集合里面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(Object source, Object dest)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	FlowSet srcSet = (FlowSet)source,</span><br><span class="line">	FlowSet destSet = (FlowSet)dest;</span><br><span class="line">	srcSet.copy(destSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>交汇运算 merge()  </p>
<p>merge(..)方法被用来在control-flow的合并点处合并数据流集，例如：在句子(if/then/else)分支的结束点。与copy(..)不同的是，它携带了三个参数，一个参数是来自左边分支的out-set，一个参数是来自右边分支的out-set，另外一个参数是两个参数merge后的集合，这个集合将是合并点的下一个句子的in-set集合。</p>
<p>注：merge(..)本质上指的是控制流的交汇运算，一般根据待分析的具体问题来决定采用并集还是交集。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Object in1, Object in2, Object out)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	FlowSet inSet1 = (FlowSet)in1,</span><br><span class="line">	inSet2 = (FlowSet)in2,</span><br><span class="line">	outSet = (FlowSet)out;</span><br><span class="line">	<span class="comment">//inSet1.union(inSet2, outSet);</span></span><br><span class="line">	inSet1.intersection(inSet2, outSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>flowThrough(..)  大名鼎鼎的transfer function</p>
<p>flowThrough(..)方法是真正的执行流函数，它有三个参数：A in-set、被处理的N类型节点（一般指的就是句子Unit）、A out-set。这个方法的实现内容完全取决于你的分析。</p>
<p>注：flowThrough()本质上就是一个传递函数。在一个语句之前和之后的数据流值受该语句的语义的约束。比如，假设我们的数据流分析涉及确定各个程序点上各变量的常量值。如果变量a在执行语句b=a之前的值为v，那么在该语句之后a和b的值都是v。一个赋值语句之前和之后的数据流值的关系被称为传递函数。针对前向分析和后向分析，传递函数有两种风格。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">flowThrough</span><span class="params">(Object in, Object d, Object out)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	FlowSet inSet = (FlowSet)in,</span><br><span class="line">	FlowSet outSet = (FlowSet)out;</span><br><span class="line">	Unit u = (Unit) d;</span><br><span class="line">	kill(inSet,u,outSet);</span><br><span class="line">	gen(outSet,u);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">kill</span><span class="params">(FlowSet inSet, Unit u, FlowSet outSet)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	FlowSet kills = (FlowSet)emptySet.clone();<span class="comment">//Unit的kills</span></span><br><span class="line">	Iterator defIt = u.getDefBoxes().iterator();</span><br><span class="line">	<span class="keyword">while</span>(defIt.hasNext())&#123;</span><br><span class="line">		ValueBox defBox = (ValueBox)defIt.next();</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">if</span>(defBox.getValue() <span class="keyword">instanceof</span> Local)&#123;</span><br><span class="line">			Iterator inIt = inSet.iterator();</span><br><span class="line">			<span class="keyword">while</span>(inIt.hasNext())&#123;</span><br><span class="line">				Local inValue = (Local)inIt.next();</span><br><span class="line">				<span class="keyword">if</span>(inValue.equivTo(defBox.getValue()))&#123;</span><br><span class="line">					kills.add(defBox.getValue());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	inSet.difference(kills, outSet);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">gen</span><span class="params">(FlowSet outSet, Unit u)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	Iterator useIt = u.getUseBoxes().iterator();</span><br><span class="line">	<span class="keyword">while</span>(useIt.hasNext())&#123;</span><br><span class="line">		ValueBox e = (ValueBox)useIt.next();</span><br><span class="line">		<span class="keyword">if</span>(e.getValue() <span class="keyword">instanceof</span> Local)</span><br><span class="line">			outSet.add(e.getValue());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Flow-sets"><a href="#Flow-sets" class="headerlink" title="Flow-sets"></a>Flow-sets</h2><p>在soot中，flow sets代表control-flow-graph中与节点相关的数据集合。</p>
<p>CFG中的每个节点，都有一个flowset与之关联。</p>
<p>Flow set存在有边界的（需要实现BoundedFlowSet接口）和无边界的（需要实现FlowSet接口）两种表达。</p>
<p><strong>有边界的集合知道possible值的全体集合(适合指针分析)，而无边界的集合则不知道。</strong></p>
<h3 id="interface-FlowSet-lt-T-gt"><a href="#interface-FlowSet-lt-T-gt" class="headerlink" title="interface FlowSet&lt;T&gt;"></a>interface FlowSet<code>&lt;T&gt;</code></h3><p>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FlowSet&lt;T&gt; <span class="title">clone</span><span class="params">()</span></span>; <span class="comment">//克隆当前FlowSet的集合</span></span><br><span class="line"></span><br><span class="line"><span class="function">FlowSet&lt;T&gt; <span class="title">emptySet</span><span class="params">()</span></span>;<span class="comment">//返回一个空集，通常比((FlowSet)clone()).clear()效率更高</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(FlowSet&lt;T&gt; dest)</span></span>;<span class="comment">//拷贝当前集合到dest集合中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;<span class="comment">//返回该flowset的清空</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(FlowSet&lt;T&gt; other)</span></span>; <span class="comment">//将FlowSet ∪nion other 并集返回值再赋给FlowSet</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(FlowSet&lt;T&gt; other, FlowSet&lt;T&gt; dest)</span></span>; <span class="comment">// FlowSet ∪ other = dest，其中other、dest可以与该FlowSet一样</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intersection</span><span class="params">(FlowSet&lt;T&gt; other)</span></span>; <span class="comment">//FlowSet ∩ other = FlowSet</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intersection</span><span class="params">(FlowSet&lt;T&gt; other, FlowSet&lt;T&gt; dest)</span></span>; <span class="comment">//FlowSet ∩ other = dest 其中，dest、other可以和该FlowSet一样</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">difference</span><span class="params">(FlowSet&lt;T&gt; other)</span></span>; <span class="comment">// FlowSet-other = FlowSet</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">difference</span><span class="params">(FlowSet&lt;T&gt; other, FlowSet&lt;T&gt; dest)</span></span>; <span class="comment">// FlowSet-other = dest,其中，dest、other和FlowSet可能相同。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T var1, FlowSet&lt;T&gt; var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T var1, FlowSet&lt;T&gt; var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(T var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSubSet</span><span class="params">(FlowSet&lt;T&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">toList</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>上述方法足以使flow sets成为一个有效的lattice元素。</p>
<p>而对于有边界的flowset，需要实现BoundedFlowSet接口</p>
<p>它需要提供方法，该方法能够产生set‘s complement（补集）和它的topped set（全集）（一个lattice element包括所有的可能的值的集合）。</p>
<img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210329153258001.png" alt="image-20210329153258001" style="zoom:80%;">

<h3 id="四种flow-sets的实现"><a href="#四种flow-sets的实现" class="headerlink" title="四种flow sets的实现"></a>四种flow sets的实现</h3><p>ArraySparseSet,ArrayPackedSet,ToppedSet和DavaFlowSet。</p>
<img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210329153345586.png" alt="image-20210329153345586" style="zoom:67%;">

<p>ArraySparseSet:是一个无界限的flowset。该set代表一个数组引用。注意：当比较元素是否相等时，一般使用继承自Object对象的equals。但是在soot中的元素都是代表一些代码结构，不能覆写equals方法。而是实现了interface soot.EquivTo。因此，如果你需要一个包含类似binary operation expressions的集合，你需要使用equivTo方法实现自定义的比较方法去比较是否相等。</p>
<p>ArrayPackedSet : 有界flow set。需要提供FlowUniverse 对象，即代表全集的容器。由一个在integer和object双向map和一个用来表示全集成员是否在内的bit vector表示。</p>
<p>ToppedSet : 在基于上面两种的set前提下，加入额外信息来表示其为lattice中的Top。</p>
<h2 id="soot官方例子"><a href="#soot官方例子" class="headerlink" title="soot官方例子"></a>soot官方例子</h2><h3 id="Live-Variables-Analysis"><a href="#Live-Variables-Analysis" class="headerlink" title="Live Variables Analysis"></a>Live Variables Analysis</h3><p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210430181603345.png" alt="image-20210430181603345"></p>
<p>变量v是live状态的条件是：</p>
<p>从v的定义点p开始，v就是活跃的，一直到use(v)地方，中间没有对v的<strong>重定义</strong>；</p>
<h4 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h4><p>May-analysis : BackwardAnalysis 下面这张图 倒着看 效果会更好！</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210430201447240.png" alt="image-20210430201447240"></p>
<p>在soot里面，后向分析可以继承BackwardFlowAnalysis抽象类。</p>
<p>汇聚点的操作是<strong>union</strong></p>
<p>变量集合可以是继承了FlowSet的ArraySparseSet集合</p>
<h4 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h4><p>copy和merge的具体操作：</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210430202734875.png" alt="image-20210430202734875"></p>
<p><strong>copy()</strong></p>
<p>copy就是<strong>直接</strong>把当前节点的IN copy 给上一个BB块的OUT</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210501161528622.png" alt="image-20210501161528622"></p>
<p><strong>merge()</strong></p>
<p>由于是union ， 所以是把分叉点的两个IN union取并集 为分支点的OUT</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210501162907634.png" alt="image-20210501162907634"></p>
<h4 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h4><p><strong>flowThrough()</strong></p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210501163108300.png" alt="image-20210501163108300"></p>
<p>例如: x = y * z</p>
<p>backwardanalysis分析：先kill def[x] ,再 gen use[y,z]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kill </span></span><br><span class="line"><span class="comment">// for each local v def’d in this unit, remove v from dest</span></span><br><span class="line"><span class="keyword">for</span>(ValueBox box : ut.getDefBoxes())&#123;</span><br><span class="line">	Value value = box.getValue();</span><br><span class="line">  <span class="keyword">if</span>( value <span class="keyword">instanceof</span> Local )&#123;</span><br><span class="line">    dest.remove( value );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gen</span></span><br><span class="line"><span class="comment">// for each local v used in this unit, add v to dest</span></span><br><span class="line"><span class="keyword">for</span> (ValueBox box : ut.getUseBoxes())&#123;</span><br><span class="line">	Value value = box.getValue();</span><br><span class="line">	<span class="keyword">if</span> (value <span class="keyword">instanceof</span> Local)&#123;</span><br><span class="line">    dest.add(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h4><p><strong>Initial values</strong></p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210501170326266.png" alt="image-20210501170326266"></p>
<h4 id="step5"><a href="#step5" class="headerlink" title="step5"></a>step5</h4><p><strong>Constructor</strong></p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210501172943670.png" alt="image-20210501172943670"></p>
<h4 id="step6"><a href="#step6" class="headerlink" title="step6"></a>step6</h4><p><strong>Enjoy result</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LiveVariablesAnalysis lv = <span class="keyword">new</span> LiveVariablesAnalysis(g);</span><br><span class="line"><span class="comment">// return SparseArraySets of live variables:</span></span><br><span class="line">lv.getFlowBefore(s);</span><br><span class="line">lv.getFlowAfter(s);</span><br></pre></td></tr></table></figure>



<h3 id="Branched-Nullness-Analysis"><a href="#Branched-Nullness-Analysis" class="headerlink" title="Branched Nullness Analysis"></a>Branched Nullness Analysis</h3><p> 定义：</p>
<p>如果所有到达s的control-flow path 都导致v被分配了一个非null的值，那么局部变量v在s处就是非null的。</p>
<p>图示：</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504160140618.png" alt="image-20210504160140618"></p>
<h4 id="step1-1"><a href="#step1-1" class="headerlink" title="step1"></a>step1</h4><p>选择实现ForwardBranchedFlowAnalysis</p>
<h4 id="step2-1"><a href="#step2-1" class="headerlink" title="step2"></a>step2</h4><p>和上一个例子一样：</p>
<p>copy()</p>
<p>forward 正常copy就行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(Object src, Object dest)</span> </span>&#123;</span><br><span class="line">  FlowSet sourceSet = (FlowSet)src,</span><br><span class="line">  destSet = (FlowSet) dest;</span><br><span class="line">  sourceSet.copy(destSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>merge()</p>
<p>如果一个变量v在从开始到s的所有路径上都是非空的，那么它就是非空的，所以<strong>取交集</strong>，intersection()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// [cast Objects to FlowSets]</span></span><br><span class="line">  srcSet1.intersection(srcSet2,destSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="step3-1"><a href="#step3-1" class="headerlink" title="step3"></a>step3</h4><p>设计 flow function</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504161739103.png" alt="image-20210504161739103"></p>
<h1 id="零散知识点"><a href="#零散知识点" class="headerlink" title="零散知识点"></a>零散知识点</h1><p>以$开头的都是临时变量，表示相对堆栈位置，并不是源程序中的局部变量。</p>
<p>没有$的局部变量则代表真正的局部变量。</p>
<p>jtp是允许用户自定义的，wjtp全程序转换包</p>
<p><strong>clinit</strong>方法<strong>clinit是</strong>类构造器方法，也就是在jvm在进行类加载-验证-解析-初始化中的<strong>初始化</strong>阶段，jvm会调用<strong>clinit</strong>. <strong>clinit</strong>方法<strong>是</strong>在类加载过程中执行的，而init方法<strong>是</strong>在对象实例化执行的。</p>
<p>虚方法没有methodbody</p>
<p>soot的控制流图在soot.toolkits.graph这个包内；</p>
<p>Annotating Code</p>
<p>四个接口：</p>
<ul>
<li>Host：是可以容纳和管理标签的对象。就像SootClass、SootField、Body、Unit、Value、ValueBox等</li>
<li>Tag：可以给Host打标记的对象，很通用，用来标记name-vlaue对给Host</li>
<li>Attribute：是Tag的拓展。任何属于属性的东西都可以输出到文件中。Soot里有一个tool叫做SootClass，可以输出直接码ByteCode，任何应该输出到类文件的东西都必须extend JasminAttribute。</li>
</ul>
<p>CallGraph的方法调用</p>
<p>Soot中调用图的所有已知方法调用edge边的集合。</p>
<p>包括：</p>
<p>显式方法调用</p>
<p>隐式静态初始化器</p>
<p>隐式调用Thread.run()</p>
<p>隐式调用</p>
<p>调用图的每一条边edge对象都存在四个元素：</p>
<p>源方法 source method</p>
<p>源语句 source statement</p>
<p>目标方法 target method、</p>
<p>边的种类，例如静态调用invoke static 、虚拟调用 invoke virtual、接口调用invoke interface</p>
<p>CallGraph也有几个经典方法：</p>
<p><code>edgesInto(method)</code>：查询进入method方法的边</p>
<p><code>edgesOutOf(method)</code>：从method方法流出来的边</p>
<p><code>edgesOutOf(statement)</code>：从特定语句statement流出来的边</p>
<p>每个方法其实都会返回一个Iterator来调度Edge边对象</p>
<p>Soot提供了三个适配器来针对Edges进行分析：</p>
<ul>
<li>Sources：每条边的原方法</li>
<li>Units：每条边的原语句</li>
<li>Targets：每条边的目标方法</li>
</ul>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printPossibleCallers</span><span class="params">(SootMethod target)</span></span>&#123;</span><br><span class="line">  CallGraph cg = Scene.v().getCallGraph();</span><br><span class="line">  Iterator sources = <span class="keyword">new</span> Sources(cg.edgesInto(target));</span><br><span class="line">  <span class="keyword">while</span>(sources.hasNext())&#123;</span><br><span class="line">    SootMethod src = (SootMethod)sources.next();</span><br><span class="line">    Sysytem.out.println(target + <span class="string">"might be called by "</span> + src);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>更详细的两个图类：</p>
<p><code>ReachableMethods</code>  and <code>TransitiveTargets</code></p>
<p><code>ReachableMethods</code></p>
<p>表示能从entrypoints开始，能reach到的方法集合</p>
<p>方法<code>contains(method)</code>表示去测试method方法能不能到达，能不能reachable</p>
<p>方法<code>listener()</code>返回的是一个迭代器遍历所有可达方法。</p>
<p><code>TransitiveTargets</code></p>
<p>表示从一个特定的方法能指向的所有方法，<strong>这个方法可以用来分析调用链</strong>。</p>
<p>构造函数接收（除了调用图之外）一个额外过滤器<code>Filter</code></p>
<p>Filter表示调用图中满足给定的<code>EdgePredicate</code>的边的子集。</p>
<p><code>EdgePredicate</code>是一组接口，它主要有两个实现，<code>ExplicitEdgespred</code> ,<code>InstanceInvokeEdgesPred</code>；</p>
<p>三个翻译器类：</p>
<p>JavaTranslator、StmtTranslator、ExprTranslator</p>
<p>JavaTranslator负责将给定的Java程序的方法进行翻译，然后将这些翻译之后的语句组合在一起。</p>
<p>它会维护着一个数组，数组会在<code>makeMethod</code>方法之后被初始化。</p>
<p><code>translate</code>方法是主要方法，这个方法会完成语句的翻译和链接。</p>
<p>StmtTranslator继承了AbstractStmtSwitch，他会翻译单独、独立的语句。</p>
<p>它的主要方法是<code>translateStmt</code>，这个方法其实会把StmtTranslator应用于语句，然后建立一个Map映射对，把Java语句和Jimple代码进行映射，对错误报告很方便。</p>
<p>此外还有一个方法是<code>addStatement</code>，它会将给定的语句添加到指定的方法中，它是整个翻译过程中用来添加语句的方法。</p>
<p>Subexpression是用ExprTranslator（它是AbstractJimpleValueSwitch类的拓展）来翻译的。</p>
<p>切入点是<code>translateExpr</code>方法，他是将Exprtranslator应用到给定的ValueBox上面。</p>
<p>两个有趣方法：</p>
<p><code>caseSpecialInvokerExpr</code>和<code>handleCall</code>；</p>
<p><code>caseSpecialInvokerExpr</code>是用来测试是否进行了对象的初始化，如果是的话，那么就创建一个Foo初始化语句；如果不是的话，那么就调用handleCall方法。</p>
<h1 id="过程内分析"><a href="#过程内分析" class="headerlink" title="过程内分析"></a>过程内分析</h1><p>数据流分析是针对某一个方法的控制流图（在Soot里面用的是UnitGragh）来分析的。由于是方法内的数据流分析，所以每一个节点都是Stmt语句。</p>
<p>一个UnitGraph会把每条语句作为节点node，两个节点所对应的语句如果能够流通，那么在图上就会有一条边。</p>
<p>每个节点会有两个集合，一个代表入集：in-set，一个代表出集：out-set。</p>
<p>这些集合会随着程序运行实时保存记录，直到遇到一个fixed-point点结束。</p>
<p>在Soot里面有三种数据流分析，分别是Forward/Backward/和Branched</p>
<p>ForwardFlowAnalysis：就是正向的数据分析，从程序的入口点entry point顺着一路下来分析；</p>
<p>BackWardsFlowAnalysis：逆向分析，从程序的结束点exit-node倒推。这里官方文档说可以顺着ForeardAnalysis来继续用，但是需要换成用InverseGraph，以后有空补上这个细节。</p>
<p>ForwardBranchedAnalysis：也是正向分析的一种，只不过会对if这样的分支语句进行分支分析。例如if(p!=null)，那么在当分析这一条语句时候，他其实就会自动分出分支，将<code>p is not null</code>放到then分支，然后把<code>p is null</code>放到else分支。</p>
<p><strong>实现Analysis接口</strong></p>
<p>ForwardFlowAnalysis是抽象类，继承关系如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbstractFlowAnalysis&lt;N,A&gt; -&gt;FlowAnalysis&lt;N,A&gt;-&gt;ForwardFlowAnalysis&lt;N,A&gt;</span><br></pre></td></tr></table></figure>

<p>ForwardFlowAnalysis有两个参数：</p>
<ul>
<li><p>N：节点种类。通常是Unit</p>
</li>
<li><p>A：Abstraction Type 抽象类型。人们通常会用Set和Map来表示，但是，Soot要求抽象类型必须正确实现equals()和hashCode()方法，这样Soot才能确定何时到达一个固定点。</p>
</li>
</ul>
<p>构造函数：</p>
<p>要求：必须实现一个构造函数，该构造函数至少接收一个<a href="https://www.sable.mcgill.ca/soot/doc/soot/toolkits/graph/DirectedGraph.html" target="_blank" rel="noopener"><code>DirectedGraph</code></a>作为参数，其中N为节点类型，并且将它传递给父类的constructor；<code>super.init</code></p>
<p>并且在自定义的constructor最后，需要调用<code>doAnalysis()</code>函数，这个函数在最后才会分析数据流。</p>
<p>在调用superconstructor和doAnalysis()函数之间，你可以自定义分析数据结构。</p>
<p>方法：</p>
<p> <code>newInitialFlow()</code> and <code>entryInitialFlow()</code></p>
<p><code>newInitialFlow()</code>会返回一个抽象类型对象A，这个对象是每个node节点默认初始化的in-set和out-set。</p>
<p>特殊的是entry-point的in-set是通过<code>entryInitialFlow()</code>方法完成的。</p>
<p><code>copy()</code>方法接收两个A类型的参数，分别是source和target，该方法其实就是把source复制到target集合里面。</p>
<blockquote>
<p>The <code>copy(..)</code> method takes two arguments of type A (your abstraction), a source and a target. It merely copies the source into the target. Note that the class A has to provide appropriate methods. In particular, A may not be immutable. You can work around this limitation by using a box or set type for A.</p>
</blockquote>
<p><code>merge()</code>方法用来在分支汇聚点处汇聚flowsets</p>
<p>它会接收3个参数，分别是左分支和右分支还有一个额外分支，这个额外分支其实是为了下一个节点汇聚而成的in-set。</p>
<blockquote>
<p>Opposed to <code>copy(..)</code> it takes three arguments, an out-set from the left-hand branch, an out-set from the right-hand branch and another set, which is going to be the newly merged in-set for the next statement after the merge point.</p>
</blockquote>
<p>最后需要实现的方法是<code>flowThrough()</code>;</p>
<p><code>flowThrough()</code>方法会接收3个参数作为输入：</p>
<ol>
<li>A的in-set。</li>
<li>N类型的node，也就需要待处理的语句。</li>
<li>A的out-set。</li>
</ol>
<p>这个方法的内容完全取决于你的分析和抽象。</p>
<h1 id="soot-tricks"><a href="#soot-tricks" class="headerlink" title="soot tricks"></a>soot tricks</h1><p><strong>print in console</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">soot.SootClass c = <span class="comment">// your SootClass</span></span><br><span class="line">SootMethod c = <span class="comment">// your method Body </span></span><br><span class="line">PrintWriter writer = <span class="keyword">new</span> PrintWriter(System.out); </span><br><span class="line">soot.Printer.v().printTo(c, writer);</span><br><span class="line">writer.flush();</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure>

<p><strong>print to a jimple file</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">soot.SootClass c = <span class="comment">// your SootClass</span></span><br><span class="line">File file = <span class="keyword">new</span> File(c.getName() + <span class="string">".jimple"</span>);</span><br><span class="line">PrintWriter writer;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  writer = <span class="keyword">new</span> PrintWriter(file);</span><br><span class="line">  soot.Printer.v().printTo(c, writer);</span><br><span class="line">  writer.flush();</span><br><span class="line">  writer.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a href="https://gist.github.com/linghuiluo/f937ab3ec656991b4b3ec121d7847b1d" target="_blank" rel="noopener">Jimple Checklist</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Soot/" rel="tag"><i class="fa fa-tag"></i>Soot</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/%E8%AE%B0%E4%B8%80%E6%AC%A1ASM%E6%8F%92%E6%A1%A9/" rel="prev" title="记一次ASM插桩">
      <i class="fa fa-chevron-left"></i> 记一次ASM插桩
    </a></div>
      <div class="post-nav-item">
    <a href="/soot-%E5%A6%82%E4%BD%95%E5%8F%8D%E7%BC%96%E8%AF%91%E7%B1%BB%E6%96%87%E4%BB%B6/" rel="next" title="[soot]如何反编译类文件">
      [soot]如何反编译类文件 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>
      <!--
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="https://link.hhtjim.com/163/26348068.mp3"></iframe>
      -->
      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#序言"><span class="nav-number">1.</span> <span class="nav-text">序言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SSA"><span class="nav-number">2.</span> <span class="nav-text">SSA</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#soot配置选项"><span class="nav-number">3.</span> <span class="nav-text">soot配置选项</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#soot的基本数据结构"><span class="nav-number">4.</span> <span class="nav-text">soot的基本数据结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#主流IR-Jimple"><span class="nav-number">5.</span> <span class="nav-text">主流IR Jimple</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Value-amp-Box"><span class="nav-number">5.1.</span> <span class="nav-text">Value&amp;Box</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Local"><span class="nav-number">5.1.1.</span> <span class="nav-text">Local</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Constant"><span class="nav-number">5.1.2.</span> <span class="nav-text">Constant</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ref"><span class="nav-number">5.1.3.</span> <span class="nav-text">Ref</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Box"><span class="nav-number">5.1.4.</span> <span class="nav-text">Box</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stmt和Expr的区别"><span class="nav-number">5.2.</span> <span class="nav-text">Stmt和Expr的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AbstractStmt"><span class="nav-number">5.2.1.</span> <span class="nav-text">AbstractStmt</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AbstractDefinitionStmt"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">AbstractDefinitionStmt</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AbstractSwitchStmt"><span class="nav-number">5.2.1.2.</span> <span class="nav-text">AbstractSwitchStmt</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AbstractOpStmt"><span class="nav-number">5.2.1.3.</span> <span class="nav-text">AbstractOpStmt</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他Stmt-直接写上"><span class="nav-number">5.2.2.</span> <span class="nav-text">其他Stmt 直接写上</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AbstractInvokeExpr"><span class="nav-number">5.2.3.</span> <span class="nav-text">AbstractInvokeExpr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AbstractInstanceInvokeExpr"><span class="nav-number">5.2.4.</span> <span class="nav-text">AbstractInstanceInvokeExpr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AbstractBinopExpr"><span class="nav-number">5.2.5.</span> <span class="nav-text">AbstractBinopExpr</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#其他Expr-直接写上"><span class="nav-number">5.2.5.1.</span> <span class="nav-text">其他Expr 直接写上</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#处理阶段Pack-Transformer"><span class="nav-number">6.</span> <span class="nav-text">处理阶段Pack&#x2F;Transformer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#核心阶段与小阶段"><span class="nav-number">6.1.</span> <span class="nav-text">核心阶段与小阶段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#body-packs"><span class="nav-number">6.2.</span> <span class="nav-text">body packs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Transformer"><span class="nav-number">6.3.</span> <span class="nav-text">Transformer</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#控制流图-CFG"><span class="nav-number">7.</span> <span class="nav-text">控制流图 CFG</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#语句图UnitGraph"><span class="nav-number">7.1.</span> <span class="nav-text">语句图UnitGraph</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#UnitGraph的四个子类"><span class="nav-number">7.1.1.</span> <span class="nav-text">UnitGraph的四个子类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Host-amp-Tag"><span class="nav-number">8.</span> <span class="nav-text">Host &amp; Tag</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CG-amp-CFG-amp-ICFG"><span class="nav-number">8.1.</span> <span class="nav-text">CG &amp; CFG &amp; ICFG</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CG-Call-Graph"><span class="nav-number">8.2.</span> <span class="nav-text">CG Call Graph</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Querying-Call-Graph"><span class="nav-number">8.2.0.1.</span> <span class="nav-text">Querying Call Graph</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reachable-Methods"><span class="nav-number">8.2.0.2.</span> <span class="nav-text">Reachable Methods</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Transitive-Targets"><span class="nav-number">8.2.0.3.</span> <span class="nav-text">Transitive Targets</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spark"><span class="nav-number">8.3.</span> <span class="nav-text">Spark</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Point-to"><span class="nav-number">8.4.</span> <span class="nav-text">Point-to</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#例子a"><span class="nav-number">8.4.0.1.</span> <span class="nav-text">例子a</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#例子b"><span class="nav-number">8.4.0.2.</span> <span class="nav-text">例子b</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据流分析"><span class="nav-number">9.</span> <span class="nav-text">数据流分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#近似分析"><span class="nav-number">9.1.</span> <span class="nav-text">近似分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#近似的两种级别"><span class="nav-number">9.1.1.</span> <span class="nav-text">近似的两种级别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#敏感性"><span class="nav-number">9.2.</span> <span class="nav-text">敏感性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#按照上下文区分：context-sentitive"><span class="nav-number">9.2.1.</span> <span class="nav-text">按照上下文区分：context-sentitive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按照位置区分：flow-sentitive"><span class="nav-number">9.2.2.</span> <span class="nav-text">按照位置区分：flow-sentitive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按照路径区分：path-sentitive"><span class="nav-number">9.2.3.</span> <span class="nav-text">按照路径区分：path-sentitive</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#soot实现数据流分析"><span class="nav-number">9.3.</span> <span class="nav-text">soot实现数据流分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#四步走"><span class="nav-number">9.3.1.</span> <span class="nav-text">四步走</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#义务，必须要做的事情，关键方法"><span class="nav-number">9.3.2.</span> <span class="nav-text">义务，必须要做的事情，关键方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ForwardFlowAnalysis"><span class="nav-number">9.3.3.</span> <span class="nav-text">ForwardFlowAnalysis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关键方法举例"><span class="nav-number">9.3.4.</span> <span class="nav-text">关键方法举例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flow-sets"><span class="nav-number">9.4.</span> <span class="nav-text">Flow-sets</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#interface-FlowSet-lt-T-gt"><span class="nav-number">9.4.1.</span> <span class="nav-text">interface FlowSet&lt;T&gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四种flow-sets的实现"><span class="nav-number">9.4.2.</span> <span class="nav-text">四种flow sets的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#soot官方例子"><span class="nav-number">9.5.</span> <span class="nav-text">soot官方例子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Live-Variables-Analysis"><span class="nav-number">9.5.1.</span> <span class="nav-text">Live Variables Analysis</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#step1"><span class="nav-number">9.5.1.1.</span> <span class="nav-text">step1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#step2"><span class="nav-number">9.5.1.2.</span> <span class="nav-text">step2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#step3"><span class="nav-number">9.5.1.3.</span> <span class="nav-text">step3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#step4"><span class="nav-number">9.5.1.4.</span> <span class="nav-text">step4</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#step5"><span class="nav-number">9.5.1.5.</span> <span class="nav-text">step5</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#step6"><span class="nav-number">9.5.1.6.</span> <span class="nav-text">step6</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Branched-Nullness-Analysis"><span class="nav-number">9.5.2.</span> <span class="nav-text">Branched Nullness Analysis</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#step1-1"><span class="nav-number">9.5.2.1.</span> <span class="nav-text">step1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#step2-1"><span class="nav-number">9.5.2.2.</span> <span class="nav-text">step2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#step3-1"><span class="nav-number">9.5.2.3.</span> <span class="nav-text">step3</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#零散知识点"><span class="nav-number">10.</span> <span class="nav-text">零散知识点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#过程内分析"><span class="nav-number">11.</span> <span class="nav-text">过程内分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#soot-tricks"><span class="nav-number">12.</span> <span class="nav-text">soot tricks</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="0range"
      src="/images/yfy.png">
  <p class="site-author-name" itemprop="name">0range</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/0range228" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;0range228" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.0kami.cn/" title="https:&#x2F;&#x2F;blog.0kami.cn&#x2F;" rel="noopener" target="_blank">wh1t3p1g</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://zebork.org/" title="https:&#x2F;&#x2F;zebork.org" rel="noopener" target="_blank">Zebork</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://su18.org/" title="https:&#x2F;&#x2F;su18.org" rel="noopener" target="_blank">su18</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/tr1ple/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;tr1ple&#x2F;" rel="noopener" target="_blank">tr1ple</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.cnpanda.net/" title="http:&#x2F;&#x2F;www.cnpanda.net&#x2F;" rel="noopener" target="_blank">panda</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://m0d9.me/" title="http:&#x2F;&#x2F;m0d9.me&#x2F;" rel="noopener" target="_blank">yangbh</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://anemone.top/" title="http:&#x2F;&#x2F;anemone.top" rel="noopener" target="_blank">Anemone</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.kingkk.com/" title="https:&#x2F;&#x2F;www.kingkk.com&#x2F;" rel="noopener" target="_blank">kingkk</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.yuque.com/ni4n/blogs" title="https:&#x2F;&#x2F;www.yuque.com&#x2F;ni4n&#x2F;blogs" rel="noopener" target="_blank">Ni4n</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://summersec.github.io/" title="https:&#x2F;&#x2F;summersec.github.io" rel="noopener" target="_blank">SummerSec</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.zhihu.com/people/chenwengang" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;chenwengang" rel="noopener" target="_blank">ApsarasX</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>




      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        


<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="true"></i>
  </span>
   Powered By - 
  <span class="author" itemprop="copyrightHolder">0range</span>

  <!--
    <span class="post-meta-divider"> | </span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">792k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">22:01</span>
  -->

</div>

        






  <script>
  function leancloudSelector(url) {
    url = encodeURI(url);
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.getAttribute('id'));
      var title = visitors.dataset.flagTitle;

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.getAttribute('id'));
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (let item of results) {
            let { url, time } = item;
            leancloudSelector(url).innerText = time;
          }
          for (let url of entries) {
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=Xm92yiHJb6lBpsP02sgh3uGo-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : 'Xm92yiHJb6lBpsP02sgh3uGo-gzGzoHsz',
            'X-LC-Key'    : 'l8KvoMr1i8urA7X7BzPMtQC7',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Xm92yiHJb6lBpsP02sgh3uGo-gzGzoHsz',
      appKey     : 'l8KvoMr1i8urA7X7BzPMtQC7',
      placeholder: "Say Something~",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


<!--

  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unjkp.com/valine/dist/Valine.min.js"></script>  
  <script src="/js/Valine.min.js"></script> 

   
  
  <script src="/js/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(function (item) {
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'Xm92yiHJb6lBpsP02sgh3uGo-gzGzoHsz',
        appKey: 'l8KvoMr1i8urA7X7BzPMtQC7',
        placeholder: 'Say Something~',
        avatar:'mm',
        guest_info:['nick'] ,  //评论者只需要提供评论的昵称即可
        pageSize:'10' || 10,
    });
  
    var infoEle = document.querySelector('#comments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0){
      infoEle.childNodes.forEach(function(item) {
        item.parentNode.removeChild(item);
      });
    }
  </script>

-->

</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/click_love.js"></script>